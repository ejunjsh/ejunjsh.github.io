<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[利用raspberry PI 搭建一个简易的NAS]]></title>
      <url>/2017/07/20/raspberry-nas/</url>
      <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>raspberry pi 3</li>
<li>硬盘（格式化过ext4的）</li>
<li>连接raspberry用的终端<a id="more"></a>
</li>
</ul>
<h1 id="安装samba"><a href="#安装samba" class="headerlink" title="安装samba"></a>安装samba</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install samba samba-common-bin</div></pre></td></tr></table></figure>
<h1 id="配置samba"><a href="#配置samba" class="headerlink" title="配置samba"></a>配置samba</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.back</div><div class="line">sudo vim /etc/samba/smb.conf</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在末尾加入如下内容</span></div><div class="line"><span class="comment"># 分享名称</span></div><div class="line">[MyNAS]</div><div class="line"><span class="comment"># 说明信息</span></div><div class="line">comment = NAS Storage</div><div class="line"><span class="comment"># 可以访问的用户</span></div><div class="line">valid users = pi,root</div><div class="line"><span class="comment"># 共享文件的路径,raspberry pi 会自动将连接到其上的外接存储设备挂载到/media/pi/目录下。</span></div><div class="line">path = /media/pi/</div><div class="line"><span class="comment"># 可被其他人看到资源名称（非内容）</span></div><div class="line">browseable = yes</div><div class="line"><span class="comment"># 可写</span></div><div class="line">writable = yes</div><div class="line"><span class="comment"># 新建文件的权限为 664</span></div><div class="line">create mask = 0664</div><div class="line"><span class="comment"># 新建目录的权限为 775</span></div><div class="line">directory mask = 0775</div></pre></td></tr></table></figure>
<p>可以把配置文件中你不需要的分享名称删除，例如 [homes], [printers] 等。<br>测试配置文件是否有错误，根据提示做相应修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">testparm</div></pre></td></tr></table></figure></p>
<p>添加登陆账户并创建密码，必须是 linux 已存在的用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo smbpasswd -a pi</div></pre></td></tr></table></figure></p>
<p>重启 samba 服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/samba restart</div></pre></td></tr></table></figure></p>
<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>一般树莓派跟你的WiFi相连的话，你的网络就能看到跟上面配置一样的分享名称，如mac上面这样的显示：<br><a href="/images/nas-screenshot.png"><img src="/images/nas-screenshot.png" alt=""></a><br>如果显示没权限，可以断开连接，用你上面添加的账号登录。</p>
]]></content>
      
        <categories>
            
            <category> raspberrypi </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> raspberrypi </tag>
            
            <tag> NAS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用树莓派实现一个能播放天气的闹钟]]></title>
      <url>/2017/07/18/raspberry-weather-clock/</url>
      <content type="html"><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>你要有个pi😄<br><a id="more"></a></p>
<h1 id="获取天气接口"><a href="#获取天气接口" class="headerlink" title="获取天气接口"></a>获取天气接口</h1><p>这里我是用图灵机器人来获取天气的接口，你可以自己上去注册一个，下面代码URL的Key是我注册的机器人给的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getWeatherText</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        response = requests.get(</div><div class="line">            <span class="string">"http://www.tuling123.com/openapi/api?key=652ae4a714794fe6b01faa990d7a981f&amp;info=%s"</span> % <span class="string">"广州今日天气"</span>)</div><div class="line">        json = response.json()</div><div class="line">        <span class="keyword">if</span> json[<span class="string">"code"</span>] == <span class="number">100000</span>:</div><div class="line">            <span class="keyword">return</span> json[<span class="string">"text"</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span></div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span></div></pre></td></tr></table></figure></p>
<h1 id="播放文字"><a href="#播放文字" class="headerlink" title="播放文字"></a>播放文字</h1><p>利用百度的接口可以转换文本为语音。默认只有女声<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2voice</span><span class="params">(text)</span>:</span></div><div class="line">    url = <span class="string">'http://tts.baidu.com/text2audio?idx=1&amp;tex=&#123;0&#125;&amp;cuid=baidu_speech_'</span> \</div><div class="line">          <span class="string">'demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=4&amp;per=4&amp;vol=5&amp;pit=5'</span>.format(text)</div><div class="line">    <span class="comment"># 用mplayer播放语音</span></div><div class="line">    os.system(<span class="string">'mplayer "%s"'</span> % url)</div></pre></td></tr></table></figure></p>
<h1 id="安装播放媒体软件"><a href="#安装播放媒体软件" class="headerlink" title="安装播放媒体软件"></a>安装播放媒体软件</h1><p>上面代码你看到的<code>mplayer</code>,就是用来播放语音的，传个url作为参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mplayer</div><div class="line">usage: mplayer [url]</div></pre></td></tr></table></figure></p>
<h1 id="播放音乐"><a href="#播放音乐" class="headerlink" title="播放音乐"></a>播放音乐</h1><p>有了上面这个神器，你可以给播报语音前后加一首音乐😄<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">playMusic</span><span class="params">(path)</span>:</span></div><div class="line">    os.system(<span class="string">'mplayer %s'</span> % path)</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用上面的东东，可以组合些好玩的东西了，至于闹钟的唤醒，可以crob job 做，也可以代码里面实现，enjoy…😄<br>全部代码地址 <a href="https://github.com/ejunjsh/raspberrypi-code/blob/master/clock/weather.py" target="_blank" rel="external">https://github.com/ejunjsh/raspberrypi-code/blob/master/clock/weather.py</a></p>
]]></content>
      
        <categories>
            
            <category> raspberrypi </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> raspberrypi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用go实现一个简单的restful接口]]></title>
      <url>/2017/07/18/go-first-rest/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>go的标准库<code>http</code>已经封装好很多接口，可以很简单实现一个web服务器。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义 handler</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</div><div class="line">    io.WriteString(w, <span class="string">"hello, world!\n"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">//绑定pattern和handler</span></div><div class="line">    http.HandleFunc(<span class="string">"/hello"</span>, HelloServer)</div><div class="line">    err := http.ListenAndServe(<span class="string">":12345"</span>, <span class="literal">nil</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基于上面例子可以封装一个restful接口，不是难事。<br><a id="more"></a></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>从上面例子可以看到，一个url pattern对应一个handler，即对应一个处理，就可以处理http请求了，所以下面的实现是基于对这两个东西的封装开始</p>
<h2 id="封装一个restful-app-结构"><a href="#封装一个restful-app-结构" class="headerlink" title="封装一个restful app 结构"></a>封装一个restful app 结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">//一个map，key是pattern，value是handler</span></div><div class="line">	handlers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(r *HttpRequest,w HttpResponse)</span><span class="title">error</span></span></div><div class="line">    //<span class="title">pattern</span>数组，用来保证加入<span class="title">pattern</span>的顺序，因为上面的<span class="title">map</span>是无顺序的</div><div class="line">	<span class="title">patterns</span> []<span class="title">string</span></div><div class="line">    //一个<span class="title">map</span>，<span class="title">key</span>是<span class="title">pattern</span>，<span class="title">value</span>是<span class="title">http</span> <span class="title">method</span></div><div class="line">	<span class="title">methods</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></div><div class="line">    //用来实现在<span class="title">url</span> <span class="title">path</span>取出参数的。</div><div class="line">	<span class="title">regexps</span> <span class="title">map</span>[<span class="title">string</span>]*<span class="title">regexp</span>.<span class="title">Regexp</span></div><div class="line">	<span class="title">pathparamanmes</span> <span class="title">map</span>[<span class="title">string</span>][]<span class="title">string</span></div><div class="line">    //用来处理异常的<span class="title">handler</span></div><div class="line">	<span class="title">errHandler</span> <span class="title">func</span><span class="params">( err error, r *HttpRequest,w HttpResponse)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApp</span><span class="params">()</span> *<span class="title">App</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;App&#123;</div><div class="line">		handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>),</span></div><div class="line">		<span class="title">patterns</span>:<span class="title">make</span><span class="params">([]<span class="keyword">string</span>,0)</span>,</div><div class="line">		<span class="title">methods</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span>,</div><div class="line">		<span class="title">regexps</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]*regexp.Regexp)</span>,</div><div class="line">		<span class="title">pathparamanmes</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span>,</div><div class="line">        //一个默认的异常处理，直接返回异常内容</div><div class="line">		<span class="title">errHandler</span>: <span class="title">func</span><span class="params">(err error, r *HttpRequest, w HttpResponse)</span> &#123;</div><div class="line">			w.Write( []<span class="keyword">byte</span>(err.Error()))</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="映射绑定"><a href="#映射绑定" class="headerlink" title="映射绑定"></a>映射绑定</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">handle</span><span class="params">(method <span class="keyword">string</span>,pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span> <span class="title">error</span>)</span>&#123;</div><div class="line">    <span class="comment">//绑定pattern和handler</span></div><div class="line">	a.handlers[pattern]=handler</div><div class="line">    <span class="comment">//绑定pattern和method</span></div><div class="line">	a.methods[pattern]=method</div><div class="line">    <span class="comment">//绑定pattern 正则，用来匹配url pattern,和获取url path 参数</span></div><div class="line">	a.regexps[pattern],a.pathparamanmes[pattern]=convertPatterntoRegex(pattern)</div><div class="line">	<span class="keyword">for</span> _,s:=<span class="keyword">range</span> a.patterns&#123;</div><div class="line">		<span class="keyword">if</span> s==pattern&#123;</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//加入数组，方便用此数组确定顺序</span></div><div class="line">	a.patterns=<span class="built_in">append</span>(a.patterns,pattern)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//绑定GET</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Get</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"GET"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定POST</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Post</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"POST"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定DELETE</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Delete</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"DELETE"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定PUT</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Put</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span> <span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"PUT"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Error</span><span class="params">(handler <span class="keyword">func</span>(err error,r *HttpRequest,w HttpResponse)</span>)</span>  &#123;</div><div class="line">	a.errHandler=handler</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了Restful接口的四个方法映射绑定，剩下的就要请求能进到来，所以接下来要写个入口才行。</p>
<h2 id="编写http入口"><a href="#编写http入口" class="headerlink" title="编写http入口"></a>编写http入口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//http 入口</span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">Run</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</div><div class="line">	fmt.Printf(<span class="string">"Server listens on %s"</span>,address)</div><div class="line">	err:=http.ListenAndServe(address,&amp;hodler&#123;app:a&#125;)</div><div class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//https 入口</span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">RunTls</span><span class="params">(address <span class="keyword">string</span>,cert <span class="keyword">string</span>,key <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</div><div class="line">	fmt.Printf(<span class="string">"Server listens on %s"</span>,address)</div><div class="line">	err:=http.ListenAndServeTLS(address,cert,key,&amp;hodler&#123;app:a&#125;)</div><div class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>入口函数主要调用<code>http</code>库来启动http服务，然后把请求处理函数作为<code>ListenAndServe</code>第二个参数传入。这里由<code>holder</code>来实现这个处理函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hodler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</div><div class="line">	<span class="comment">//封装一下，附加更多功能</span></div><div class="line">    request:= newHttpRequest(r)</div><div class="line">	response:=newHttpResponse(w)</div><div class="line">	<span class="comment">//捕获panic，并让errhandler处理返回。</span></div><div class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span>&#123;</div><div class="line">			<span class="keyword">if</span> e,ok:=err.(error);ok&#123;</div><div class="line">				h.app.errHandler(InternalError&#123;e,<span class="string">""</span>&#125;,request,response)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> e,ok:=err.(<span class="keyword">string</span>);ok&#123;</div><div class="line">				h.app.errHandler(InternalError&#123;<span class="literal">nil</span>,e&#125;,request,response)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">    <span class="comment">//根据pattern的添加顺序，循环判断</span></div><div class="line">   <span class="keyword">for</span> _,p:=<span class="keyword">range</span> h.app.patterns&#123;</div><div class="line">       <span class="keyword">if</span> reg,ok:= h.app.regexps[p];ok&#123;</div><div class="line">           <span class="comment">//匹配method</span></div><div class="line">		   <span class="keyword">if</span> method,ok:=h.app.methods[p];ok&amp;&amp;r.Method==method&#123;</div><div class="line">              <span class="comment">//匹配pattern</span></div><div class="line">			   <span class="keyword">if</span> reg.Match([]<span class="keyword">byte</span>(r.URL.Path)) &#123;</div><div class="line">                   <span class="comment">//抽取url path parameters</span></div><div class="line">				   matchers:=reg.FindSubmatch([]<span class="keyword">byte</span>(r.URL.Path))</div><div class="line">				   pathParamMap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</div><div class="line">				   <span class="keyword">if</span> <span class="built_in">len</span>(matchers)&gt;<span class="number">1</span>&#123;</div><div class="line">                       <span class="keyword">if</span> pathParamNames,ok:=h.app.pathparamanmes[p];ok&#123;</div><div class="line">						   <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(matchers);i++&#123;</div><div class="line">							   pathParamMap[pathParamNames[i]]=<span class="keyword">string</span>(matchers[i])</div><div class="line">						   &#125;</div><div class="line">					   &#125;</div><div class="line">				   &#125;</div><div class="line">                   <span class="comment">//PathParams是封装后的request独有的属性</span></div><div class="line">				   request.PathParams=pathParamMap</div><div class="line">				   <span class="keyword">if</span> handler,ok:=h.app.handlers[p];ok&#123;</div><div class="line">                       <span class="comment">//执行handler</span></div><div class="line">					   err:=handler(request,response)</div><div class="line">					   <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">                           <span class="comment">//执行errhandler</span></div><div class="line">						   h.app.errHandler(err,request,response)</div><div class="line">					   &#125;</div><div class="line">					   <span class="keyword">return</span></div><div class="line">				   &#125;</div><div class="line">			   &#125;</div><div class="line">		   &#125;</div><div class="line">	   &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//执行no found errhandler</span></div><div class="line">	h.app.errHandler(NoFoundError&#123;&#125;,request,response)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基本一个请求的流程如下：<br>requset-&gt;ServeHTTP()-&gt;匹配url pattern-&gt;匹配method-&gt;匹配到你的handler-&gt;执行你的handler-&gt;你的handler返回结果</p>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>由于返回结果可以有很多，所以封装了<code>http</code>库的<code>http.ResponseWriter</code>来实现<code>WriteString,WriteJson,WriteXml,WriteFile</code>等方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//封装request，附件一个PathParams来保存url path parameters.</span></div><div class="line"><span class="keyword">type</span> HttpRequest <span class="keyword">struct</span> &#123;</div><div class="line">	*http.Request</div><div class="line">	PathParams <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> HttpResponse <span class="keyword">struct</span> &#123;</div><div class="line">	http.ResponseWriter</div><div class="line">&#125;</div><div class="line"><span class="comment">//用来返回字符</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteString</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回JSON</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteJson</span><span class="params">(jsonObj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回XML</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteXml</span><span class="params">(xmlObj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回文件</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteFile</span><span class="params">(filepath <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回一个模板html</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteTemplates</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;,tplPath ...<span class="keyword">string</span>)</span> <span class="title">error</span></span>  &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//new 一个restful接口</span></div><div class="line">	app:=gorest.NewApp()</div><div class="line">    <span class="comment">//绑定</span></div><div class="line">	app.Get(<span class="string">"/json"</span>, <span class="function"><span class="keyword">func</span><span class="params">(r *gorest.HttpRequest, w gorest.HttpResponse)</span> <span class="title">error</span></span> &#123;</div><div class="line">		a:= <span class="keyword">struct</span> &#123;</div><div class="line">			Abc <span class="keyword">string</span> <span class="string">`json:"abc"`</span></div><div class="line">			Cba <span class="keyword">string</span> <span class="string">`json:"cba"`</span></div><div class="line">		&#125;&#123;<span class="string">"123"</span>,<span class="string">"321"</span>&#125;</div><div class="line">        <span class="comment">//返回json作为结果</span></div><div class="line">		<span class="keyword">return</span> w.WriteJson(a)</div><div class="line">	&#125;)</div><div class="line">	app.Error(<span class="function"><span class="keyword">func</span><span class="params">(err error, r *gorest.HttpRequest, w gorest.HttpResponse)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span> e,ok:=err.(gorest.NoFoundError);ok &#123;</div><div class="line">			w.Write([]<span class="keyword">byte</span>(e.Error()))</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> e,ok:=err.(gorest.InternalError);ok &#123;</div><div class="line">			w.Write([]<span class="keyword">byte</span>(e.Error()))</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">    <span class="comment">//启动</span></div><div class="line">	app.Run(<span class="string">":8081"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>收工😄</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>go的标准库封装了很多了，所以实现这个其实还是比较轻松的😄<br>详细代码见<a href="https://github.com/ejunjsh/gorest" target="_blank" rel="external">https://github.com/ejunjsh/gorest</a></p>
]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> restful </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一张图了解一致性hash]]></title>
      <url>/2017/07/16/consistent-hash/</url>
      <content type="html"><![CDATA[<p><a href="/images/consistent-hash.png"><img src="/images/consistent-hash.png" alt="one image describes how consistent-hash works"></a><br><a id="more"></a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一张图了解hashmap]]></title>
      <url>/2017/07/15/hashmap/</url>
      <content type="html"><![CDATA[<p><a href="/images/hashmap.png"><img src="/images/hashmap.png" alt="one image describes how hashmap works"></a><br><a id="more"></a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通过反编译深入理解Java String及intern]]></title>
      <url>/2016/07/29/java-string-intern/</url>
      <content type="html"><![CDATA[<h1 id="字符串问题"><a href="#字符串问题" class="headerlink" title="字符串问题"></a>字符串问题</h1><p>字符串在我们平时的编码工作中其实用的非常多，并且用起来也比较简单，所以很少有人对其做特别深入的研究。倒是面试或者笔试的时候，往往会涉及比较深入和难度大一点的问题。我在招聘的时候也偶尔会问应聘者相关的问题，倒不是说一定要回答的特别正确和深入，通常问这些问题的目的有两个，第一是考察对 JAVA 基础知识的了解程度，第二是考察应聘者对技术的态度。<br><a id="more"></a><br>　　我们看看以下程序会输出什么结果？如果你能正确的回答每一道题，并且清楚其原因，那本文对你就没什么太大的意义。如果回答不正确或者不是很清楚其原理，那就仔细看看以下的分析，本文应该能帮助你清楚的理解每段程序的结果及输出该结果的深层次原因。</p>
<p>代码段一：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.string;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String str1 = <span class="string">"string"</span>;</div><div class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"string"</span>);</div><div class="line">        String str3 = str2.intern();</div><div class="line"> </div><div class="line">        System.out.println(str1==str2);<span class="comment">//#1</span></div><div class="line">        System.out.println(str1==str3);<span class="comment">//#2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段二：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> com.paddx.test.string;</div><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest01</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String baseStr = <span class="string">"baseStr"</span>;</div><div class="line">        <span class="keyword">final</span> String baseFinalStr = <span class="string">"baseStr"</span>;</div><div class="line"> </div><div class="line">        String str1 = <span class="string">"baseStr01"</span>;</div><div class="line">        String str2 = <span class="string">"baseStr"</span>+<span class="string">"01"</span>;</div><div class="line">        String str3 = baseStr + <span class="string">"01"</span>;</div><div class="line">        String str4 = baseFinalStr+<span class="string">"01"</span>;</div><div class="line">        String str5 = <span class="keyword">new</span> String(<span class="string">"baseStr01"</span>).intern();</div><div class="line"> </div><div class="line">        System.out.println(str1 == str2);<span class="comment">//#3</span></div><div class="line">        System.out.println(str1 == str3);<span class="comment">//#4</span></div><div class="line">        System.out.println(str1 == str4);<span class="comment">//#5</span></div><div class="line">        System.out.println(str1 == str5);<span class="comment">//#6</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段三（1）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.string;&lt;br&gt;　　</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</div><div class="line">        str2.intern();</div><div class="line">        String str1 = <span class="string">"str01"</span>;</div><div class="line">        System.out.println(str2==str1);<span class="comment">//#7</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段三（2）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> com.paddx.test.string;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternTest01</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String str1 = <span class="string">"str01"</span>;</div><div class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</div><div class="line">        str2.intern();</div><div class="line">        System.out.println(str2 == str1);<span class="comment">//#8</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了方便描述，我对上述代码的输出结果由#1~#8进行了编码，下文中蓝色字体部分即为结果。</p>
<h1 id="字符串深入分析"><a href="#字符串深入分析" class="headerlink" title="字符串深入分析"></a>字符串深入分析</h1><h2 id="代码段一分析"><a href="#代码段一分析" class="headerlink" title="代码段一分析"></a>代码段一分析</h2><p>字符串不属于基本类型，但是可以像基本类型一样，直接通过字面量赋值，当然也可以通过new来生成一个字符串对象。不过通过字面量赋值的方式和new的方式生成字符串有本质的区别：<br><a href="/images/java-string-intern-1.jpg"><img src="/images/java-string-intern-1.jpg" alt=""></a> </p>
<p>通过字面量赋值创建字符串时，会优先在常量池中查找是否已经存在相同的字符串，倘若已经存在，栈中的引用直接指向该字符串；倘若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。而通过new的方式创建字符串时，就直接在堆中生成一个字符串的对象（备注，JDK 7 以后，HotSpot 已将常量池从永久代转移到了堆中。详细信息可参考《<a href="/2016/07/26/java8-permgen-metaspace/">JDK8内存模型-消失的PermGen</a>》一文），栈中的引用指向该对象。对于堆中的字符串对象，可以通过 intern() 方法来将字符串添加的常量池中，并返回指向该常量的引用。<br>现在我们应该能很清楚代码段一的结果了：</p>
<font color="blue">结果 #1：因为str1指向的是字符串中的常量，str2是在堆中生成的对象，所以str1==str2返回false。<br>结果 #2：str2调用intern方法，会将str2中值（“string”）复制到常量池中，但是常量池中已经存在该字符串（即str1指向的字符串），所以直接返回该字符串的引用，因此str1==str2返回true。</font>

<p>以下运行代码段一的代码的结果：<br><a href="/images/java-string-intern-2.jpg"><img src="/images/java-string-intern-2.jpg" alt=""></a> </p>
<h2 id="代码段二分析"><a href="#代码段二分析" class="headerlink" title="代码段二分析"></a>代码段二分析</h2><p>对于代码段二的结果，还是通过反编译StringTest01.class文件比较容易理解：<br>常量池内容（部分）：<br><a href="/images/java-string-intern-3.jpg"><img src="/images/java-string-intern-3.jpg" alt=""></a><br>执行指令（部分，第二列#+序数对应常量池中的项）：<br><a href="/images/java-string-intern-4.jpg"><img src="/images/java-string-intern-4.jpg" alt=""></a><br>在解释上述执行过程之前，先了解两条指令：</p>
<p>ldc：Push item from run-time constant pool，从常量池中加载指定项的引用到栈。</p>
<p>astore_<n>：Store reference into local variable，将引用赋值给第n个局部变量。</n></p>
<p>现在我们开始解释代码段二的执行过程：</p>
<p>0: ldc           #2：加载常量池中的第二项（”baseStr”）到栈中。</p>
<p>2: astore_1      ：将1中的引用赋值给第一个局部变量，即String baseStr = “baseStr”；</p>
<p>3: ldc           #2：加载常量池中的第二项（”baseStr”）到栈中。</p>
<p>5: astore_2      ：将3中的引用赋值给第二个局部变量，即 final String baseFinalStr=”baseStr”； </p>
<p>6: ldc           #3：加载常量池中的第三项（”baseStr01”）到栈中。</p>
<p>8: astore_3     ：将6中的引用赋值给第三个局部变量，即String str1=”baseStr01”;</p>
<p>9: ldc           #3：加载常量池中的第三项（”baseStr01”）到栈中。</p>
<p>11: astore        4：将9中的引用赋值给第四个局部变量：即String str2=”baseStr01”；</p>
<font color="blue"><br>结果#3：str1==str2 肯定会返回true，因为str1和str2都指向常量池中的同一引用地址。所以其实在JAVA 1.6之后，常量字符串的“+”操作，编译阶段直接会合成为一个字符串。</font><br>13: new           #4：生成StringBuilder的实例。<br><br>16: dup 　　　　   ：复制13生成对象的引用并压入栈中。<br><br>17: invokespecial #5：调用常量池中的第五项，即StringBuilder.<init>方法。<br><br>以上三条指令的作用是生成一个StringBuilder的对象。<br><br>20: aload_1　　：加载第一个参数的值，即”baseStr”<br><br>21: invokevirtual #6 ：调用StringBuilder对象的append方法。<br><br>24: ldc           #7：加载常量池中的第七项（”01”）到栈中。<br><br>26: invokevirtual #6：调用StringBuilder.append方法。<br><br>29: invokevirtual #8：调用StringBuilder.toString方法。<br><br>32: astore        5：将29中的结果引用赋值改第五个局部变量，即对变量str3的赋值。<br><font color="blue"><br>结果 #4：因为str3实际上是stringBuilder.append()生成的结果，所以与str1不相等，结果返回false。</font><br>34: ldc           #3：加载常量池中的第三项（”baseStr01”）到栈中。<br><br>36: astore        6：将34中的引用赋值给第六个局部变量，即str4=”baseStr01”;<br><font color="blue"><br>结果 #5 ：因为str1和str4指向的都是常量池中的第三项，所以str1==str4返回true。这里我们还能发现一个现象，对于final字段，编译期直接进行了常量替换，而对于非final字段则是在运行期进行赋值处理的。</font><br>38: new           #9：创建String对象<br><br>41: dup               ：复制引用并压如栈中。<br><br>42: ldc           #3：加载常量池中的第三项（”baseStr01”）到栈中。<br><br>44: invokespecial #10：调用String.”<init>“方法，并传42步骤中的引用作为参数传入该方法。<br><br>47: invokevirtual #11：调用String.intern方法。<br><br>从38到41的对应的源码就是new String(“baseStr01”).intern()。<br><br>50: astore        7：将47步返回的结果赋值给变量7，即str5指向baseStr01在常量池中的位置。<br><font color="blue"><br>结果 #6 ：因为str5和str1都指向的都是常量池中的同一个字符串，所以str1==str5返回true。</font><br>运行代码段二，输出结果如下：<br><a href="/images/java-string-intern-5.jpg"><img src="/images/java-string-intern-5.jpg" alt=""></a><br><br>## 代码段三解析：<br>对于代码段三，在 JDK 1.6 和 JDK 1.7中的运行结果不同。我们先看一下运行结果，然后再来解释其原因：<br><br>JDK 1.6 下的运行结果：<br><a href="/images/java-string-intern-6.jpg"><img src="/images/java-string-intern-6.jpg" alt=""></a><br>JDK 1.7 下的运行结果：<br><a href="/images/java-string-intern-7.jpg"><img src="/images/java-string-intern-7.jpg" alt=""></a><br><br>根据对代码段一的分析，应该可以很简单得出 JDK 1.6 的结果，因为 str2 和 str1本来就是指向不同的位置，理应返回false。<br><br>比较奇怪的问题在于JDK 1.7后，对于第一种情况返回true，但是调换了一下位置返回的结果就变成了false。这个原因主要是从JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7 后的intern方法在实现上发生了比较大的改变，JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。所以:<br><font color="blue"><br>结果 #7：在第一种情况下，因为常量池中没有“str01”这个字符串，所以会在常量池中生成一个对堆中的“str01”的引用，而在进行字面量赋值的时候，常量池中已经存在，所以直接返回该引用即可，因此str1和str2都指向堆中的字符串，返回true。<br><br>结果 #8：调换位置以后，因为在进行字面量赋值（String str1 = “str01”）的时候，常量池中不存在，所以str1指向的常量池中的位置，而str2指向的是堆中的对象，再进行intern方法时，对str1和str2已经没有影响了，所以返回false。</font>

<h1 id="常见面试题解答"><a href="#常见面试题解答" class="headerlink" title="常见面试题解答"></a>常见面试题解答</h1><p>有了对以上的知识的了解，我们现在再来看常见的面试或笔试题就很简单了：</p>
<p>Q：String s = new String(“xyz”)，创建了几个String Object? </p>
<p>A：两个，常量池中的”xyz”和堆中对象。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s1 = “abc”;<br>String s2 = “abc”;<br>System.out.println(s1 == s2);</p>
<p>A：true，均指向常量池中对象。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s1 = new String(“abc”);<br>String s2 = new String(“abc”);<br>System.out.println(s1 == s2);</p>
<p>A：false，两个引用指向堆中的不同对象。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s1 = “abc”;<br>String s2 = “a”;<br>String s3 = “bc”;<br>String s4 = s2 + s3;<br>System.out.println(s1 == s4);</p>
<p>A：false，因为s2+s3实际上是使用StringBuilder.append来完成，会生成不同的对象。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s1 = “abc”;<br>final String s2 = “a”;<br>final String s3 = “bc”;<br>String s4 = s2 + s3;<br>System.out.println(s1 == s4);</p>
<p>A：true，因为final变量在编译后会直接替换成对应的值，所以实际上等于s4=”a”+”bc”，而这种情况下，编译器会直接合并为s4=”abc”，所以最终s1==s4。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s = new String(“abc”);<br>String s1 = “abc”;<br>String s2 = new String(“abc”);</p>
<p>System.out.println(s == s1.intern());<br>System.out.println(s == s2.intern());<br>System.out.println(s1 == s2.intern());</p>
<p>A：false，false，true，具体原因参考第二部分内容。</p>
<p>原文地址 <a href="http://www.cnblogs.com/paddix/p/5326863.html" target="_blank" rel="external">http://www.cnblogs.com/paddix/p/5326863.html</a></p>
</init></init>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java8内存模型—永久代(PermGen)和元空间(Metaspace)]]></title>
      <url>/2016/07/26/java8-permgen-metaspace/</url>
      <content type="html"><![CDATA[<h1 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h1><p>根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。<br><a href="/images/java8-permgen-metaspace-1.png"><img src="/images/java8-permgen-metaspace-1.png" alt=""></a><br><a id="more"></a></p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误，不过这个深度范围不是一个恒定的值，我们通过下面这段程序可以测试一下这个结果：<br>栈溢出测试源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorMock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">1</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</div><div class="line">        index++;</div><div class="line">        call();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StackErrorMock mock = <span class="keyword">new</span> StackErrorMock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mock.call();</div><div class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</div><div class="line">            System.out.println(<span class="string">"Stack deep : "</span>+index);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段1</p>
<p>运行三次，可以看出每次栈的深度都是不一样的，输出结果如下。<br><a href="/images/java8-permgen-metaspace-2.png"><img src="/images/java8-permgen-metaspace-2.png" alt=""></a><br>至于红色框里的值是怎么出来的，就需要深入到 JVM 的源码中才能探讨，这里不作详细阐述。</p>
<p>虚拟机栈除了上述错误外，还有另一种错误，那就是当申请不到空间时，会抛出 OutOfMemoryError。这里有一个小细节需要注意，catch 捕获的是 Throwable，而不是 Exception。因为 StackOverflowError 和 OutOfMemoryError 都不属于 Exception 的子类。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>这部分主要与虚拟机用到的 Native 方法相关，一般情况下， Java 应用程序员并不需要关心这部分的内容</p>
<h2 id="PC-寄存器"><a href="#PC-寄存器" class="headerlink" title="PC 寄存器"></a>PC 寄存器</h2><p>PC 寄存器，也叫程序计数器。JVM支持多个线程同时运行，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native 方法，则PC寄存器中为空。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。下面我们简单的模拟一个堆内存溢出的情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOomMock</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">while</span> (flag)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                i++;</div><div class="line">                list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);<span class="comment">//每次增加一个1M大小的数组对象</span></div><div class="line">            &#125;<span class="keyword">catch</span> (Throwable e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">                System.out.println(<span class="string">"count="</span>+i);<span class="comment">//记录运行的次数</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段2</p>
<p>运行上述代码，输出结果如下：　<br><a href="/images/java8-permgen-metaspace-3.png"><img src="/images/java8-permgen-metaspace-3.png" alt=""></a><br><em>注意，这里我指定了堆内存的大小为16M，所以这个地方显示的count=14（这个数字不是固定的），至于为什么会是14或其他数字，需要根据 GC 日志来判断</em></p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>　　方法区也是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。 关于方法区内存溢出的问题会在下文中详细探讨。</p>
<h1 id="PermGen（永久代）"><a href="#PermGen（永久代）" class="headerlink" title="PermGen（永久代）"></a>PermGen（永久代）</h1><p>绝大部分 Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space “这个异常。这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。我们现在通过动态生成类来模拟 “PermGen space”的内存溢出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"><span class="keyword">import</span> java.net.URLClassLoader;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermGenOomMock</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        URL url = <span class="keyword">null</span>;</div><div class="line">        List&lt;ClassLoader&gt; classLoaderList = <span class="keyword">new</span> ArrayList&lt;ClassLoader&gt;();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            url = <span class="keyword">new</span> File(<span class="string">"/tmp"</span>).toURI().toURL();</div><div class="line">            URL[] urls = &#123;url&#125;;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">                ClassLoader loader = <span class="keyword">new</span> URLClassLoader(urls);</div><div class="line">                classLoaderList.add(loader);</div><div class="line">                loader.loadClass(<span class="string">"com.paddx.test.memory.Test"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码段3</p>
<p>运行结果如下：<br><a href="/images/java8-permgen-metaspace-4.png"><img src="/images/java8-permgen-metaspace-4.png" alt=""></a><br>　　本例中使用的 JDK 版本是 1.7，指定的 PermGen 区的大小为 8M。通过每次生成不同URLClassLoader对象来加载Test类，从而生成不同的类对象，这样就能看到我们熟悉的 “java.lang.OutOfMemoryError: PermGen space “ 异常了。这里之所以采用 JDK 1.7，是因为在 JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。下面我们就来看看 Metaspace 与 PermGen space 的区别。</p>
<h1 id="Metaspace（元空间）"><a href="#Metaspace（元空间）" class="headerlink" title="Metaspace（元空间）"></a>Metaspace（元空间）</h1><p>其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。我们可以通过一段程序来比较 JDK 1.6 与 JDK 1.7及 JDK 1.8 的区别，以字符串常量为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringOomMock</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> String  base = <span class="string">"string"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; Integer.MAX_VALUE;i++)&#123;</div><div class="line">            String str = base + base;</div><div class="line">            base = str;</div><div class="line">            list.add(str.intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段4</p>
<p>这段程序以2的指数级不断的生成新的字符串，这样可以比较快速的消耗内存。我们通过 JDK 1.6、JDK 1.7 和 JDK 1.8 分别运行：<br>JDK 1.6 的运行结果：<br><a href="/images/java8-permgen-metaspace-5.png"><img src="/images/java8-permgen-metaspace-5.png" alt=""></a><br>JDK 1.7的运行结果：<br><a href="/images/java8-permgen-metaspace-6.png"><img src="/images/java8-permgen-metaspace-6.png" alt=""></a><br>JDK 1.8的运行结果：<br><a href="/images/java8-permgen-metaspace-7.png"><img src="/images/java8-permgen-metaspace-7.png" alt=""></a><br>从上述结果可以看出，JDK 1.6下，会出现“PermGen Space”的内存溢出，而在 JDK 1.7和 JDK 1.8 中，会出现堆内存溢出，并且 JDK 1.8中 PermSize 和 MaxPermGen 已经无效。因此，可以大致验证 JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论。现在我们看看元空间到底是一个什么东西？</p>
<p>　　元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<p>　　-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。<br>　　-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p>
<p>　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：<br>　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集<br>　　-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p>
<p>现在我们在 JDK 8下重新运行一下代码段3，不过这次不再指定 PermSize 和 MaxPermSize。而是指定 MetaSpaceSize 和 MaxMetaSpaceSize的大小。输出结果如下：<br><a href="/images/java8-permgen-metaspace-8.png"><img src="/images/java8-permgen-metaspace-8.png" alt=""></a><br>从输出结果，我们可以看出，这次不再出现永久代溢出，而是出现了元空间的溢出。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　通过上面分析，大家应该大致了解了 JVM 的内存划分，也清楚了 JDK 8 中永久代向元空间的转换。不过大家应该都有一个疑问，就是为什么要做这个转换？所以，最后给大家总结以下几点原因：</p>
<ul>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
<li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li>
</ul>
<p>原文地址 <a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="external">http://www.cnblogs.com/paddix/p/5309550.html</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从字节码层面看“HelloWorld”]]></title>
      <url>/2016/07/23/bytecode-hello-world/</url>
      <content type="html"><![CDATA[<h1 id="HelloWorld-字节码生成"><a href="#HelloWorld-字节码生成" class="headerlink" title="HelloWorld 字节码生成"></a>HelloWorld 字节码生成</h1><p>众所周知，Java 程序是在 JVM 上运行的，不过 JVM 运行的其实不是 Java 语言本身，而是 Java 程序编译成的字节码文件。可能一开始 JVM 是为 Java 语言服务的，不过随着编译技术和 JVM 自身的不断发展和成熟，JVM 已经不仅仅只运行 Java 程序。任何能编译成为符合 JVM 字节码规范的语言都可以在 JVM 上运行，比较常见的 Scala、Groove、JRuby等。今天，我就从大家最熟悉的程序“HelloWorld”程序入手，分析整个 Class 文件的结构。虽然这个程序比较简单，但是基本上包含了字节码规范中的所有内容，因此即使以后要分析更复杂的程序，那也只是“量”上的变化，本质上没有区别。<br><a id="more"></a><br>　　我们先直观的看下源码与字节码之间的对应关系:<br>HelloWorld的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.asm;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello,World!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器采用JDK 1.7：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>编译以后的字节码文件（使用UltraEdit的16进制模式打开）：<br><a href="/images/bytecode-hello-world-1.jpg"><img src="/images/bytecode-hello-world-1.jpg" alt=""></a><br>红色框内的部分就是HelloWorld.class的内容，其他部分是UltraEdit自动生成的：红色框顶部的0~f代表列号，左边部分代表行号，右侧部分是二进制码对应的字符（utf-8编码）。</p>
<h1 id="字节码解析"><a href="#字节码解析" class="headerlink" title="字节码解析"></a>字节码解析</h1><p>要弄明白 HelloWorld.java 和 HelloWorld.class 文件是如何对应的，我们必须对 JVM 的字节码规范有所了解。字节码文件的结构非常紧凑，没有任何冗余的信息，连分隔符都没有，它采用的是固定的文件结构和数据类型来实现对内容的分割的。字节码中包括两种数据类型：无符号数和表。无符号数又包括 u1，u2，u4，u8四种，分别代表1个字节、2个字节、4个字节和8个字节。而表结构则是由无符号数据组成的。</p>
<p>字节码文件的格式固定如下：</p>
<table>
<thead>
<tr>
<th>type</th>
<th>descriptor</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool[cosntant_pool_count – 1]</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count]</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
</tr>
<tr>
<td>field_info</td>
<td>fields[fields_count]</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
</tr>
<tr>
<td>method_info</td>
<td>methods[methods_count]</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes[attributes_count]</td>
</tr>
</tbody>
</table>
<p>现在，我们就按这个格式对上述HelloWorld.class文件进行分析：</p>
<p>magic（u4）：CA FE BA BE ，代表该文件是一个字节码文件，我们平时区分文件类型都是通过后缀名来区分的，不过后缀名是可以随便修改的，所以仅靠后缀名不能真正区分一个文件的类型。区分文件类型的另个办法就是magic数字，JVM 就是通过 CA FE BA BE 来判断该文件是不是class文件。</p>
<p>minor_version（u2）：00 00，小版本号，因为我这里采用的1.7，所以小版本号为0.</p>
<p>major_version（u2）：00 33，大版本号，x033转换为十进制为51，下表是jdk 1.6 以后对应支持的 Class 文件版本号：</p>
<table>
<thead>
<tr>
<th>编译器版本</th>
<th>-target参数</th>
<th>十六进制版本</th>
<th>十进制版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK 1.6.0_01</td>
<td>不带（默认 -target 1.6）</td>
<td>00 00 00 32</td>
<td>50.0</td>
</tr>
<tr>
<td>JDK 1.6.0_01</td>
<td>-target 1.5</td>
<td>00 00 00 31</td>
<td>49.0</td>
</tr>
<tr>
<td>JDK 1.6.0_01</td>
<td>-target 1.4 -source 1.4</td>
<td>00 00 00 30</td>
<td>48.0</td>
</tr>
<tr>
<td>JDK 1.7.0</td>
<td>不带（默认 -target 1.7）</td>
<td>00 00 00 33</td>
<td>51.0</td>
</tr>
<tr>
<td>JDK 1.7.0</td>
<td>-target 1.6</td>
<td>00 00 00 32</td>
<td>50.0</td>
</tr>
<tr>
<td>JDK 1.7.0</td>
<td>-target 1.4 -source 1.4</td>
<td>00 00 00 30</td>
<td>48.0</td>
</tr>
<tr>
<td>JDK 1.8.0</td>
<td>不带（默认 -target 1.8）</td>
<td>00 00 00 34</td>
<td>52.0</td>
</tr>
</tbody>
</table>
<p>constant_pool_count（u2）：00 22，常量池数量，转换为十进制后为34，这里需要注意的是，字节码的常量池是从1开始计数的，所以34表示为（34-1）=33项。</p>
<p>TAG（u1）：0A，常量池的数据类型是表，每一项的开始都有一个tag（u1），表示常量的类型，常量池的表的类型包括如下14种，这里A（10）表示CONSTANT_Methodref，代表方法引用。</p>
<table>
<thead>
<tr>
<th>常量类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Utf8_info</td>
<td>1</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
</tr>
</tbody>
</table>
<p>每种常量类型对应表结构：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th style="text-align:right">项目</th>
<th style="text-align:right">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Utf8_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">length</td>
<td style="text-align:right">u2</td>
<td>字节数</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">bytes</td>
<td style="text-align:right">u1</td>
<td>utf-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>3</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">bytes</td>
<td style="text-align:right">u4</td>
<td>int值</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u4</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">bytes</td>
<td style="text-align:right">u1</td>
<td>float值</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>5</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">bytes</td>
<td style="text-align:right">u8</td>
<td>long值</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">bytes</td>
<td style="text-align:right">u8</td>
<td>double值</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>7</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向全限定名常量项的索引</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向字符串常量的索引</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>9</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向声明字段的类或接口描述符CONSTANT_Class_info的索引值</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向CONSTANT_NameAndType_info的索引值</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>10</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向声明方法的类描述符CONSTANT_Class_info的索引值</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向CONSTANT_NameAndType_info的索引值</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>11</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向声明方法的接口描述符CONSTANT_Class_info的索引值</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向CONSTANT_NameAndType_info的索引值</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>12</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向该字段或方法名称常量的索引值</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向该字段或方法描述符常量的索引值</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>15</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">reference_kind</td>
<td style="text-align:right">u1</td>
<td>值必须1~9，它决定了方法句柄的的类型</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">reference_index</td>
<td style="text-align:right">u2</td>
<td>对常量池的索引</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>16</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">description_index</td>
<td style="text-align:right">u2</td>
<td>对常量池中方法描述符的索引</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>18</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">bootstap_method_attr_index</td>
<td style="text-align:right">u2</td>
<td>对引导方法表的索引</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">name_and_type_index</td>
<td style="text-align:right">u2</td>
<td>对CONSTANT_NameAndType_info的索引</td>
</tr>
</tbody>
</table>
<p>CONSTANT_Methodref_info（u2):00 06，因为tag为A，代表一个方法引用表（CONSTANT_Methodref_info），所以第二项（u2）应该是指向常量池的位置，即常量池的第六项，表示一个CONSTANT_Class_info表的索引，用类似的方法往下分析，可以发现常量池的第六项如下，tag类型为07，查询上表可知道其即为CONSTANT_Class_info。<br><a href="/images/bytecode-hello-world-2.jpg"><img src="/images/bytecode-hello-world-2.jpg" alt=""></a><br> 07之后的00 1B表示对常量池地27项（CONSTANT_Utf8_info）的引用，查看第27项如下图，即（java/lang/Object）：<br> <a href="/images/bytecode-hello-world-3.jpg"><img src="/images/bytecode-hello-world-3.jpg" alt=""></a><br> CONSTANT_NameAndType_info（u2）：00 14,方法引用表的第三项（u2），常量池索引，指向第20项。</p>
<p>CONSTANT_Fieldref_info（u1）：tag为09。</p>
<p>…..</p>
<p>常量池的分析都类似，其他的分析由于篇幅问题就不在此一一讲述了。跳过常量池就到了访问标识（u2）：<br> <a href="/images/bytecode-hello-world-4.jpg"><img src="/images/bytecode-hello-world-4.jpg" alt=""></a><br>  JVM 对访问标示符的规范如下：</p>
<table>
<thead>
<tr>
<th>Flag Name</th>
<th>Value</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>pubilc</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>final</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>用于兼容早期编译器，新编译器都设置该标记，以在使用 invokespecial指令时对子类方法做特定处理。</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>接口，同时需要设置：ACC_ABSTRACT。不可同时设置：ACC_FINAL、ACC_SUPER、ACC_ENUM</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>抽象类，无法实例化。不可与ACC_FINAL同时设置。</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>synthetic，由编译器产生，不存在于源代码中。</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>注解类型（annotation），需同时设置：ACC_INTERFACE、ACC_ABSTRACT</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>枚举类型</td>
</tr>
</tbody>
</table>
<p> 这个表里面无法直接查询到0021这个值，原因是0021=0020+0001，即public+invokespecial指令，源码中的方法main是public的，而invokespecial是现在的版本都有的，所以值为0021。</p>
<p>接着往下是this_class（u2）：是指向constant pool的索引值，该值必须是CONSTANT_Class_info类型，值为00 05，即指向常量池中的第五项，第五项指向常量池中的第26项，即com/paddx/test/asm/HelloWorld：<br> <a href="/images/bytecode-hello-world-5.jpg"><img src="/images/bytecode-hello-world-5.jpg" alt=""></a></p>
<p>super_class(u2)）：super_class是指向constant pool的索引值，该值必须是CONSTANT_Class_info类型，指定当前字节码定义的类或接口的直接父类。这里的取值为00 06，根据上面的分析，对应的指向的全限定性类名为java/lang/object，即当前类的父类为Object类。</p>
<p>interfaces_count（u2）：接口的数量，因为这里没有实现接口，所以值为 00 00。</p>
<p>interfaces[interfaces_count]：因为没有接口，所以就不存在interfces选项。</p>
<p>field_count：属性数量，00 00。</p>
<p>field_info：因为没有属性，所以不存在这个选项。</p>
<p>method_count：00 02，为什么会有两个方法呢？我们明明只写了一个方法，这是因为JVM 会自动生成一个 <init>的方法。</init></p>
<p>method_info：方法表，其结构如下：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Descriptor</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>access_flag</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attribute_info[attributes_count]</td>
</tr>
</tbody>
</table>
<p>HelloWorld.class文件中对应的数据：<br> <a href="/images/bytecode-hello-world-6.jpg"><img src="/images/bytecode-hello-world-6.jpg" alt=""></a></p>
<p> access_flag（u2）: 00 01</p>
<p>name_index（u2）:00 07</p>
<p>descriptor_index（u2）:00 08</p>
<p>可以看看 07、08对应的常量池里面的值：<br> <a href="/images/bytecode-hello-world-7.jpg"><img src="/images/bytecode-hello-world-7.jpg" alt=""></a></p>
<p>即 07 对应的是 &#60;init&#62;，08 对应的是()；</p>
<p>attributes_count:00 01，表示包含一个属性</p>
<p>attribute_info：属性表，该表的结构如下：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Descriptor</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
</tr>
</tbody>
</table>
<p> <a href="/images/bytecode-hello-world-8.jpg"><img src="/images/bytecode-hello-world-8.jpg" alt=""></a></p>
<p>attribute_name_index（u2）: 00 09，指向常量池中的索引。</p>
<p>attribute_length（u4）：00 00 00 2F，属性的长度47。</p>
<p>attribute_info:具体属性的分析与上面类似，大家可以对着JVM的规范自己尝试分析一下。</p>
<p>第一个方法结束后，接着进入第二个方法：<br> <a href="/images/bytecode-hello-world-9.jpg"><img src="/images/bytecode-hello-world-9.jpg" alt=""></a><br> 第二个方法的属性长度为x037，转换为十进制为55个字节。两个方法之后紧跟着的是attribute_count和attributes：<br>  <a href="/images/bytecode-hello-world-10.jpg"><img src="/images/bytecode-hello-world-10.jpg" alt=""></a><br>attribute_count（u2）:值为 00 01，即有一个属性。</p>
<p>attribute_name_index（u2）：指向常量池中的第十二项。</p>
<p>attribute_length（u4）：00 00 00 02，长度为2。</p>
<p>分析完毕！</p>
<h1 id="基于字节码的操作"><a href="#基于字节码的操作" class="headerlink" title="基于字节码的操作"></a>基于字节码的操作</h1><p>　　通过对HelloWorld这个程序的字节码分析，我们应该能够比较清楚的认识到整个字节码的结构。那我们通过字节码，可以做些什么呢？其实通过字节码能做很多平时我们无法完成的工作。比如，在类加载之前添加某些操作或者直接动态的生成字节码，CGlib就是通过这种方式来实现动态代理的。现在，我们就来完成另一个版本的HelloWorld：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.asm;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们有个空的方法 sayHello()，现在要实现调该方法的时候打印出“HelloWorld”，怎么处理？如果我们手动去修改字节码文件，将打印“HelloWorld”的代码插入到sayHello方法中，原理上肯定没问题，不过操作过程还是比较复杂的。Java 的最大优势就在于只要你能想到的功能，基本上就有第三方开源的库实现过。字节码操作的开源库也比较多，这里我就用 ASM 4.0来实现该功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.asm;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.objectweb.asm.*;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsmDemo</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, IllegalAccessException, InstantiationException, InvocationTargetException </span>&#123;</div><div class="line">        ClassReader classReader = <span class="keyword">new</span> ClassReader(<span class="string">"com.paddx.test.asm.HelloWorld2"</span>);</div><div class="line">        ClassWriter cw=<span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);</div><div class="line">        CustomVisitor myv=<span class="keyword">new</span> CustomVisitor(Opcodes.ASM4,cw);</div><div class="line">        classReader.accept(myv, <span class="number">0</span>);</div><div class="line"> </div><div class="line">        <span class="keyword">byte</span>[] code=cw.toByteArray();</div><div class="line"> </div><div class="line">        AsmDemo loader=<span class="keyword">new</span> AsmDemo();</div><div class="line">        Class&lt;?&gt; appClass=loader.defineClass(<span class="keyword">null</span>, code, <span class="number">0</span>,code.length);</div><div class="line">        appClass.getMethods()[<span class="number">0</span>].invoke(appClass.newInstance(), <span class="keyword">new</span> Object[]&#123;&#125;);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomVisitor</span><span class="params">(<span class="keyword">int</span> api, ClassVisitor cv)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(api, cv);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</div><div class="line">        MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</div><div class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"sayHello"</span>)) &#123;</div><div class="line">            mv.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</div><div class="line">            mv.visitLdcInsn(<span class="string">"HelloWorld!"</span>);</div><div class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mv;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如下：<br>  <a href="/images/bytecode-hello-world-11.jpg"><img src="/images/bytecode-hello-world-11.jpg" alt=""></a></p>
<p>关于 ASM 4的操作在这就不细说了。有兴趣的朋友可以自己去研究一下，有机会，我也可以再后续的博文中跟大家分享。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　本文通过HelloWorld这样一个大家都非常熟悉的例子，深入的分析了字节码文件的结构。利用这些特性，我们可以完成一些相对高级的功能，如动态代理等。这些例子虽然都很简单，但是“麻雀虽小五脏俱全”，即使再复杂的程序也逃离不了这些最基本的东西。技术层面的东西就是这样子，只要你能了解一个简单的程序的原理，举一反三，就能很容易的理解更复杂的程序，这就是技术“易”的方面。同时，反过来说，即使“HelloWorld”这样一个简单的程序，如果我们深入探究，也不一定能特别理解其原理，这就是技术“难”的方面。总之，技术这种东西只要你用心深入地去研究，总是能带给你意想不到的惊喜~</p>
<p>原文地址 <a href="http://www.cnblogs.com/paddix/p/5282004.html" target="_blank" rel="external">http://www.cnblogs.com/paddix/p/5282004.html</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis cluster管理工具redis-trib.rb详解]]></title>
      <url>/2016/04/22/redis-trib/</url>
      <content type="html"><![CDATA[<blockquote>
<p>redis-trib.rb是redis官方推出的管理redis集群的工具，集成在redis的源码src目录下，是基于redis提供的集群命令封装成简单、便捷、实用的操作工具。redis-trib.rb是redis作者用ruby完成的。为了看懂redis-trib.rb，我特意花了一个星期学习了ruby，也被ruby的简洁、明了所吸引。ruby是门非常灵活的语言，redis-trib.rb只用了1600行左右的代码，就实现了强大的集群操作。本文对redis-trib.rb的介绍是基于redis 3.0.6版本的源码。阅读本文需要对redis集群功能有一定的了解。关于redis集群功能的介绍，可以参考本人的另一篇文章《redis3.0 cluster功能介绍》。</p>
</blockquote>
<a id="more"></a>
<h1 id="help-信息"><a href="#help-信息" class="headerlink" title="help 信息"></a>help 信息</h1><p>先从redis-trib.rb的help信息，看下redis-trib.rb提供了哪些功能。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb <span class="built_in">help</span></div><div class="line">Usage: redis-trib &lt;<span class="built_in">command</span>&gt; &lt;options&gt; &lt;arguments ...&gt;</div><div class="line"></div><div class="line">  create          host1:port1 ... hostN:portN</div><div class="line">                  --replicas &lt;arg&gt;</div><div class="line">  check           host:port</div><div class="line">  info            host:port</div><div class="line">  fix             host:port</div><div class="line">                  --timeout &lt;arg&gt;</div><div class="line">  reshard         host:port</div><div class="line">                  --from &lt;arg&gt;</div><div class="line">                  --to &lt;arg&gt;</div><div class="line">                  --slots &lt;arg&gt;</div><div class="line">                  --yes</div><div class="line">                  --timeout &lt;arg&gt;</div><div class="line">                  --pipeline &lt;arg&gt;</div><div class="line">  rebalance       host:port</div><div class="line">                  --weight &lt;arg&gt;</div><div class="line">                  --auto-weights</div><div class="line">                  --threshold &lt;arg&gt;</div><div class="line">                  --use-empty-masters</div><div class="line">                  --timeout &lt;arg&gt;</div><div class="line">                  --simulate</div><div class="line">                  --pipeline &lt;arg&gt;</div><div class="line">  add-node        new_host:new_port existing_host:existing_port</div><div class="line">                  --slave</div><div class="line">                  --master-id &lt;arg&gt;</div><div class="line">  del-node        host:port node_id</div><div class="line">  <span class="built_in">set</span>-timeout     host:port milliseconds</div><div class="line">  call            host:port <span class="built_in">command</span> arg arg .. arg</div><div class="line">  import          host:port</div><div class="line">                  --from &lt;arg&gt;</div><div class="line">                  --copy</div><div class="line">                  --replace</div><div class="line">  <span class="built_in">help</span>            (show this <span class="built_in">help</span>)</div><div class="line"></div><div class="line">For check, fix, reshard, del-node, <span class="built_in">set</span>-timeout you can specify the host and port of any working node <span class="keyword">in</span> the cluster.</div></pre></td></tr></table></figure></p>
<p>可以看到redis-trib.rb具有以下功能：<br>1、create：创建集群<br>2、check：检查集群<br>3、info：查看集群信息<br>4、fix：修复集群<br>5、reshard：在线迁移slot<br>6、rebalance：平衡集群节点slot数量<br>7、add-node：将新节点加入集群<br>8、del-node：从集群中删除节点<br>9、set-timeout：设置集群节点间心跳连接的超时时间<br>10、call：在集群全部节点上执行命令<br>11、import：将外部redis数据导入集群<br>下面从redis-trib.rb使用和源码的角度详细介绍redis-trib.rb的每个功能。</p>
<p>redis-trib.rb主要有两个类：ClusterNode和RedisTrib。ClusterNode保存了每个节点的信息，RedisTrib则是redis-trib.rb各个功能的实现。</p>
<h1 id="ClusterNode对象"><a href="#ClusterNode对象" class="headerlink" title="ClusterNode对象"></a>ClusterNode对象</h1><p>先分析ClusterNode源码。ClusterNode有下面几个成员变量（ruby的类成员变量是以@开头的）：<br>@r：执行redis命令的客户端对象。<br>@info：保存了该节点的详细信息，包括cluster nodes命令中自己这行的信息和cluster info的信息。<br>@dirty：节点信息是否需要更新，如果为true，我们需要把内存的节点更新信息到节点上。<br>@friends：保存了集群其他节点的info信息。其信息为通过cluster nodes命令获得的其他节点信息。<br>ClusterNode有下面一些成员方法：<br>initialize：ClusterNode的构造方法，需要传入节点的地址信息。<br>friends：返回@friends对象。<br>slots：返回该节点负责的slots信息。<br>has_flag?：判断节点info信息的的flags中是否有给定的flag。<br>to_s：类似java的toString方法，返回节点的地址信息。<br>connect：连接redis节点。<br>assert_cluster：判断节点开启了集群配置。<br>assert_empty：确定节点目前没有跟任何其他节点握手，同时自己的db数据为空。<br>load_info：通过cluster info和cluster nodes导入节点信息。<br>add_slots：给节点增加slot，该操作只是在内存中修改，并把dirty设置成true，等待flush_node_config将内存中的数据同步在节点执行。<br>set_as_replica：slave设置复制的master地址。dirty设置成true。<br>flush_node_config：将内存的数据修改同步在集群节点中执行。<br>info_string：简单的info信息。<br>get_config_signature：用来验证集群节点见的cluster nodes信息是否一致。该方法返回节点的签名信息。<br>info：返回@info对象，包含详细的info信息。<br>is_dirty?：判断@dirty。<br>r：返回执行redis命令的客户端对象。</p>
<p>有了ClusterNode对象，在处理集群操作的时候，就获得了集群的信息，可以进行集群相关操作。在此先简单介绍下redis-trib.rb脚本的使用，以create为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create host1:port1 ... hostN:portN</div><div class="line">       --replicas &lt;arg&gt;</div></pre></td></tr></table></figure></p>
<p>host1:port1 … hostN:portN表示子参数，这个必须在可选参数之后，–replicas <arg>是可选参数，带的表示后面必须填写一个参数，像–slave这样，后面就不带参数，掌握了这个基本规则，就能从help命令中获得redis-trib.rb的使用方法。</arg></p>
<p>其他命令大都需要传递host:port，这是redis-trib.rb为了连接集群，需要选择集群中的一个节点，然后通过该节点获得整个集群的信息。</p>
<p>下面就一一详细介绍redis-trib.rb的每个功能。</p>
<h1 id="create创建集群"><a href="#create创建集群" class="headerlink" title="create创建集群"></a>create创建集群</h1><p>create命令可选replicas参数，replicas表示需要有几个slave。最简单命令使用如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb create 10.180.157.199:6379 10.180.157.200:6379 10.180.157.201:6379</div></pre></td></tr></table></figure></p>
<p>有一个slave的创建命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb create --replicas 1 10.180.157.199:6379 10.180.157.200:6379 10.180.157.201:6379 10.180.157.202:6379  10.180.157.205:6379  10.180.157.208:6379</div></pre></td></tr></table></figure></p>
<p>创建流程如下：<br>1、首先为每个节点创建ClusterNode对象，包括连接每个节点。检查每个节点是否为独立且db为空的节点。执行load_info方法导入节点信息。<br>2、检查传入的master节点数量是否大于等于3个。只有大于3个节点才能组成集群。<br>3、计算每个master需要分配的slot数量，以及给master分配slave。分配的算法大致如下：<br>先把节点按照host分类，这样保证master节点能分配到更多的主机中。<br>不停遍历遍历host列表，从每个host列表中弹出一个节点，放入interleaved数组。直到所有的节点都弹出为止。<br>master节点列表就是interleaved前面的master数量的节点列表。保存在masters数组。<br>计算每个master节点负责的slot数量，保存在slots_per_node对象，用slot总数除以master数量取整即可。<br>遍历masters数组，每个master分配slots_per_node个slot，最后一个master，分配到16384个slot为止。<br>接下来为master分配slave，分配算法会尽量保证master和slave节点不在同一台主机上。对于分配完指定slave数量的节点，还有多余的节点，也会为这些节点寻找master。分配算法会遍历两次masters数组。<br>第一次遍历masters数组，在余下的节点列表找到replicas数量个slave。每个slave为第一个和master节点host不一样的节点，如果没有不一样的节点，则直接取出余下列表的第一个节点。<br>第二次遍历是在对于节点数除以replicas不为整数，则会多余一部分节点。遍历的方式跟第一次一样，只是第一次会一次性给master分配replicas数量个slave，而第二次遍历只分配一个，直到余下的节点被全部分配出去。<br>4、打印出分配信息，并提示用户输入“yes”确认是否按照打印出来的分配方式创建集群。<br>5、输入“yes”后，会执行flush_nodes_config操作，该操作执行前面的分配结果，给master分配slot，让slave复制master，对于还没有握手（cluster meet）的节点，slave复制操作无法完成，不过没关系，flush_nodes_config操作出现异常会很快返回，后续握手后会再次执行flush_nodes_config。<br>6、给每个节点分配epoch，遍历节点，每个节点分配的epoch比之前节点大1。<br>7、节点间开始相互握手，握手的方式为节点列表的其他节点跟第一个节点握手。<br>8、然后每隔1秒检查一次各个节点是否已经消息同步完成，使用ClusterNode的get_config_signature方法，检查的算法为获取每个节点cluster nodes信息，排序每个节点，组装成node_id1:slots|node_id2:slot2|…的字符串。如果每个节点获得字符串都相同，即认为握手成功。<br>9、此后会再执行一次flush_nodes_config，这次主要是为了完成slave复制操作。<br>10、最后再执行check_cluster，全面检查一次集群状态。包括和前面握手时检查一样的方式再检查一遍。确认没有迁移的节点。确认所有的slot都被分配出去了。<br>11、至此完成了整个创建流程，返回[OK] All 16384 slots covered.。</p>
<h1 id="check检查集群"><a href="#check检查集群" class="headerlink" title="check检查集群"></a>check检查集群</h1><p>检查集群状态的命令，没有其他参数，只需要选择一个集群中的一个节点即可。执行命令以及结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb check 10.180.157.199:6379</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 10.180.157.199:6379)</div><div class="line">M: b2506515b38e6bbd3034d540599f4cd2a5279ad1 10.180.157.199:6379</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: d376aaf80de0e01dde1f8cd4647d5ac3317a8641 10.180.157.205:6379</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates e36c46dbe90960f30861af00786d4c2064e63df2</div><div class="line">M: 15126fb33796c2c26ea89e553418946f7443d5a5 10.180.157.201:6379</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: 59fa6ee455f58a5076f6d6f83ddd74161fd7fb55 10.180.157.208:6379</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 15126fb33796c2c26ea89e553418946f7443d5a5</div><div class="line">S: 460b3a11e296aafb2615043291b7dd98274bb351 10.180.157.202:6379</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b2506515b38e6bbd3034d540599f4cd2a5279ad1</div><div class="line">M: e36c46dbe90960f30861af00786d4c2064e63df2 10.180.157.200:6379</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure></p>
<p>检查前会先执行load_cluster_info_from_node方法，把所有节点数据load进来。load的方式为通过自己的cluster nodes发现其他节点，然后连接每个节点，并加入nodes数组。接着生成节点间的复制关系。</p>
<p>load完数据后，开始检查数据，检查的方式也是调用创建时候使用的check_cluster。</p>
<h1 id="info查看集群信息"><a href="#info查看集群信息" class="headerlink" title="info查看集群信息"></a>info查看集群信息</h1><p>info命令用来查看集群的信息。info命令也是先执行load_cluster_info_from_node获取完整的集群信息。然后显示ClusterNode的info_string结果，示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb info 10.180.157.199:6379</div><div class="line">10.180.157.199:6379 (b2506515...) -&gt; 0 keys | 5461 slots | 1 slaves.</div><div class="line">10.180.157.201:6379 (15126fb3...) -&gt; 0 keys | 5461 slots | 1 slaves.</div><div class="line">10.180.157.200:6379 (e36c46db...) -&gt; 0 keys | 5462 slots | 1 slaves.</div><div class="line">[OK] 0 keys <span class="keyword">in</span> 3 masters.</div><div class="line">0.00 keys per slot on average.</div></pre></td></tr></table></figure></p>
<h1 id="fix修复集群"><a href="#fix修复集群" class="headerlink" title="fix修复集群"></a>fix修复集群</h1><p>fix命令的流程跟check的流程很像，显示加载集群信息，然后在check_cluster方法内传入fix为<br>true的变量，会在集群检查出现异常的时候执行修复流程。目前fix命令能修复两种异常，一种是集群有处于迁移中的slot的节点，一种是slot未完全分配的异常。</p>
<p>fix_open_slot方法是修复集群有处于迁移中的slot的节点异常。<br>1、先检查该slot是谁负责的，迁移的源节点如果没完成迁移，owner还是该节点。没有owner的slot无法完成修复功能。<br>2、遍历每个节点，获取哪些节点标记该slot为migrating状态，哪些节点标记该slot为importing状态。对于owner不是该节点，但是通过cluster countkeysinslot获取到该节点有数据的情况，也认为该节点为importing状态。<br>3、如果migrating和importing状态的节点均只有1个，这可能是迁移过程中redis-trib.rb被中断所致，直接执行move_slot继续完成迁移任务即可。传递dots和fix为true。<br>4、如果migrating为空，importing状态的节点大于0，那么这种情况执行回滚流程，将importing状态的节点数据通过move_slot方法导给slot的owner节点，传递dots、fix和cold为true。接着对importing的节点执行cluster stable命令恢复稳定。<br>5、如果importing状态的节点为空，有一个migrating状态的节点，而且该节点在当前slot没有数据，那么可以直接把这个slot设为stable。<br>6、如果migrating和importing状态不是上述情况，目前redis-trib.rb工具无法修复，上述的三种情况也已经覆盖了通过redis-trib.rb工具迁移出现异常的各个方面，人为的异常情形太多，很难考虑完全。</p>
<p>fix_slots_coverage方法能修复slot未完全分配的异常。未分配的slot有三种状态。<br>1、所有节点的该slot都没有数据。该状态redis-trib.rb工具直接采用随机分配的方式，并没有考虑节点的均衡。本人尝试对没有分配slot的集群通过fix修复集群，结果slot还是能比较平均的分配，但是没有了连续性，打印的slot信息非常离散。<br>2、有一个节点的该slot有数据。该状态下，直接把slot分配给该slot有数据的节点。<br>3、有多个节点的该slot有数据。此种情况目前还处于TODO状态，不过redis作者列出了修复的步骤，对这些节点，除第一个节点，执行cluster migrating命令，然后把这些节点的数据迁移到第一个节点上。清除migrating状态，然后把slot分配给第一个节点。</p>
<h1 id="reshard在线迁移slot"><a href="#reshard在线迁移slot" class="headerlink" title="reshard在线迁移slot"></a>reshard在线迁移slot</h1><p>reshard命令可以在线把集群的一些slot从集群原来slot负责节点迁移到新的节点，利用reshard可以完成集群的在线横向扩容和缩容。<br>reshard的参数很多，下面来一一解释一番：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">reshard         host:port</div><div class="line">                --from &lt;arg&gt;</div><div class="line">                --to &lt;arg&gt;</div><div class="line">                --slots &lt;arg&gt;</div><div class="line">                --yes</div><div class="line">                --timeout &lt;arg&gt;</div><div class="line">                --pipeline &lt;arg&gt;</div></pre></td></tr></table></figure></p>
<p>host:port：这个是必传参数，用来从一个节点获取整个集群信息，相当于获取集群信息的入口。<br>–from <arg>：需要从哪些源节点上迁移slot，可从多个源节点完成迁移，以逗号隔开，传递的是节点的node id，还可以直接传递–from all，这样源节点就是集群的所有节点，不传递该参数的话，则会在迁移过程中提示用户输入。<br>–to <arg>：slot需要迁移的目的节点的node id，目的节点只能填写一个，不传递该参数的话，则会在迁移过程中提示用户输入。<br>–slots <arg>：需要迁移的slot数量，不传递该参数的话，则会在迁移过程中提示用户输入。<br>–yes：设置该参数，可以在打印执行reshard计划的时候，提示用户输入yes确认后再执行reshard。<br>–timeout <arg>：设置migrate命令的超时时间。<br>–pipeline <arg>：定义cluster getkeysinslot命令一次取出的key数量，不传的话使用默认值为10。</arg></arg></arg></arg></arg></p>
<p>迁移的流程如下：<br>1、通过load_cluster_info_from_node方法装载集群信息。<br>2、执行check_cluster方法检查集群是否健康。只有健康的集群才能进行迁移。<br>3、获取需要迁移的slot数量，用户没传递–slots参数，则提示用户手动输入。<br>4、获取迁移的目的节点，用户没传递–to参数，则提示用户手动输入。此处会检查目的节点必须为master节点。<br>5、获取迁移的源节点，用户没传递–from参数，则提示用户手动输入。此处会检查源节点必须为master节点。–from all的话，源节点就是除了目的节点外的全部master节点。这里为了保证集群slot分配的平均，建议传递–from all。<br>6、执行compute_reshard_table方法，计算需要迁移的slot数量如何分配到源节点列表，采用的算法是按照节点负责slot数量由多到少排序，计算每个节点需要迁移的slot的方法为：迁移slot数量 * (该源节点负责的slot数量 / 源节点列表负责的slot总数)。这样算出的数量可能不为整数，这里代码用了下面的方式处理：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">n = (numslots/source_tot_slots*s.slots.length)</div><div class="line"><span class="keyword">if</span> i == <span class="number">0</span></div><div class="line">    n = n.ceil</div><div class="line"><span class="keyword">else</span></div><div class="line">    n = n.floor</div></pre></td></tr></table></figure></p>
<p>这样的处理方式会带来最终分配的slot与请求迁移的slot数量不一致，这个BUG已经在github上提给作者，<a href="https://github.com/antirez/redis/issues/2990。" target="_blank" rel="external">https://github.com/antirez/redis/issues/2990。</a><br>7、打印出reshard计划，如果用户没传–yes，就提示用户确认计划。<br>8、根据reshard计划，一个个slot的迁移到新节点上，迁移使用move_slot方法，该方法被很多命令使用，具体可以参见下面的迁移流程。move_slot方法传递dots为true和pipeline数量。<br>9、至此，就完成了全部的迁移任务。<br>下面看下一次reshard的执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb reshard --from all --to 80b661ecca260c89e3d8ea9b98f77edaeef43dcd --slots 11 10.180.157.199:6379</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 10.180.157.199:6379)</div><div class="line">S: b2506515b38e6bbd3034d540599f4cd2a5279ad1 10.180.157.199:6379</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 460b3a11e296aafb2615043291b7dd98274bb351</div><div class="line">S: d376aaf80de0e01dde1f8cd4647d5ac3317a8641 10.180.157.205:6379</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates e36c46dbe90960f30861af00786d4c2064e63df2</div><div class="line">M: 15126fb33796c2c26ea89e553418946f7443d5a5 10.180.157.201:6379</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: 59fa6ee455f58a5076f6d6f83ddd74161fd7fb55 10.180.157.208:6379</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 15126fb33796c2c26ea89e553418946f7443d5a5</div><div class="line">M: 460b3a11e296aafb2615043291b7dd98274bb351 10.180.157.202:6379</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">M: 80b661ecca260c89e3d8ea9b98f77edaeef43dcd 10.180.157.200:6380</div><div class="line">   slots: (0 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">M: e36c46dbe90960f30861af00786d4c2064e63df2 10.180.157.200:6379</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div><div class="line"></div><div class="line">Ready to move 11 slots.</div><div class="line">  Source nodes:</div><div class="line">    M: 15126fb33796c2c26ea89e553418946f7443d5a5 10.180.157.201:6379</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">    M: 460b3a11e296aafb2615043291b7dd98274bb351 10.180.157.202:6379</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">    M: e36c46dbe90960f30861af00786d4c2064e63df2 10.180.157.200:6379</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">  Destination node:</div><div class="line">    M: 80b661ecca260c89e3d8ea9b98f77edaeef43dcd 10.180.157.200:6380</div><div class="line">   slots: (0 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">  Resharding plan:</div><div class="line">    Moving slot 5461 from e36c46dbe90960f30861af00786d4c2064e63df2</div><div class="line">    Moving slot 5462 from e36c46dbe90960f30861af00786d4c2064e63df2</div><div class="line">    Moving slot 5463 from e36c46dbe90960f30861af00786d4c2064e63df2</div><div class="line">    Moving slot 5464 from e36c46dbe90960f30861af00786d4c2064e63df2</div><div class="line">    Moving slot 0 from 460b3a11e296aafb2615043291b7dd98274bb351</div><div class="line">    Moving slot 1 from 460b3a11e296aafb2615043291b7dd98274bb351</div><div class="line">    Moving slot 2 from 460b3a11e296aafb2615043291b7dd98274bb351</div><div class="line">    Moving slot 10923 from 15126fb33796c2c26ea89e553418946f7443d5a5</div><div class="line">    Moving slot 10924 from 15126fb33796c2c26ea89e553418946f7443d5a5</div><div class="line">    Moving slot 10925 from 15126fb33796c2c26ea89e553418946f7443d5a5</div><div class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</div><div class="line">Moving slot 5461 from 10.180.157.200:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 5462 from 10.180.157.200:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 5463 from 10.180.157.200:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 5464 from 10.180.157.200:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 0 from 10.180.157.202:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 1 from 10.180.157.202:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 2 from 10.180.157.202:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 10923 from 10.180.157.201:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 10924 from 10.180.157.201:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 10925 from 10.180.157.201:6379 to 10.180.157.200:6380:</div></pre></td></tr></table></figure></p>
<p>move_slot方法可以在线将一个slot的全部数据从源节点迁移到目的节点，fix、reshard、rebalance都需要调用该方法迁移slot。<br>move_slot接受下面几个参数，<br>1、pipeline：设置一次从slot上获取多少个key。<br>2、quiet：迁移会打印相关信息，设置quiet参数，可以不用打印这些信息。<br>3、cold：设置cold，会忽略执行importing和migrating。<br>4、dots：设置dots，则会在迁移过程打印迁移key数量的进度。<br>5、update：设置update，则会更新内存信息，方便以后的操作。</p>
<p>move_slot流程如下：<br>1、如果没有设置cold，则对源节点执行cluster importing命令，对目的节点执行migrating命令。fix的时候有可能importing和migrating已经执行过来，所以此种场景会设置cold。<br>2、通过cluster getkeysinslot命令，一次性获取远节点迁移slot的pipeline个key的数量.<br>3、对这些key执行migrate命令，将数据从源节点迁移到目的节点。<br>4、如果migrate出现异常，在fix模式下，BUSYKEY的异常，会使用migrate的replace模式再执行一次，BUSYKEY表示目的节点已经有该key了，replace模式可以强制替换目的节点的key。不是fix模式就直接返回错误了。<br>5、循环执行cluster getkeysinslot命令，直到返回的key数量为0，就退出循环。<br>6、如果没有设置cold，对每个节点执行cluster setslot命令，把slot赋给目的节点。<br>7、如果设置update，则修改源节点和目的节点的slot信息。<br>8、至此完成了迁移slot的流程。</p>
<h1 id="rebalance平衡集群节点slot数量"><a href="#rebalance平衡集群节点slot数量" class="headerlink" title="rebalance平衡集群节点slot数量"></a>rebalance平衡集群节点slot数量</h1><p>rebalance命令可以根据用户传入的参数平衡集群节点的slot数量，rebalance功能非常强大，可以传入的参数很多，以下是rebalance的参数列表和命令示例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">rebalance       host:port</div><div class="line">                --weight &lt;arg&gt;</div><div class="line">                --auto-weights</div><div class="line">                --threshold &lt;arg&gt;</div><div class="line">                --use-empty-masters</div><div class="line">                --timeout &lt;arg&gt;</div><div class="line">                --simulate</div><div class="line">                --pipeline &lt;arg&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb rebalance --threshold 1 --weight b31e3a2e=5 --weight 60b8e3a1=5 --use-empty-masters  --simulate 10.180.157.199:6379</div></pre></td></tr></table></figure>
<p>下面也先一一解释下每个参数的用法：<br>host:port：这个是必传参数，用来从一个节点获取整个集群信息，相当于获取集群信息的入口。<br>–weight <arg>：节点的权重，格式为node_id=weight，如果需要为多个节点分配权重的话，需要添加多个–weight <arg>参数，即–weight b31e3a2e=5 –weight 60b8e3a1=5，node_id可为节点名称的前缀，只要保证前缀位数能唯一区分该节点即可。没有传递–weight的节点的权重默认为1。<br>–auto-weights：这个参数在rebalance流程中并未用到。<br>–threshold <arg>：只有节点需要迁移的slot阈值超过threshold，才会执行rebalance操作。具体计算方法可以参考下面的rebalance命令流程的第四步。<br>–use-empty-masters：rebalance是否考虑没有节点的master，默认没有分配slot节点的master是不参与rebalance的，设置–use-empty-masters可以让没有分配slot的节点参与rebalance。<br>–timeout <arg>：设置migrate命令的超时时间。<br>–simulate：设置该参数，可以模拟rebalance操作，提示用户会迁移哪些slots，而不会真正执行迁移操作。<br>–pipeline <arg>：与reshar的pipeline参数一样，定义cluster getkeysinslot命令一次取出的key数量，不传的话使用默认值为10。</arg></arg></arg></arg></arg></p>
<p>rebalance命令流程如下：<br>1、load_cluster_info_from_node方法先加载集群信息。<br>2、计算每个master的权重，根据参数–weight <arg>，为每个设置的节点分配权重，没有设置的节点，则权重默认为1。<br>3、根据每个master的权重，以及总的权重，计算自己期望被分配多少个slot。计算的方式为：总slot数量 <em> （自己的权重 / 总权重）。<br>4、计算每个master期望分配的slot是否超过设置的阈值，即–threshold <arg>设置的阈值或者默认的阈值。计算的方式为：先计算期望移动节点的阈值，算法为：(100-(100.0</arg></em>expected/n.slots.length)).abs，如果计算出的阈值没有超出设置阈值，则不需要为该节点移动slot。只要有一个master的移动节点超过阈值，就会触发rebalance操作。<br>5、如果触发了rebalance操作。那么就开始执行rebalance操作，先将每个节点当前分配的slots数量减去期望分配的slot数量获得balance值。将每个节点的balance从小到大进行排序获得sn数组。<br>6、用dst_idx和src_idx游标分别从sn数组的头部和尾部开始遍历。目的是为了把尾部节点的slot分配给头部节点。</arg></p>
<p>sn数组保存的balance列表排序后，负数在前面，正数在后面。负数表示需要有slot迁入，所以使用dst_idx游标，正数表示需要有slot迁出，所以使用src_idx游标。理论上sn数组各节点的balance值加起来应该为0，不过由于在计算期望分配的slot的时候只是使用直接取整的方式，所以可能出现balance值之和不为0的情况，balance值之和不为0即为节点不平衡的slot数量，由于slot总数有16384个，不平衡数量相对于总数，基数很小，所以对rebalance流程影响不大。</p>
<p>7、获取sn[dst_idx]和sn[src_idx]的balance值较小的那个值，该值即为需要从sn[src_idx]节点迁移到sn[dst_idx]节点的slot数量。<br>8、接着通过compute_reshard_table方法计算源节点的slot如何分配到源节点列表。这个方法在reshard流程中也有调用，具体步骤可以参考reshard流程的第六步。<br>9、如果是simulate模式，则只是打印出迁移列表。<br>10、如果没有设置simulate，则执行move_slot操作，迁移slot，传入的参数为:quiet=&gt;true,:dots=&gt;false,:update=&gt;true。<br>11、迁移完成后更新sn[dst_idx]和sn[src_idx]的balance值。如果balance值为0后，游标向前进1。<br>12、直到dst_idx到达src_idx游标，完成整个rebalance操作。</p>
<h1 id="add-node将新节点加入集群"><a href="#add-node将新节点加入集群" class="headerlink" title="add-node将新节点加入集群"></a>add-node将新节点加入集群</h1><p>add-node命令可以将新节点加入集群，节点可以为master，也可以为某个master节点的slave。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">add-node    new_host:new_port existing_host:existing_port</div><div class="line">          --slave</div><div class="line">          --master-id &lt;arg&gt;</div></pre></td></tr></table></figure></p>
<p>add-node有两个可选参数：<br>–slave：设置该参数，则新节点以slave的角色加入集群<br>–master-id：这个参数需要设置了–slave才能生效，–master-id用来指定新节点的master节点。如果不设置该参数，则会随机为节点选择master节点。<br>可以看下add-node命令的执行示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb add-node --slave --master-id dcb792b3e85726f012e83061bf237072dfc45f99 10.180.157.202:6379 10.180.157.199:6379</div><div class="line">&gt;&gt;&gt; Adding node 10.180.157.202:6379 to cluster 10.180.157.199:6379</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 10.180.157.199:6379)</div><div class="line">M: dcb792b3e85726f012e83061bf237072dfc45f99 10.180.157.199:6379</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">M: 464d740bf48953ebcf826f4113c86f9db3a9baf3 10.180.157.201:6379</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">M: befa7e17b4e5f239e519bc74bfef3264a40f96ae 10.180.157.200:6379</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div><div class="line">&gt;&gt;&gt; Send CLUSTER MEET to node 10.180.157.202:6379 to make it join the cluster.</div><div class="line">Waiting <span class="keyword">for</span> the cluster to join.</div><div class="line">&gt;&gt;&gt; Configure node as replica of 10.180.157.199:6379.</div><div class="line">[OK] New node added correctly.</div></pre></td></tr></table></figure></p>
<p>add-node流程如下：<br>1、通过load_cluster_info_from_node方法转载集群信息，check_cluster方法检查集群是否健康。<br>2、如果设置了–slave，则需要为该节点寻找master节点。设置了–master-id，则以该节点作为新节点的master，如果没有设置–master-id，则调用get_master_with_least_replicas方法，寻找slave数量最少的master节点。如果slave数量一致，则选取load_cluster_info_from_node顺序发现的第一个节点。load_cluster_info_from_node顺序的第一个节点是add-node设置的existing_host:existing_port节点，后面的顺序根据在该节点执行cluster nodes返回的结果返回的节点顺序。<br>3、连接新的节点并与集群第一个节点握手。<br>4、如果没设置–slave就直接返回ok，设置了–slave，则需要等待确认新节点加入集群，然后执行cluster replicate命令复制master节点。<br>5、至此，完成了全部的增加节点的流程。</p>
<h1 id="del-node从集群中删除节点"><a href="#del-node从集群中删除节点" class="headerlink" title="del-node从集群中删除节点"></a>del-node从集群中删除节点</h1><p>del-node可以把某个节点从集群中删除。del-node只能删除没有分配slot的节点。删除命令传递两个参数：<br>host:port：从该节点获取集群信息。<br>node_id：需要删除的节点id。<br>del-node执行结果示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb del-node 10.180.157.199:6379 d5f6d1d17426bd564a6e309f32d0f5b96962fe53</div><div class="line">&gt;&gt;&gt; Removing node d5f6d1d17426bd564a6e309f32d0f5b96962fe53 from cluster 10.180.157.199:6379</div><div class="line">&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</div><div class="line">&gt;&gt;&gt; SHUTDOWN the node.</div></pre></td></tr></table></figure></p>
<p>del-node流程如下：<br>1、通过load_cluster_info_from_node方法转载集群信息。<br>2、根据传入的node id获取节点，如果节点没找到，则直接提示错误并退出。<br>3、如果节点分配的slot不为空，则直接提示错误并退出。<br>4、遍历集群内的其他节点，执行cluster forget命令，从每个节点中去除该节点。如果删除的节点是master，而且它有slave的话，这些slave会去复制其他master，调用的方法是get_master_with_least_replicas，与add-node没设置–master-id寻找master的方法一样。<br>5、然后关闭该节点</p>
<p>set-timeout设置集群节点间心跳连接的超时时间<br>set-timeout用来设置集群节点间心跳连接的超时时间，单位是毫秒，不得小于100毫秒，因为100毫秒对于心跳时间来说太短了。该命令修改是节点配置参数cluster-node-timeout，默认是15000毫秒。通过该命令，可以给每个节点设置超时时间，设置的方式使用config set命令动态设置，然后执行config rewrite命令将配置持久化保存到硬盘。以下是示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ruby redis-trib.rb <span class="built_in">set</span>-timeout 10.180.157.199:6379 30000</div><div class="line">&gt;&gt;&gt; Reconfiguring node timeout <span class="keyword">in</span> every cluster node...</div><div class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 10.180.157.199:6379</div><div class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 10.180.157.205:6379</div><div class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 10.180.157.201:6379</div><div class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 10.180.157.200:6379</div><div class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 10.180.157.208:6379</div><div class="line">&gt;&gt;&gt; New node timeout <span class="built_in">set</span>. 5 OK, 0 ERR.</div></pre></td></tr></table></figure></p>
<h1 id="call在集群全部节点上执行命令"><a href="#call在集群全部节点上执行命令" class="headerlink" title="call在集群全部节点上执行命令"></a>call在集群全部节点上执行命令</h1><p>call命令可以用来在集群的全部节点执行相同的命令。call命令也是需要通过集群的一个节点地址，连上整个集群，然后在集群的每个节点执行该命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb call 10.180.157.199:6379 get key</div><div class="line">&gt;&gt;&gt; Calling GET key</div><div class="line">10.180.157.199:6379: MOVED 12539 10.180.157.201:6379</div><div class="line">10.180.157.205:6379: MOVED 12539 10.180.157.201:6379</div><div class="line">10.180.157.201:6379:</div><div class="line">10.180.157.200:6379: MOVED 12539 10.180.157.201:6379</div><div class="line">10.180.157.208:6379: MOVED 12539 10.180.157.201:6379</div></pre></td></tr></table></figure></p>
<h1 id="import将外部redis数据导入集群"><a href="#import将外部redis数据导入集群" class="headerlink" title="import将外部redis数据导入集群"></a>import将外部redis数据导入集群</h1><p>import命令可以把外部的redis节点数据导入集群。导入的流程如下：<br>1、通过load_cluster_info_from_node方法转载集群信息，check_cluster方法检查集群是否健康。<br>2、连接外部redis节点，如果外部节点开启了cluster_enabled，则提示错误。<br>3、通过scan命令遍历外部节点，一次获取1000条数据。<br>4、遍历这些key，计算出key对应的slot。<br>5、执行migrate命令,源节点是外部节点,目的节点是集群slot对应的节点，如果设置了–copy参数，则传递copy参数，如果设置了–replace，则传递replace参数。<br>6、不停执行scan命令，直到遍历完全部的key。<br>7、至此完成整个迁移流程<br>这中间如果出现异常，程序就会停止。没使用–copy模式，则可以重新执行import命令，使用–copy的话，最好清空新的集群再导入一次。</p>
<p>import命令更适合离线的把外部Redis数据导入，在线导入的话最好使用更专业的导入工具，以slave的方式连接redis节点去同步节点数据应该是更好的方式。</p>
<p>下面是一个例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb import --from 10.0.10.1:6379 10.10.10.1:7000</div><div class="line">上面的命令是把 10.0.10.1:6379（redis 2.8）上的数据导入到 10.10.10.1:7000这个节点所在的集群</div></pre></td></tr></table></figure></p>
<p>原文地址<a href="http://blog.csdn.net/huwei2003/article/details/50973967" target="_blank" rel="external">http://blog.csdn.net/huwei2003/article/details/50973967</a></p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python在不同层级目录import模块的方法]]></title>
      <url>/2015/02/18/python-import-module/</url>
      <content type="html"><![CDATA[<blockquote>
<p>使用python进行程序编写时，经常会使用第三方模块包。这种包我们可以通过python setup install 进行安装后，通过import XXX或from XXX import yyy 进行导入。不过如果是自己遍写的依赖包，又不想安装到python的相应目录，可以放到本目录里进行import进行调用；为了更清晰的理清程序之间的关系，例如我们会把这种包放到lib目录再调用。本篇就针对常见的模块调用方法汇总下。</p>
</blockquote>
<a id="more"></a>
<h1 id="同级目录下的调有"><a href="#同级目录下的调有" class="headerlink" title="同级目录下的调有"></a>同级目录下的调有</h1><p>程序结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-- src</div><div class="line">    |-- mod1.py</div><div class="line">    |-- test1.py</div></pre></td></tr></table></figure></p>
<p>若在程序test1.py中导入模块mod1, 则直接使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> mod1</div><div class="line">或</div><div class="line"><span class="keyword">from</span> mod1 <span class="keyword">import</span> *;</div></pre></td></tr></table></figure></p>
<h1 id="调用子目录下的模块"><a href="#调用子目录下的模块" class="headerlink" title="调用子目录下的模块"></a>调用子目录下的模块</h1><p>程序结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-- src</div><div class="line">    |-- mod1.py</div><div class="line">    |-- lib</div><div class="line">    |    |-- mod2.py</div><div class="line">    |-- test1.py</div></pre></td></tr></table></figure></p>
<p>这时看到test1.py和lib目录（即mod2.py的父级目录），如果想在程序test1.py中导入模块mod2.py ，可以在lib件夹中建立空文件<strong>init</strong>.py文件(也可以在该文件中自定义输出模块接口)，然后使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lib.mod2 <span class="keyword">import</span> *</div><div class="line">或</div><div class="line"><span class="keyword">import</span> lib.mod2</div></pre></td></tr></table></figure></p>
<h1 id="调用上级目录下的文件"><a href="#调用上级目录下的文件" class="headerlink" title="调用上级目录下的文件"></a>调用上级目录下的文件</h1><p>程序结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-- src</div><div class="line">    |-- mod1.py</div><div class="line">    |-- lib</div><div class="line">    |    |-- mod2.py</div><div class="line">    |-- sub</div><div class="line">    |    |-- test2.py</div></pre></td></tr></table></figure></p>
<p>这里想要实现test2.py调用mod1.py和mod2.py ，做法是我们先跳到src目录下面，直接可以调用mod1，然后在lib上当下建一个空文件<strong>init</strong>.py ，就可以像第二步调用子目录下的模块一样，通过import  lib.mod2进行调用了。具体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line">sys.path.append(<span class="string">".."</span>)</div><div class="line"><span class="keyword">import</span> mod1</div><div class="line"><span class="keyword">import</span> lib.mod2</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos 启用ftp功能]]></title>
      <url>/2014/08/17/centos-ftp/</url>
      <content type="html"><![CDATA[<p>1.安装vsftpd组件，安装完后，有/etc/vsftpd/vsftpd.conf 文件，用来配置，还有新建了一个ftp用户和ftp的组，指向home目录为/var/ftp,默认是nologin（不能登录系统）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install vsftpd</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>可以用下面命令查看用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /etc/passwd</div></pre></td></tr></table></figure></p>
<p>默认ftp服务是没有启动的，用下面命令启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service vsftpd start</div></pre></td></tr></table></figure></p>
<p>2.安装ftp客户端组件（用来验证是否vsftpd）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install ftp</div></pre></td></tr></table></figure></p>
<p>执行命令尝试登录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftp localhost</div></pre></td></tr></table></figure></p>
<p>输入用户名ftp，密码随便（因为默认是允许匿名的）</p>
<p>登录成功，就代表ftp服务可用了。</p>
<p>但是，外网是访问不了的，所以还要继续配置。</p>
<p>3.取消匿名登陆<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/vsftpd/vsftpd.conf</div></pre></td></tr></table></figure></p>
<p>把第一行的 anonymous_enable=YES ，改为NO<br>重启<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service vsftpd restart</div></pre></td></tr></table></figure></p>
<p>4.新建一个用户(ftpuser为用户名，随便就可以)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd ftpuser</div></pre></td></tr></table></figure></p>
<p>修改密码（输入两次）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">passwd ftpuser</div></pre></td></tr></table></figure></p>
<p>这样一个用户建完，可以用这个登录，记得用普通登录不要用匿名了。登录后默认的路径为 /home/ftpuser.</p>
<p>5.开放21端口</p>
<p>因为ftp默认的端口为21，而centos默认是没有开启的，所以要修改iptables文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/sysconfig/iptables</div></pre></td></tr></table></figure></p>
<p>在行上面有22 -j ACCEPT 下面另起一行输入跟那行差不多的，只是把22换成21，然后：wq保存。<br>还要运行下,重启iptables<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service iptables restart</div></pre></td></tr></table></figure></p>
<p>外网是可以访问上去了，可是发现没法返回目录，也上传不了，因为selinux作怪了。<br>6.修改selinux<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getsebool -a | grep ftp</div></pre></td></tr></table></figure></p>
<p>执行上面命令，再返回的结果看到两行都是off，代表，没有开启外网的访问<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.... </div><div class="line">allow_ftpd_full_access off </div><div class="line">....</div><div class="line">....</div><div class="line">ftp_home_dir off</div></pre></td></tr></table></figure></p>
<p>只要把上面都变成on就行<br>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setsebool -P allow_ftpd_full_access 1 </div><div class="line">setsebool -P ftp_home_dir off 1</div></pre></td></tr></table></figure></p>
<p>再重启一下vsftpd<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service vsftpd restart</div></pre></td></tr></table></figure></p>
<p>这样应该没问题了（如果，还是不行，看看是不是用了ftp客户端工具用了passive模式访问了，如提示Entering Passive mode，就代表是passive模式，默认是不行的，因为ftp passive模式被iptables挡住了，下面会讲怎么开启，如果懒得开的话，就看看你客户端ftp是否有port模式的选项，或者把passive模式的选项去掉。如果客户端还是不行，看看客户端上的主机的电脑是否开了防火墙，关吧）</p>
<p>7.开启passive模式</p>
<p>默认是开启的，但是要指定一个端口范围，打开vsftpd.conf文件，在后面加上<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pasv_min_port=30000</div><div class="line"></div><div class="line">pasv_max_port=30999</div></pre></td></tr></table></figure></p>
<p>表示端口范围为30000~30999，这个可以随意改。<br>改完重启一下vsftpd</p>
<p>由于指定这段端口范围，iptables也要相应的开启这个范围，所以像上面那样打开iptables文件</p>
<p>也是在21上下面另起一行，更那行差不多，只是把21 改为30000:30999,然后:wq保存，重启下iptables。这样就搞定了。</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用cglib生成的代理类取不到注解的问题]]></title>
      <url>/2014/07/19/cglib-annonation/</url>
      <content type="html"><![CDATA[<p>百度找了一下没找到，谷歌搜一下就出来了（会点英语就是好）</p>
<p>直接在注解上面加@Inherited<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原来CGLIB 返回的代理类是基于原来类的子类的，加上这个标志就可以令子类继承这个注解（唉，基础啊）<br>链接<a href="http://stackoverflow.com/questions/1706751/retain-annotations-on-cglib-proxies" target="_blank" rel="external">http://stackoverflow.com/questions/1706751/retain-annotations-on-cglib-proxies</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[maven resource 记录]]></title>
      <url>/2014/02/20/maven-resouce/</url>
      <content type="html"><![CDATA[<p>今天遇到maven打包的时候发现在main/java里面的xml没有打包进jar上。</p>
<p>上网搜了下，maven默认打包main/resource的资源，要想打包main/java的要像下面这样配。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span> </div><div class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span> </div><div class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span> </div><div class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span> </div><div class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span> </div><div class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span> </div><div class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.tld<span class="tag">&lt;/<span class="name">include</span>&gt;</span> </div><div class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span> </div><div class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span> </div><div class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>搞定收工。。。不知道有没有更好到方法呢？</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux awk命令详解]]></title>
      <url>/2014/01/06/linux-awk/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>
<p>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</p>
<p>awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。<br><a id="more"></a></p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;pattern + action&#125;&apos; &#123;filenames&#125;</div></pre></td></tr></table></figure>
<p>尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。</p>
<p>awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。</p>
<p>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</p>
<h1 id="调用awk"><a href="#调用awk" class="headerlink" title="调用awk"></a>调用awk</h1><p>有三种方式调用awk</p>
<p>1.命令行方式<br>awk [-F  field-separator]  ‘commands’  input-file(s)<br>其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。<br>在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。</p>
<p>2.shell脚本方式<br>将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。<br>相当于shell脚本首行的：#!/bin/sh<br>可以换成：#!/bin/awk</p>
<p>3.将所有的awk命令插入一个单独文件，然后调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk -f awk-script-file input-file(s)</div></pre></td></tr></table></figure></p>
<p>其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。</p>
<p>本章重点介绍命令行方式。</p>
<h1 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h1><p>假设last -n 5的输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@www ~]# last -n 5 &lt;==仅取出前五行</div><div class="line">root     pts/1   192.168.1.100  Tue Feb 10 11:21   still logged in</div><div class="line">root     pts/1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)</div><div class="line">root     pts/1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)</div><div class="line">dmtsai   pts/1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)</div><div class="line">root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)</div></pre></td></tr></table></figure>
<p>如果只是显示最近登录的5个帐号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#last -n 5 | awk  &apos;&#123;print $1&#125;&apos;</div><div class="line">root</div><div class="line">root</div><div class="line">root</div><div class="line">dmtsai</div><div class="line">root</div></pre></td></tr></table></figure>
<p>awk工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”,所以$1表示登录用户，$3表示登录用户ip,以此类推。</p>
<p>如果只是显示/etc/passwd的账户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#cat /etc/passwd |awk  -F &apos;:&apos;  &apos;&#123;print $1&#125;&apos;  </div><div class="line">root</div><div class="line">daemon</div><div class="line">bin</div><div class="line">sys</div></pre></td></tr></table></figure>
<p>这种是awk+action的示例，每行都会执行action{print $1}。</p>
<p>-F指定域分隔符为’:’。</p>
<p>如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab键分割</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#cat /etc/passwd |awk  -F &apos;:&apos;  &apos;&#123;print $1&quot;\t&quot;$7&#125;&apos;</div><div class="line">root    /bin/bash</div><div class="line">daemon  /bin/sh</div><div class="line">bin     /bin/sh</div><div class="line">sys     /bin/sh</div></pre></td></tr></table></figure>
<p>如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以逗号分割,而且在所有行添加列名name,shell,在最后一行添加”blue,/bin/nosh”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cat /etc/passwd |awk  -F &apos;:&apos;  &apos;BEGIN &#123;print &quot;name,shell&quot;&#125;  &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,/bin/nosh&quot;&#125;&apos;</div><div class="line">name,shell</div><div class="line">root,/bin/bash</div><div class="line">daemon,/bin/sh</div><div class="line">bin,/bin/sh</div><div class="line">sys,/bin/sh</div><div class="line">....</div><div class="line">blue,/bin/nosh</div></pre></td></tr></table></figure>
<p>awk工作流程是这样的：先执行BEGING，然后读取文件，读入有/n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域， $0则表示所有域,$1表示第一个域,$n表示第n个域 ,随后开始执行模式所对应的动作action。接着开始读入第二条记录······直到所有的记录都读完，最后执行END操作。 </p>
<p>搜索/etc/passwd有root关键字的所有行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#awk -F: &apos;/root/&apos; /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div></pre></td></tr></table></figure>
<p>这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。</p>
<p>搜索支持正则，例如找root开头的: awk -F: ‘/^root/‘ /etc/passwd</p>
<p>搜索/etc/passwd有root关键字的所有行，并显示对应的shell </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># awk -F: &apos;/root/&#123;print $7&#125;&apos; /etc/passwd             </div><div class="line">/bin/bash</div></pre></td></tr></table></figure>
<p>这里指定了action{print $7}</p>
<h1 id="awk内置变量"><a href="#awk内置变量" class="headerlink" title="awk内置变量"></a>awk内置变量</h1><p>awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出了最常用的一些变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ARGC               命令行参数个数</div><div class="line">ARGV               命令行参数排列</div><div class="line">ENVIRON            支持队列中系统环境变量的使用</div><div class="line">FILENAME           awk浏览的文件名</div><div class="line">FNR                浏览文件的记录数</div><div class="line">FS                 设置输入域分隔符，等价于命令行 -F选项</div><div class="line">NF                 浏览记录的域的个数</div><div class="line">NR                 已读的记录数</div><div class="line">OFS                输出域分隔符</div><div class="line">ORS                输出记录分隔符</div><div class="line">RS                 控制记录分隔符</div></pre></td></tr></table></figure>
<p>此外, $0变量是指整条记录。$1表示当前行的第一个域,$2表示当前行的第二个域,……以此类推。</p>
<p>统计/etc/passwd:文件名，每行的行号，每行的列数，对应的完整行内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#awk  -F &apos;:&apos;  &apos;&#123;print &quot;filename:&quot; FILENAME &quot;,linenumber:&quot; NR &quot;,columns:&quot; NF &quot;,linecontent:&quot;$0&#125;&apos; /etc/passwd</div><div class="line">filename:/etc/passwd,linenumber:1,columns:7,linecontent:root:x:0:0:root:/root:/bin/bash</div><div class="line">filename:/etc/passwd,linenumber:2,columns:7,linecontent:daemon:x:1:1:daemon:/usr/sbin:/bin/sh</div><div class="line">filename:/etc/passwd,linenumber:3,columns:7,linecontent:bin:x:2:2:bin:/bin:/bin/sh</div><div class="line">filename:/etc/passwd,linenumber:4,columns:7,linecontent:sys:x:3:3:sys:/dev:/bin/sh</div></pre></td></tr></table></figure>
<p>使用printf替代print,可以让代码更加简洁，易读</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk  -F &apos;:&apos;  &apos;&#123;printf(&quot;filename:%10s,linenumber:%s,columns:%s,linecontent:%s\n&quot;,FILENAME,NR,NF,$0)&#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<h1 id="print和printf"><a href="#print和printf" class="headerlink" title="print和printf"></a>print和printf</h1><p>awk中同时提供了print和printf两种打印输出的函数。</p>
<p>其中print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。</p>
<p>printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂。</p>
<h1 id="awk编程"><a href="#awk编程" class="headerlink" title="awk编程"></a>awk编程</h1><p> 变量和赋值</p>
<p>除了awk的内置变量，awk还可以自定义变量。</p>
<p>下面统计/etc/passwd的账户人数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;count++;print $0;&#125; END&#123;print &quot;user count is &quot;, count&#125;&apos; /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">......</div><div class="line">user count is  40</div></pre></td></tr></table></figure></p>
<p>count是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。</p>
<p>这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">awk &apos;BEGIN &#123;count=0;print &quot;[start]user count is &quot;, count&#125; &#123;count=count+1;print $0;&#125; END&#123;print &quot;[end]user count is &quot;, count&#125;&apos; /etc/passwd</div><div class="line">[start]user count is  0</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">...</div><div class="line">[end]user count is  40</div></pre></td></tr></table></figure>
<p>统计某个文件夹下的文件占用的字节数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls -l |awk &apos;BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print &quot;[end]size is &quot;, size&#125;&apos;</div><div class="line">[end]size is  8657198</div></pre></td></tr></table></figure></p>
<p>如果以M为单位显示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls -l |awk &apos;BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print &quot;[end]size is &quot;, size/1024/1024,&quot;M&quot;&#125;&apos; </div><div class="line">[end]size is  8.25889 M</div></pre></td></tr></table></figure></p>
<p>注意，统计不包括文件夹的子目录。</p>
<p>条件语句<br>awk中的条件语句是从C语言中借鉴来的，见如下声明方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">if (expression) &#123;</div><div class="line">    statement;</div><div class="line">    statement;</div><div class="line">    ... ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (expression) &#123;</div><div class="line">    statement;</div><div class="line">&#125; else &#123;</div><div class="line">    statement2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (expression) &#123;</div><div class="line">    statement1;</div><div class="line">&#125; else if (expression1) &#123;</div><div class="line">    statement2;</div><div class="line">&#125; else &#123;</div><div class="line">    statement3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>统计某个文件夹下的文件占用的字节数,过滤4096大小的文件(一般都是文件夹):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls -l |awk &apos;BEGIN &#123;size=0;print &quot;[start]size is &quot;, size&#125; &#123;if($5!=4096)&#123;size=size+$5;&#125;&#125; END&#123;print &quot;[end]size is &quot;, size/1024/1024,&quot;M&quot;&#125;&apos; </div><div class="line">[end]size is  8.22339 M</div></pre></td></tr></table></figure></p>
<p>循环语句</p>
<p>awk中的循环语句同样借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同。</p>
<p>数组</p>
<p>  因为awk中数组的下标可以是数字和字母，数组的下标通常被称为关键字(key)。值和关键字都存储在内部的一张针对key/value应用hash的表格里。由于hash不是顺序存储，因此在显示数组内容时会发现，它们并不是按照你预料的顺序显示出来的。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等。</p>
<p>显示/etc/passwd的账户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">awk -F &apos;:&apos; &apos;BEGIN &#123;count=0;&#125; &#123;name[count] = $1;count++;&#125;; END&#123;for (i = 0; i &lt; NR; i++) print i, name[i]&#125;&apos; /etc/passwd</div><div class="line">root</div><div class="line">daemon</div><div class="line">bin</div><div class="line">sys</div><div class="line">sync</div><div class="line">games</div><div class="line">......</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> awk </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux sed命令详解]]></title>
      <url>/2014/01/05/linux-sed/</url>
      <content type="html"><![CDATA[<p>功能说明：</p>
<p>利用script来处理文本文件。 </p>
<p>语　　法：</p>
<p>sed [-hnV][-e script][-f script文件][文本文件]<br><a id="more"></a></p>
<p>补充说明：</p>
<p>sed可依照script的指令，来处理、编辑文本文件。 </p>
<p>参　　数：<br>-e script或—expression=script   以选项中指定的script来处理输入的文本文件。<br>-f script文件或—file=script文件   以选项中指定的script文件来处理输入的文本文件。<br>-h或—help 显示帮助。<br>-n或—quiet或–silent 仅显示script处理后的结果。<br>-V或—version 显示版本信息。  </p>
<p>例      子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e <span class="string">'s/123/1234/'</span> a.txt</div></pre></td></tr></table></figure></p>
<p>将a.txt文件中所有行中的123用1234替换（-e表示命令以命令行的方式执行；参数s，表示执行替换操作） </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e <span class="string">'3,5 a4'</span> a.txt</div></pre></td></tr></table></figure>
<p>将a.txt文件中的3行到5行之间所有行的后面添加一行内容为4的行（参数a，表示添加行，参数a后面指定添加的内容） </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e <span class="string">'1 s/12/45/'</span> a.txt</div></pre></td></tr></table></figure>
<p>把第一行的12替换成45 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -i <span class="string">"s/oldstring/newstring/g"</span> `grep oldstring -rl yourdir`</div></pre></td></tr></table></figure>
<p>批量处理通过grep搜索出来的所有文档，将这些文档中所有的oldstring用newstring替换（-i参数表示直接对目标文件操作） </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -n <span class="string">'s/^test/mytest/p'</span> example.file</div></pre></td></tr></table></figure>
<p>(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。(^这是正则表达式中表示开头，该符号后面跟的就是开头的字符串)（参数p表示打印行） </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'s/^wangpan/&amp;19850715/'</span> example.file</div></pre></td></tr></table></figure>
<p>表示被替换换字符串被找到后，被替换的字符串通过＆符号连接给出的字符串组成新字符传替换被替换的字符串,所有以wangpan开头的行都会被替换成它自已加19850715，变成wangpan19850715 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -n <span class="string">'s/\(love\)able/\1rs/p'</span> example.file</div></pre></td></tr></table></figure>
<p>love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。需要将这条命令分解，s/是表示替换操作，(love)表示选中love字符串，(love)able/表示包含loveable的行，(love)able/\l表示love字符串标记为1，表示在替换过程中不变。rs/表示替换的目标字符串。这条命令的操作含义：只打印替换了的行 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'s#10#100#g'</span> example.file</div></pre></td></tr></table></figure>
<p>不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -n <span class="string">'/love/,/unlove/p'</span> example.file</div></pre></td></tr></table></figure>
<p>只打印包含love字符串行到包含unlove字符串行之间的所有行（确定行的范围就是通过逗号实现的） </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -n <span class="string">'5,/^wang/p'</span> example</div></pre></td></tr></table></figure>
<p>只打印从第五行开始到第一个包含以wang开始的行之间的所有行 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'/love/,/unlove/s/$/wangpan/'</span> example.file</div></pre></td></tr></table></figure>
<p>对于包含love字符串的行到包含unlove字符串之间的行，每行的末尾用字符串wangpan替换。<br>字符串$/表示以字符串结尾的行，$/表示每一行的结尾，s/$/wangpan/表示每一行的结尾添加wangpan字符串 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e <span class="string">'11,53d'</span> -e <span class="string">'s/wang/pan/'</span> example.file</div></pre></td></tr></table></figure>
<p>(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除11至53行，第二条命令用pan替换wang。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。(参数d，表示删除指定的行) </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed --expression=<span class="string">'s/wang/pan/'</span> --expression=<span class="string">'/love/d'</span> example.file</div></pre></td></tr></table></figure>
<p>一个比-e更好的命令是–expression。它能给sed表达式赋值。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'/wangpan/r file'</span> example.file</div></pre></td></tr></table></figure>
<p>file里的内容被读进来，显示在与wangpan匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。参数r，表示读出文件，后面空格紧跟文件名称 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -n <span class="string">'/test/w file'</span> example.file</div></pre></td></tr></table></figure>
<p>在example.file中所有包含test的行都被写入file里。参数w，表示将匹配的行写入到指定的文件file中 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'/^test/a\oh! My god!'</span> example.file</div></pre></td></tr></table></figure>
<p>‘oh! My god!’被追加到以test开头的行的后面，sed要求参数a后面有一个反斜杠。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'/test/i\oh! My god!'</span> example.file</div></pre></td></tr></table></figure>
<p>‘oh! My god!’被追加到包含test字符串行的前面，参数i表示添加指定内容到匹配行的前面，sed要求参数i后面有一个反斜杠 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'/test/&#123; n; s/aa/bb/; &#125;'</span> example.file</div></pre></td></tr></table></figure>
<p>如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb。参数n，表示读取匹配行的下一个输入行，用下一个命令处理新的行而不是匹配行。Sed要求参数n后跟分号 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'1,10y/abcde/ABCDE/'</span> example.file</div></pre></td></tr></table></figure>
<p>把1—10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。参数y，表示把一个字符翻译为另外的字符（但是不用于正则表达式） </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -i <span class="string">'s/now/right now/g'</span> test_sed_command.txt</div></pre></td></tr></table></figure>
<p>表示直接操作文件test_sed_command.txt，将文件test_sed_command.txt中所有的now用right now替换。参数-i，表示直接操作修改文件，不输出。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'2q'</span> test_sed_command.txt</div></pre></td></tr></table></figure>
<p>在打印完第2行后，就直接退出sed。参数q，表示退出 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e <span class="string">'/old/h'</span> -e <span class="string">'/girl-friend/G'</span> test_sed_command.txt</div></pre></td></tr></table></figure>
<p>首先了解参数h，拷贝匹配成功行的内容到内存中的缓冲区。在了解参数G，获得内存缓冲区的内容，并追加到当前模板块文本的后面。上面命令行的含义：将包含old字符串的行的内容保存在缓冲区中，然后将缓冲区的内容拿出来添加到包含girl-friend字符串行的后面。隐含要求搜集到缓冲区的匹配行在需要添加行的前面。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e <span class="string">'/test/h'</span> -e <span class="string">'/wangpan/x'</span> example.file</div></pre></td></tr></table></figure>
<p>将包含test字符串的行的内容保存在缓冲区中，然后再将缓冲区的内容替换包含wangpan字符串的行。参数x，表示行替换操作。隐含要求搜集到缓冲区的匹配行在需要被替换行的前面。 </p>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> sed </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux grep命令详解]]></title>
      <url>/2014/01/04/linux-grep/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<p>Unix的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。<br><a id="more"></a></p>
<h1 id="grep常用用法"><a href="#grep常用用法" class="headerlink" title="grep常用用法"></a>grep常用用法</h1><p>grep [-acinv] [–color=auto] ‘搜寻字符串’ filename<br>选项与参数：<br>-a ：将 binary 文件以 text 文件的方式搜寻数据<br>-c ：计算找到 ‘搜寻字符串’ 的次数<br>-i ：忽略大小写的不同，所以大小写视为相同<br>-n ：顺便输出行号<br>-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！<br>–color=auto ：可以将找到的关键词部分加上颜色的显示喔！</p>
<p>将/etc/passwd，有出现 root 的行取出来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">grep root /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">operator:x:11:0:operator:/root:/sbin/nologin</div><div class="line">或</div><div class="line">cat /etc/passwd | grep root </div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">operator:x:11:0:operator:/root:/sbin/nologin</div></pre></td></tr></table></figure></p>
<p>将/etc/passwd，有出现 root 的行取出来,同时显示这些行在/etc/passwd的行号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep -n root /etc/passwd</div><div class="line">1:root:x:0:0:root:/root:/bin/bash</div><div class="line">30:operator:x:11:0:operator:/root:/sbin/nologin</div></pre></td></tr></table></figure></p>
<p>在关键字的显示方面，grep 可以使用 –color=auto 来将关键字部分使用颜色显示。 这可是个很不错的功能啊！但是如果每次使用 grep 都得要自行加上 –color=auto 又显的很麻烦～ 此时那个好用的 alias 就得来处理一下啦！你可以在 ~/.bashrc 内加上这行：<code>alias grep=&#39;grep --color=auto&#39;</code>再以<code>source ~/.bashrc</code>来立即生效即可喔！ 这样每次运行 grep 他都会自动帮你加上颜色显示啦</p>
<p>将/etc/passwd，将没有出现 root 的行取出来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep -v root /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">operator:x:11:0:operator:/root:/sbin/nologin</div></pre></td></tr></table></figure></p>
<p>将/etc/passwd，将没有出现 root 和nologin的行取出来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep -v root /etc/passwd | grep -v nologin</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">operator:x:11:0:operator:/root:/sbin/nologin</div></pre></td></tr></table></figure></p>
<p>用 dmesg 列出核心信息，再以 grep 找出内含 eth 那行,要将捉到的关键字显色，且加上行号来表示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># dmesg | grep -n --color=auto 'eth'</span></div><div class="line">247:eth0: RealTek RTL8139 at 0xee846000, 00:90:cc:a6:34:84, IRQ 10</div><div class="line">248:eth0: Identified 8139 chip <span class="built_in">type</span> <span class="string">'RTL-8139C'</span></div><div class="line">294:eth0: link up, 100Mbps, full-duplex, lpa 0xC5E1</div><div class="line">305:eth0: no IPv6 routers present</div></pre></td></tr></table></figure></p>
<p>你会发现除了 eth 会有特殊颜色来表示之外，最前面还有行号喔！<br>在关键字的显示方面，grep 可以使用 –color=auto 来将关键字部分使用颜色显示。 这可是个很不错的功能啊！但是如果每次使用 grep 都得要自行加上 –color=auto 又显的很麻烦～ 此时那个好用的 alias 就得来处理一下啦！你可以在 ~/.bashrc 内加上这行：<code>alias grep=&#39;grep --color=auto&#39;</code>再以<code>source ~/.bashrc</code>来立即生效即可喔！ 这样每次运行 grep 他都会自动帮你加上颜色显示啦</p>
<p>用 dmesg 列出核心信息，再以 grep 找出内含 eth 那行,在关键字所在行的前两行与后三行也一起捉出来显示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># dmesg | grep -n -A3 -B2 --color=auto 'eth'</span></div><div class="line">245-PCI: setting IRQ 10 as level-triggered</div><div class="line">246-ACPI: PCI Interrupt 0000:00:0e.0[A] -&gt; Link [LNKB] ...</div><div class="line">247:eth0: RealTek RTL8139 at 0xee846000, 00:90:cc:a6:34:84, IRQ 10</div><div class="line">248:eth0: Identified 8139 chip <span class="built_in">type</span> <span class="string">'RTL-8139C'</span></div><div class="line">249-input: PC Speaker as /class/input/input2</div><div class="line">250-ACPI: PCI Interrupt 0000:00:01.4[B] -&gt; Link [LNKB] ...</div><div class="line">251-hdb: ATAPI 48X DVD-ROM DVD-R-RAM CD-R/RW drive, 2048kB Cache, UDMA(66)</div></pre></td></tr></table></figure></p>
<p>如上所示，你会发现关键字 247 所在的前两行及 248 后三行也都被显示出来！<br>这样可以让你将关键字前后数据捉出来进行分析啦！</p>
<p>根据文件内容递归查找目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep ‘energywise’ *           <span class="comment">#在当前目录搜索带'energywise'行的文件</span></div><div class="line">grep -r ‘energywise’ *        <span class="comment">#在当前目录及其子目录下搜索'energywise'行的文件</span></div><div class="line">grep -l -r ‘energywise’ *     <span class="comment">#在当前目录及其子目录下搜索'energywise'行的文件，但是不显示匹配的行，只显示匹配的文件</span></div></pre></td></tr></table></figure></p>
<h1 id="grep与正规表达式"><a href="#grep与正规表达式" class="headerlink" title="grep与正规表达式"></a>grep与正规表达式</h1><p>字符类</p>
<p>字符类的搜索：如果我想要搜寻 test 或 taste 这两个单字时，可以发现到，其实她们有共通的 ‘t?st’ 存在～这个时候，我可以这样来搜寻：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 't[ae]st' regular_express.txt</span></div><div class="line">8:I can<span class="string">'t finish the test.</span></div><div class="line">9:Oh! The soup taste good.</div></pre></td></tr></table></figure></p>
<p>其实 [] 里面不论有几个字节，他都谨代表某<code>一个</code>字节， 所以，上面的例子说明了，我需要的字串是<code>tast</code>或<code>test</code>两个字串而已！</p>
<p>字符类的反向选择 [^] ：如果想要搜索到有 oo 的行，但不想要 oo 前面有 g，如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '[^g]oo' regular_express.txt</span></div><div class="line">2:apple is my favorite food.</div><div class="line">3:Football game is not use feet only.</div><div class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>第 2,3 行没有疑问，因为 foo 与 Foo 均可被接受！</p>
<p>但是第 18 行明明有 google 的 goo 啊～别忘记了，因为该行后面出现了 tool 的 too 啊！所以该行也被列出来～ 也就是说， 18 行里面虽然出现了我们所不要的项目 (goo) 但是由於有需要的项目 (too) ， 因此，是符合字串搜寻的喔！</p>
<p>至於第 19 行，同样的，因为 goooooogle 里面的 oo 前面可能是 o ，例如： go(ooo)oogle ，所以，这一行也是符合需求的！</p>
<p>字符类的连续：再来，假设我 oo 前面不想要有小写字节，所以，我可以这样写 [^abcd….z]oo ， 但是这样似乎不怎么方便，由於小写字节的 ASCII 上编码的顺序是连续的， 因此，我们可以将之简化为底下这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '[^a-z]oo' regular_express.txt</span></div><div class="line">3:Football game is not use feet only.</div></pre></td></tr></table></figure></p>
<p>也就是说，当我们在一组集合字节中，如果该字节组是连续的，例如大写英文/小写英文/数字等等， 就可以使用[a-z],[A-Z],[0-9]等方式来书写，那么如果我们的要求字串是数字与英文呢？ 呵呵！就将他全部写在一起，变成：[a-zA-Z0-9]。</p>
<p>我们要取得有数字的那一行，就这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '[0-9]' regular_express.txt</span></div><div class="line">5:However, this dress is about $ 3183 dollars.</div><div class="line">15:You are the best is mean you are the no. 1.</div></pre></td></tr></table></figure></p>
<p>行首与行尾字节 ^ $<br>行首字符：如果我想要让 the 只在行首列出呢？ 这个时候就得要使用定位字节了！我们可以这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '^the' regular_express.txt</span></div><div class="line">12:the symbol <span class="string">'*'</span> is represented as start.</div></pre></td></tr></table></figure></p>
<p>此时，就只剩下第 12 行，因为只有第 12 行的行首是 the 开头啊～此外， 如果我想要开头是小写字节的那一行就列出呢？可以这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '^[a-z]' regular_express.txt</span></div><div class="line">2:apple is my favorite food.</div><div class="line">4:this dress doesn<span class="string">'t fit me.</span></div><div class="line">10:motorcycle is cheap than car.</div><div class="line">12:the symbol '*<span class="string">' is represented as start.</span></div><div class="line">18:google is the best tools for search keyword.</div><div class="line">19:goooooogle yes!</div><div class="line">20:go! go! Let's go.</div></pre></td></tr></table></figure></p>
<p>如果我不想要开头是英文字母，则可以是这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '^[^a-zA-Z]' regular_express.txt</span></div><div class="line">1:<span class="string">"Open Source"</span> is a good mechanism to develop programs.</div><div class="line">21:<span class="comment"># I am VBird</span></div></pre></td></tr></table></figure></p>
<p>^ 符号，在字符类符号(括号[])之内与之外是不同的！ 在 [] 内代表<code>反向选择</code>，在 [] 之外则代表定位在行首的意义！</p>
<p>那如果我想要找出来，行尾结束为小数点 (.) 的那一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '\.$' regular_express.txt</span></div><div class="line">1:<span class="string">"Open Source"</span> is a good mechanism to develop programs.</div><div class="line">2:apple is my favorite food.</div><div class="line">3:Football game is not use feet only.</div><div class="line">4:this dress doesn<span class="string">'t fit me.</span></div><div class="line">10:motorcycle is cheap than car.</div><div class="line">11:This window is clear.</div><div class="line">12:the symbol '*<span class="string">' is represented as start.</span></div><div class="line">15:You are the best is mean you are the no. 1.</div><div class="line">16:The world &lt;Happy&gt; is the same with "glad".</div><div class="line">17:I like dog.</div><div class="line">18:google is the best tools for search keyword.</div><div class="line">20:go! go! Let's go.</div></pre></td></tr></table></figure></p>
<p>特别注意到，因为小数点具有其他意义(底下会介绍)，所以必须要使用转义字符(\)来加以解除其特殊意义！</p>
<p>找出空白行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '^$' regular_express.txt</span></div><div class="line">22:</div></pre></td></tr></table></figure></p>
<p>因为只有行首跟行尾 (^$)，所以，这样就可以找出空白行啦！</p>
<p>任意一个字节 . 与重复字节 *<br>这两个符号在正则表达式的意义如下：</p>
<p>. (小数点)：代表<code>一定有一个任意字节</code>的意思；<br>* (星号)：代表<code>重复前一个字符， 0 到无穷多次</code>的意思，为组合形态</p>
<p>假设我需要找出 g??d 的字串，亦即共有四个字节， 起头是 g 而结束是 d ，我可以这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'g..d' regular_express.txt</span></div><div class="line">1:<span class="string">"Open Source"</span> is a good mechanism to develop programs.</div><div class="line">9:Oh! The soup taste good.</div><div class="line">16:The world &lt;Happy&gt; is the same with <span class="string">"glad"</span>.</div></pre></td></tr></table></figure></p>
<p>因为强调 g 与 d 之间一定要存在两个字节，因此，第 13 行的 god 与第 14 行的 gd 就不会被列出来啦！</p>
<p>如果我想要列出有 oo, ooo, oooo 等等的数据， 也就是说，至少要有两个(含) o 以上，该如何是好？</p>
<p>因为 * 代表的是<code>重复 0 个或多个前面的 RE 字符</code>的意义， 因此 <code>o*</code> 代表的是：<code>拥有空字节或一个 o 以上的字节</code>，因此，<code>grep -n &#39;o*&#39; regular_express.txt</code>将会把所有的数据都列印出来终端上！</p>
<p>当我们需要<code>至少两个 o 以上的字串</code>时，就需要 <code>ooo*</code> ，亦即是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'ooo*' regular_express.txt</span></div><div class="line">1:<span class="string">"Open Source"</span> is a good mechanism to develop programs.</div><div class="line">2:apple is my favorite food.</div><div class="line">3:Football game is not use feet only.</div><div class="line">9:Oh! The soup taste good.</div><div class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>如果我想要字串开头与结尾都是 g，但是两个 g 之间仅能存在至少一个 o ，亦即是 gog, goog, gooog…. 等等，那该如何？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'goo*g' regular_express.txt</span></div><div class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>如果我想要找出 g 开头与 g 结尾的行，当中的字符可有可无<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'g.*g' regular_express.txt</span></div><div class="line">1:<span class="string">"Open Source"</span> is a good mechanism to develop programs.</div><div class="line">14:The gd software is a library <span class="keyword">for</span> drafting programs.</div><div class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</div><div class="line">19:goooooogle yes!</div><div class="line">20:go! go! Let<span class="string">'s go.</span></div></pre></td></tr></table></figure></p>
<p>因为是代表 g 开头与 g 结尾，中间任意字节均可接受，所以，第 1, 14, 20 行是可接受的喔！ 这个 .* 的 RE 表示任意字符是很常见的.</p>
<p>如果我想要找出<code>任意数字</code>的行？因为仅有数字，所以就成为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '[0-9][0-9]*' regular_express.txt</span></div><div class="line">5:However, this dress is about $ 3183 dollars.</div><div class="line">15:You are the best is mean you are the no. 1.</div></pre></td></tr></table></figure></p>
<p>限定连续 RE 字符范围 {}<br>我们可以利用 . 与 RE 字符及 <code>*</code> 来配置 0 个到无限多个重复字节， 那如果我想要限制一个范围区间内的重复字节数呢？</p>
<p>举例来说，我想要找出两个到五个 o 的连续字串，该如何作？这时候就得要使用到限定范围的字符 {} 了。 但因为 { 与 } 的符号在 shell 是有特殊意义的，因此， 我们必须要使用字符 <code>\</code> 来让他失去特殊意义才行。 至於 {} 的语法是这样的，假设我要找到两个 o 的字串，可以是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'o\&#123;2\&#125;' regular_express.txt</span></div><div class="line">1:<span class="string">"Open Source"</span> is a good mechanism to develop programs.</div><div class="line">2:apple is my favorite food.</div><div class="line">3:Football game is not use feet only.</div><div class="line">9:Oh! The soup taste good.</div><div class="line">18:google is the best tools <span class="keyword">for</span> search ke</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>假设我们要找出 g 后面接 2 到 5 个 o ，然后再接一个 g 的字串，他会是这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'go\&#123;2,5\&#125;g' regular_express.txt</span></div><div class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</div></pre></td></tr></table></figure></p>
<p>如果我想要的是 2 个 o 以上的 goooo….g 呢？除了可以是 gooo*g ，也可以是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'go\&#123;2,\&#125;g' regular_express.txt</span></div><div class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>扩展grep(grep -E 或者 egrep)：<br>使用扩展grep的主要好处是增加了额外的正则表达式元字符集。</p>
<p>打印所有包含NW或EA的行。如果不是使用egrep，而是grep，将不会有结果查出。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">egrep <span class="string">'NW|EA'</span> testfile     </div><div class="line">    northwest       NW      Charles Main        3.0     .98     3       34</div><div class="line">    eastern         EA      TB Savage           4.4     .84     5       20</div></pre></td></tr></table></figure></p>
<p>对于标准grep，如果在扩展元字符前面加\，grep会自动启用扩展选项-E。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep <span class="string">'NW\|EA'</span> testfile</div><div class="line">northwest       NW      Charles Main        3.0     .98     3       34</div><div class="line">eastern         EA      TB Savage           4.4     .84     5       20</div></pre></td></tr></table></figure></p>
<p>搜索所有包含一个或多个3的行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">egrep <span class="string">'3+'</span> testfile</div><div class="line">grep -E <span class="string">'3+'</span> testfile</div><div class="line">grep <span class="string">'3\+'</span> testfile        </div><div class="line"><span class="comment">#这3条命令将会</span></div><div class="line">northwest       NW      Charles Main          3.0     .98     3       34</div><div class="line">western         WE      Sharon Gray           5.3     .97     5       23</div><div class="line">northeast       NE      AM Main Jr.           5.1     .94     3       13</div><div class="line">central         CT      Ann Stephens          5.7     .94     5       13</div></pre></td></tr></table></figure></p>
<p>搜索所有包含0个或1个小数点字符的行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">egrep <span class="string">'2\.?[0-9]'</span> testfile </div><div class="line">grep -E <span class="string">'2\.?[0-9]'</span> testfile</div><div class="line">grep <span class="string">'2\.\?[0-9]'</span> testfile </div><div class="line"><span class="comment">#首先含有2字符，其后紧跟着0个或1个点，后面再是0和9之间的数字。</span></div><div class="line">western         WE       Sharon Gray          5.3     .97     5       23</div><div class="line">southwest       SW      Lewis Dalsass         2.7     .8      2       18</div><div class="line">eastern         EA       TB Savage             4.4     .84     5       20</div></pre></td></tr></table></figure></p>
<p>搜索一个或者多个连续的no的行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">egrep <span class="string">'(no)+'</span> testfile</div><div class="line">grep -E <span class="string">'(no)+'</span> testfile</div><div class="line">grep <span class="string">'\(no\)\+'</span> testfile   <span class="comment">#3个命令返回相同结果，</span></div><div class="line">northwest       NW      Charles Main        3.0     .98     3       34</div><div class="line">northeast       NE       AM Main Jr.        5.1     .94     3       13</div><div class="line">north           NO      Margot Weber        4.5     .89     5       9</div></pre></td></tr></table></figure></p>
<p>不使用正则表达式</p>
<p>fgrep 查询速度比grep命令快，但是不够灵活：它只能找固定的文本，而不是规则表达式。</p>
<p>如果你想在一个文件或者输出中找到包含星号字符的行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fgrep  <span class="string">'*'</span> /etc/profile</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh ; <span class="keyword">do</span></div><div class="line">或</div><div class="line">grep -F <span class="string">'*'</span> /etc/profile</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh ; <span class="keyword">do</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> grep </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery的.bind()、.live()和.delegate()之间区别]]></title>
      <url>/2014/01/04/jquery-bind-delegate/</url>
      <content type="html"><![CDATA[<p><code>摘要: jQuery的.bind()、.live()和.delegate()之间的区别并非总是那么明显的，然而，如果我们对所有的不同之处都有清晰的理解的话，那么这将会有助于我们编写出更加简洁的代码，以及防止在交互应用中弹出错误。</code></p>
<p><a href="/images/jquery-1.jpg"><img src="/images/jquery-1.jpg" alt=""></a><br><a id="more"></a></p>
<p>DOM树</p>
<p>首先，可视化一个HMTL文档的DOM树是很有帮助的。一个简单的HTML页面看起来就像是这个样子：<br><a href="/images/jquery-2.png"><img src="/images/jquery-2.png" alt=""></a> </p>
<p>事件冒泡(又称事件传播)</p>
<p>当我们点击一个链接时，其触发了链接元素的单击事件，该事件则引发任何我们已绑定到该元素的单击事件上的函数的执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'a'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"That tickles!"</span>) &#125;);</div></pre></td></tr></table></figure>
<p>因此一个单击操作会触发alert函数的执行。<br><a href="/images/jquery-3.png"><img src="/images/jquery-3.png" alt=""></a> </p>
<p>click事件接着会向树的根方向传播，广播到父元素，然后接着是每个祖先元素，只要是它的某个后代元素上的单击事件被触发，事件就会传给它。</p>
<p><a href="/images/jquery-4.png"><img src="/images/jquery-4.png" alt=""></a> </p>
<p>在操纵DOM的语境中，document是根节点。</p>
<p>现在我们可以较容易地说明.bind()、.live()和.delegate()的不同之处了。</p>
<p>.bind()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'a'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"That tickles!"</span>) &#125;);</div></pre></td></tr></table></figure>
<p>这是最简单的绑定方法了。JQuery扫描文档找出所有的$(‘a’)元素，并把alert函数绑定到每个元素的click事件上。</p>
<p>.live()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'a'</span>).live(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"That tickles!"</span>) &#125;);</div></pre></td></tr></table></figure>
<p>JQuery把alert函数绑定到$(document)元素上，并使用’click’和’a’作为参数。任何时候只要有事件冒泡到document节点上，它就查看该事件是否是一个click事件，以及该事件的目标元素与’a’这一CSS选择器是否匹配，如果都是的话，则执行函数。</p>
<p>live方法还可以被绑定到具体的元素(或“context”)而不是document上，像这样：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'a'</span>, $(<span class="string">'#container'</span>)[<span class="number">0</span>]).live(...);</div></pre></td></tr></table></figure>
<p>.delegate()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#container'</span>).delegate(<span class="string">'a'</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"That tickles!"</span>) &#125;);</div></pre></td></tr></table></figure>
<p>JQuery扫描文档查找$(‘#container’)，并使用click事件和’a’这一CSS选择器作为参数把alert函数绑定到$(‘#container’)上。任何时候只要有事件冒泡到$(‘#container’)上，它就查看该事件是否是click事件，以及该事件的目标元素是否与CCS选择器相匹配。如果两种检查的结果都为真的话，它就执行函数。</p>
<p>可以注意到，这一过程与.live()类似，但是其把处理程序绑定到具体的元素而非document这一根上。精明的JS’er们可能会做出这样的结论，即$(‘a’).live() == $(document).delegate(‘a’)，是这样吗?嗯，不，不完全是。</p>
<p>为什么.delegate()要比.live()好用</p>
<p>基于几个原因，人们通常更愿意选用jQuery的delegate方法而不是live方法。考虑下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'a'</span>).live(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; blah() &#125;);     </div><div class="line"><span class="comment">// 或者   </span></div><div class="line">$(<span class="built_in">document</span>).delegate(<span class="string">'a'</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; blah() &#125;);</div></pre></td></tr></table></figure>
<p>速度</p>
<p>后者实际上要快过前者，因为前者首先要扫描整个的文档查找所有的$(‘a’)元素，把它们存成jQuery对象。尽管live函数仅需要把’a’作为串参数传递以用做之后的判断，但是$()函数并未“知道”被链接的方法将会是.live()。</p>
<p>而另一方面，delegate方法仅需要查找并存储$(document)元素。</p>
<p>一种寻求避开这一问题的方法是调用在$(document).ready()之外绑定的live，这样它就会立即执行。在这种方式下，其会在DOM获得填充之前运行，因此就不会查找元素或是创建jQuery对象了。</p>
<p>灵活性和链能力</p>
<p>live函数也挺令人费解的。想想看，它被链到$(‘a’)对象集上，但其实际上是在$(document)对象上发生作用。由于这个原因，它能够试图以一种吓死人的方式来把方法链到自身上。实际上，我想说的是，以$.live(‘a’,…)这一形式作为一种全局性的jQuery方法，live方法会更具意义一些。</p>
<p>仅支持CSS选择器</p>
<p>最后一点，live方法有一个非常大的缺点，那就是它仅能针对直接的CSS选择器做操作，这使得它变得非常的不灵活。</p>
<p>欲了解更多关于CSS选择器的缺点，请参阅Exploring jQuery .live() and .die()一文。</p>
<p>更新：感谢Hacker News上的pedalpete和后面评论中的Ellsass提醒我加入接下来的这一节内容。</p>
<p>为什么选择.live()或.delegate()而不是.bind()</p>
<p>毕竟，bind看起来似乎更加的明确和直接，难道不是吗?嗯，有两个原因让我们更愿意选择delegate或live而不是bind：</p>
<p>为了把处理程序附加到可能还未存在于DOM中的DOM元素之上。因为bind是直接把处理程序绑定到各个元素上，它不能把处理程序绑定到还未存在于页面中的元素之上。</p>
<p>如果你运行了$(‘a’).bind(…)，而后新的链接经由AJAX加入到了页面中，则你的bind处理程序对于这些新加入的链接来说是无效的。而另一方面live和delegate则是被绑定到另一个祖先节点上，因此其对于任何目前或是将来存在于该祖先元素之内的元素都是有效的。</p>
<p>或者为了把处理程序附加到单个元素上或是一小组元素之上，监听后代元素上的事件而不是循环遍历并把同一个函数逐个附加到DOM中的100个元素上。把处理程序附加到一个(或是一小组)祖先元素上而不是直接把处理程序附加到页面中的所有元素上，这种做法带来了性能上的好处。</p>
<p>停止传播</p>
<p>最后一个我想做的提醒与事件传播有关。通常情况下，我们可以通过使用这样的事件方法来终止处理函数的执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'a'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;      </div><div class="line">e.preventDefault();   </div><div class="line"><span class="comment">// 或者   </span></div><div class="line">e.stopPropagation();   </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>不过，当我们使用live或是delegate方法的时候，处理函数实际上并没有在运行，需要等到事件冒泡到处理程序实际绑定的元素上时函数才会运行。而到此时为止，我们的其他的来自.bind()的处理函数早已运行了。</p>
<p>原文地址：<a href="http://developer.51cto.com/art/201103/249694.htm" target="_blank" rel="external">http://developer.51cto.com/art/201103/249694.htm</a></p>
]]></content>
      
        <categories>
            
            <category> jQuery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[正确理解ThreadLocal]]></title>
      <url>/2014/01/04/threadlocal-understanding/</url>
      <content type="html"><![CDATA[<p>首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。 各个线程中访问的是不同的对象。  </p>
<p>另外，说ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()来实现的，而是通过每个线程中的new 对象 的操作来创建的对象，每个线程创建一个，不是什么对象的拷贝或副本。 通过ThreadLocal.set()将这个新创建的对象的引用保存到各线程的自己的一个map中，每个线程都有这样一个map，执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象，因此取出来的是各自自己线程中的对象，ThreadLocal实例是作为map的key来使用的。<br><a id="more"></a><br>如果ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问问题。  </p>
<p>下面来看一个hibernate中典型的ThreadLocal的应用： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</div><div class="line">        Session s = (Session) threadSession.get();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</div><div class="line">                s = getSessionFactory().openSession();</div><div class="line">                threadSession.set(s);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到在getSession()方法中，首先判断当前线程中有没有放进去session，如果还没有，那么通过sessionFactory().openSession()来创建一个session，再将session set到线程中，实际是放到当前线程的ThreadLocalMap这个map中，这时，对于这个session的唯一引用就是当前线程中的那个ThreadLocalMap（下面会讲到），而threadSession作为这个值的key，要取得这个session可以通过threadSession.get()来得到，里面执行的操作实际是先取得当前线程中的ThreadLocalMap，然后将threadSession作为key将对应的值取出。这个session相当于线程的私有变量，而不是public的。<br>显然，其他线程中是取不到这个session的，他们也只能取到自己的ThreadLocalMap中的东西。要是session是多个线程共享使用的，那还不乱套了。<br>试想如果不用ThreadLocal怎么来实现呢？可能就要在action中创建session，然后把session一个个传到service和dao中，这可够麻烦的。或者可以自己定义一个静态的map，将当前thread作为key，创建的session作为值，put到map中，应该也行，这也是一般人的想法，但事实上，ThreadLocal的实现刚好相反，它是在每个线程中有一个map，而将ThreadLocal实例作为key，这样每个map中的项数很少，而且当线程销毁时相应的东西也一起销毁了，不知道除了这些还有什么其他的好处。  </p>
<p>总之，ThreadLocal不是用来解决对象共享访问问题的，而主要是提供了保持对象的方法和避免参数传递的方便的对象访问方式。归纳了两点：<br>1。每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。<br>2。将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。   </p>
<p>当然如果要把本来线程共享的对象通过ThreadLocal.set()放到线程中也可以，可以实现避免参数传递的访问方式，但是要注意get()到的是那同一个共享对象，并发访问问题要靠其他手段来解决。但一般来说线程共享的对象通过设置为某类的静态变量就可以实现方便的访问了，似乎没必要放到线程中。  </p>
<p>ThreadLocal的应用场合，我觉得最适合的是按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。   </p>
<p>下面来看看ThreadLocal的实现原理（jdk1.5源码）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * ThreadLocals rely on per-thread hash maps attached to each thread</div><div class="line">     * (Thread.threadLocals and inheritableThreadLocals).  The ThreadLocal</div><div class="line">     * objects act as keys, searched via threadLocalHashCode.  This is a</div><div class="line">     * custom hash code (useful only within ThreadLocalMaps) that eliminates</div><div class="line">     * collisions in the common case where consecutively constructed</div><div class="line">     * ThreadLocals are used by the same threads, while remaining well-behaved</div><div class="line">     * in less common cases.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The next hash code to be given out. Accessed only by like-named method.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextHashCode = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The difference between successively generated hash codes - turns</div><div class="line">     * implicit sequential thread-local IDs into near-optimally spread</div><div class="line">     * multiplicative hash values for power-of-two-sized tables.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Compute the next hash code. The static synchronization used here</div><div class="line">     * should not be a performance bottleneck. When ThreadLocals are</div><div class="line">     * generated in different threads at a fast enough rate to regularly</div><div class="line">     * contend on this lock, memory contention is by far a more serious</div><div class="line">     * problem than lock contention.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = nextHashCode;</div><div class="line">        nextHashCode = h + HASH_INCREMENT;</div><div class="line">        <span class="keyword">return</span> h;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a thread local variable.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the value in the current thread's copy of this thread-local</div><div class="line">     * variable.  Creates and initializes the copy if this is the first time</div><div class="line">     * the thread has called this method.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> the current thread's value of this thread-local</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> (T)map.get(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Maps are constructed lazily.  if the map for this thread</span></div><div class="line">        <span class="comment">// doesn't exist, create it, with this ThreadLocal and its</span></div><div class="line">        <span class="comment">// initial value as its only entry.</span></div><div class="line">        T value = initialValue();</div><div class="line">        createMap(t, value);</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sets the current thread's copy of this thread-local variable</div><div class="line">     * to the specified value.  Many applications will have no need for</div><div class="line">     * this functionality, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</div><div class="line">     * method to set the values of thread-locals.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> value the value to be stored in the current threads' copy of</div><div class="line">     *        this thread-local.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the map associated with a ThreadLocal. Overridden in</div><div class="line">     * InheritableThreadLocal.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span>  t the current thread</div><div class="line">     * <span class="doctag">@return</span> the map</div><div class="line">     */</div><div class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> t.threadLocals;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Create the map associated with a ThreadLocal. Overridden in</div><div class="line">     * InheritableThreadLocal.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> t the current thread</div><div class="line">     * <span class="doctag">@param</span> firstValue value for the initial entry of the map</div><div class="line">     * <span class="doctag">@param</span> map the map to store.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .......</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * ThreadLocalMap is a customized hash map suitable only for</div><div class="line">     * maintaining thread local values. No operations are exported</div><div class="line">     * outside of the ThreadLocal class. The class is package private to</div><div class="line">     * allow declaration of fields in class Thread.  To help deal with</div><div class="line">     * very large and long-lived usages, the hash table entries use</div><div class="line">     * WeakReferences for keys. However, since reference queues are not</div><div class="line">     * used, stale entries are guaranteed to be removed only when</div><div class="line">     * the table starts running out of space.</div><div class="line">     */</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</div><div class="line"></div><div class="line">    ........</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到ThreadLocal类中的变量只有这3个int型： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextHashCode = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</div></pre></td></tr></table></figure>
<p>而作为ThreadLocal实例的变量只有 threadLocalHashCode 这一个，nextHashCode 和HASH_INCREMENT 是ThreadLocal类的静态变量，实际上HASH_INCREMENT是一个常量，表示了连续分配的两个ThreadLocal实例的threadLocalHashCode值的增量，而nextHashCode 的表示了即将分配的下一个ThreadLocal实例的threadLocalHashCode 的值。  </p>
<p>可以来看一下创建一个ThreadLocal实例即new ThreadLocal()时做了哪些操作，从上面看到构造函数ThreadLocal()里什么操作都没有，唯一的操作是这句： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</div></pre></td></tr></table></figure>
<p>那么nextHashCode()做了什么呢： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = nextHashCode;</div><div class="line">        nextHashCode = h + HASH_INCREMENT;</div><div class="line">        <span class="keyword">return</span> h;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>就是将ThreadLocal类的下一个hashCode值即nextHashCode的值赋给实例的threadLocalHashCode，然后nextHashCode的值增加HASH_INCREMENT这个值。  </p>
<p>因此ThreadLocal实例的变量只有这个threadLocalHashCode，而且是final的，用来区分不同的ThreadLocal实例，ThreadLocal类主要是作为工具类来使用，那么ThreadLocal.set()进去的对象是放在哪儿的呢？  </p>
<p>看一下上面的set()方法，两句合并一下成为 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ThreadLocalMap map = Thread.currentThread().threadLocals;</div></pre></td></tr></table></figure>
<p>这个ThreadLocalMap 类是ThreadLocal中定义的内部类，但是它的实例却用在Thread类中： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line">     * by the ThreadLocal class. */</div><div class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;  </div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再看这句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div></pre></td></tr></table></figure></p>
<p>也就是将该ThreadLocal实例作为key，要保持的对象作为值，设置到当前线程的ThreadLocalMap 中，get()方法同样大家看了代码也就明白了，ThreadLocalMap 类的代码太多了，我就不帖了，自己去看源码吧。 </p>
<p>贴个例子吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">0</span>;   <span class="comment">//年龄</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">//创建线程局部变量studentLocal，在后面你会发现用来保存Student对象</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal studentLocal = <span class="keyword">new</span> ThreadLocal();</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> </span>&#123;</div><div class="line">        ThreadLocalDemo td = <span class="keyword">new</span> ThreadLocalDemo();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(td, <span class="string">"a"</span>);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(td, <span class="string">"b"</span>);</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        accessStudent();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 示例业务方法，用来测试</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accessStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//获取当前线程的名字</span></div><div class="line">        String currentThreadName = Thread.currentThread().getName();</div><div class="line">        System.out.println(currentThreadName + <span class="string">" is running!"</span>);</div><div class="line">        <span class="comment">//产生一个随机数并打印</span></div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">int</span> age = random.nextInt(<span class="number">100</span>);</div><div class="line">        System.out.println(<span class="string">"thread "</span> + currentThreadName + <span class="string">" set age to:"</span> + age);</div><div class="line">        <span class="comment">//获取一个Student对象，并将随机数年龄插入到对象属性中</span></div><div class="line">        Student student = getStudent();</div><div class="line">        student.setAge(age);</div><div class="line">        System.out.println(<span class="string">"thread "</span> + currentThreadName + <span class="string">" first read age is:"</span> + student.getAge());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">500</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">            ex.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"thread "</span> + currentThreadName + <span class="string">" second read age is:"</span> + student.getAge());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">protected</span> Student <span class="title">getStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//获取本地线程变量并强制转换为Student类型</span></div><div class="line">        Student student = (Student) studentLocal.get();</div><div class="line">        <span class="comment">//线程首次执行此方法的时候，studentLocal.get()肯定为null</span></div><div class="line">        <span class="keyword">if</span> (student == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//创建一个Student对象，并保存到本地线程变量studentLocal中</span></div><div class="line">            student = <span class="keyword">new</span> Student();</div><div class="line">            studentLocal.set(student);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> student;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a is running! </div><div class="line">thread a <span class="built_in">set</span> age to:76 </div><div class="line">b is running! </div><div class="line">thread b <span class="built_in">set</span> age to:27 </div><div class="line">thread a first <span class="built_in">read</span> age is:76 </div><div class="line">thread b first <span class="built_in">read</span> age is:27 </div><div class="line">thread a second <span class="built_in">read</span> age is:76 </div><div class="line">thread b second <span class="built_in">read</span> age is:27</div></pre></td></tr></table></figure></p>
<p>原文地址：<a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">http://www.iteye.com/topic/103804</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> threadlocal </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2014/01/01/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog, This is my first post.so hello world<br><a id="more"></a></p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hello </tag>
            
            <tag> world </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
