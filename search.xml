<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[一张图了解三色标记法]]></title>
      <url>/2017/08/16/gc-three-color/</url>
      <content type="html"><![CDATA[<p><a href="/images/gc-1.gif"><img src="/images/gc-1.gif" alt=""></a><br><a id="more"></a><br>三色标记法是传统 Mark-Sweep 的一个改进，它是一个并发的 GC 算法。<br>原理如下，<br>1.首先创建三个集合：白、灰、黑。<br>2.将所有对象放入白色集合中。<br>3.然后从根节点开始遍历所有对象（注意这里并不<strong>递归遍历</strong>），把遍历到的对象从白色集合放入灰色集合。<br>4.之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合<br>5.重复 4 直到灰色中无任何对象<br>6.通过write-barrier检测对象有变化，重复以上操作<br>7.收集所有白色对象（垃圾）<br>这个算法可以实现 “on-the-fly”，也就是在程序执行的同时进行收集，并不需要暂停整个程序。<br>但是也会有一个缺陷，可能程序中的垃圾产生的速度会大于垃圾收集的速度，这样会导致程序中的垃圾越来越多无法被收集掉。</p>
]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gc </tag>
            
            <tag> go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一张图了解标记清除算法]]></title>
      <url>/2017/08/16/gc-mark-sweep/</url>
      <content type="html"><![CDATA[<p><a href="/images/gc.gif"><img src="/images/gc.gif" alt=""></a><br><a id="more"></a><br>这个算法分为两步，标记和清除。</p>
<ul>
<li>标记：从程序的根节点开始， 递归地 遍历所有对象，将能遍历到的对象打上标记。</li>
<li>清除：讲所有未标记的的对象当作垃圾销毁。</li>
</ul>
<p>但是这个算法也有一个缺陷，就是人们常常说的 STW 问题（Stop The World）。因为算法在标记时必须暂停整个程序，否则其他线程的代码可能会改变对象状态，从而可能把不应该回收的对象当做垃圾收集掉。<br>当程序中的对象逐渐增多时，递归遍历整个对象树会消耗很多的时间，在大型程序中这个时间可能会是毫秒级别的。让所有的用户等待几百毫秒的 GC 时间这是不能容忍的。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> gc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[postman的几种body的使用介绍]]></title>
      <url>/2017/08/10/postman/</url>
      <content type="html"><![CDATA[<blockquote>
<p>postman,用来模拟发送http请求的工具，里面涉及的请求body有以下几个类型，所以记下，而且也能理解http body的几种格式，分享之。。</p>
</blockquote>
<a id="more"></a>
<h1 id="form-data"><a href="#form-data" class="headerlink" title="form-data"></a>form-data</h1><p>就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型；content-disposition，用来说明字段的一些信息；<br>由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。</p>
<p><a href="/images/postman-1.png"><img src="/images/postman-1.png" alt=""></a><br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">POST /login HTTP/1.1</div><div class="line">Host: 10.170.56.67</div><div class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Cache-Control: no-cache</div><div class="line">Postman-Token: 9843651a-5bf9-0544-03c1-fcc2a16f484b</div><div class="line"></div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;username&quot;</div><div class="line"></div><div class="line">admin</div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;password&quot;</div><div class="line"></div><div class="line">admin123</div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;abc&quot;; filename=&quot;&quot;</div><div class="line">Content-Type: </div><div class="line"></div><div class="line"></div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;tttt&quot;; filename=&quot;&quot;</div><div class="line">Content-Type: </div><div class="line"></div><div class="line"></div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</div></pre></td></tr></table></figure></p>
<h1 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h1><p>就是application/x-www-from-urlencoded,会将表单内的数据转换为键值对，并以urlencode为格式<br><a href="/images/postman-2.png"><img src="/images/postman-2.png" alt=""></a><br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST /login HTTP/1.1</div><div class="line">Host: 10.170.56.67</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Cache-Control: no-cache</div><div class="line">Postman-Token: e6887900-a46e-2ff4-8232-de878b75f5fd</div><div class="line"></div><div class="line">username=admin&amp;password=admin123</div></pre></td></tr></table></figure></p>
<h1 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h1><p>可以上传任意格式的文本，可以上传text、json、xml、html等<br><a href="/images/postman-3.png"><img src="/images/postman-3.png" alt=""></a><br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">POST /login HTTP/1.1</div><div class="line">Host: 10.170.56.67</div><div class="line">Content-Type: application/json</div><div class="line">Cache-Control: no-cache</div><div class="line">Postman-Token: 233df0e0-c6d9-98c7-4d7e-736329322683</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;abc&quot;:&quot;cba&quot;,</div><div class="line">  &quot;cba&quot;:&quot;abc&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从图片和内容对比，可以发现，基本，粘什么，就发什么，不会进行任何转意。</p>
<h1 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h1><p>相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。</p>
<h1 id="multipart-form-data与x-www-form-urlencoded区别"><a href="#multipart-form-data与x-www-form-urlencoded区别" class="headerlink" title="multipart/form-data与x-www-form-urlencoded区别"></a>multipart/form-data与x-www-form-urlencoded区别</h1><ul>
<li>multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息；</li>
<li>x-www-form-urlencoded：只能上传键值对，并且键值对都是间隔分开的</li>
</ul>
]]></content>
      
        <categories>
            
            <category> http </category>
            
        </categories>
        
        
        <tags>
            
            <tag> postman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[go的是否需要用goroutine pool？]]></title>
      <url>/2017/08/03/go-worker-pool-if-need/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这几天无聊，想到java有自己的线程池，是否对应go也有它的goroutine pool呢，所以搜了下，标准库没有，github有，但都大同小异，所以自己实现了一个。</p>
</blockquote>
<a id="more"></a>
<h1 id="一个简单的goroutine-pool"><a href="#一个简单的goroutine-pool" class="headerlink" title="一个简单的goroutine pool"></a>一个简单的goroutine pool</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> workerpool</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> task <span class="function"><span class="keyword">func</span><span class="params">()</span></span></div><div class="line"></div><div class="line"><span class="title">type</span> <span class="title">worker</span> <span class="title">struct</span> &#123;</div><div class="line">	stopC <span class="keyword">chan</span> <span class="keyword">bool</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> WorkerPool <span class="keyword">struct</span> &#123;</div><div class="line">	num <span class="keyword">int</span></div><div class="line">	sync.Mutex</div><div class="line">	taskQ <span class="keyword">chan</span> task</div><div class="line">	workers []*worker</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorkerPool</span><span class="params">(workerNum <span class="keyword">int</span>,queueCap <span class="keyword">int</span>)</span> *<span class="title">WorkerPool</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> &amp;WorkerPool&#123;num:workerNum,taskQ:<span class="built_in">make</span>(<span class="keyword">chan</span> task,queueCap),workers:<span class="built_in">make</span>([]*worker,workerNum)&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span> <span class="title">Execute</span><span class="params">(t task)</span></span>&#123;</div><div class="line">	wp.taskQ&lt;-t</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span> <span class="title">Start</span><span class="params">()</span> *<span class="title">WorkerPool</span></span>&#123;</div><div class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;wp.num;i++&#123;</div><div class="line">		wp.workers[i]=&amp;worker&#123; <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)&#125;</div><div class="line">		w:=wp.workers[i]</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> &#123;</div><div class="line">				    stop:=<span class="literal">false</span></div><div class="line">					<span class="keyword">select</span> &#123;</div><div class="line">					    <span class="keyword">case</span> f:=&lt;-wp.taskQ:</div><div class="line">							f()</div><div class="line">					    <span class="keyword">case</span> stop=&lt;-w.stopC:</div><div class="line">						     <span class="keyword">break</span></div><div class="line"></div><div class="line">					&#125;</div><div class="line"></div><div class="line">				<span class="keyword">if</span> stop&#123;</div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			fmt.Println(<span class="string">"stop"</span>)</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> wp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">for</span> _,w:=<span class="keyword">range</span> wp.workers&#123;</div><div class="line">		w.stopC&lt;- <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很简单，就是<code>NewWorkerPool</code>一个池子的时候设置goroutine的数量和任务队列的大小。<code>Start</code>后就创建那么多goroutine去任务队列取任务执行，取不到任务就自循。<code>Execute</code>方法是把任务压进队列，如果队列满了就阻塞。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>要测试性能，肯定要有对比，以下是没有使用pool:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">nopool</span><span class="params">()</span></span> &#123;</div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">    <span class="comment">//执行1000000次，每次都启动一个goroutine</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">defer</span> wg.Done()</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	wg.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下是简单版的只是单纯限制goroutine数量和任务队列的代码，没有任何封装的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopool</span><span class="params">()</span></span> &#123;</div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">    <span class="comment">//队列100</span></div><div class="line">	data := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</div><div class="line"></div><div class="line">    <span class="comment">//goroutine 数量10个</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">defer</span> wg.Done()</div><div class="line">			<span class="keyword">for</span> _ = <span class="keyword">range</span> data &#123;</div><div class="line">				<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</div><div class="line">					<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</div><div class="line"></div><div class="line">					&#125;</div><div class="line">				&#125;()</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="comment">//执行1000000个任务</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</div><div class="line">		data &lt;- i</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">close</span>(data)</div><div class="line">	wg.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是主角:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">workerpool</span><span class="params">()</span></span> &#123;</div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">    <span class="comment">//十个goroutine，队列容量100</span></div><div class="line">	wp:=NewWorkerPool(<span class="number">10</span>,<span class="number">100</span>)</div><div class="line">	wp.Start()</div><div class="line">    <span class="comment">//提交1000000任务</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		wp.Execute(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			wg.Done()</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码基本都是做同样一件事，但是后两个只开10个goroutine，第一个就开了1000000个，结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BenchmarkNopool-8                      1        7966900091 ns/op</div><div class="line">BenchmarkGopool-8                      1        7949844269 ns/op</div><div class="line">BenchmarkWorkerPool-8                  1        7997732135 ns/op</div></pre></td></tr></table></figure></p>
<p>可以看出来，没有区别，重新run几次基本没有多大变化。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于go本身有对goroutine有调度，所以自己实现的池子来调度其实好像没有什么用。还有可能我自己能力实现不好，没发挥池子的作用😀。<br>但是用更少的goroutine能完成同样的事情，应该是一种优化，而且这里的goroutine执行都是简单的循环，没有复杂的业务，一旦业务复杂，更少goroutine能够减少内存和goroutine切换时的cpu资源，有可能上面性能的比较会拉开。</p>
]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用树莓派搭建一个简易的NAS]]></title>
      <url>/2017/07/20/raspberry-nas/</url>
      <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>raspberry pi 3</li>
<li>硬盘（格式化过ext4的）</li>
<li>连接raspberry用的终端</li>
</ul>
<a id="more"></a>
<h1 id="安装samba"><a href="#安装samba" class="headerlink" title="安装samba"></a>安装samba</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install samba samba-common-bin</div></pre></td></tr></table></figure>
<h1 id="配置samba"><a href="#配置samba" class="headerlink" title="配置samba"></a>配置samba</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.back</div><div class="line">sudo vim /etc/samba/smb.conf</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在末尾加入如下内容</span></div><div class="line"><span class="comment"># 分享名称</span></div><div class="line">[MyNAS]</div><div class="line"><span class="comment"># 说明信息</span></div><div class="line">comment = NAS Storage</div><div class="line"><span class="comment"># 可以访问的用户</span></div><div class="line">valid users = pi,root</div><div class="line"><span class="comment"># 共享文件的路径,raspberry pi 会自动将连接到其上的外接存储设备挂载到/media/pi/目录下。</span></div><div class="line">path = /media/pi/</div><div class="line"><span class="comment"># 可被其他人看到资源名称（非内容）</span></div><div class="line">browseable = yes</div><div class="line"><span class="comment"># 可写</span></div><div class="line">writable = yes</div><div class="line"><span class="comment"># 新建文件的权限为 664</span></div><div class="line">create mask = 0664</div><div class="line"><span class="comment"># 新建目录的权限为 775</span></div><div class="line">directory mask = 0775</div></pre></td></tr></table></figure>
<p>可以把配置文件中你不需要的分享名称删除，例如 [homes], [printers] 等。<br>测试配置文件是否有错误，根据提示做相应修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">testparm</div></pre></td></tr></table></figure></p>
<p>添加登陆账户并创建密码，必须是 linux 已存在的用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo smbpasswd -a pi</div></pre></td></tr></table></figure></p>
<p>重启 samba 服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/samba restart</div></pre></td></tr></table></figure></p>
<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>一般树莓派跟你的WiFi相连的话，你的网络就能看到跟上面配置一样的分享名称，如mac上面这样的显示：<br><a href="/images/nas-screenshot.png"><img src="/images/nas-screenshot.png" alt=""></a><br>如果显示没权限，可以断开连接，用你上面添加的账号登录。</p>
]]></content>
      
        <categories>
            
            <category> raspberrypi </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> raspberrypi </tag>
            
            <tag> NAS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用树莓派实现一个能播放天气的闹钟]]></title>
      <url>/2017/07/18/raspberry-weather-clock/</url>
      <content type="html"><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>你要有个pi😄<br><a id="more"></a></p>
<h1 id="获取天气接口"><a href="#获取天气接口" class="headerlink" title="获取天气接口"></a>获取天气接口</h1><p>这里我是用图灵机器人来获取天气的接口，你可以自己上去注册一个，下面代码URL的Key是我注册的机器人给的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getWeatherText</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        response = requests.get(</div><div class="line">            <span class="string">"http://www.tuling123.com/openapi/api?key=652ae4a714794fe6b01faa990d7a981f&amp;info=%s"</span> % <span class="string">"广州今日天气"</span>)</div><div class="line">        json = response.json()</div><div class="line">        <span class="keyword">if</span> json[<span class="string">"code"</span>] == <span class="number">100000</span>:</div><div class="line">            <span class="keyword">return</span> json[<span class="string">"text"</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span></div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span></div></pre></td></tr></table></figure></p>
<h1 id="播放文字"><a href="#播放文字" class="headerlink" title="播放文字"></a>播放文字</h1><p>利用百度的接口可以转换文本为语音。默认只有女声<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2voice</span><span class="params">(text)</span>:</span></div><div class="line">    url = <span class="string">'http://tts.baidu.com/text2audio?idx=1&amp;tex=&#123;0&#125;&amp;cuid=baidu_speech_'</span> \</div><div class="line">          <span class="string">'demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=4&amp;per=4&amp;vol=5&amp;pit=5'</span>.format(text)</div><div class="line">    <span class="comment"># 用mplayer播放语音</span></div><div class="line">    os.system(<span class="string">'mplayer "%s"'</span> % url)</div></pre></td></tr></table></figure></p>
<h1 id="安装播放媒体软件"><a href="#安装播放媒体软件" class="headerlink" title="安装播放媒体软件"></a>安装播放媒体软件</h1><p>上面代码你看到的<code>mplayer</code>,就是用来播放语音的，传个url作为参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mplayer</div><div class="line">usage: mplayer [url]</div></pre></td></tr></table></figure></p>
<h1 id="播放音乐"><a href="#播放音乐" class="headerlink" title="播放音乐"></a>播放音乐</h1><p>有了上面这个神器，你可以给播报语音前后加一首音乐😄<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">playMusic</span><span class="params">(path)</span>:</span></div><div class="line">    os.system(<span class="string">'mplayer %s'</span> % path)</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用上面的东东，可以组合些好玩的东西了，至于闹钟的唤醒，可以crob job 做，也可以代码里面实现，enjoy…😄<br>全部代码地址 <a href="https://github.com/ejunjsh/raspberrypi-code/blob/master/clock/weather.py" target="_blank" rel="external">https://github.com/ejunjsh/raspberrypi-code/blob/master/clock/weather.py</a></p>
]]></content>
      
        <categories>
            
            <category> raspberrypi </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> raspberrypi </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用go实现一个简单的restful接口]]></title>
      <url>/2017/07/18/go-first-rest/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>go的标准库<code>http</code>已经封装好很多接口，可以很简单实现一个web服务器。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义 handler</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</div><div class="line">    io.WriteString(w, <span class="string">"hello, world!\n"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">//绑定pattern和handler</span></div><div class="line">    http.HandleFunc(<span class="string">"/hello"</span>, HelloServer)</div><div class="line">    err := http.ListenAndServe(<span class="string">":12345"</span>, <span class="literal">nil</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基于上面例子可以封装一个restful接口，不是难事。<br><a id="more"></a></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>从上面例子可以看到，一个url pattern对应一个handler，即对应一个处理，就可以处理http请求了，所以下面的实现是基于对这两个东西的封装开始</p>
<h2 id="封装一个restful-app-结构"><a href="#封装一个restful-app-结构" class="headerlink" title="封装一个restful app 结构"></a>封装一个restful app 结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">//一个map，key是pattern，value是handler</span></div><div class="line">	handlers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(r *HttpRequest,w HttpResponse)</span><span class="title">error</span></span></div><div class="line">    //<span class="title">pattern</span>数组，用来保证加入<span class="title">pattern</span>的顺序，因为上面的<span class="title">map</span>是无顺序的</div><div class="line">	<span class="title">patterns</span> []<span class="title">string</span></div><div class="line">    //一个<span class="title">map</span>，<span class="title">key</span>是<span class="title">pattern</span>，<span class="title">value</span>是<span class="title">http</span> <span class="title">method</span></div><div class="line">	<span class="title">methods</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></div><div class="line">    //用来实现在<span class="title">url</span> <span class="title">path</span>取出参数的。</div><div class="line">	<span class="title">regexps</span> <span class="title">map</span>[<span class="title">string</span>]*<span class="title">regexp</span>.<span class="title">Regexp</span></div><div class="line">	<span class="title">pathparamanmes</span> <span class="title">map</span>[<span class="title">string</span>][]<span class="title">string</span></div><div class="line">    //用来处理异常的<span class="title">handler</span></div><div class="line">	<span class="title">errHandler</span> <span class="title">func</span><span class="params">( err error, r *HttpRequest,w HttpResponse)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApp</span><span class="params">()</span> *<span class="title">App</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;App&#123;</div><div class="line">		handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>),</span></div><div class="line">		<span class="title">patterns</span>:<span class="title">make</span><span class="params">([]<span class="keyword">string</span>,0)</span>,</div><div class="line">		<span class="title">methods</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span>,</div><div class="line">		<span class="title">regexps</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]*regexp.Regexp)</span>,</div><div class="line">		<span class="title">pathparamanmes</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span>,</div><div class="line">        //一个默认的异常处理，直接返回异常内容</div><div class="line">		<span class="title">errHandler</span>: <span class="title">func</span><span class="params">(err error, r *HttpRequest, w HttpResponse)</span> &#123;</div><div class="line">			w.Write( []<span class="keyword">byte</span>(err.Error()))</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="映射绑定"><a href="#映射绑定" class="headerlink" title="映射绑定"></a>映射绑定</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">handle</span><span class="params">(method <span class="keyword">string</span>,pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span> <span class="title">error</span>)</span>&#123;</div><div class="line">    <span class="comment">//绑定pattern和handler</span></div><div class="line">	a.handlers[pattern]=handler</div><div class="line">    <span class="comment">//绑定pattern和method</span></div><div class="line">	a.methods[pattern]=method</div><div class="line">    <span class="comment">//绑定pattern 正则，用来匹配url pattern,和获取url path 参数</span></div><div class="line">	a.regexps[pattern],a.pathparamanmes[pattern]=convertPatterntoRegex(pattern)</div><div class="line">	<span class="keyword">for</span> _,s:=<span class="keyword">range</span> a.patterns&#123;</div><div class="line">		<span class="keyword">if</span> s==pattern&#123;</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//加入数组，方便用此数组确定顺序</span></div><div class="line">	a.patterns=<span class="built_in">append</span>(a.patterns,pattern)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//绑定GET</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Get</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"GET"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定POST</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Post</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"POST"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定DELETE</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Delete</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"DELETE"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定PUT</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Put</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span> <span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"PUT"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Error</span><span class="params">(handler <span class="keyword">func</span>(err error,r *HttpRequest,w HttpResponse)</span>)</span>  &#123;</div><div class="line">	a.errHandler=handler</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了Restful接口的四个方法映射绑定，剩下的就要请求能进到来，所以接下来要写个入口才行。</p>
<h2 id="编写http入口"><a href="#编写http入口" class="headerlink" title="编写http入口"></a>编写http入口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//http 入口</span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">Run</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</div><div class="line">	fmt.Printf(<span class="string">"Server listens on %s"</span>,address)</div><div class="line">	err:=http.ListenAndServe(address,&amp;hodler&#123;app:a&#125;)</div><div class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//https 入口</span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">RunTls</span><span class="params">(address <span class="keyword">string</span>,cert <span class="keyword">string</span>,key <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</div><div class="line">	fmt.Printf(<span class="string">"Server listens on %s"</span>,address)</div><div class="line">	err:=http.ListenAndServeTLS(address,cert,key,&amp;hodler&#123;app:a&#125;)</div><div class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>入口函数主要调用<code>http</code>库来启动http服务，然后把请求处理函数作为<code>ListenAndServe</code>第二个参数传入。这里由<code>holder</code>来实现这个处理函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hodler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</div><div class="line">	<span class="comment">//封装一下，附加更多功能</span></div><div class="line">    request:= newHttpRequest(r)</div><div class="line">	response:=newHttpResponse(w)</div><div class="line">	<span class="comment">//捕获panic，并让errhandler处理返回。</span></div><div class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span>&#123;</div><div class="line">			<span class="keyword">if</span> e,ok:=err.(error);ok&#123;</div><div class="line">				h.app.errHandler(InternalError&#123;e,<span class="string">""</span>&#125;,request,response)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> e,ok:=err.(<span class="keyword">string</span>);ok&#123;</div><div class="line">				h.app.errHandler(InternalError&#123;<span class="literal">nil</span>,e&#125;,request,response)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">    <span class="comment">//根据pattern的添加顺序，循环判断</span></div><div class="line">   <span class="keyword">for</span> _,p:=<span class="keyword">range</span> h.app.patterns&#123;</div><div class="line">       <span class="keyword">if</span> reg,ok:= h.app.regexps[p];ok&#123;</div><div class="line">           <span class="comment">//匹配method</span></div><div class="line">		   <span class="keyword">if</span> method,ok:=h.app.methods[p];ok&amp;&amp;r.Method==method&#123;</div><div class="line">              <span class="comment">//匹配pattern</span></div><div class="line">			   <span class="keyword">if</span> reg.Match([]<span class="keyword">byte</span>(r.URL.Path)) &#123;</div><div class="line">                   <span class="comment">//抽取url path parameters</span></div><div class="line">				   matchers:=reg.FindSubmatch([]<span class="keyword">byte</span>(r.URL.Path))</div><div class="line">				   pathParamMap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</div><div class="line">				   <span class="keyword">if</span> <span class="built_in">len</span>(matchers)&gt;<span class="number">1</span>&#123;</div><div class="line">                       <span class="keyword">if</span> pathParamNames,ok:=h.app.pathparamanmes[p];ok&#123;</div><div class="line">						   <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(matchers);i++&#123;</div><div class="line">							   pathParamMap[pathParamNames[i]]=<span class="keyword">string</span>(matchers[i])</div><div class="line">						   &#125;</div><div class="line">					   &#125;</div><div class="line">				   &#125;</div><div class="line">                   <span class="comment">//PathParams是封装后的request独有的属性</span></div><div class="line">				   request.PathParams=pathParamMap</div><div class="line">				   <span class="keyword">if</span> handler,ok:=h.app.handlers[p];ok&#123;</div><div class="line">                       <span class="comment">//执行handler</span></div><div class="line">					   err:=handler(request,response)</div><div class="line">					   <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">                           <span class="comment">//执行errhandler</span></div><div class="line">						   h.app.errHandler(err,request,response)</div><div class="line">					   &#125;</div><div class="line">					   <span class="keyword">return</span></div><div class="line">				   &#125;</div><div class="line">			   &#125;</div><div class="line">		   &#125;</div><div class="line">	   &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//执行no found errhandler</span></div><div class="line">	h.app.errHandler(NoFoundError&#123;&#125;,request,response)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基本一个请求的流程如下：<br>requset-&gt;ServeHTTP()-&gt;匹配url pattern-&gt;匹配method-&gt;匹配到你的handler-&gt;执行你的handler-&gt;你的handler返回结果</p>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>由于返回结果可以有很多，所以封装了<code>http</code>库的<code>http.ResponseWriter</code>来实现<code>WriteString,WriteJson,WriteXml,WriteFile</code>等方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//封装request，附件一个PathParams来保存url path parameters.</span></div><div class="line"><span class="keyword">type</span> HttpRequest <span class="keyword">struct</span> &#123;</div><div class="line">	*http.Request</div><div class="line">	PathParams <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> HttpResponse <span class="keyword">struct</span> &#123;</div><div class="line">	http.ResponseWriter</div><div class="line">&#125;</div><div class="line"><span class="comment">//用来返回字符</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteString</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回JSON</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteJson</span><span class="params">(jsonObj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回XML</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteXml</span><span class="params">(xmlObj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回文件</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteFile</span><span class="params">(filepath <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回一个模板html</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteTemplates</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;,tplPath ...<span class="keyword">string</span>)</span> <span class="title">error</span></span>  &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//new 一个restful接口</span></div><div class="line">	app:=gorest.NewApp()</div><div class="line">    <span class="comment">//绑定</span></div><div class="line">	app.Get(<span class="string">"/json"</span>, <span class="function"><span class="keyword">func</span><span class="params">(r *gorest.HttpRequest, w gorest.HttpResponse)</span> <span class="title">error</span></span> &#123;</div><div class="line">		a:= <span class="keyword">struct</span> &#123;</div><div class="line">			Abc <span class="keyword">string</span> <span class="string">`json:"abc"`</span></div><div class="line">			Cba <span class="keyword">string</span> <span class="string">`json:"cba"`</span></div><div class="line">		&#125;&#123;<span class="string">"123"</span>,<span class="string">"321"</span>&#125;</div><div class="line">        <span class="comment">//返回json作为结果</span></div><div class="line">		<span class="keyword">return</span> w.WriteJson(a)</div><div class="line">	&#125;)</div><div class="line">	app.Error(<span class="function"><span class="keyword">func</span><span class="params">(err error, r *gorest.HttpRequest, w gorest.HttpResponse)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span> e,ok:=err.(gorest.NoFoundError);ok &#123;</div><div class="line">			w.Write([]<span class="keyword">byte</span>(e.Error()))</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> e,ok:=err.(gorest.InternalError);ok &#123;</div><div class="line">			w.Write([]<span class="keyword">byte</span>(e.Error()))</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">    <span class="comment">//启动</span></div><div class="line">	app.Run(<span class="string">":8081"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>收工😄</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>go的标准库封装了很多了，所以实现这个其实还是比较轻松的😄<br>详细代码见<a href="https://github.com/ejunjsh/gorest" target="_blank" rel="external">https://github.com/ejunjsh/gorest</a></p>
]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> restful </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一张图了解一致性hash]]></title>
      <url>/2017/07/16/consistent-hash/</url>
      <content type="html"><![CDATA[<p><a href="/images/consistent-hash.png"><img src="/images/consistent-hash.png" alt="one image describes how consistent-hash works"></a><br><a id="more"></a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一张图了解hashmap]]></title>
      <url>/2017/07/15/hashmap/</url>
      <content type="html"><![CDATA[<p><a href="/images/hashmap.png"><img src="/images/hashmap.png" alt="one image describes how hashmap works"></a><br><a id="more"></a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单理解Java GC与幽灵引用]]></title>
      <url>/2016/09/11/java-gc-reference/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Java中一共有4种类型的引用:StrongReference、SoftReference、WeakReference以及PhantomReference (幽灵引用), 这 4 种类型的引用与Java GC有着密切的关系, 让我们逐一来看它们的定义和使用场景。</p>
</blockquote>
<a id="more"></a>
<h1 id="Strong-Reference"><a href="#Strong-Reference" class="headerlink" title="Strong Reference"></a>Strong Reference</h1><p>StrongReference 是 Java 的默认引用实现,它会尽可能长时间的存活于 JVM 内， 当没有任何对象指向它时Java GC 执行后将会被回收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strongReference</span><span class="params">()</span> </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 通过赋值创建 StrongReference   </div><div class="line"> */  </div><div class="line">Object strongReference = referent;   </div><div class="line">   </div><div class="line">assertSame(referent, strongReference);   </div><div class="line">   </div><div class="line">referent = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * StrongReference 在 GC 后不会被回收  </div><div class="line"> */  </div><div class="line">assertNotNull(strongReference);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="WeakReference-amp-WeakHashMap"><a href="#WeakReference-amp-WeakHashMap" class="headerlink" title="WeakReference &amp; WeakHashMap"></a>WeakReference &amp; WeakHashMap</h1><p>WeakReference， 顾名思义,是一个弱引用,当所引用的对象在 JVM 内不再有强引用时, Java GC 后 weak reference 将会被自动回收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakReference</span><span class="params">()</span> </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();   </div><div class="line">WeakReference&lt;Object&gt; weakRerference = <span class="keyword">new</span> WeakReference&lt;Object&gt;(referent);   </div><div class="line"> </div><div class="line">assertSame(referent, weakRerference.get());   </div><div class="line">   </div><div class="line">referent = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 一旦没有指向 referent 的强引用, weak reference 在 GC 后会被自动回收  </div><div class="line"> */  </div><div class="line">assertNull(weakRerference.get());   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WeakHashMap 使用 WeakReference 作为 key， 一旦没有指向 key 的强引用, WeakHashMap 在Java GC 后将自动删除相关的 entry<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakHashMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </div><div class="line">Map&lt;Object, Object&gt; weakHashMap = <span class="keyword">new</span> WeakHashMap&lt;Object, Object&gt;();   </div><div class="line">Object key = <span class="keyword">new</span> Object();   </div><div class="line">Object value = <span class="keyword">new</span> Object();   </div><div class="line">weakHashMap.put(key, value);   </div><div class="line"> </div><div class="line">assertTrue(weakHashMap.containsValue(value));   </div><div class="line">   </div><div class="line">key = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 等待无效 entries 进入 ReferenceQueue 以便下一次调用 getTable 时被清理  </div><div class="line"> */  </div><div class="line">Thread.sleep(<span class="number">1000</span>);   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 一旦没有指向 key 的强引用, WeakHashMap 在 GC 后将自动删除相关的 entry  </div><div class="line"> */  </div><div class="line">assertFalse(weakHashMap.containsValue(value));   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="SoftReference"><a href="#SoftReference" class="headerlink" title="SoftReference"></a>SoftReference</h1><p>SoftReference 于 WeakReference 的特性基本一致， 最大的区别在于 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">softReference</span><span class="params">()</span> </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();   </div><div class="line">SoftReference&lt;Object&gt; softRerference = <span class="keyword">new</span> SoftReference&lt;Object&gt;(referent);   </div><div class="line"> </div><div class="line">assertNotNull(softRerference.get());   </div><div class="line">   </div><div class="line">referent = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> *soft references 只有在 jvm OutOfMemory 之前才会被回收, 所以它非常适合缓存应用  </div><div class="line"> */  </div><div class="line">assertNotNull(softRerference.get());   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Phantom-Reference"><a href="#Phantom-Reference" class="headerlink" title="Phantom Reference"></a>Phantom Reference</h1><p>作为本文主角， Phantom Reference(幽灵引用) 与 WeakReference 和 SoftReference 有很大的不同,因为它的 get() 方法永远返回 null, 这也正是它名字的由来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phantomReferenceAlwaysNull</span><span class="params">()</span> </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();   </div><div class="line">PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(referent, <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;());   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * phantom reference 的 get 方法永远返回 null   </div><div class="line"> */  </div><div class="line">assertNull(phantomReference.get());   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>诸位可能要问, 一个永远返回 null 的 reference 要来何用,请注意构造 PhantomReference 时的第二个参数 ReferenceQueue(事实上 WeakReference &amp; SoftReference 也可以有这个参数)，<br>PhantomReference 唯一的用处就是跟踪 referent何时被 enqueue 到 ReferenceQueue 中.</p>
<h1 id="RererenceQueue"><a href="#RererenceQueue" class="headerlink" title="RererenceQueue"></a>RererenceQueue</h1><p>当一个 WeakReference 开始返回 null 时， 它所指向的对象已经准备被回收， 这时可以做一些合适的清理工作. 将一个 ReferenceQueue 传给一个 Reference 的构造函数， 当对象被回收时， 虚拟机会自动将这个对象插入到 ReferenceQueue 中， WeakHashMap 就是利用 ReferenceQueue 来清除 key 已经没有强引用的 entries.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">referenceQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();  </div><div class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();   </div><div class="line">WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;Object&gt;(referent, referenceQueue);   </div><div class="line">   </div><div class="line">assertFalse(weakReference.isEnqueued());   </div><div class="line">Reference&lt;? extends Object&gt; polled = referenceQueue.poll();   </div><div class="line">assertNull(polled);   </div><div class="line">   </div><div class="line">referent = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line"> </div><div class="line">assertTrue(weakReference.isEnqueued());   </div><div class="line">Reference&lt;? extends Object&gt; removed = referenceQueue.remove();   </div><div class="line">assertNotNull(removed);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Phantom-Reference-vs-Weak-Reference"><a href="#Phantom-Reference-vs-Weak-Reference" class="headerlink" title="Phantom Reference vs Weak Reference"></a>Phantom Reference vs Weak Reference</h1><p>PhantomReference有两个好处， 其一， 它可以让我们准确地知道对象何时被从内存中删除， 这个特性可以被用于一些特殊的需求中(例如 Distributed GC，XWork 和 google-guice 中也使用 PhantomReference 做了一些清理性工作).</p>
<p>其二， 它可以避免 finalization 带来的一些根本性问题, 上文提到 PhantomReference 的唯一作用就是跟踪 referent 何时被 enqueue 到 ReferenceQueue 中,但是 WeakReference 也有对应的功能, 两者的区别到底在哪呢 ?<br>这就要说到 Object 的 finalize 方法, 此方法将在 gc 执行前被调用, 如果某个对象重载了 finalize 方法并故意在方法内创建本身的强引用,这将导致这一轮的 GC 无法回收这个对象并有可能<br>引起任意次 GC， 最后的结果就是明明 JVM 内有很多 Garbage 却 OutOfMemory， 使用 PhantomReference 就可以避免这个问题， 因为 PhantomReference 是在 finalize 方法执行后回收的，也就意味着此时已经不可能拿到原来的引用,也就不会出现上述问题,当然这是一个很极端的例子, 一般不会出现.</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p><strong>Soft vs Weak vs Phantom References</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Purpose</th>
<th>Use</th>
<th>When GCed</th>
<th>Implementing Class</th>
</tr>
</thead>
<tbody>
<tr>
<td>Strong Reference</td>
<td>An ordinary reference. Keeps objects alive as long as they are referenced.</td>
<td>normal reference.</td>
<td>Any object not pointed to can be reclaimed.</td>
<td>default</td>
</tr>
<tr>
<td>Soft Reference</td>
<td>Keeps objects alive provided there’s enough memory.</td>
<td>to keep objects alive even after clients have removed their references (memory-sensitive caches), in case clients start asking for them again by key.</td>
<td>After a first gc pass, the JVM decides it still needs to reclaim more space.</td>
<td>java.lang.ref.SoftReference</td>
</tr>
<tr>
<td>Weak Reference</td>
<td>Keeps objects alive only while they’re in use (reachable) by clients.</td>
<td>Containers that automatically delete objects no longer in use.</td>
<td>After gc determines the object is only weakly reachable</td>
<td>java.lang.ref.WeakReference java.util.WeakHashMap</td>
</tr>
<tr>
<td>Phantom Reference</td>
<td>Lets you clean up after finalization but before the space is reclaimed (replaces or augments the use offinalize())</td>
<td>Special clean up processing</td>
<td>After finalization.</td>
<td>java.lang.ref.PhantomReference</td>
</tr>
</tbody>
</table>
<h1 id="Java-GC小结"><a href="#Java-GC小结" class="headerlink" title="Java GC小结"></a>Java GC小结</h1><p>一般的应用程序不会涉及到 Reference 编程， 但是了解这些知识会对理解Java GC 的工作原理以及性能调优有一定帮助, 在实现一些基础性设施比如缓存时也可能会用到， 希望本文能有所帮助.</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> gc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis的事务和watch]]></title>
      <url>/2016/09/03/redis-transaction-watch/</url>
      <content type="html"><![CDATA[<h1 id="redis的事务"><a href="#redis的事务" class="headerlink" title="redis的事务"></a>redis的事务</h1><p>严格意义来讲,redis的事务和我们理解的传统数据库(如mysql)的事务是不一样的。<br><a id="more"></a></p>
<h2 id="redis中的事务定义"><a href="#redis中的事务定义" class="headerlink" title="redis中的事务定义"></a>redis中的事务定义</h2><p>Redis中的事务（transaction）是一组命令的集合。</p>
<p>事务同命令一样都是Redis的最小执行单位，一个事务中的命令要么都执行，要么都不执行。<br>事务的原理是先将属于一个事务的命令发送给Redis，然后再让Redis依次执行这些命令。</p>
<blockquote>
<p>Redis保证一个事务中的所有命令要么都执行，要么都不执行。如果在发送EXEC命令前客户端断线了，则Redis会清空事务队列，事务中的所有命令都不会执行。而一旦客户端发送了EXEC命令，所有的命令就都会被执行，即使此后客户端断线也没关系，因为Redis中已经记录了所有要执行的命令。</p>
<p>除此之外，Redis的事务还能保证一个事务内的命令依次执行而不被其他命令插入。试想客户端A需要执行几条命令，同时客户端B发送了一条命令，如果不使用事务，则客户端B的命令可能会插入到客户端A的几条命令中执行。如果不希望发生这种情况，也可以使用事务。</p>
</blockquote>
<h2 id="事务的应用"><a href="#事务的应用" class="headerlink" title="事务的应用"></a>事务的应用</h2><blockquote>
<p>事务的应用非常普遍，如银行转账过程中A给B汇款，首先系统从A的账户中将钱划走，然后向B的账户增加相应的金额。这两个步骤必须属于同一个事务，要么全执行，要么全不执行。否则只执行第一步，钱就凭空消失了，这显然让人无法接受。</p>
</blockquote>
<h2 id="和传统的事务不同"><a href="#和传统的事务不同" class="headerlink" title="和传统的事务不同"></a>和传统的事务不同</h2><blockquote>
<p>和传统的mysql事务不同的事，即使我们的加钱操作失败,我们也无法在这一组命令中让整个状态回滚到操作之前</p>
</blockquote>
<h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h2><p>如果一个事务中的某个命令执行出错，Redis会怎样处理呢？要回答这个问题，首先需要知道什么原因会导致命令执行出错。</p>
<h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p>语法错误指命令不存在或者命令参数的个数不对。比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redis＞MULTI</div><div class="line">OK</div><div class="line">redis＞SET key value</div><div class="line">QUEUED</div><div class="line">redis＞SET key</div><div class="line">(error)ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'set'</span> <span class="built_in">command</span></div><div class="line">redis＞ errorCOMMAND key</div><div class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">'errorCOMMAND'</span></div><div class="line">redis＞ EXEC</div><div class="line">(error) EXECABORT Transaction discarded because of previous errors.</div></pre></td></tr></table></figure></p>
<p>跟在MULTI命令后执行了3个命令：一个是正确的命令，成功地加入事务队列；其余两个命令都有语法错误。而只要有一个命令有语法错误，执行EXEC命令后Redis就会直接返回错误，连语法正确的命令也不会执行。</p>
<h4 id="这里需要注意一点："><a href="#这里需要注意一点：" class="headerlink" title="这里需要注意一点："></a>这里需要注意一点：</h4><p>Redis 2.6.5之前的版本会忽略有语法错误的命令，然后执行事务中其他语法正确的命令。就此例而言，SET key value会被执行，EXEC命令会返回一个结果：1) OK。</p>
<h3 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h3><p>运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前Redis是无法发现的，所以在事务里这样的命令是会被Redis接受并执行的。如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续执行（包括出错命令之后的命令），示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">redis＞MULTI</div><div class="line">OK</div><div class="line">redis＞SET key 1</div><div class="line">QUEUED</div><div class="line">redis＞SADD key 2</div><div class="line">QUEUED</div><div class="line">redis＞SET key 3</div><div class="line">QUEUED</div><div class="line">redis＞EXEC</div><div class="line">1) OK</div><div class="line">2) (error) ERR Operation against a key holding the wrong kind of value</div><div class="line">3) OK</div><div class="line">redis＞GET key</div><div class="line"><span class="string">"3"</span></div></pre></td></tr></table></figure></p>
<p>可见虽然SADD key 2出现了错误，但是SET key 3依然执行了。</p>
<p>Redis的事务没有关系数据库事务提供的回滚（rollback）功能。为此开发者必须在事务执行出错后自己收拾剩下的摊子（将数据库复原回事务执行前的状态等,这里我们一般采取日志记录然后业务补偿的方式来处理，但是一般情况下，在redis做的操作不应该有这种强一致性要求的需求，我们认为这种需求为不合理的设计）。</p>
<h1 id="Watch命令"><a href="#Watch命令" class="headerlink" title="Watch命令"></a>Watch命令</h1><p>大家可能知道redis提供了基于incr命令来操作一个整数型数值的原子递增，那么我们假设如果redis没有这个incr命令，我们该怎么实现这个incr的操作呢？</p>
<p>那么我们下面的正主<code>watch</code>就要上场了。</p>
<h2 id="如何使用watch命令"><a href="#如何使用watch命令" class="headerlink" title="如何使用watch命令"></a>如何使用watch命令</h2><p>正常情况下我们想要对一个整形数值做修改是这么做的(伪代码实现)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val = GET mykey</div><div class="line">val = val + 1</div><div class="line">SET mykey <span class="variable">$val</span></div></pre></td></tr></table></figure></p>
<p>但是上述的代码会出现一个问题,因为上面吧正常的一个incr(原子递增操作)分为了两部分,那么在多线程(分布式)环境中，这个操作就有可能不再具有原子性了。</p>
<p>研究过java的juc包的人应该都知道cas，那么redis也提供了这样的一个机制，就是利用watch命令来实现的。</p>
<h2 id="watch命令描述"><a href="#watch命令描述" class="headerlink" title="watch命令描述"></a>watch命令描述</h2><blockquote>
<p>WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值）</p>
</blockquote>
<h2 id="利用watch实现incr"><a href="#利用watch实现incr" class="headerlink" title="利用watch实现incr"></a>利用watch实现incr</h2><p>具体做法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">WATCH mykey</div><div class="line">val = GET mykey</div><div class="line">val = val + 1</div><div class="line">MULTI</div><div class="line">SET mykey <span class="variable">$val</span></div><div class="line">EXEC</div></pre></td></tr></table></figure></p>
<p>和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前，如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>由于WATCH命令的作用只是当被监控的键值被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一键值，所以在一般的情况下我们需要在EXEC执行失败后重新执行整个函数。</p>
<p>执行EXEC命令后会取消对所有键的监控，如果不想执行事务中的命令也可以使用UNWATCH命令来取消监控。</p>
<h2 id="实现一个hsetNX函数"><a href="#实现一个hsetNX函数" class="headerlink" title="实现一个hsetNX函数"></a>实现一个hsetNX函数</h2><p>我们实现的hsetNX这个功能是：仅当字段存在时才赋值。</p>
<p>为了避免竞态条件我们使用watch和事务来完成这一功能（伪代码）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">WATCH key  </div><div class="line">isFieldExists = HEXISTS key, field  </div><div class="line"><span class="keyword">if</span> isFieldExists is 1  </div><div class="line">MULTI  </div><div class="line">HSET key, field, value  </div><div class="line">EXEC  </div><div class="line"><span class="keyword">else</span>  </div><div class="line">UNWATCH  </div><div class="line"><span class="built_in">return</span> isFieldExists</div></pre></td></tr></table></figure></p>
<p>在代码中会判断要赋值的字段是否存在，如果字段不存在的话就不执行事务中的命令，但需要使用UNWATCH命令来保证下一个事务的执行不会受到影响。</p>
<p>原文地址 <a href="http://www.jianshu.com/p/361cb9cd13d5" target="_blank" rel="external">http://www.jianshu.com/p/361cb9cd13d5</a></p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程(二) 同步和锁]]></title>
      <url>/2016/08/20/java-thread-2-md/</url>
      <content type="html"><![CDATA[<blockquote>
<p>记录，汇总</p>
</blockquote>
<a id="more"></a>
<h1 id="线程同步问题的产生"><a href="#线程同步问题的产生" class="headerlink" title="线程同步问题的产生"></a>线程同步问题的产生</h1><p>什么是线程同步问题，我们先来看一段卖票系统的代码，然后再分析这个问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> num = <span class="number">100</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    Thread.sleep(<span class="number">10</span>);</div><div class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)</div><div class="line">                &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//输出卖票信息</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">".....sale...."</span>+num--);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面是卖票线程类，下来再来看看执行类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TickeDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        TicketSeller t = <span class="keyword">new</span> TicketSeller();<span class="comment">//创建一个线程任务对象。</span></div><div class="line"></div><div class="line">        <span class="comment">//创建4个线程同时卖票</span></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(t);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(t);</div><div class="line">        Thread t3 = <span class="keyword">new</span> Thread(t);</div><div class="line">        Thread t4 = <span class="keyword">new</span> Thread(t);</div><div class="line">        <span class="comment">//启动线程</span></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        t4.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行程序结果如下（仅截取部分数据）：<br><a href="/images/java-thread-2-1.png"><img src="/images/java-thread-2-1.png" alt=""></a><br>从运行结果，我们就可以看出我们3个售票窗口同时卖出了96号票，这显然是不合逻辑的，其实这个问题就是我们前面所说的线程同步问题。不同的线程都对同一个数据进了操作这就容易导致数据错乱的问题，也就是线程不同步。那么这个问题该怎么解决呢？在给出解决思路之前我们先来分析一下这个问题是怎么产生的？我们声明一个线程类TicketSeller，在这个类中我们又声明了一个成员变量num也就是票的数量，然后我们通过run方法不断的去获取票数并输出，最后我们在外部类TicketDemo中创建了四个线程同时操作这个数据，运行后就出现我们刚才所说的线程同步问题，从这里我们可以看出产生线程同步(线程安全)问题的条件有两个：1.多个线程在操作共享的数据（num），2.操作共享数据的线程代码有多条（4条线程）；既然原因知道了，那该怎么解决？</p>
<blockquote>
<p>解决思路：将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。 好了，思路知道了，我们就用java代码的方式来解决这个问题。</p>
</blockquote>
<h1 id="解决线程同步的两种典型方案"><a href="#解决线程同步的两种典型方案" class="headerlink" title="解决线程同步的两种典型方案"></a>解决线程同步的两种典型方案</h1><p>在java中有两种机制可以防止线程安全的发生，Java语言提供了一个synchronized关键字来解决这问题，同时在Java SE5.0引入了Lock锁对象的相关类，接下来我们分别介绍这两种方法</p>
<h2 id="通过锁（Lock）对象的方式解决线程安全问题"><a href="#通过锁（Lock）对象的方式解决线程安全问题" class="headerlink" title="通过锁（Lock）对象的方式解决线程安全问题"></a>通过锁（Lock）对象的方式解决线程安全问题</h2><p>在给出解决代码前我们先来介绍一个知识点：Lock，锁对象。在java中锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但有的锁可以允许多个线程并发访问共享资源，比如读写锁，后面我们会分析）。在Lock接口出现之前，java程序是靠synchronized关键字（后面分析）实现锁功能的，而JAVA SE5.0之后并发包中新增了Lock接口用来实现锁的功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁，缺点就是缺少像synchronized那样隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。接下来我们就来介绍Lock接口的主要API方便我们学习</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>相关描述内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td>void lock()</td>
<td>获取锁，调用该方法当前线程会获取锁，当获取锁后。从该方法返回</td>
</tr>
<tr>
<td>void lockInterruptibly() throws InterruptedException</td>
<td>可中断获取锁和lock()方法不同的是该方法会响应中断，即在获取锁中可以中断当前线程。例如某个线程在等待一个锁的控制权的这段时间需要中断。</td>
</tr>
<tr>
<td>boolean tryLock()</td>
<td>尝试非阻塞获取锁，调用该方法后立即返回，如果能够获取锁则返回true，否则返回false。</td>
</tr>
<tr>
<td>boolean tryLock(long time,TimeUnit unit) throws  InterruptedException</td>
<td>超时获取锁，当前线程在以下3种情况返回：1.当前线程在超时时间内获取了锁2.当前线程在超时时间被中断3.当前线程超时时间结束，返回false</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
<tr>
<td>Condition newCondition()</td>
<td>条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁。</td>
</tr>
</tbody>
</table>
<p>这里先介绍一下API，接下来我们将结合Lock接口的实现子类ReentrantLock来讲解下他的几个方法。</p>
<h3 id="ReentrantLock（重入锁"><a href="#ReentrantLock（重入锁" class="headerlink" title="ReentrantLock（重入锁)"></a>ReentrantLock（重入锁)</h3><p>重入锁，顾名思义就是支持重新进入的锁，它表示该锁能够支持一个线程对资源的重复加锁，也就是说在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞，同时还支持获取锁的公平性和非公平性。这里的公平是在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平锁，反之，是不公平的(但是如果不是需要，建议不要用公平锁，因为会造成一些资源的没必要等待，浪费性能)。那么该如何使用呢？看范例代码：<br>1.同步执行的代码跟synchronized类似功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//参数默认false，不公平锁    </span></div><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">//公平锁    </span></div><div class="line">    </div><div class="line">lock.lock(); <span class="comment">//如果被其它资源锁定，会在此等待锁释放，达到暂停的效果    </span></div><div class="line"><span class="keyword">try</span> &#123;    </div><div class="line">    <span class="comment">//操作    </span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;    </div><div class="line">    lock.unlock();  <span class="comment">//释放锁  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.防止重复执行代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();    </div><div class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;  <span class="comment">//如果已经被lock，则立即返回false不会等待，达到忽略操作的效果     </span></div><div class="line">    <span class="keyword">try</span> &#123;    </div><div class="line">        <span class="comment">//操作    </span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;    </div><div class="line">        lock.unlock();    </div><div class="line">   &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.尝试等待执行的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">//公平锁    </span></div><div class="line"><span class="keyword">try</span> &#123;    </div><div class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;        </div><div class="line">        <span class="comment">//如果已经被lock，尝试等待5s，看是否可以获得锁，如果5s后仍然无法获得锁则返回false继续执行    </span></div><div class="line">       <span class="keyword">try</span> &#123;    </div><div class="line">            <span class="comment">//操作    </span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;    </div><div class="line">            lock.unlock();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;    </div><div class="line">    e.printStackTrace(); <span class="comment">//当前线程被中断时(interrupt)，会抛InterruptedException                     </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有点需要特别注意的，把解锁操作放在finally代码块内这个十分重要。如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。好了，ReentrantLock我们就简单介绍到这里，接下来我们通过ReentrantLock来解决前面卖票线程的线程同步（安全）问题，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSellerWithLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//创建锁对象</span></div><div class="line">    <span class="keyword">private</span> Lock ticketLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="comment">//创建锁对象(公平锁)</span></div><div class="line">    <span class="comment">//private Lock ticketLock = new ReentrantLock(true);</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> num = <span class="number">100</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            ticketLock.lock();<span class="comment">//获取锁</span></div><div class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    Thread.sleep(<span class="number">10</span>);</div><div class="line">                    <span class="comment">//输出卖票信息</span></div><div class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">".....sale...."</span>+num--);</div><div class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)</div><div class="line">                &#123;</div><div class="line">                    Thread.currentThread().interrupt();<span class="comment">//继续中断异常</span></div><div class="line">                &#125;<span class="keyword">finally</span> &#123;</div><div class="line">                    ticketLock.unlock();<span class="comment">//释放锁</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                ticketLock.unlock();<span class="comment">//释放锁</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TicketDemo类无需变化，线程安全问题就此解决。<br>但是还是要说一下公平锁的问题，上面例子，不开公平锁的结果如下：<br><a href="/images/java-thread-2-2.png"><img src="/images/java-thread-2-2.png" alt=""></a><br>开公平锁的结果如下：<br><a href="/images/java-thread-2-3.png"><img src="/images/java-thread-2-3.png" alt=""></a><br><em>你会发现不开公平锁，cpu钟爱用第一个线程做事情，而开了公平锁后，基本是各个线程交替执行。上面提到公平锁是会消耗性能的，如果CPU调度的时候选择的不是公平调度的那个线程，CPU会放弃本次调度，干别的事情，如果老是调度不到的话，是浪费CPU调度的。</em></p>
<h2 id="通过synchronied关键字的方式解决线程安全问题"><a href="#通过synchronied关键字的方式解决线程安全问题" class="headerlink" title="通过synchronied关键字的方式解决线程安全问题"></a>通过synchronied关键字的方式解决线程安全问题</h2><p>在Java中内置了语言级的同步原语－synchronized，这个可以大大简化了Java中多线程同步的使用。从JAVA SE1.0开始，java中的每一个对象都有一个内部锁，如果一个方法使用synchronized关键字进行声明，那么这个对象将保护整个方法，也就是说调用该方法线程必须获得内部的对象锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> method&#123;  </div><div class="line">  <span class="comment">//method body  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Lock ticketLock = <span class="keyword">new</span> ReentrantLock();  </div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> method&#123;  </div><div class="line"> ticketLock.lock();  </div><div class="line"> <span class="keyword">try</span>&#123;  </div><div class="line">  <span class="comment">//.......  </span></div><div class="line"> &#125;<span class="keyword">finally</span>&#123;  </div><div class="line">   ticketLock.unlock();  </div><div class="line"> &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这里可以看出使用synchronized关键字来编写代码要简洁得多了。当然，要理解这一代码，我们必须知道每个对象有一个内部锁，并且该锁有一个内部条件。由锁来管理那些试图进入synchronized方法的线程，由条件来管那些调用wait的线程(wait()/notifyAll/notify())。同时我们必须明白一旦有一个线程通过synchronied方法获取到内部锁，该类的所有synchronied方法或者代码块都无法被其他线程访问直到当前线程释放了内部锁。刚才上面说的是同步方法，synchronized还有一种同步代码块的实现方式：</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程(一)基础]]></title>
      <url>/2016/08/08/java-thread-1-md/</url>
      <content type="html"><![CDATA[<blockquote>
<p>对多线程复习下，汇总一下</p>
</blockquote>
<a id="more"></a>
<h1 id="什么是线程以及多线程与进程的区别"><a href="#什么是线程以及多线程与进程的区别" class="headerlink" title="什么是线程以及多线程与进程的区别"></a>什么是线程以及多线程与进程的区别</h1><p>在现代操作在运行一个程序时，会为其创建一个进程。例如启动一个QQ程序，操作系统就会为其创建一个进程。而操作系统中调度的最小单位元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器，堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。因此我们可以这样理解：<br>进程：正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。<br>线程：是进程中的单个顺序控制流，是一条执行路径一个进程如果只有一条执行路径，则称为单线程程序。一个进程如果有多条执行路径，则称为多线程程序。</p>
<h1 id="多线程的创建与启动"><a href="#多线程的创建与启动" class="headerlink" title="多线程的创建与启动"></a>多线程的创建与启动</h1><p>创建多线程有两种方法，一种是继承Thread类重写run方法，另一种是实现Runnable接口重写run方法。<br>下面我们分别给出代码示例，继承Thread类重写run方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"I'm a thread that extends Thread!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现Runnable接口重写run方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"I'm a thread that implements Runnable !"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>怎么启动线程？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartThread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        </div><div class="line">        NewThread t1=<span class="keyword">new</span> NewThread();</div><div class="line">        t1.start();</div><div class="line"></div><div class="line">        NewRunnable r=<span class="keyword">new</span> NewRunnable();</div><div class="line">        Thread t2=<span class="keyword">new</span> Thread(r);</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I&apos;m a thread that extends Thread!</div><div class="line">I&apos;m a thread that implements Runnable !</div></pre></td></tr></table></figure></p>
<p>代码相当简单，不过多解释。这里有点需要注意的是调用start()方法后并不是是立即的执行多线程的代码，而是使该线程变为可运行态，什么时候运行多线程代码是由操作系统决定的。</p>
<h1 id="中断线程和守护线程以及线程优先级"><a href="#中断线程和守护线程以及线程优先级" class="headerlink" title="中断线程和守护线程以及线程优先级"></a>中断线程和守护线程以及线程优先级</h1><h2 id="什么是中断线程？"><a href="#什么是中断线程？" class="headerlink" title="什么是中断线程？"></a>什么是中断线程？</h2><p>我们先来看看中断线程是什么？(该解释来自java核心技术一书，我对其进行稍微简化)，当线程的run()方法执行方法体中的最后一条语句后，并经由执行return语句返回时，或者出现在方法中没有捕获的异常时线程将终止。在java早期版本中有一个stop方法，其他线程可以调用它终止线程，但是这个方法现在已经被弃用了，因为这个方法会造成一些线程不安全的问题。我们可以把中断理解为一个标识位的属性，它表示一个运行中的线程是否被其他线程进行了中断操作，而中断就好比其他线程对该线程打可个招呼，其他线程通过调用该线程的interrupt方法对其进行中断操作，当一个线程调用interrupt方法时，线程的中断状态（标识位）将被置位（改变），这是每个线程都具有的boolean标志，每个线程都应该不时的检查这个标志，来判断线程是否被中断。而要判断线程是否被中断，我们可以使用如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread.currentThread().isInterrupted()</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;  </div><div class="line">    <span class="keyword">do</span> something  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果此时线程处于阻塞状态（sleep或者wait），就无法检查中断状态，此时会抛出InterruptedException异常。如果每次迭代之后都调用sleep方法（或者其他可中断的方法），isInterrupted检测就没必要也没用处了，如果在中断状态被置位时调用sleep方法，它不会休眠反而会清除这一休眠状态并抛出InterruptedException。所以如果在循环中调用sleep,不要去检测中断状态，只需捕获InterruptedException。代码范例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">while</span>(more work to <span class="keyword">do</span> )&#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                Thread.sleep(<span class="number">5000</span>);  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                <span class="comment">//thread was interrupted during sleep  </span></div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;<span class="keyword">finally</span>&#123;  </div><div class="line">                <span class="comment">//clean up , if required  </span></div><div class="line">            &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不妥的处理方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myTask</span><span class="params">()</span></span>&#123;  </div><div class="line">    ...  </div><div class="line">   <span class="keyword">try</span>&#123;  </div><div class="line">       sleep(<span class="number">50</span>)  </div><div class="line">      &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </div><div class="line">   ...  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正确的处理方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myTask</span><span class="params">()</span>throw InterruptedException</span>&#123;  </div><div class="line">    sleep(<span class="number">50</span>)  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myTask</span><span class="params">()</span></span>&#123;  </div><div class="line">    ...  </div><div class="line">    <span class="keyword">try</span>&#123;  </div><div class="line">    sleep(<span class="number">50</span>)  </div><div class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </div><div class="line">     Thread.currentThread().interrupt();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后关于中断线程，我们这里给出中断线程的一些主要方法：<br>void interrupt()：向线程发送中断请求，线程的中断状态将会被设置为true，如果当前线程被一个sleep调用阻塞，那么将会抛出interrupedException异常。<br>static boolean interrupted()：测试当前线程（当前正在执行命令的这个线程）是否被中断。注意这是个静态方法，调用这个方法会产生一个副作用那就是它会将当前线程的中断状态重置为false。<br>boolean isInterrupted()：判断线程是否被中断，这个方法的调用不会产生副作用即不改变线程的当前中断状态。<br>static Thread currentThread() : 返回代表当前执行线程的Thread对象。</p>
<p><strong>这里要注意下，为啥上面的代码，在catch之后还要在中断一次，因为catch会把当前线程的中断标志重置为false，这里不重新中断一次，上层代码就不知道中断了，程序就不知道有中断的发生，下面代码可以说明这个</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ejunjsh on 8/10/2017.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterrupt</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        Thread t= <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">5000</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line">                    <span class="comment">//catch 异常之后，输出是false</span></div><div class="line">                    System.out.println(<span class="string">"1.current interrupted flag is "</span> +Thread.currentThread().isInterrupted());</div><div class="line">                    Thread.currentThread().interrupt();</div><div class="line">                    System.out.println(<span class="string">"2.current interrupted flag is "</span> +Thread.currentThread().isInterrupted());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">5000</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line">                    System.out.println(<span class="string">"3.current interrupted flag is "</span> +Thread.currentThread().isInterrupted());</div><div class="line">                    Thread.currentThread().interrupt();</div><div class="line">                    System.out.println(<span class="string">"4.current interrupted flag is "</span> +Thread.currentThread().isInterrupted());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        t.start();</div><div class="line">        <span class="comment">//开始中断</span></div><div class="line">        t.interrupt();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            t.join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"5.current state is "</span> +t.getState());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.current interrupted flag is false</div><div class="line">2.current interrupted flag is true</div><div class="line">3.current interrupted flag is false</div><div class="line">4.current interrupted flag is true</div><div class="line">5.current state is TERMINATED</div></pre></td></tr></table></figure></p>
<p>很明显，<code>开始中断</code>后，catch的标志位被重置了。</p>
<h2 id="什么是守护线程？"><a href="#什么是守护线程？" class="headerlink" title="什么是守护线程？"></a>什么是守护线程？</h2><p>首先我们可以通过t.setDaemon(true)的方法将线程转化为守护线程。而守护线程的唯一作用就是为其他线程提供服务。计时线程就是一个典型的例子，它定时地发送“计时器滴答”信号告诉其他线程去执行某项任务。当只剩下守护线程时，虚拟机就退出了，因为如果只剩下守护线程，程序就没有必要执行了。另外JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。最后还有一点需要特别注意的是在java虚拟机退出时Daemon线程中的finally代码块并不一定会执行哦，代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deamon</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread deamon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(),<span class="string">"DaemonRunner"</span>);</div><div class="line">        <span class="comment">//设置为守护线程</span></div><div class="line">        deamon.setDaemon(<span class="keyword">true</span>);</div><div class="line">        deamon.start();<span class="comment">//启动线程</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">500</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;<span class="keyword">finally</span>&#123;</div><div class="line">                System.out.println(<span class="string">"这里的代码在java虚拟机退出时并不一定会执行哦！"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此在构建Daemon线程时，不能依靠finally代码块中的内容来确保执行关闭或清理资源的逻辑。</p>
<h2 id="什么是线程优先级"><a href="#什么是线程优先级" class="headerlink" title="什么是线程优先级"></a>什么是线程优先级</h2><p>在现代操作系统中基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下一次分配。线程分配到的时间片多少也决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。在java线程中，通过一个整型的成员变量Priority来控制线程优先级，每一个线程有一个优先级，默认情况下，一个线程继承它父类的优先级。可以用setPriority方法提高或降低任何一个线程优先级。可以将优先级设置在MIN_PRIORITY（在Thread类定义为1）与MAX_PRIORITY（在Thread类定义为10）之间的任何值。线程的默认优先级为NORM_PRIORITY（在Thread类定义为5）。尽量不要依赖优先级，如果确实要用，应该避免初学者常犯的一个错误。如果有几个高优先级的线程没有进入非活动状态，低优先级线程可能永远也不能执行。每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择，尽管这样会使低优先级的线程可能永远不会被执行到。因此我们在设置优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高的优先级，而偏重计算（需要较多CPU时间或者运算）的线程则设置较低的优先级，这样才能确保处理器不会被长久独占。当然还有要注意就是在不同的JVM以及操作系统上线程的规划存在差异，有些操作系统甚至会忽略对线程优先级的设定，如mac os系统或者Ubuntu系统……..</p>
<h1 id="线程的状态转化关系"><a href="#线程的状态转化关系" class="headerlink" title="线程的状态转化关系"></a>线程的状态转化关系</h1><p>1.新建状态（New）：新创建了一个线程对象。<br>2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。<br>3.运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。<br>4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p>
<ul>
<li>等待阻塞（WAITING）：运行的线程执行wait()方法，JVM会把该线程放入等待池中。</li>
<li>同步阻塞（Blocked）：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li>
<li>超时阻塞（TIME_WAITING）：运行的线程执行sleep(long)或join(long)方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。</li>
</ul>
<p>5.死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。<br><a href="/images/java-thread-1-1.png"><img src="/images/java-thread-1-1.png" alt=""></a><br>图中的方法解析如下：<br>Thread.sleep()：在指定时间内让当前正在执行的线程暂停执行，但不会释放”锁标志”。不推荐使用。<br>Thread.sleep(long)：使当前线程进入阻塞状态，在指定时间内不会执行。<br>Object.wait()和Object.wait(long)：在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的”锁标志”，从而使别的线程有机会抢占该锁。 当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。 唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常，waite()和notify()必须在synchronized函数或synchronized中进行调用。如果在non-synchronized函数或non-synchronized中进行调用,虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。<br>Object.notifyAll()：则从对象等待池中唤醒所有等待等待线程<br>Object.notify()：则从对象等待池中唤醒其中一个线程。<br>Thread.yield()方法 暂停当前正在执行的线程对象，yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，yield()只能使同优先级或更高优先级的线程有执行的机会。<br>Thread.Join()：把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。<br>好了。本篇线程基础知识介绍到此结束。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通过反编译深入理解Java String及intern]]></title>
      <url>/2016/07/29/java-string-intern/</url>
      <content type="html"><![CDATA[<h1 id="字符串问题"><a href="#字符串问题" class="headerlink" title="字符串问题"></a>字符串问题</h1><p>字符串在我们平时的编码工作中其实用的非常多，并且用起来也比较简单，所以很少有人对其做特别深入的研究。倒是面试或者笔试的时候，往往会涉及比较深入和难度大一点的问题。我在招聘的时候也偶尔会问应聘者相关的问题，倒不是说一定要回答的特别正确和深入，通常问这些问题的目的有两个，第一是考察对 JAVA 基础知识的了解程度，第二是考察应聘者对技术的态度。<br><a id="more"></a><br>　　我们看看以下程序会输出什么结果？如果你能正确的回答每一道题，并且清楚其原因，那本文对你就没什么太大的意义。如果回答不正确或者不是很清楚其原理，那就仔细看看以下的分析，本文应该能帮助你清楚的理解每段程序的结果及输出该结果的深层次原因。</p>
<p>代码段一：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.string;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String str1 = <span class="string">"string"</span>;</div><div class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"string"</span>);</div><div class="line">        String str3 = str2.intern();</div><div class="line"> </div><div class="line">        System.out.println(str1==str2);<span class="comment">//#1</span></div><div class="line">        System.out.println(str1==str3);<span class="comment">//#2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段二：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> com.paddx.test.string;</div><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest01</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String baseStr = <span class="string">"baseStr"</span>;</div><div class="line">        <span class="keyword">final</span> String baseFinalStr = <span class="string">"baseStr"</span>;</div><div class="line"> </div><div class="line">        String str1 = <span class="string">"baseStr01"</span>;</div><div class="line">        String str2 = <span class="string">"baseStr"</span>+<span class="string">"01"</span>;</div><div class="line">        String str3 = baseStr + <span class="string">"01"</span>;</div><div class="line">        String str4 = baseFinalStr+<span class="string">"01"</span>;</div><div class="line">        String str5 = <span class="keyword">new</span> String(<span class="string">"baseStr01"</span>).intern();</div><div class="line"> </div><div class="line">        System.out.println(str1 == str2);<span class="comment">//#3</span></div><div class="line">        System.out.println(str1 == str3);<span class="comment">//#4</span></div><div class="line">        System.out.println(str1 == str4);<span class="comment">//#5</span></div><div class="line">        System.out.println(str1 == str5);<span class="comment">//#6</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段三（1）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.string;&lt;br&gt;　　</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</div><div class="line">        str2.intern();</div><div class="line">        String str1 = <span class="string">"str01"</span>;</div><div class="line">        System.out.println(str2==str1);<span class="comment">//#7</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段三（2）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> com.paddx.test.string;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternTest01</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String str1 = <span class="string">"str01"</span>;</div><div class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</div><div class="line">        str2.intern();</div><div class="line">        System.out.println(str2 == str1);<span class="comment">//#8</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了方便描述，我对上述代码的输出结果由#1~#8进行了编码，下文中蓝色字体部分即为结果。</p>
<h1 id="字符串深入分析"><a href="#字符串深入分析" class="headerlink" title="字符串深入分析"></a>字符串深入分析</h1><h2 id="代码段一分析"><a href="#代码段一分析" class="headerlink" title="代码段一分析"></a>代码段一分析</h2><p>字符串不属于基本类型，但是可以像基本类型一样，直接通过字面量赋值，当然也可以通过new来生成一个字符串对象。不过通过字面量赋值的方式和new的方式生成字符串有本质的区别：<br><a href="/images/java-string-intern-1.jpg"><img src="/images/java-string-intern-1.jpg" alt=""></a> </p>
<p>通过字面量赋值创建字符串时，会优先在常量池中查找是否已经存在相同的字符串，倘若已经存在，栈中的引用直接指向该字符串；倘若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。而通过new的方式创建字符串时，就直接在堆中生成一个字符串的对象（备注，JDK 7 以后，HotSpot 已将常量池从永久代转移到了堆中。详细信息可参考《<a href="/2016/07/26/java8-permgen-metaspace/">JDK8内存模型-消失的PermGen</a>》一文），栈中的引用指向该对象。对于堆中的字符串对象，可以通过 intern() 方法来将字符串添加的常量池中，并返回指向该常量的引用。<br>现在我们应该能很清楚代码段一的结果了：</p>
<font color="blue">结果 #1：因为str1指向的是字符串中的常量，str2是在堆中生成的对象，所以str1==str2返回false。<br>结果 #2：str2调用intern方法，会将str2中值（“string”）复制到常量池中，但是常量池中已经存在该字符串（即str1指向的字符串），所以直接返回该字符串的引用，因此str1==str2返回true。</font>

<p>以下运行代码段一的代码的结果：<br><a href="/images/java-string-intern-2.jpg"><img src="/images/java-string-intern-2.jpg" alt=""></a> </p>
<h2 id="代码段二分析"><a href="#代码段二分析" class="headerlink" title="代码段二分析"></a>代码段二分析</h2><p>对于代码段二的结果，还是通过反编译StringTest01.class文件比较容易理解：<br>常量池内容（部分）：<br><a href="/images/java-string-intern-3.jpg"><img src="/images/java-string-intern-3.jpg" alt=""></a><br>执行指令（部分，第二列#+序数对应常量池中的项）：<br><a href="/images/java-string-intern-4.jpg"><img src="/images/java-string-intern-4.jpg" alt=""></a><br>在解释上述执行过程之前，先了解两条指令：</p>
<p>ldc：Push item from run-time constant pool，从常量池中加载指定项的引用到栈。</p>
<p>astore_<n>：Store reference into local variable，将引用赋值给第n个局部变量。</n></p>
<p>现在我们开始解释代码段二的执行过程：</p>
<p>0: ldc           #2：加载常量池中的第二项（”baseStr”）到栈中。</p>
<p>2: astore_1      ：将1中的引用赋值给第一个局部变量，即String baseStr = “baseStr”；</p>
<p>3: ldc           #2：加载常量池中的第二项（”baseStr”）到栈中。</p>
<p>5: astore_2      ：将3中的引用赋值给第二个局部变量，即 final String baseFinalStr=”baseStr”； </p>
<p>6: ldc           #3：加载常量池中的第三项（”baseStr01”）到栈中。</p>
<p>8: astore_3     ：将6中的引用赋值给第三个局部变量，即String str1=”baseStr01”;</p>
<p>9: ldc           #3：加载常量池中的第三项（”baseStr01”）到栈中。</p>
<p>11: astore        4：将9中的引用赋值给第四个局部变量：即String str2=”baseStr01”；</p>
<font color="blue"><br>结果#3：str1==str2 肯定会返回true，因为str1和str2都指向常量池中的同一引用地址。所以其实在JAVA 1.6之后，常量字符串的“+”操作，编译阶段直接会合成为一个字符串。</font><br>13: new           #4：生成StringBuilder的实例。<br><br>16: dup 　　　　   ：复制13生成对象的引用并压入栈中。<br><br>17: invokespecial #5：调用常量池中的第五项，即StringBuilder.<init>方法。<br><br>以上三条指令的作用是生成一个StringBuilder的对象。<br><br>20: aload_1　　：加载第一个参数的值，即”baseStr”<br><br>21: invokevirtual #6 ：调用StringBuilder对象的append方法。<br><br>24: ldc           #7：加载常量池中的第七项（”01”）到栈中。<br><br>26: invokevirtual #6：调用StringBuilder.append方法。<br><br>29: invokevirtual #8：调用StringBuilder.toString方法。<br><br>32: astore        5：将29中的结果引用赋值改第五个局部变量，即对变量str3的赋值。<br><font color="blue"><br>结果 #4：因为str3实际上是stringBuilder.append()生成的结果，所以与str1不相等，结果返回false。</font><br>34: ldc           #3：加载常量池中的第三项（”baseStr01”）到栈中。<br><br>36: astore        6：将34中的引用赋值给第六个局部变量，即str4=”baseStr01”;<br><font color="blue"><br>结果 #5 ：因为str1和str4指向的都是常量池中的第三项，所以str1==str4返回true。这里我们还能发现一个现象，对于final字段，编译期直接进行了常量替换，而对于非final字段则是在运行期进行赋值处理的。</font><br>38: new           #9：创建String对象<br><br>41: dup               ：复制引用并压如栈中。<br><br>42: ldc           #3：加载常量池中的第三项（”baseStr01”）到栈中。<br><br>44: invokespecial #10：调用String.”<init>“方法，并传42步骤中的引用作为参数传入该方法。<br><br>47: invokevirtual #11：调用String.intern方法。<br><br>从38到41的对应的源码就是new String(“baseStr01”).intern()。<br><br>50: astore        7：将47步返回的结果赋值给变量7，即str5指向baseStr01在常量池中的位置。<br><font color="blue"><br>结果 #6 ：因为str5和str1都指向的都是常量池中的同一个字符串，所以str1==str5返回true。</font><br>运行代码段二，输出结果如下：<br><a href="/images/java-string-intern-5.jpg"><img src="/images/java-string-intern-5.jpg" alt=""></a><br><br>## 代码段三解析：<br>对于代码段三，在 JDK 1.6 和 JDK 1.7中的运行结果不同。我们先看一下运行结果，然后再来解释其原因：<br><br>JDK 1.6 下的运行结果：<br><a href="/images/java-string-intern-6.jpg"><img src="/images/java-string-intern-6.jpg" alt=""></a><br>JDK 1.7 下的运行结果：<br><a href="/images/java-string-intern-7.jpg"><img src="/images/java-string-intern-7.jpg" alt=""></a><br><br>根据对代码段一的分析，应该可以很简单得出 JDK 1.6 的结果，因为 str2 和 str1本来就是指向不同的位置，理应返回false。<br><br>比较奇怪的问题在于JDK 1.7后，对于第一种情况返回true，但是调换了一下位置返回的结果就变成了false。这个原因主要是从JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7 后的intern方法在实现上发生了比较大的改变，JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。所以:<br><font color="blue"><br>结果 #7：在第一种情况下，因为常量池中没有“str01”这个字符串，所以会在常量池中生成一个对堆中的“str01”的引用，而在进行字面量赋值的时候，常量池中已经存在，所以直接返回该引用即可，因此str1和str2都指向堆中的字符串，返回true。<br><br>结果 #8：调换位置以后，因为在进行字面量赋值（String str1 = “str01”）的时候，常量池中不存在，所以str1指向的常量池中的位置，而str2指向的是堆中的对象，再进行intern方法时，对str1和str2已经没有影响了，所以返回false。</font>

<h1 id="常见面试题解答"><a href="#常见面试题解答" class="headerlink" title="常见面试题解答"></a>常见面试题解答</h1><p>有了对以上的知识的了解，我们现在再来看常见的面试或笔试题就很简单了：</p>
<p>Q：String s = new String(“xyz”)，创建了几个String Object? </p>
<p>A：两个，常量池中的”xyz”和堆中对象。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s1 = “abc”;<br>String s2 = “abc”;<br>System.out.println(s1 == s2);</p>
<p>A：true，均指向常量池中对象。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s1 = new String(“abc”);<br>String s2 = new String(“abc”);<br>System.out.println(s1 == s2);</p>
<p>A：false，两个引用指向堆中的不同对象。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s1 = “abc”;<br>String s2 = “a”;<br>String s3 = “bc”;<br>String s4 = s2 + s3;<br>System.out.println(s1 == s4);</p>
<p>A：false，因为s2+s3实际上是使用StringBuilder.append来完成，会生成不同的对象。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s1 = “abc”;<br>final String s2 = “a”;<br>final String s3 = “bc”;<br>String s4 = s2 + s3;<br>System.out.println(s1 == s4);</p>
<p>A：true，因为final变量在编译后会直接替换成对应的值，所以实际上等于s4=”a”+”bc”，而这种情况下，编译器会直接合并为s4=”abc”，所以最终s1==s4。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s = new String(“abc”);<br>String s1 = “abc”;<br>String s2 = new String(“abc”);</p>
<p>System.out.println(s == s1.intern());<br>System.out.println(s == s2.intern());<br>System.out.println(s1 == s2.intern());</p>
<p>A：false，false，true，具体原因参考第二部分内容。</p>
<p>原文地址 <a href="http://www.cnblogs.com/paddix/p/5326863.html" target="_blank" rel="external">http://www.cnblogs.com/paddix/p/5326863.html</a></p>
</init></init>]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java8内存模型—永久代(PermGen)和元空间(Metaspace)]]></title>
      <url>/2016/07/26/java8-permgen-metaspace/</url>
      <content type="html"><![CDATA[<h1 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h1><p>根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。<br><a href="/images/java8-permgen-metaspace-1.png"><img src="/images/java8-permgen-metaspace-1.png" alt=""></a><br><a id="more"></a></p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误，不过这个深度范围不是一个恒定的值，我们通过下面这段程序可以测试一下这个结果：<br>栈溢出测试源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorMock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">1</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</div><div class="line">        index++;</div><div class="line">        call();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StackErrorMock mock = <span class="keyword">new</span> StackErrorMock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mock.call();</div><div class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</div><div class="line">            System.out.println(<span class="string">"Stack deep : "</span>+index);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段1</p>
<p>运行三次，可以看出每次栈的深度都是不一样的，输出结果如下。<br><a href="/images/java8-permgen-metaspace-2.png"><img src="/images/java8-permgen-metaspace-2.png" alt=""></a><br>至于红色框里的值是怎么出来的，就需要深入到 JVM 的源码中才能探讨，这里不作详细阐述。</p>
<p>虚拟机栈除了上述错误外，还有另一种错误，那就是当申请不到空间时，会抛出 OutOfMemoryError。这里有一个小细节需要注意，catch 捕获的是 Throwable，而不是 Exception。因为 StackOverflowError 和 OutOfMemoryError 都不属于 Exception 的子类。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>这部分主要与虚拟机用到的 Native 方法相关，一般情况下， Java 应用程序员并不需要关心这部分的内容</p>
<h2 id="PC-寄存器"><a href="#PC-寄存器" class="headerlink" title="PC 寄存器"></a>PC 寄存器</h2><p>PC 寄存器，也叫程序计数器。JVM支持多个线程同时运行，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native 方法，则PC寄存器中为空。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。下面我们简单的模拟一个堆内存溢出的情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOomMock</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">while</span> (flag)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                i++;</div><div class="line">                list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);<span class="comment">//每次增加一个1M大小的数组对象</span></div><div class="line">            &#125;<span class="keyword">catch</span> (Throwable e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">                System.out.println(<span class="string">"count="</span>+i);<span class="comment">//记录运行的次数</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段2</p>
<p>运行上述代码，输出结果如下：　<br><a href="/images/java8-permgen-metaspace-3.png"><img src="/images/java8-permgen-metaspace-3.png" alt=""></a><br><em>注意，这里我指定了堆内存的大小为16M，所以这个地方显示的count=14（这个数字不是固定的），至于为什么会是14或其他数字，需要根据 GC 日志来判断</em></p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>　　方法区也是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。 关于方法区内存溢出的问题会在下文中详细探讨。</p>
<h1 id="PermGen（永久代）"><a href="#PermGen（永久代）" class="headerlink" title="PermGen（永久代）"></a>PermGen（永久代）</h1><p>绝大部分 Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space “这个异常。这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。我们现在通过动态生成类来模拟 “PermGen space”的内存溢出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"><span class="keyword">import</span> java.net.URLClassLoader;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermGenOomMock</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        URL url = <span class="keyword">null</span>;</div><div class="line">        List&lt;ClassLoader&gt; classLoaderList = <span class="keyword">new</span> ArrayList&lt;ClassLoader&gt;();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            url = <span class="keyword">new</span> File(<span class="string">"/tmp"</span>).toURI().toURL();</div><div class="line">            URL[] urls = &#123;url&#125;;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">                ClassLoader loader = <span class="keyword">new</span> URLClassLoader(urls);</div><div class="line">                classLoaderList.add(loader);</div><div class="line">                loader.loadClass(<span class="string">"com.paddx.test.memory.Test"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码段3</p>
<p>运行结果如下：<br><a href="/images/java8-permgen-metaspace-4.png"><img src="/images/java8-permgen-metaspace-4.png" alt=""></a><br>　　本例中使用的 JDK 版本是 1.7，指定的 PermGen 区的大小为 8M。通过每次生成不同URLClassLoader对象来加载Test类，从而生成不同的类对象，这样就能看到我们熟悉的 “java.lang.OutOfMemoryError: PermGen space “ 异常了。这里之所以采用 JDK 1.7，是因为在 JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。下面我们就来看看 Metaspace 与 PermGen space 的区别。</p>
<h1 id="Metaspace（元空间）"><a href="#Metaspace（元空间）" class="headerlink" title="Metaspace（元空间）"></a>Metaspace（元空间）</h1><p>其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。我们可以通过一段程序来比较 JDK 1.6 与 JDK 1.7及 JDK 1.8 的区别，以字符串常量为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringOomMock</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> String  base = <span class="string">"string"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; Integer.MAX_VALUE;i++)&#123;</div><div class="line">            String str = base + base;</div><div class="line">            base = str;</div><div class="line">            list.add(str.intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段4</p>
<p>这段程序以2的指数级不断的生成新的字符串，这样可以比较快速的消耗内存。我们通过 JDK 1.6、JDK 1.7 和 JDK 1.8 分别运行：<br>JDK 1.6 的运行结果：<br><a href="/images/java8-permgen-metaspace-5.png"><img src="/images/java8-permgen-metaspace-5.png" alt=""></a><br>JDK 1.7的运行结果：<br><a href="/images/java8-permgen-metaspace-6.png"><img src="/images/java8-permgen-metaspace-6.png" alt=""></a><br>JDK 1.8的运行结果：<br><a href="/images/java8-permgen-metaspace-7.png"><img src="/images/java8-permgen-metaspace-7.png" alt=""></a><br>从上述结果可以看出，JDK 1.6下，会出现“PermGen Space”的内存溢出，而在 JDK 1.7和 JDK 1.8 中，会出现堆内存溢出，并且 JDK 1.8中 PermSize 和 MaxPermGen 已经无效。因此，可以大致验证 JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论。现在我们看看元空间到底是一个什么东西？</p>
<p>　　元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<p>　　-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。<br>　　-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p>
<p>　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：<br>　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集<br>　　-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p>
<p>现在我们在 JDK 8下重新运行一下代码段3，不过这次不再指定 PermSize 和 MaxPermSize。而是指定 MetaSpaceSize 和 MaxMetaSpaceSize的大小。输出结果如下：<br><a href="/images/java8-permgen-metaspace-8.png"><img src="/images/java8-permgen-metaspace-8.png" alt=""></a><br>从输出结果，我们可以看出，这次不再出现永久代溢出，而是出现了元空间的溢出。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　通过上面分析，大家应该大致了解了 JVM 的内存划分，也清楚了 JDK 8 中永久代向元空间的转换。不过大家应该都有一个疑问，就是为什么要做这个转换？所以，最后给大家总结以下几点原因：</p>
<ul>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
<li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li>
</ul>
<p>原文地址 <a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="external">http://www.cnblogs.com/paddix/p/5309550.html</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从字节码层面看“HelloWorld”]]></title>
      <url>/2016/07/23/bytecode-hello-world/</url>
      <content type="html"><![CDATA[<h1 id="HelloWorld-字节码生成"><a href="#HelloWorld-字节码生成" class="headerlink" title="HelloWorld 字节码生成"></a>HelloWorld 字节码生成</h1><p>众所周知，Java 程序是在 JVM 上运行的，不过 JVM 运行的其实不是 Java 语言本身，而是 Java 程序编译成的字节码文件。可能一开始 JVM 是为 Java 语言服务的，不过随着编译技术和 JVM 自身的不断发展和成熟，JVM 已经不仅仅只运行 Java 程序。任何能编译成为符合 JVM 字节码规范的语言都可以在 JVM 上运行，比较常见的 Scala、Groove、JRuby等。今天，我就从大家最熟悉的程序“HelloWorld”程序入手，分析整个 Class 文件的结构。虽然这个程序比较简单，但是基本上包含了字节码规范中的所有内容，因此即使以后要分析更复杂的程序，那也只是“量”上的变化，本质上没有区别。<br><a id="more"></a><br>　　我们先直观的看下源码与字节码之间的对应关系:<br>HelloWorld的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.asm;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello,World!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器采用JDK 1.7：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>编译以后的字节码文件（使用UltraEdit的16进制模式打开）：<br><a href="/images/bytecode-hello-world-1.jpg"><img src="/images/bytecode-hello-world-1.jpg" alt=""></a><br>红色框内的部分就是HelloWorld.class的内容，其他部分是UltraEdit自动生成的：红色框顶部的0~f代表列号，左边部分代表行号，右侧部分是二进制码对应的字符（utf-8编码）。</p>
<h1 id="字节码解析"><a href="#字节码解析" class="headerlink" title="字节码解析"></a>字节码解析</h1><p>要弄明白 HelloWorld.java 和 HelloWorld.class 文件是如何对应的，我们必须对 JVM 的字节码规范有所了解。字节码文件的结构非常紧凑，没有任何冗余的信息，连分隔符都没有，它采用的是固定的文件结构和数据类型来实现对内容的分割的。字节码中包括两种数据类型：无符号数和表。无符号数又包括 u1，u2，u4，u8四种，分别代表1个字节、2个字节、4个字节和8个字节。而表结构则是由无符号数据组成的。</p>
<p>字节码文件的格式固定如下：</p>
<table>
<thead>
<tr>
<th>type</th>
<th>descriptor</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool[cosntant_pool_count – 1]</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count]</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
</tr>
<tr>
<td>field_info</td>
<td>fields[fields_count]</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
</tr>
<tr>
<td>method_info</td>
<td>methods[methods_count]</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes[attributes_count]</td>
</tr>
</tbody>
</table>
<p>现在，我们就按这个格式对上述HelloWorld.class文件进行分析：</p>
<p>magic（u4）：CA FE BA BE ，代表该文件是一个字节码文件，我们平时区分文件类型都是通过后缀名来区分的，不过后缀名是可以随便修改的，所以仅靠后缀名不能真正区分一个文件的类型。区分文件类型的另个办法就是magic数字，JVM 就是通过 CA FE BA BE 来判断该文件是不是class文件。</p>
<p>minor_version（u2）：00 00，小版本号，因为我这里采用的1.7，所以小版本号为0.</p>
<p>major_version（u2）：00 33，大版本号，x033转换为十进制为51，下表是jdk 1.6 以后对应支持的 Class 文件版本号：</p>
<table>
<thead>
<tr>
<th>编译器版本</th>
<th>-target参数</th>
<th>十六进制版本</th>
<th>十进制版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK 1.6.0_01</td>
<td>不带（默认 -target 1.6）</td>
<td>00 00 00 32</td>
<td>50.0</td>
</tr>
<tr>
<td>JDK 1.6.0_01</td>
<td>-target 1.5</td>
<td>00 00 00 31</td>
<td>49.0</td>
</tr>
<tr>
<td>JDK 1.6.0_01</td>
<td>-target 1.4 -source 1.4</td>
<td>00 00 00 30</td>
<td>48.0</td>
</tr>
<tr>
<td>JDK 1.7.0</td>
<td>不带（默认 -target 1.7）</td>
<td>00 00 00 33</td>
<td>51.0</td>
</tr>
<tr>
<td>JDK 1.7.0</td>
<td>-target 1.6</td>
<td>00 00 00 32</td>
<td>50.0</td>
</tr>
<tr>
<td>JDK 1.7.0</td>
<td>-target 1.4 -source 1.4</td>
<td>00 00 00 30</td>
<td>48.0</td>
</tr>
<tr>
<td>JDK 1.8.0</td>
<td>不带（默认 -target 1.8）</td>
<td>00 00 00 34</td>
<td>52.0</td>
</tr>
</tbody>
</table>
<p>constant_pool_count（u2）：00 22，常量池数量，转换为十进制后为34，这里需要注意的是，字节码的常量池是从1开始计数的，所以34表示为（34-1）=33项。</p>
<p>TAG（u1）：0A，常量池的数据类型是表，每一项的开始都有一个tag（u1），表示常量的类型，常量池的表的类型包括如下14种，这里A（10）表示CONSTANT_Methodref，代表方法引用。</p>
<table>
<thead>
<tr>
<th>常量类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Utf8_info</td>
<td>1</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
</tr>
</tbody>
</table>
<p>每种常量类型对应表结构：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th style="text-align:right">项目</th>
<th style="text-align:right">类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Utf8_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">length</td>
<td style="text-align:right">u2</td>
<td>字节数</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">bytes</td>
<td style="text-align:right">u1</td>
<td>utf-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>3</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">bytes</td>
<td style="text-align:right">u4</td>
<td>int值</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u4</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">bytes</td>
<td style="text-align:right">u1</td>
<td>float值</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>5</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">bytes</td>
<td style="text-align:right">u8</td>
<td>long值</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">bytes</td>
<td style="text-align:right">u8</td>
<td>double值</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>7</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向全限定名常量项的索引</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向字符串常量的索引</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>9</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向声明字段的类或接口描述符CONSTANT_Class_info的索引值</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向CONSTANT_NameAndType_info的索引值</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>10</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向声明方法的类描述符CONSTANT_Class_info的索引值</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向CONSTANT_NameAndType_info的索引值</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>11</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向声明方法的接口描述符CONSTANT_Class_info的索引值</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向CONSTANT_NameAndType_info的索引值</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>12</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向该字段或方法名称常量的索引值</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">index</td>
<td style="text-align:right">u2</td>
<td>指向该字段或方法描述符常量的索引值</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>15</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">reference_kind</td>
<td style="text-align:right">u1</td>
<td>值必须1~9，它决定了方法句柄的的类型</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">reference_index</td>
<td style="text-align:right">u2</td>
<td>对常量池的索引</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>16</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">description_index</td>
<td style="text-align:right">u2</td>
<td>对常量池中方法描述符的索引</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td style="text-align:right">tag</td>
<td style="text-align:right">u1</td>
<td>18</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">bootstap_method_attr_index</td>
<td style="text-align:right">u2</td>
<td>对引导方法表的索引</td>
</tr>
<tr>
<td></td>
<td style="text-align:right">name_and_type_index</td>
<td style="text-align:right">u2</td>
<td>对CONSTANT_NameAndType_info的索引</td>
</tr>
</tbody>
</table>
<p>CONSTANT_Methodref_info（u2):00 06，因为tag为A，代表一个方法引用表（CONSTANT_Methodref_info），所以第二项（u2）应该是指向常量池的位置，即常量池的第六项，表示一个CONSTANT_Class_info表的索引，用类似的方法往下分析，可以发现常量池的第六项如下，tag类型为07，查询上表可知道其即为CONSTANT_Class_info。<br><a href="/images/bytecode-hello-world-2.jpg"><img src="/images/bytecode-hello-world-2.jpg" alt=""></a><br> 07之后的00 1B表示对常量池地27项（CONSTANT_Utf8_info）的引用，查看第27项如下图，即（java/lang/Object）：<br> <a href="/images/bytecode-hello-world-3.jpg"><img src="/images/bytecode-hello-world-3.jpg" alt=""></a><br> CONSTANT_NameAndType_info（u2）：00 14,方法引用表的第三项（u2），常量池索引，指向第20项。</p>
<p>CONSTANT_Fieldref_info（u1）：tag为09。</p>
<p>…..</p>
<p>常量池的分析都类似，其他的分析由于篇幅问题就不在此一一讲述了。跳过常量池就到了访问标识（u2）：<br> <a href="/images/bytecode-hello-world-4.jpg"><img src="/images/bytecode-hello-world-4.jpg" alt=""></a><br>  JVM 对访问标示符的规范如下：</p>
<table>
<thead>
<tr>
<th>Flag Name</th>
<th>Value</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>pubilc</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>final</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>用于兼容早期编译器，新编译器都设置该标记，以在使用 invokespecial指令时对子类方法做特定处理。</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>接口，同时需要设置：ACC_ABSTRACT。不可同时设置：ACC_FINAL、ACC_SUPER、ACC_ENUM</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>抽象类，无法实例化。不可与ACC_FINAL同时设置。</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>synthetic，由编译器产生，不存在于源代码中。</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>注解类型（annotation），需同时设置：ACC_INTERFACE、ACC_ABSTRACT</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>枚举类型</td>
</tr>
</tbody>
</table>
<p> 这个表里面无法直接查询到0021这个值，原因是0021=0020+0001，即public+invokespecial指令，源码中的方法main是public的，而invokespecial是现在的版本都有的，所以值为0021。</p>
<p>接着往下是this_class（u2）：是指向constant pool的索引值，该值必须是CONSTANT_Class_info类型，值为00 05，即指向常量池中的第五项，第五项指向常量池中的第26项，即com/paddx/test/asm/HelloWorld：<br> <a href="/images/bytecode-hello-world-5.jpg"><img src="/images/bytecode-hello-world-5.jpg" alt=""></a></p>
<p>super_class(u2)）：super_class是指向constant pool的索引值，该值必须是CONSTANT_Class_info类型，指定当前字节码定义的类或接口的直接父类。这里的取值为00 06，根据上面的分析，对应的指向的全限定性类名为java/lang/object，即当前类的父类为Object类。</p>
<p>interfaces_count（u2）：接口的数量，因为这里没有实现接口，所以值为 00 00。</p>
<p>interfaces[interfaces_count]：因为没有接口，所以就不存在interfces选项。</p>
<p>field_count：属性数量，00 00。</p>
<p>field_info：因为没有属性，所以不存在这个选项。</p>
<p>method_count：00 02，为什么会有两个方法呢？我们明明只写了一个方法，这是因为JVM 会自动生成一个 <init>的方法。</init></p>
<p>method_info：方法表，其结构如下：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Descriptor</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>access_flag</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attribute_info[attributes_count]</td>
</tr>
</tbody>
</table>
<p>HelloWorld.class文件中对应的数据：<br> <a href="/images/bytecode-hello-world-6.jpg"><img src="/images/bytecode-hello-world-6.jpg" alt=""></a></p>
<p> access_flag（u2）: 00 01</p>
<p>name_index（u2）:00 07</p>
<p>descriptor_index（u2）:00 08</p>
<p>可以看看 07、08对应的常量池里面的值：<br> <a href="/images/bytecode-hello-world-7.jpg"><img src="/images/bytecode-hello-world-7.jpg" alt=""></a></p>
<p>即 07 对应的是 &#60;init&#62;，08 对应的是()；</p>
<p>attributes_count:00 01，表示包含一个属性</p>
<p>attribute_info：属性表，该表的结构如下：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Descriptor</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
</tr>
</tbody>
</table>
<p> <a href="/images/bytecode-hello-world-8.jpg"><img src="/images/bytecode-hello-world-8.jpg" alt=""></a></p>
<p>attribute_name_index（u2）: 00 09，指向常量池中的索引。</p>
<p>attribute_length（u4）：00 00 00 2F，属性的长度47。</p>
<p>attribute_info:具体属性的分析与上面类似，大家可以对着JVM的规范自己尝试分析一下。</p>
<p>第一个方法结束后，接着进入第二个方法：<br> <a href="/images/bytecode-hello-world-9.jpg"><img src="/images/bytecode-hello-world-9.jpg" alt=""></a><br> 第二个方法的属性长度为x037，转换为十进制为55个字节。两个方法之后紧跟着的是attribute_count和attributes：<br>  <a href="/images/bytecode-hello-world-10.jpg"><img src="/images/bytecode-hello-world-10.jpg" alt=""></a><br>attribute_count（u2）:值为 00 01，即有一个属性。</p>
<p>attribute_name_index（u2）：指向常量池中的第十二项。</p>
<p>attribute_length（u4）：00 00 00 02，长度为2。</p>
<p>分析完毕！</p>
<h1 id="基于字节码的操作"><a href="#基于字节码的操作" class="headerlink" title="基于字节码的操作"></a>基于字节码的操作</h1><p>　　通过对HelloWorld这个程序的字节码分析，我们应该能够比较清楚的认识到整个字节码的结构。那我们通过字节码，可以做些什么呢？其实通过字节码能做很多平时我们无法完成的工作。比如，在类加载之前添加某些操作或者直接动态的生成字节码，CGlib就是通过这种方式来实现动态代理的。现在，我们就来完成另一个版本的HelloWorld：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.asm;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们有个空的方法 sayHello()，现在要实现调该方法的时候打印出“HelloWorld”，怎么处理？如果我们手动去修改字节码文件，将打印“HelloWorld”的代码插入到sayHello方法中，原理上肯定没问题，不过操作过程还是比较复杂的。Java 的最大优势就在于只要你能想到的功能，基本上就有第三方开源的库实现过。字节码操作的开源库也比较多，这里我就用 ASM 4.0来实现该功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.asm;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> org.objectweb.asm.*;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsmDemo</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, IllegalAccessException, InstantiationException, InvocationTargetException </span>&#123;</div><div class="line">        ClassReader classReader = <span class="keyword">new</span> ClassReader(<span class="string">"com.paddx.test.asm.HelloWorld2"</span>);</div><div class="line">        ClassWriter cw=<span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);</div><div class="line">        CustomVisitor myv=<span class="keyword">new</span> CustomVisitor(Opcodes.ASM4,cw);</div><div class="line">        classReader.accept(myv, <span class="number">0</span>);</div><div class="line"> </div><div class="line">        <span class="keyword">byte</span>[] code=cw.toByteArray();</div><div class="line"> </div><div class="line">        AsmDemo loader=<span class="keyword">new</span> AsmDemo();</div><div class="line">        Class&lt;?&gt; appClass=loader.defineClass(<span class="keyword">null</span>, code, <span class="number">0</span>,code.length);</div><div class="line">        appClass.getMethods()[<span class="number">0</span>].invoke(appClass.newInstance(), <span class="keyword">new</span> Object[]&#123;&#125;);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> <span class="keyword">implements</span> <span class="title">Opcodes</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomVisitor</span><span class="params">(<span class="keyword">int</span> api, ClassVisitor cv)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(api, cv);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</div><div class="line">        MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</div><div class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"sayHello"</span>)) &#123;</div><div class="line">            mv.visitFieldInsn(GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</div><div class="line">            mv.visitLdcInsn(<span class="string">"HelloWorld!"</span>);</div><div class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mv;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如下：<br>  <a href="/images/bytecode-hello-world-11.jpg"><img src="/images/bytecode-hello-world-11.jpg" alt=""></a></p>
<p>关于 ASM 4的操作在这就不细说了。有兴趣的朋友可以自己去研究一下，有机会，我也可以再后续的博文中跟大家分享。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　本文通过HelloWorld这样一个大家都非常熟悉的例子，深入的分析了字节码文件的结构。利用这些特性，我们可以完成一些相对高级的功能，如动态代理等。这些例子虽然都很简单，但是“麻雀虽小五脏俱全”，即使再复杂的程序也逃离不了这些最基本的东西。技术层面的东西就是这样子，只要你能了解一个简单的程序的原理，举一反三，就能很容易的理解更复杂的程序，这就是技术“易”的方面。同时，反过来说，即使“HelloWorld”这样一个简单的程序，如果我们深入探究，也不一定能特别理解其原理，这就是技术“难”的方面。总之，技术这种东西只要你用心深入地去研究，总是能带给你意想不到的惊喜~</p>
<p>原文地址 <a href="http://www.cnblogs.com/paddix/p/5282004.html" target="_blank" rel="external">http://www.cnblogs.com/paddix/p/5282004.html</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis cluster管理工具redis-trib.rb详解]]></title>
      <url>/2016/04/22/redis-trib/</url>
      <content type="html"><![CDATA[<blockquote>
<p>redis-trib.rb是redis官方推出的管理redis集群的工具，集成在redis的源码src目录下，是基于redis提供的集群命令封装成简单、便捷、实用的操作工具。redis-trib.rb是redis作者用ruby完成的。为了看懂redis-trib.rb，我特意花了一个星期学习了ruby，也被ruby的简洁、明了所吸引。ruby是门非常灵活的语言，redis-trib.rb只用了1600行左右的代码，就实现了强大的集群操作。本文对redis-trib.rb的介绍是基于redis 3.0.6版本的源码。阅读本文需要对redis集群功能有一定的了解。关于redis集群功能的介绍，可以参考本人的另一篇文章《redis3.0 cluster功能介绍》。</p>
</blockquote>
<a id="more"></a>
<h1 id="help-信息"><a href="#help-信息" class="headerlink" title="help 信息"></a>help 信息</h1><p>先从redis-trib.rb的help信息，看下redis-trib.rb提供了哪些功能。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb <span class="built_in">help</span></div><div class="line">Usage: redis-trib &lt;<span class="built_in">command</span>&gt; &lt;options&gt; &lt;arguments ...&gt;</div><div class="line"></div><div class="line">  create          host1:port1 ... hostN:portN</div><div class="line">                  --replicas &lt;arg&gt;</div><div class="line">  check           host:port</div><div class="line">  info            host:port</div><div class="line">  fix             host:port</div><div class="line">                  --timeout &lt;arg&gt;</div><div class="line">  reshard         host:port</div><div class="line">                  --from &lt;arg&gt;</div><div class="line">                  --to &lt;arg&gt;</div><div class="line">                  --slots &lt;arg&gt;</div><div class="line">                  --yes</div><div class="line">                  --timeout &lt;arg&gt;</div><div class="line">                  --pipeline &lt;arg&gt;</div><div class="line">  rebalance       host:port</div><div class="line">                  --weight &lt;arg&gt;</div><div class="line">                  --auto-weights</div><div class="line">                  --threshold &lt;arg&gt;</div><div class="line">                  --use-empty-masters</div><div class="line">                  --timeout &lt;arg&gt;</div><div class="line">                  --simulate</div><div class="line">                  --pipeline &lt;arg&gt;</div><div class="line">  add-node        new_host:new_port existing_host:existing_port</div><div class="line">                  --slave</div><div class="line">                  --master-id &lt;arg&gt;</div><div class="line">  del-node        host:port node_id</div><div class="line">  <span class="built_in">set</span>-timeout     host:port milliseconds</div><div class="line">  call            host:port <span class="built_in">command</span> arg arg .. arg</div><div class="line">  import          host:port</div><div class="line">                  --from &lt;arg&gt;</div><div class="line">                  --copy</div><div class="line">                  --replace</div><div class="line">  <span class="built_in">help</span>            (show this <span class="built_in">help</span>)</div><div class="line"></div><div class="line">For check, fix, reshard, del-node, <span class="built_in">set</span>-timeout you can specify the host and port of any working node <span class="keyword">in</span> the cluster.</div></pre></td></tr></table></figure></p>
<p>可以看到redis-trib.rb具有以下功能：<br>1、create：创建集群<br>2、check：检查集群<br>3、info：查看集群信息<br>4、fix：修复集群<br>5、reshard：在线迁移slot<br>6、rebalance：平衡集群节点slot数量<br>7、add-node：将新节点加入集群<br>8、del-node：从集群中删除节点<br>9、set-timeout：设置集群节点间心跳连接的超时时间<br>10、call：在集群全部节点上执行命令<br>11、import：将外部redis数据导入集群<br>下面从redis-trib.rb使用和源码的角度详细介绍redis-trib.rb的每个功能。</p>
<p>redis-trib.rb主要有两个类：ClusterNode和RedisTrib。ClusterNode保存了每个节点的信息，RedisTrib则是redis-trib.rb各个功能的实现。</p>
<h1 id="ClusterNode对象"><a href="#ClusterNode对象" class="headerlink" title="ClusterNode对象"></a>ClusterNode对象</h1><p>先分析ClusterNode源码。ClusterNode有下面几个成员变量（ruby的类成员变量是以@开头的）：<br>@r：执行redis命令的客户端对象。<br>@info：保存了该节点的详细信息，包括cluster nodes命令中自己这行的信息和cluster info的信息。<br>@dirty：节点信息是否需要更新，如果为true，我们需要把内存的节点更新信息到节点上。<br>@friends：保存了集群其他节点的info信息。其信息为通过cluster nodes命令获得的其他节点信息。<br>ClusterNode有下面一些成员方法：<br>initialize：ClusterNode的构造方法，需要传入节点的地址信息。<br>friends：返回@friends对象。<br>slots：返回该节点负责的slots信息。<br>has_flag?：判断节点info信息的的flags中是否有给定的flag。<br>to_s：类似java的toString方法，返回节点的地址信息。<br>connect：连接redis节点。<br>assert_cluster：判断节点开启了集群配置。<br>assert_empty：确定节点目前没有跟任何其他节点握手，同时自己的db数据为空。<br>load_info：通过cluster info和cluster nodes导入节点信息。<br>add_slots：给节点增加slot，该操作只是在内存中修改，并把dirty设置成true，等待flush_node_config将内存中的数据同步在节点执行。<br>set_as_replica：slave设置复制的master地址。dirty设置成true。<br>flush_node_config：将内存的数据修改同步在集群节点中执行。<br>info_string：简单的info信息。<br>get_config_signature：用来验证集群节点见的cluster nodes信息是否一致。该方法返回节点的签名信息。<br>info：返回@info对象，包含详细的info信息。<br>is_dirty?：判断@dirty。<br>r：返回执行redis命令的客户端对象。</p>
<p>有了ClusterNode对象，在处理集群操作的时候，就获得了集群的信息，可以进行集群相关操作。在此先简单介绍下redis-trib.rb脚本的使用，以create为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create host1:port1 ... hostN:portN</div><div class="line">       --replicas &lt;arg&gt;</div></pre></td></tr></table></figure></p>
<p>host1:port1 … hostN:portN表示子参数，这个必须在可选参数之后，–replicas <arg>是可选参数，带的表示后面必须填写一个参数，像–slave这样，后面就不带参数，掌握了这个基本规则，就能从help命令中获得redis-trib.rb的使用方法。</arg></p>
<p>其他命令大都需要传递host:port，这是redis-trib.rb为了连接集群，需要选择集群中的一个节点，然后通过该节点获得整个集群的信息。</p>
<p>下面就一一详细介绍redis-trib.rb的每个功能。</p>
<h1 id="create创建集群"><a href="#create创建集群" class="headerlink" title="create创建集群"></a>create创建集群</h1><p>create命令可选replicas参数，replicas表示需要有几个slave。最简单命令使用如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb create 10.180.157.199:6379 10.180.157.200:6379 10.180.157.201:6379</div></pre></td></tr></table></figure></p>
<p>有一个slave的创建命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb create --replicas 1 10.180.157.199:6379 10.180.157.200:6379 10.180.157.201:6379 10.180.157.202:6379  10.180.157.205:6379  10.180.157.208:6379</div></pre></td></tr></table></figure></p>
<p>创建流程如下：<br>1、首先为每个节点创建ClusterNode对象，包括连接每个节点。检查每个节点是否为独立且db为空的节点。执行load_info方法导入节点信息。<br>2、检查传入的master节点数量是否大于等于3个。只有大于3个节点才能组成集群。<br>3、计算每个master需要分配的slot数量，以及给master分配slave。分配的算法大致如下：<br>先把节点按照host分类，这样保证master节点能分配到更多的主机中。<br>不停遍历遍历host列表，从每个host列表中弹出一个节点，放入interleaved数组。直到所有的节点都弹出为止。<br>master节点列表就是interleaved前面的master数量的节点列表。保存在masters数组。<br>计算每个master节点负责的slot数量，保存在slots_per_node对象，用slot总数除以master数量取整即可。<br>遍历masters数组，每个master分配slots_per_node个slot，最后一个master，分配到16384个slot为止。<br>接下来为master分配slave，分配算法会尽量保证master和slave节点不在同一台主机上。对于分配完指定slave数量的节点，还有多余的节点，也会为这些节点寻找master。分配算法会遍历两次masters数组。<br>第一次遍历masters数组，在余下的节点列表找到replicas数量个slave。每个slave为第一个和master节点host不一样的节点，如果没有不一样的节点，则直接取出余下列表的第一个节点。<br>第二次遍历是在对于节点数除以replicas不为整数，则会多余一部分节点。遍历的方式跟第一次一样，只是第一次会一次性给master分配replicas数量个slave，而第二次遍历只分配一个，直到余下的节点被全部分配出去。<br>4、打印出分配信息，并提示用户输入“yes”确认是否按照打印出来的分配方式创建集群。<br>5、输入“yes”后，会执行flush_nodes_config操作，该操作执行前面的分配结果，给master分配slot，让slave复制master，对于还没有握手（cluster meet）的节点，slave复制操作无法完成，不过没关系，flush_nodes_config操作出现异常会很快返回，后续握手后会再次执行flush_nodes_config。<br>6、给每个节点分配epoch，遍历节点，每个节点分配的epoch比之前节点大1。<br>7、节点间开始相互握手，握手的方式为节点列表的其他节点跟第一个节点握手。<br>8、然后每隔1秒检查一次各个节点是否已经消息同步完成，使用ClusterNode的get_config_signature方法，检查的算法为获取每个节点cluster nodes信息，排序每个节点，组装成node_id1:slots|node_id2:slot2|…的字符串。如果每个节点获得字符串都相同，即认为握手成功。<br>9、此后会再执行一次flush_nodes_config，这次主要是为了完成slave复制操作。<br>10、最后再执行check_cluster，全面检查一次集群状态。包括和前面握手时检查一样的方式再检查一遍。确认没有迁移的节点。确认所有的slot都被分配出去了。<br>11、至此完成了整个创建流程，返回[OK] All 16384 slots covered.。</p>
<h1 id="check检查集群"><a href="#check检查集群" class="headerlink" title="check检查集群"></a>check检查集群</h1><p>检查集群状态的命令，没有其他参数，只需要选择一个集群中的一个节点即可。执行命令以及结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb check 10.180.157.199:6379</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 10.180.157.199:6379)</div><div class="line">M: b2506515b38e6bbd3034d540599f4cd2a5279ad1 10.180.157.199:6379</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: d376aaf80de0e01dde1f8cd4647d5ac3317a8641 10.180.157.205:6379</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates e36c46dbe90960f30861af00786d4c2064e63df2</div><div class="line">M: 15126fb33796c2c26ea89e553418946f7443d5a5 10.180.157.201:6379</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: 59fa6ee455f58a5076f6d6f83ddd74161fd7fb55 10.180.157.208:6379</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 15126fb33796c2c26ea89e553418946f7443d5a5</div><div class="line">S: 460b3a11e296aafb2615043291b7dd98274bb351 10.180.157.202:6379</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates b2506515b38e6bbd3034d540599f4cd2a5279ad1</div><div class="line">M: e36c46dbe90960f30861af00786d4c2064e63df2 10.180.157.200:6379</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div></pre></td></tr></table></figure></p>
<p>检查前会先执行load_cluster_info_from_node方法，把所有节点数据load进来。load的方式为通过自己的cluster nodes发现其他节点，然后连接每个节点，并加入nodes数组。接着生成节点间的复制关系。</p>
<p>load完数据后，开始检查数据，检查的方式也是调用创建时候使用的check_cluster。</p>
<h1 id="info查看集群信息"><a href="#info查看集群信息" class="headerlink" title="info查看集群信息"></a>info查看集群信息</h1><p>info命令用来查看集群的信息。info命令也是先执行load_cluster_info_from_node获取完整的集群信息。然后显示ClusterNode的info_string结果，示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb info 10.180.157.199:6379</div><div class="line">10.180.157.199:6379 (b2506515...) -&gt; 0 keys | 5461 slots | 1 slaves.</div><div class="line">10.180.157.201:6379 (15126fb3...) -&gt; 0 keys | 5461 slots | 1 slaves.</div><div class="line">10.180.157.200:6379 (e36c46db...) -&gt; 0 keys | 5462 slots | 1 slaves.</div><div class="line">[OK] 0 keys <span class="keyword">in</span> 3 masters.</div><div class="line">0.00 keys per slot on average.</div></pre></td></tr></table></figure></p>
<h1 id="fix修复集群"><a href="#fix修复集群" class="headerlink" title="fix修复集群"></a>fix修复集群</h1><p>fix命令的流程跟check的流程很像，显示加载集群信息，然后在check_cluster方法内传入fix为<br>true的变量，会在集群检查出现异常的时候执行修复流程。目前fix命令能修复两种异常，一种是集群有处于迁移中的slot的节点，一种是slot未完全分配的异常。</p>
<p>fix_open_slot方法是修复集群有处于迁移中的slot的节点异常。<br>1、先检查该slot是谁负责的，迁移的源节点如果没完成迁移，owner还是该节点。没有owner的slot无法完成修复功能。<br>2、遍历每个节点，获取哪些节点标记该slot为migrating状态，哪些节点标记该slot为importing状态。对于owner不是该节点，但是通过cluster countkeysinslot获取到该节点有数据的情况，也认为该节点为importing状态。<br>3、如果migrating和importing状态的节点均只有1个，这可能是迁移过程中redis-trib.rb被中断所致，直接执行move_slot继续完成迁移任务即可。传递dots和fix为true。<br>4、如果migrating为空，importing状态的节点大于0，那么这种情况执行回滚流程，将importing状态的节点数据通过move_slot方法导给slot的owner节点，传递dots、fix和cold为true。接着对importing的节点执行cluster stable命令恢复稳定。<br>5、如果importing状态的节点为空，有一个migrating状态的节点，而且该节点在当前slot没有数据，那么可以直接把这个slot设为stable。<br>6、如果migrating和importing状态不是上述情况，目前redis-trib.rb工具无法修复，上述的三种情况也已经覆盖了通过redis-trib.rb工具迁移出现异常的各个方面，人为的异常情形太多，很难考虑完全。</p>
<p>fix_slots_coverage方法能修复slot未完全分配的异常。未分配的slot有三种状态。<br>1、所有节点的该slot都没有数据。该状态redis-trib.rb工具直接采用随机分配的方式，并没有考虑节点的均衡。本人尝试对没有分配slot的集群通过fix修复集群，结果slot还是能比较平均的分配，但是没有了连续性，打印的slot信息非常离散。<br>2、有一个节点的该slot有数据。该状态下，直接把slot分配给该slot有数据的节点。<br>3、有多个节点的该slot有数据。此种情况目前还处于TODO状态，不过redis作者列出了修复的步骤，对这些节点，除第一个节点，执行cluster migrating命令，然后把这些节点的数据迁移到第一个节点上。清除migrating状态，然后把slot分配给第一个节点。</p>
<h1 id="reshard在线迁移slot"><a href="#reshard在线迁移slot" class="headerlink" title="reshard在线迁移slot"></a>reshard在线迁移slot</h1><p>reshard命令可以在线把集群的一些slot从集群原来slot负责节点迁移到新的节点，利用reshard可以完成集群的在线横向扩容和缩容。<br>reshard的参数很多，下面来一一解释一番：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">reshard         host:port</div><div class="line">                --from &lt;arg&gt;</div><div class="line">                --to &lt;arg&gt;</div><div class="line">                --slots &lt;arg&gt;</div><div class="line">                --yes</div><div class="line">                --timeout &lt;arg&gt;</div><div class="line">                --pipeline &lt;arg&gt;</div></pre></td></tr></table></figure></p>
<p>host:port：这个是必传参数，用来从一个节点获取整个集群信息，相当于获取集群信息的入口。<br>–from <arg>：需要从哪些源节点上迁移slot，可从多个源节点完成迁移，以逗号隔开，传递的是节点的node id，还可以直接传递–from all，这样源节点就是集群的所有节点，不传递该参数的话，则会在迁移过程中提示用户输入。<br>–to <arg>：slot需要迁移的目的节点的node id，目的节点只能填写一个，不传递该参数的话，则会在迁移过程中提示用户输入。<br>–slots <arg>：需要迁移的slot数量，不传递该参数的话，则会在迁移过程中提示用户输入。<br>–yes：设置该参数，可以在打印执行reshard计划的时候，提示用户输入yes确认后再执行reshard。<br>–timeout <arg>：设置migrate命令的超时时间。<br>–pipeline <arg>：定义cluster getkeysinslot命令一次取出的key数量，不传的话使用默认值为10。</arg></arg></arg></arg></arg></p>
<p>迁移的流程如下：<br>1、通过load_cluster_info_from_node方法装载集群信息。<br>2、执行check_cluster方法检查集群是否健康。只有健康的集群才能进行迁移。<br>3、获取需要迁移的slot数量，用户没传递–slots参数，则提示用户手动输入。<br>4、获取迁移的目的节点，用户没传递–to参数，则提示用户手动输入。此处会检查目的节点必须为master节点。<br>5、获取迁移的源节点，用户没传递–from参数，则提示用户手动输入。此处会检查源节点必须为master节点。–from all的话，源节点就是除了目的节点外的全部master节点。这里为了保证集群slot分配的平均，建议传递–from all。<br>6、执行compute_reshard_table方法，计算需要迁移的slot数量如何分配到源节点列表，采用的算法是按照节点负责slot数量由多到少排序，计算每个节点需要迁移的slot的方法为：迁移slot数量 * (该源节点负责的slot数量 / 源节点列表负责的slot总数)。这样算出的数量可能不为整数，这里代码用了下面的方式处理：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">n = (numslots/source_tot_slots*s.slots.length)</div><div class="line"><span class="keyword">if</span> i == <span class="number">0</span></div><div class="line">    n = n.ceil</div><div class="line"><span class="keyword">else</span></div><div class="line">    n = n.floor</div></pre></td></tr></table></figure></p>
<p>这样的处理方式会带来最终分配的slot与请求迁移的slot数量不一致，这个BUG已经在github上提给作者，<a href="https://github.com/antirez/redis/issues/2990。" target="_blank" rel="external">https://github.com/antirez/redis/issues/2990。</a><br>7、打印出reshard计划，如果用户没传–yes，就提示用户确认计划。<br>8、根据reshard计划，一个个slot的迁移到新节点上，迁移使用move_slot方法，该方法被很多命令使用，具体可以参见下面的迁移流程。move_slot方法传递dots为true和pipeline数量。<br>9、至此，就完成了全部的迁移任务。<br>下面看下一次reshard的执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb reshard --from all --to 80b661ecca260c89e3d8ea9b98f77edaeef43dcd --slots 11 10.180.157.199:6379</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 10.180.157.199:6379)</div><div class="line">S: b2506515b38e6bbd3034d540599f4cd2a5279ad1 10.180.157.199:6379</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 460b3a11e296aafb2615043291b7dd98274bb351</div><div class="line">S: d376aaf80de0e01dde1f8cd4647d5ac3317a8641 10.180.157.205:6379</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates e36c46dbe90960f30861af00786d4c2064e63df2</div><div class="line">M: 15126fb33796c2c26ea89e553418946f7443d5a5 10.180.157.201:6379</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">S: 59fa6ee455f58a5076f6d6f83ddd74161fd7fb55 10.180.157.208:6379</div><div class="line">   slots: (0 slots) slave</div><div class="line">   replicates 15126fb33796c2c26ea89e553418946f7443d5a5</div><div class="line">M: 460b3a11e296aafb2615043291b7dd98274bb351 10.180.157.202:6379</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">M: 80b661ecca260c89e3d8ea9b98f77edaeef43dcd 10.180.157.200:6380</div><div class="line">   slots: (0 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">M: e36c46dbe90960f30861af00786d4c2064e63df2 10.180.157.200:6379</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div><div class="line"></div><div class="line">Ready to move 11 slots.</div><div class="line">  Source nodes:</div><div class="line">    M: 15126fb33796c2c26ea89e553418946f7443d5a5 10.180.157.201:6379</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">    M: 460b3a11e296aafb2615043291b7dd98274bb351 10.180.157.202:6379</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">    M: e36c46dbe90960f30861af00786d4c2064e63df2 10.180.157.200:6379</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   1 additional replica(s)</div><div class="line">  Destination node:</div><div class="line">    M: 80b661ecca260c89e3d8ea9b98f77edaeef43dcd 10.180.157.200:6380</div><div class="line">   slots: (0 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">  Resharding plan:</div><div class="line">    Moving slot 5461 from e36c46dbe90960f30861af00786d4c2064e63df2</div><div class="line">    Moving slot 5462 from e36c46dbe90960f30861af00786d4c2064e63df2</div><div class="line">    Moving slot 5463 from e36c46dbe90960f30861af00786d4c2064e63df2</div><div class="line">    Moving slot 5464 from e36c46dbe90960f30861af00786d4c2064e63df2</div><div class="line">    Moving slot 0 from 460b3a11e296aafb2615043291b7dd98274bb351</div><div class="line">    Moving slot 1 from 460b3a11e296aafb2615043291b7dd98274bb351</div><div class="line">    Moving slot 2 from 460b3a11e296aafb2615043291b7dd98274bb351</div><div class="line">    Moving slot 10923 from 15126fb33796c2c26ea89e553418946f7443d5a5</div><div class="line">    Moving slot 10924 from 15126fb33796c2c26ea89e553418946f7443d5a5</div><div class="line">    Moving slot 10925 from 15126fb33796c2c26ea89e553418946f7443d5a5</div><div class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</div><div class="line">Moving slot 5461 from 10.180.157.200:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 5462 from 10.180.157.200:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 5463 from 10.180.157.200:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 5464 from 10.180.157.200:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 0 from 10.180.157.202:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 1 from 10.180.157.202:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 2 from 10.180.157.202:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 10923 from 10.180.157.201:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 10924 from 10.180.157.201:6379 to 10.180.157.200:6380:</div><div class="line">Moving slot 10925 from 10.180.157.201:6379 to 10.180.157.200:6380:</div></pre></td></tr></table></figure></p>
<p>move_slot方法可以在线将一个slot的全部数据从源节点迁移到目的节点，fix、reshard、rebalance都需要调用该方法迁移slot。<br>move_slot接受下面几个参数，<br>1、pipeline：设置一次从slot上获取多少个key。<br>2、quiet：迁移会打印相关信息，设置quiet参数，可以不用打印这些信息。<br>3、cold：设置cold，会忽略执行importing和migrating。<br>4、dots：设置dots，则会在迁移过程打印迁移key数量的进度。<br>5、update：设置update，则会更新内存信息，方便以后的操作。</p>
<p>move_slot流程如下：<br>1、如果没有设置cold，则对源节点执行cluster importing命令，对目的节点执行migrating命令。fix的时候有可能importing和migrating已经执行过来，所以此种场景会设置cold。<br>2、通过cluster getkeysinslot命令，一次性获取远节点迁移slot的pipeline个key的数量.<br>3、对这些key执行migrate命令，将数据从源节点迁移到目的节点。<br>4、如果migrate出现异常，在fix模式下，BUSYKEY的异常，会使用migrate的replace模式再执行一次，BUSYKEY表示目的节点已经有该key了，replace模式可以强制替换目的节点的key。不是fix模式就直接返回错误了。<br>5、循环执行cluster getkeysinslot命令，直到返回的key数量为0，就退出循环。<br>6、如果没有设置cold，对每个节点执行cluster setslot命令，把slot赋给目的节点。<br>7、如果设置update，则修改源节点和目的节点的slot信息。<br>8、至此完成了迁移slot的流程。</p>
<h1 id="rebalance平衡集群节点slot数量"><a href="#rebalance平衡集群节点slot数量" class="headerlink" title="rebalance平衡集群节点slot数量"></a>rebalance平衡集群节点slot数量</h1><p>rebalance命令可以根据用户传入的参数平衡集群节点的slot数量，rebalance功能非常强大，可以传入的参数很多，以下是rebalance的参数列表和命令示例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">rebalance       host:port</div><div class="line">                --weight &lt;arg&gt;</div><div class="line">                --auto-weights</div><div class="line">                --threshold &lt;arg&gt;</div><div class="line">                --use-empty-masters</div><div class="line">                --timeout &lt;arg&gt;</div><div class="line">                --simulate</div><div class="line">                --pipeline &lt;arg&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb rebalance --threshold 1 --weight b31e3a2e=5 --weight 60b8e3a1=5 --use-empty-masters  --simulate 10.180.157.199:6379</div></pre></td></tr></table></figure>
<p>下面也先一一解释下每个参数的用法：<br>host:port：这个是必传参数，用来从一个节点获取整个集群信息，相当于获取集群信息的入口。<br>–weight <arg>：节点的权重，格式为node_id=weight，如果需要为多个节点分配权重的话，需要添加多个–weight <arg>参数，即–weight b31e3a2e=5 –weight 60b8e3a1=5，node_id可为节点名称的前缀，只要保证前缀位数能唯一区分该节点即可。没有传递–weight的节点的权重默认为1。<br>–auto-weights：这个参数在rebalance流程中并未用到。<br>–threshold <arg>：只有节点需要迁移的slot阈值超过threshold，才会执行rebalance操作。具体计算方法可以参考下面的rebalance命令流程的第四步。<br>–use-empty-masters：rebalance是否考虑没有节点的master，默认没有分配slot节点的master是不参与rebalance的，设置–use-empty-masters可以让没有分配slot的节点参与rebalance。<br>–timeout <arg>：设置migrate命令的超时时间。<br>–simulate：设置该参数，可以模拟rebalance操作，提示用户会迁移哪些slots，而不会真正执行迁移操作。<br>–pipeline <arg>：与reshar的pipeline参数一样，定义cluster getkeysinslot命令一次取出的key数量，不传的话使用默认值为10。</arg></arg></arg></arg></arg></p>
<p>rebalance命令流程如下：<br>1、load_cluster_info_from_node方法先加载集群信息。<br>2、计算每个master的权重，根据参数–weight <arg>，为每个设置的节点分配权重，没有设置的节点，则权重默认为1。<br>3、根据每个master的权重，以及总的权重，计算自己期望被分配多少个slot。计算的方式为：总slot数量 <em> （自己的权重 / 总权重）。<br>4、计算每个master期望分配的slot是否超过设置的阈值，即–threshold <arg>设置的阈值或者默认的阈值。计算的方式为：先计算期望移动节点的阈值，算法为：(100-(100.0</arg></em>expected/n.slots.length)).abs，如果计算出的阈值没有超出设置阈值，则不需要为该节点移动slot。只要有一个master的移动节点超过阈值，就会触发rebalance操作。<br>5、如果触发了rebalance操作。那么就开始执行rebalance操作，先将每个节点当前分配的slots数量减去期望分配的slot数量获得balance值。将每个节点的balance从小到大进行排序获得sn数组。<br>6、用dst_idx和src_idx游标分别从sn数组的头部和尾部开始遍历。目的是为了把尾部节点的slot分配给头部节点。</arg></p>
<p>sn数组保存的balance列表排序后，负数在前面，正数在后面。负数表示需要有slot迁入，所以使用dst_idx游标，正数表示需要有slot迁出，所以使用src_idx游标。理论上sn数组各节点的balance值加起来应该为0，不过由于在计算期望分配的slot的时候只是使用直接取整的方式，所以可能出现balance值之和不为0的情况，balance值之和不为0即为节点不平衡的slot数量，由于slot总数有16384个，不平衡数量相对于总数，基数很小，所以对rebalance流程影响不大。</p>
<p>7、获取sn[dst_idx]和sn[src_idx]的balance值较小的那个值，该值即为需要从sn[src_idx]节点迁移到sn[dst_idx]节点的slot数量。<br>8、接着通过compute_reshard_table方法计算源节点的slot如何分配到源节点列表。这个方法在reshard流程中也有调用，具体步骤可以参考reshard流程的第六步。<br>9、如果是simulate模式，则只是打印出迁移列表。<br>10、如果没有设置simulate，则执行move_slot操作，迁移slot，传入的参数为:quiet=&gt;true,:dots=&gt;false,:update=&gt;true。<br>11、迁移完成后更新sn[dst_idx]和sn[src_idx]的balance值。如果balance值为0后，游标向前进1。<br>12、直到dst_idx到达src_idx游标，完成整个rebalance操作。</p>
<h1 id="add-node将新节点加入集群"><a href="#add-node将新节点加入集群" class="headerlink" title="add-node将新节点加入集群"></a>add-node将新节点加入集群</h1><p>add-node命令可以将新节点加入集群，节点可以为master，也可以为某个master节点的slave。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">add-node    new_host:new_port existing_host:existing_port</div><div class="line">          --slave</div><div class="line">          --master-id &lt;arg&gt;</div></pre></td></tr></table></figure></p>
<p>add-node有两个可选参数：<br>–slave：设置该参数，则新节点以slave的角色加入集群<br>–master-id：这个参数需要设置了–slave才能生效，–master-id用来指定新节点的master节点。如果不设置该参数，则会随机为节点选择master节点。<br>可以看下add-node命令的执行示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb add-node --slave --master-id dcb792b3e85726f012e83061bf237072dfc45f99 10.180.157.202:6379 10.180.157.199:6379</div><div class="line">&gt;&gt;&gt; Adding node 10.180.157.202:6379 to cluster 10.180.157.199:6379</div><div class="line">&gt;&gt;&gt; Performing Cluster Check (using node 10.180.157.199:6379)</div><div class="line">M: dcb792b3e85726f012e83061bf237072dfc45f99 10.180.157.199:6379</div><div class="line">   slots:0-5460 (5461 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">M: 464d740bf48953ebcf826f4113c86f9db3a9baf3 10.180.157.201:6379</div><div class="line">   slots:10923-16383 (5461 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">M: befa7e17b4e5f239e519bc74bfef3264a40f96ae 10.180.157.200:6379</div><div class="line">   slots:5461-10922 (5462 slots) master</div><div class="line">   0 additional replica(s)</div><div class="line">[OK] All nodes agree about slots configuration.</div><div class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</div><div class="line">&gt;&gt;&gt; Check slots coverage...</div><div class="line">[OK] All 16384 slots covered.</div><div class="line">&gt;&gt;&gt; Send CLUSTER MEET to node 10.180.157.202:6379 to make it join the cluster.</div><div class="line">Waiting <span class="keyword">for</span> the cluster to join.</div><div class="line">&gt;&gt;&gt; Configure node as replica of 10.180.157.199:6379.</div><div class="line">[OK] New node added correctly.</div></pre></td></tr></table></figure></p>
<p>add-node流程如下：<br>1、通过load_cluster_info_from_node方法转载集群信息，check_cluster方法检查集群是否健康。<br>2、如果设置了–slave，则需要为该节点寻找master节点。设置了–master-id，则以该节点作为新节点的master，如果没有设置–master-id，则调用get_master_with_least_replicas方法，寻找slave数量最少的master节点。如果slave数量一致，则选取load_cluster_info_from_node顺序发现的第一个节点。load_cluster_info_from_node顺序的第一个节点是add-node设置的existing_host:existing_port节点，后面的顺序根据在该节点执行cluster nodes返回的结果返回的节点顺序。<br>3、连接新的节点并与集群第一个节点握手。<br>4、如果没设置–slave就直接返回ok，设置了–slave，则需要等待确认新节点加入集群，然后执行cluster replicate命令复制master节点。<br>5、至此，完成了全部的增加节点的流程。</p>
<h1 id="del-node从集群中删除节点"><a href="#del-node从集群中删除节点" class="headerlink" title="del-node从集群中删除节点"></a>del-node从集群中删除节点</h1><p>del-node可以把某个节点从集群中删除。del-node只能删除没有分配slot的节点。删除命令传递两个参数：<br>host:port：从该节点获取集群信息。<br>node_id：需要删除的节点id。<br>del-node执行结果示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb del-node 10.180.157.199:6379 d5f6d1d17426bd564a6e309f32d0f5b96962fe53</div><div class="line">&gt;&gt;&gt; Removing node d5f6d1d17426bd564a6e309f32d0f5b96962fe53 from cluster 10.180.157.199:6379</div><div class="line">&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</div><div class="line">&gt;&gt;&gt; SHUTDOWN the node.</div></pre></td></tr></table></figure></p>
<p>del-node流程如下：<br>1、通过load_cluster_info_from_node方法转载集群信息。<br>2、根据传入的node id获取节点，如果节点没找到，则直接提示错误并退出。<br>3、如果节点分配的slot不为空，则直接提示错误并退出。<br>4、遍历集群内的其他节点，执行cluster forget命令，从每个节点中去除该节点。如果删除的节点是master，而且它有slave的话，这些slave会去复制其他master，调用的方法是get_master_with_least_replicas，与add-node没设置–master-id寻找master的方法一样。<br>5、然后关闭该节点</p>
<p>set-timeout设置集群节点间心跳连接的超时时间<br>set-timeout用来设置集群节点间心跳连接的超时时间，单位是毫秒，不得小于100毫秒，因为100毫秒对于心跳时间来说太短了。该命令修改是节点配置参数cluster-node-timeout，默认是15000毫秒。通过该命令，可以给每个节点设置超时时间，设置的方式使用config set命令动态设置，然后执行config rewrite命令将配置持久化保存到硬盘。以下是示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ruby redis-trib.rb <span class="built_in">set</span>-timeout 10.180.157.199:6379 30000</div><div class="line">&gt;&gt;&gt; Reconfiguring node timeout <span class="keyword">in</span> every cluster node...</div><div class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 10.180.157.199:6379</div><div class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 10.180.157.205:6379</div><div class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 10.180.157.201:6379</div><div class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 10.180.157.200:6379</div><div class="line">*** New timeout <span class="built_in">set</span> <span class="keyword">for</span> 10.180.157.208:6379</div><div class="line">&gt;&gt;&gt; New node timeout <span class="built_in">set</span>. 5 OK, 0 ERR.</div></pre></td></tr></table></figure></p>
<h1 id="call在集群全部节点上执行命令"><a href="#call在集群全部节点上执行命令" class="headerlink" title="call在集群全部节点上执行命令"></a>call在集群全部节点上执行命令</h1><p>call命令可以用来在集群的全部节点执行相同的命令。call命令也是需要通过集群的一个节点地址，连上整个集群，然后在集群的每个节点执行该命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ruby</span> redis-trib.rb call 10.180.157.199:6379 get key</div><div class="line">&gt;&gt;&gt; Calling GET key</div><div class="line">10.180.157.199:6379: MOVED 12539 10.180.157.201:6379</div><div class="line">10.180.157.205:6379: MOVED 12539 10.180.157.201:6379</div><div class="line">10.180.157.201:6379:</div><div class="line">10.180.157.200:6379: MOVED 12539 10.180.157.201:6379</div><div class="line">10.180.157.208:6379: MOVED 12539 10.180.157.201:6379</div></pre></td></tr></table></figure></p>
<h1 id="import将外部redis数据导入集群"><a href="#import将外部redis数据导入集群" class="headerlink" title="import将外部redis数据导入集群"></a>import将外部redis数据导入集群</h1><p>import命令可以把外部的redis节点数据导入集群。导入的流程如下：<br>1、通过load_cluster_info_from_node方法转载集群信息，check_cluster方法检查集群是否健康。<br>2、连接外部redis节点，如果外部节点开启了cluster_enabled，则提示错误。<br>3、通过scan命令遍历外部节点，一次获取1000条数据。<br>4、遍历这些key，计算出key对应的slot。<br>5、执行migrate命令,源节点是外部节点,目的节点是集群slot对应的节点，如果设置了–copy参数，则传递copy参数，如果设置了–replace，则传递replace参数。<br>6、不停执行scan命令，直到遍历完全部的key。<br>7、至此完成整个迁移流程<br>这中间如果出现异常，程序就会停止。没使用–copy模式，则可以重新执行import命令，使用–copy的话，最好清空新的集群再导入一次。</p>
<p>import命令更适合离线的把外部Redis数据导入，在线导入的话最好使用更专业的导入工具，以slave的方式连接redis节点去同步节点数据应该是更好的方式。</p>
<p>下面是一个例子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./redis-trib.rb import --from 10.0.10.1:6379 10.10.10.1:7000</div><div class="line">上面的命令是把 10.0.10.1:6379（redis 2.8）上的数据导入到 10.10.10.1:7000这个节点所在的集群</div></pre></td></tr></table></figure></p>
<p>原文地址<a href="http://blog.csdn.net/huwei2003/article/details/50973967" target="_blank" rel="external">http://blog.csdn.net/huwei2003/article/details/50973967</a></p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM监控与调优]]></title>
      <url>/2015/09/12/java-jvm-monitor-optimization/</url>
      <content type="html"><![CDATA[<blockquote>
<p>JVM监控与调优主要的着眼点在于如何配置、如何监控、如何优化3点上。下面就将针对这3点进行学习</p>
</blockquote>
<a id="more"></a>
<p><a href="http://www.cnblogs.com/zhguang/p/Java-JVM-GC.html" target="_blank" rel="external">http://www.cnblogs.com/zhguang/p/Java-JVM-GC.html</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java的内存分配和回收]]></title>
      <url>/2015/08/12/java-memory-gc/</url>
      <content type="html"><![CDATA[<blockquote>
<p>java的内存分配和回收，主要都在堆中分配和回收，所以堆内存是本文讲解的重点。</p>
</blockquote>
<a id="more"></a>
<h1 id="Java内存分配机制"><a href="#Java内存分配机制" class="headerlink" title="Java内存分配机制"></a>Java内存分配机制</h1><p>Java内存分配和回收的机制概括的说，就是：分代分配，分代回收。对象将根据存活的时间被分为：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）。<br>如下图<br><a href="/images/java-memory-gc.png"><img src="/images/java-memory-gc.png" alt=""></a></p>
<h2 id="年轻代（Young-Generation）"><a href="#年轻代（Young-Generation）" class="headerlink" title="年轻代（Young Generation）"></a>年轻代（Young Generation）</h2><p>对象被创建时，内存的分配首先发生在年轻代（大对象可以直接 被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消 亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。<br>年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区和两个存活区（Survivor 0 、Survivor 1）。内存分配过程如下图<br><a href="/images/java-memory-gc-1.png"><img src="/images/java-memory-gc-1.png" alt=""></a></p>
<ul>
<li>绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；</li>
<li>当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）；</li>
<li>此后，每次Eden区满了，就执行一次Minor GC，并将剩余的对象都添加到Survivor0；</li>
<li>当Survivor0也满的时候，将其中仍然活着的对象直接复制到Survivor1，以后Eden区执行Minor GC后，就将剩余的对象添加Survivor1（此时，Survivor0是空白的）。</li>
<li>当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。</li>
</ul>
<p>从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活 着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中），这不代表着停止复制清理法很高效，其实，它也只在这种情况下高效，如果在老年代采用停止复制，则挺悲剧的。<br>在Eden区，HotSpot虚拟机使用了两种技术来加快内存分配。分别是bump-the-pointer和TLAB（Thread-Local Allocation Buffers），这两种技术的做法分别是：由于Eden区是连续的，因此bump-the-pointer技术的核心就是跟踪最后创建的一个对象，在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而大大加快内存分配速度；而对于TLAB技术是对于多线程而言的，将Eden区分为若干段，每个线程使用独立的一段，避免相互影响。TLAB结合bump-the-pointer技术，将保证每个线程都使用Eden区的一段，并快速的分配内存。</p>
<h2 id="年老代（Old-Generation）"><a href="#年老代（Old-Generation）" class="headerlink" title="年老代（Old Generation）"></a>年老代（Old Generation）</h2><p>对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时， 将执行Major GC，也叫 Full GC。　　<br> 　　可以使用-XX:+UseAdaptiveSizePolicy开关来控制是否采用动态控制策略，如果动态控制，则动态调整Java堆中各个区域的大小以及进入老年代的年龄。<br>　　如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。用-XX:PretenureSizeThreshold来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。<br>　　可能存在年老代对象引用新生代对象的情况，如果需要执行Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决的方法是，年老代中维护一个512 byte的块——”card table“，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。</p>
<h1 id="Java-GC机制"><a href="#Java-GC机制" class="headerlink" title="Java GC机制"></a>Java GC机制</h1><p>GC机制的基本算法是：分代收集，这个不用赘述。下面阐述每个分代的收集方法。</p>
<h2 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h2><p>事实上，在上一节，已经介绍了新生代的主要垃圾回收方法，在新生代中，使用“停止-复制”算法进行清理，将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。</p>
<p>　　<strong>这里也可以发现，停止复制算法中，用来复制的两部分并不总是相等的（传统的停止复制算法两部分内存相等，但新生代中使用1个大的Eden区和2个小的Survivor区来避免这个问题）</strong></p>
<p>　　由于绝大部分的对象都是短命的，甚至存活不到Survivor中，所以，Eden区与Survivor的比例较大，HotSpot默认是 8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor+Eden中存活下来的内存超过了10%，则需要将一部分对象分配到 老年代。用-XX:SurvivorRatio参数来配置Eden区域Survivor区的容量比值，默认是8，代表Eden：Survivor1：Survivor2=8:1:1.</p>
<h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。<br>在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否设 置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置-XX:+HandlePromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</p>
<h2 id="方法区（永久代）"><a href="#方法区（永久代）" class="headerlink" title="方法区（永久代）"></a>方法区（永久代）</h2><p>永久代的回收有两种：常量池中的常量(<strong>1.7 已移出方法区</strong>)，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：</p>
<ul>
<li>类的所有实例都已经被回收</li>
<li>加载类的ClassLoader已经被回收</li>
<li>类对象的Class对象没有被引用（即没有通过反射引用该类的地方）</li>
</ul>
<p>永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。HotSpot提供-Xnoclassgc进行控制<br>使用-verbose，-XX:+TraceClassLoading、-XX:+TraceClassUnLoading可以查看类加载和卸载信息<br>-verbose、-XX:+TraceClassLoading可以在Product版HotSpot中使用；<br>-XX:+TraceClassUnLoading需要fastdebug版HotSpot支持</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同，HotSpot 1.6版使用的垃圾收集器如下图（图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用）：<br><a href="/images/java-memory-gc-2.jpg"><img src="/images/java-memory-gc-2.jpg" alt=""></a><br><strong>在介绍垃圾收集器之前，需要明确一点，就是在新生代采用的停止复制算法中，“停 止（Stop-the-world）”的意义是在回收内存时，需要暂停其他所 有线程的执行。这个是很低效的，现在的各种新生代收集器越来越优化这一点，但仍然只是将停止的时间变短，并未彻底取消停止。</strong></p>
<ul>
<li>Serial收集器：新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停。使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值）</li>
<li>ParNew收集器：新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，其它工作线程暂停，关注缩短垃圾收集时间。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</li>
<li>Parallel Scavenge 收集器：新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适合用户交互，提高用户体验）。使用-XX:+UseParallelGC开关控制使用 Parallel Scavenge+Serial Old收集器组合回收垃圾（这也是在Server模式下的默认值）；使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即 1%的时间用来进行垃圾回收。使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel Scavenge有效）</li>
<li>Serial Old收集器：老年代收集器，单线程收集器，使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法，使用单线程进行GC，其它工作线程暂停（注意，在老年代中进行标记整理算法清理，也需要暂停其它线程），在JDK1.5之前，Serial </li>
<li>Parallel Old收集器：老年代收集器，多线程，多线程机制与Parallel Scavenge差不错，使用标记整理（与Serial Old不同，这里的整理是Summary（汇总）和Compact（压缩），汇总的意思就是将幸存的对象复制到预先准备好的区域，而不是像Sweep（清 理）那样清理废弃的对象）算法，在Parallel Old执行时，仍然需要暂停其它线程。Parallel Old在多核计算中很有用。Parallel Old出现后（JDK 1.6），与Parallel Scavenge配合有很好的效果，充分体现Parallel Scavenge收集器吞吐量优先的效果。使用-XX:+UseParallelOldGC开关控制使用Parallel Scavenge +Parallel Old组合收集器进行收集。</li>
<li><p>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间，使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见后面），当用户线程内存不足时，采用备用方案Serial Old收集。<br><strong>CMS收集的方法是：先3次标记，再1次清除，3次标记中前两次是初始标记和重新标记（此时仍然需要停止（stop the world））， 初始标记（Initial Remark）是标记GC Roots能关联到的对象（即有引用的对象），停顿时间很短；并发标记（Concurrent remark）是执行GC Roots查找引用的过程，不需要用户线程停顿；重新标记（Remark）是在初始标记和并发标记期间，有标记变动的那部分仍需要标记，所以加上这一部分 标记的过程，停顿时间比并发标记小得多，但比初始标记稍长。在完成标记之后，就开始并发清除，不需要用户线程停顿。<br>所以在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。<br>CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。<br>另外，在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。所以使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。<br>还有，CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。</strong></p>
</li>
<li><p>G1收集器：在JDK1.7中正式发布，与现状的新生代、老年代概念有很大不同，目前使用较少，不做介绍。</p>
</li>
</ul>
<p>参考：<a href="http://www.cnblogs.com/zhguang/p/3257367.html" target="_blank" rel="external">http://www.cnblogs.com/zhguang/p/3257367.html</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
            <tag> gc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python在不同层级目录import模块的方法]]></title>
      <url>/2015/02/18/python-import-module/</url>
      <content type="html"><![CDATA[<blockquote>
<p>使用python进行程序编写时，经常会使用第三方模块包。这种包我们可以通过python setup install 进行安装后，通过import XXX或from XXX import yyy 进行导入。不过如果是自己遍写的依赖包，又不想安装到python的相应目录，可以放到本目录里进行import进行调用；为了更清晰的理清程序之间的关系，例如我们会把这种包放到lib目录再调用。本篇就针对常见的模块调用方法汇总下。</p>
</blockquote>
<a id="more"></a>
<h1 id="同级目录下的调有"><a href="#同级目录下的调有" class="headerlink" title="同级目录下的调有"></a>同级目录下的调有</h1><p>程序结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-- src</div><div class="line">    |-- mod1.py</div><div class="line">    |-- test1.py</div></pre></td></tr></table></figure></p>
<p>若在程序test1.py中导入模块mod1, 则直接使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> mod1</div><div class="line">或</div><div class="line"><span class="keyword">from</span> mod1 <span class="keyword">import</span> *;</div></pre></td></tr></table></figure></p>
<h1 id="调用子目录下的模块"><a href="#调用子目录下的模块" class="headerlink" title="调用子目录下的模块"></a>调用子目录下的模块</h1><p>程序结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-- src</div><div class="line">    |-- mod1.py</div><div class="line">    |-- lib</div><div class="line">    |    |-- mod2.py</div><div class="line">    |-- test1.py</div></pre></td></tr></table></figure></p>
<p>这时看到test1.py和lib目录（即mod2.py的父级目录），如果想在程序test1.py中导入模块mod2.py ，可以在lib件夹中建立空文件<strong>init</strong>.py文件(也可以在该文件中自定义输出模块接口)，然后使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lib.mod2 <span class="keyword">import</span> *</div><div class="line">或</div><div class="line"><span class="keyword">import</span> lib.mod2</div></pre></td></tr></table></figure></p>
<h1 id="调用上级目录下的文件"><a href="#调用上级目录下的文件" class="headerlink" title="调用上级目录下的文件"></a>调用上级目录下的文件</h1><p>程序结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-- src</div><div class="line">    |-- mod1.py</div><div class="line">    |-- lib</div><div class="line">    |    |-- mod2.py</div><div class="line">    |-- sub</div><div class="line">    |    |-- test2.py</div></pre></td></tr></table></figure></p>
<p>这里想要实现test2.py调用mod1.py和mod2.py ，做法是我们先跳到src目录下面，直接可以调用mod1，然后在lib上当下建一个空文件<strong>init</strong>.py ，就可以像第二步调用子目录下的模块一样，通过import  lib.mod2进行调用了。具体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line">sys.path.append(<span class="string">".."</span>)</div><div class="line"><span class="keyword">import</span> mod1</div><div class="line"><span class="keyword">import</span> lib.mod2</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> python基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[启用Nginx状态监控]]></title>
      <url>/2014/10/12/nginx-status-monitor/</url>
      <content type="html"><![CDATA[<h1 id="编译Nginx添加http-stub-status-module"><a href="#编译Nginx添加http-stub-status-module" class="headerlink" title="编译Nginx添加http_stub_status_module"></a>编译Nginx添加http_stub_status_module</h1><p>编译Nginx的时候添加参数：–with-http_stub_status_module<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> nginx-&#123;version&#125;/</div><div class="line"></div><div class="line">./configure  --prefix=/opt/nginx --with-http_stub_status_module</div><div class="line"> --with-http_ssl_module</div><div class="line"></div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="启用nginx-status配置"><a href="#启用nginx-status配置" class="headerlink" title="启用nginx status配置"></a>启用nginx status配置</h1><p>修改Nginx配置文件nginx.conf，在HTTP段中添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /opt/nginx/conf/nginx.conf</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">  listen 80;</div><div class="line">  server_name localhost;</div><div class="line"></div><div class="line">  location /nginx_status &#123;                  <span class="comment">#主要是这里代表根目录显示信息</span></div><div class="line">  stub_status on;</div><div class="line">  access_log  off;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="打开status页面"><a href="#打开status页面" class="headerlink" title="打开status页面"></a>打开status页面</h1><p>浏览器访问监控页面地址<a href="http://{your" target="_blank" rel="external">http://{your</a> IP}/nginx-status,显示如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Active connections: 2 server accepts handled requests 8 8 33 Reading: 0 Writing: 1 Waiting: 1</div></pre></td></tr></table></figure></p>
<p>解析：<br>Active connections    //当前 Nginx 正处理的活动连接数。<br>server accepts handledrequests //总共处理了8 个连接 , 成功创建 8 次握手,总共处理了33个请求。<br>Reading //nginx 读取到客户端的 Header 信息数。<br>Writing //nginx 返回给客户端的 Header 信息数。<br>Waiting //开启 keep-alive 的情况下，这个值等于 active – (reading + writing)，意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接</p>
]]></content>
      
        <categories>
            
            <category> ngnix </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx location 语法和优先级]]></title>
      <url>/2014/10/07/nginx-location/</url>
      <content type="html"><![CDATA[<blockquote>
<p>验证下，记录下，以后不用到处找</p>
</blockquote>
<a id="more"></a>
<p>语法:location [=|~|~*|^~] /uri/ { … }</p>
<ul>
<li>= 精确匹配，例如 location =/test 只匹配 /test</li>
<li>~ 后面接正则，区分大小写,匹配满足此正则的url</li>
<li>~* 后面接正则，不区分大小写,匹配满足此正则的url</li>
<li>^~ 匹配以什么开头的，例如  location ^~  /test 匹配 /test,/test/1,/test/2 ;</li>
<li>什么都不加的话，类似第四点，location /test 匹配 /test,/test/1,/test/2 ;<br>优先级<br>= 大于 ^~ 大于 ~ 或者~* 大于 什么都不加</li>
</ul>
<p>假如遇到同级的话</p>
<ul>
<li>~ 和~<em> （他们是同级的）比较的话，就是根据他们在文件的出现顺序。例如<br>location ~ /sb.txt<br>location ~</em> /sb.txt<br>如果访问 <a href="http://localhost/sb.txt,就会跳到第一个，访问" target="_blank" rel="external">http://localhost/sb.txt,就会跳到第一个，访问</a> <a href="http://localhost/SB.txt" target="_blank" rel="external">http://localhost/SB.txt</a> 跳到第二个，<br>换个顺序<br>location ~* /sb.txt<br>location ~ /sb.txt<br>不管访问 <a href="http://localhost/sb.txt" target="_blank" rel="external">http://localhost/sb.txt</a> 还是 <a href="http://localhost/SB.txt" target="_blank" rel="external">http://localhost/SB.txt</a> ,都只会跳到第一个</li>
<li>^~ 的话，就根据他们的匹配度，例如<br>location ^~ /sb/<br>location ^~ /sb/sb2/<br>如果访问<a href="http://localhost/sb/sb2/,就会跳到第二个去处理，因为他更加匹配吧。" target="_blank" rel="external">http://localhost/sb/sb2/,就会跳到第二个去处理，因为他更加匹配吧。</a><br>如果访问<a href="http://localhost/sb/，就会跳到第一个处理，如果访问http://localhost/sb/sb3,也会跳到第一个。" target="_blank" rel="external">http://localhost/sb/，就会跳到第一个处理，如果访问http://localhost/sb/sb3,也会跳到第一个。</a></li>
<li>什么都不加的话，也是根据他们的匹配度，例如<br>location /sb/<br>location /sb/sb2/<br>如果访问<a href="http://localhost/sb/sb2/,就会跳到第二个去处理，因为他更加匹配吧。" target="_blank" rel="external">http://localhost/sb/sb2/,就会跳到第二个去处理，因为他更加匹配吧。</a><br>如果访问<a href="http://localhost/sb/，就会跳到第一个处理，如果访问http://localhost/sb/sb3,也会跳到第一个。" target="_blank" rel="external">http://localhost/sb/，就会跳到第一个处理，如果访问http://localhost/sb/sb3,也会跳到第一个。</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> ngix </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[lvs+keepalived 做负载和热备]]></title>
      <url>/2014/10/07/linux-lvs/</url>
      <content type="html"><![CDATA[<blockquote>
<p>一直觉得nginx做负载不错了，可发现居然这玩意这么好，特别keepalived热备。</p>
</blockquote>
<a id="more"></a>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>本实验基于VMware+centos,以下是环境信息：<br>假如有4台服务器<br>master：192.168.153.132<br>backup：192.168.153.133<br>vip（virtual ip 虚拟ip）：192.168.153.100 （实际浏览器访问的地址）<br>realserver 1: 192.168.153.128<br>realserver 2: 192.168.153.129<br>热备的意思就是master坏了，backup能补上去，由于都是使用vip，所以外面浏览器访问没有影响<br>realserver1和2是用来做负载均衡，按照权重来调到相应的服务器来处理请求。<br>lvs和keepalived都要装到master和backup上</p>
<h2 id="下载keepalived和lvs的admin程序"><a href="#下载keepalived和lvs的admin程序" class="headerlink" title="下载keepalived和lvs的admin程序"></a>下载keepalived和lvs的admin程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget http://www.keepalived.org/software/keepalived-1.2.13.tar.gz</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz</div></pre></td></tr></table></figure>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum -y install libnl* openssl* popt* kernel-devel</div></pre></td></tr></table></figure>
<h2 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ tar -zxvf keepalived-1.2.13.tar.gz</div><div class="line">$ tar -zxvf ipvsadm-1.26.tar.gz</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> keepalived-1.2.13</div><div class="line">$ ./configure  --prefix=/usr  --sysconf=/etc</div><div class="line">$ make &amp;&amp; make install</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ipvsadm-1.26</div><div class="line">$ make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h2 id="验证lvs"><a href="#验证lvs" class="headerlink" title="验证lvs"></a>验证lvs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ipvsadm ln</div></pre></td></tr></table></figure>
<h2 id="验证keepalived"><a href="#验证keepalived" class="headerlink" title="验证keepalived"></a>验证keepalived</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service keepalived start</div></pre></td></tr></table></figure>
<p>如果显示无误就代表安装成功了。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置master"><a href="#配置master" class="headerlink" title="配置master"></a>配置master</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi /etc/keepalived/keepalived.conf</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">global_defs &#123;</div><div class="line">   notification_email &#123;</div><div class="line">     acassen@firewall.loc</div><div class="line">     failover@firewall.loc</div><div class="line">     sysadmin@firewall.loc</div><div class="line">   &#125;</div><div class="line">   notification_email_from Alexandre.Cassen@firewall.loc</div><div class="line">   smtp_server 192.168.200.1</div><div class="line">   smtp_connect_timeout 30</div><div class="line">   router_id LVS_DEVEL</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    state MASTER   #表示master</div><div class="line">    interface eth1 #网络接口，有可能是eth0，可以用命令ifconfig查看</div><div class="line">    virtual_router_id 51</div><div class="line">    priority 100   #优先级</div><div class="line">    advert_int 1</div><div class="line">    authentication &#123;</div><div class="line">        auth_type PASS</div><div class="line">        auth_pass 1111</div><div class="line">    &#125;</div><div class="line">    virtual_ipaddress &#123;</div><div class="line">        192.168.153.100  #vip配置</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">virtual_server 192.168.153.100 80 &#123;</div><div class="line">        delay_loop 6</div><div class="line">        lb_algo rr   #负载算法</div><div class="line">        lb_kind DR  #负载方式 DR，这种方式的话VIP端口和realserver端口必须一致</div><div class="line">        #persistence_timeout 20</div><div class="line">        protocol TCP</div><div class="line">        real_server 192.168.153.128 80 &#123;</div><div class="line">        weight 3 #权重</div><div class="line">        TCP_CHECK &#123;</div><div class="line">        connect_timeout 3</div><div class="line">        nb_get_retry 3</div><div class="line">        delay_before_retry 3</div><div class="line">        connect_port 80</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">       real_server 192.168.153.129 80 &#123;</div><div class="line">        weight 3 #权重</div><div class="line">        TCP_CHECK &#123;</div><div class="line">        connect_timeout 3</div><div class="line">        nb_get_retry 3</div><div class="line">        delay_before_retry 3</div><div class="line">        connect_port 80</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="配置backup"><a href="#配置backup" class="headerlink" title="配置backup"></a>配置backup</h2><p>基本跟master一致，只是在上面红色的第一处改成BACKUP，第二处改成比master小的值，例如90</p>
<h2 id="重启keepalived"><a href="#重启keepalived" class="headerlink" title="重启keepalived"></a>重启keepalived</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service keepalived restart</div></pre></td></tr></table></figure>
<h2 id="配置realserver"><a href="#配置realserver" class="headerlink" title="配置realserver"></a>配置realserver</h2><p>在real server 1和2上，把以下脚本放在/etc/rc.d/init.d/下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment"># description: Config realserver lo and apply noarp</span></div><div class="line"> </div><div class="line">SNS_VIP=192.168.153.100</div><div class="line"> </div><div class="line">. /etc/rc.d/init.d/<span class="built_in">functions</span></div><div class="line"> </div><div class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line">start)</div><div class="line">       ifconfig lo:0 <span class="variable">$SNS_VIP</span> netmask 255.255.255.255 broadcast <span class="variable">$SNS_VIP</span></div><div class="line">       /sbin/route add -host <span class="variable">$SNS_VIP</span> dev lo:0</div><div class="line">       <span class="built_in">echo</span> <span class="string">"1"</span> &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line">       <span class="built_in">echo</span> <span class="string">"2"</span> &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</div><div class="line">       <span class="built_in">echo</span> <span class="string">"1"</span> &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</div><div class="line">       <span class="built_in">echo</span> <span class="string">"2"</span> &gt;/proc/sys/net/ipv4/conf/all/arp_announce</div><div class="line">       sysctl -p &gt;/dev/null 2&gt;&amp;1</div><div class="line">       <span class="built_in">echo</span> <span class="string">"RealServer Start OK"</span></div><div class="line"> </div><div class="line">       ;;</div><div class="line">stop)</div><div class="line">       ifconfig lo:0 down</div><div class="line">       route del <span class="variable">$SNS_VIP</span> &gt;/dev/null 2&gt;&amp;1</div><div class="line">       <span class="built_in">echo</span> <span class="string">"0"</span> &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line">       <span class="built_in">echo</span> <span class="string">"0"</span> &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</div><div class="line">       <span class="built_in">echo</span> <span class="string">"0"</span> &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</div><div class="line">       <span class="built_in">echo</span> <span class="string">"0"</span> &gt;/proc/sys/net/ipv4/conf/all/arp_announce</div><div class="line">       <span class="built_in">echo</span> <span class="string">"RealServer Stoped"</span></div><div class="line">       ;;</div><div class="line">*)</div><div class="line">       <span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$0</span> &#123;start|stop&#125;"</span></div><div class="line">       <span class="built_in">exit</span> 1</div><div class="line"><span class="keyword">esac</span></div><div class="line"> </div><div class="line"><span class="built_in">exit</span> 0</div></pre></td></tr></table></figure></p>
<p>命名成realserver,然后可以用以下命令启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service realserver start</div></pre></td></tr></table></figure></p>
<h2 id="关闭iptable"><a href="#关闭iptable" class="headerlink" title="关闭iptable"></a>关闭iptable</h2><p>如果不想关掉的话<br>在master 加上以下规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-A INPUT -i eth1 -p vrrp -s 192.168.153.133 -j ACCEPT</div></pre></td></tr></table></figure></p>
<p>在backup加上以下规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-A INPUT -i eth1 -p vrrp -s 192.168.153.132 -j ACCEPT</div></pre></td></tr></table></figure></p>
<p>其实就是让热备之间可以通讯，注意eth1是你的网络接口，如果是eth0就要换成eth0<br>realserver就只要开启80端口就可以了。</p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><ul>
<li>开启realserver的web应用程序</li>
<li>执行realserver脚本</li>
<li>开启master和backup的keepalived</li>
<li>用<code>watch ipvsadm -ln</code>在master和backup上可以查看状态<br>如果有两条记录分别指向realserver的ip就代表运行正确了。</li>
<li>浏览器访问<code>vip</code>，看能否正确访问web应用程序。</li>
<li>关掉master 的keepalived，如果还能访问的话，就代表backup接管了。<br>可以在backup的日志上面看到，<code>tail -f /var/log/message</code><br>如果有<code>transition MASTER</code>的，就代表接管了。</li>
<li>再启动master的keepalived，再到backup的日志上面看到<code>transition BACKUP</code>的，就代表已经交回master了。</li>
<li>关掉其中一个realserver，用<code>watch ipvsadm -ln</code>可以看到该realserver的ip被剔除了。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> lvs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[centos 启用ftp功能]]></title>
      <url>/2014/08/17/centos-ftp/</url>
      <content type="html"><![CDATA[<p>1.安装vsftpd组件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install vsftpd</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>安装完后，有个/etc/vsftpd/vsftpd.conf 文件，用来配置<br>还有自动新建了一个ftp用户和ftp的组，home目录为/var/ftp,默认是nologin（不能登录系统）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /etc/passwd | grep ftp</div></pre></td></tr></table></figure></p>
<p>默认ftp服务是没有启动的，用下面命令启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service vsftpd start</div></pre></td></tr></table></figure></p>
<p>2.安装ftp客户端组件（用来验证是否vsftpd）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install ftp</div></pre></td></tr></table></figure></p>
<p>执行命令尝试登录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftp localhost</div></pre></td></tr></table></figure></p>
<p>输入用户名ftp，密码随便（因为默认是允许匿名的）</p>
<p>登录成功，就代表ftp服务可用了。</p>
<p>但是，外网是访问不了的，所以还要继续配置。</p>
<p>3.取消匿名登陆<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/vsftpd/vsftpd.conf</div></pre></td></tr></table></figure></p>
<p>把第一行的 anonymous_enable=YES ，改为NO<br>重启<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service vsftpd restart</div></pre></td></tr></table></figure></p>
<p>4.新建一个用户(ftpuser为用户名，随便就可以)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd ftpuser</div></pre></td></tr></table></figure></p>
<p>修改密码（输入两次）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">passwd ftpuser</div></pre></td></tr></table></figure></p>
<p>这样一个用户建完，可以用这个登录，记得用普通登录不要用匿名了。登录后默认的路径为 /home/ftpuser.</p>
<p>5.开放21端口</p>
<p>因为ftp默认的端口为21，而centos默认是没有开启的，所以要修改iptables文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/sysconfig/iptables</div></pre></td></tr></table></figure></p>
<p>在行上面有22 -j ACCEPT 下面另起一行输入跟那行差不多的，只是把22换成21，然后：wq保存。<br>还要运行下,重启iptables<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service iptables restart</div></pre></td></tr></table></figure></p>
<p>外网是可以访问上去了，可是发现没法返回目录，也上传不了，因为selinux作怪了。<br>6.修改selinux<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getsebool -a | grep ftp</div></pre></td></tr></table></figure></p>
<p>执行上面命令，再返回的结果看到两行都是off，代表，没有开启外网的访问<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.... </div><div class="line">allow_ftpd_full_access off </div><div class="line">....</div><div class="line">....</div><div class="line">ftp_home_dir off</div></pre></td></tr></table></figure></p>
<p>只要把上面都变成on就行<br>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setsebool -P allow_ftpd_full_access 1 </div><div class="line">setsebool -P ftp_home_dir off 1</div></pre></td></tr></table></figure></p>
<p>再重启一下vsftpd<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service vsftpd restart</div></pre></td></tr></table></figure></p>
<p>这样应该没问题了（如果，还是不行，看看是不是用了ftp客户端工具用了passive模式访问了，如提示Entering Passive mode，就代表是passive模式，默认是不行的，因为ftp passive模式被iptables挡住了，下面会讲怎么开启，如果懒得开的话，就看看你客户端ftp是否有port模式的选项，或者把passive模式的选项去掉。如果客户端还是不行，看看客户端上的主机的电脑是否开了防火墙，关吧）</p>
<p>7.开启passive模式</p>
<p>默认是开启的，但是要指定一个端口范围，打开vsftpd.conf文件，在后面加上<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pasv_min_port=30000</div><div class="line"></div><div class="line">pasv_max_port=30999</div></pre></td></tr></table></figure></p>
<p>表示端口范围为30000~30999，这个可以随意改。<br>改完重启一下vsftpd</p>
<p>由于指定这段端口范围，iptables也要相应的开启这个范围，所以像上面那样打开iptables文件</p>
<p>也是在21上下面另起一行，更那行差不多，只是把21 改为30000:30999,然后:wq保存，重启下iptables。这样就搞定了。</p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[List、Set、Map集合存放null分析]]></title>
      <url>/2014/08/16/java-collection-null/</url>
      <content type="html"><![CDATA[<blockquote>
<p>验证下。</p>
</blockquote>
<a id="more"></a>
<h1 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.collection;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNull</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">// 测试List</span></div><div class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</div><div class="line">        list.add(<span class="keyword">null</span>);</div><div class="line">        list.add(<span class="keyword">null</span>);</div><div class="line">        System.out.println(list);</div><div class="line"></div><div class="line">        <span class="comment">// 测试Set</span></div><div class="line">        Set&lt;Object&gt; set = <span class="keyword">new</span> HashSet&lt;Object&gt;();</div><div class="line">        set.add(<span class="keyword">null</span>);</div><div class="line">        set.add(<span class="keyword">null</span>);</div><div class="line">        System.out.println(set);</div><div class="line"></div><div class="line">        <span class="comment">// 测试HashMap与Hashtable</span></div><div class="line">        Map&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</div><div class="line">        hashMap.put(<span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        hashMap.put(<span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        hashMap.put(<span class="number">1</span>, <span class="keyword">null</span>);</div><div class="line">        hashMap.put(<span class="number">1</span>, <span class="number">12</span>);</div><div class="line">        System.out.println(hashMap);</div><div class="line"></div><div class="line">        Map&lt;Object, Object&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;Object, Object&gt;();</div><div class="line">        hashtable.put(<span class="number">1</span>, <span class="string">"string1"</span>);</div><div class="line">        hashtable.put(<span class="number">2</span>, <span class="string">"string2"</span>);</div><div class="line">        System.out.println(hashtable);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            hashtable.put(<span class="keyword">null</span>,<span class="string">"null"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">            System.out.println(e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            hashtable.put(<span class="number">3</span>,<span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">            System.out.println(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[null, null]</div><div class="line">[null]</div><div class="line">&#123;null=null, 1=12&#125;</div><div class="line">&#123;2=string2, 1=string1&#125;</div><div class="line">java.lang.NullPointerException</div><div class="line">java.lang.NullPointerException</div></pre></td></tr></table></figure>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>List,SET,是接受null的，而map的hashmap也是接受null的，但是hashtable不管key还是value都不接受null的🙂</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript在浏览器跨域访问的几种处理方式]]></title>
      <url>/2014/08/02/jquery-cross-domain-ajax/</url>
      <content type="html"><![CDATA[<p>这里说的js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。<br>下表给出了相对<a href="http://store.company.com/dir/page.html" target="_blank" rel="external">http://store.company.com/dir/page.html</a> 同源检测的结果:</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>结果</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://store.company.com/dir2/other.html" target="_blank" rel="external">http://store.company.com/dir2/other.html</a></td>
<td>成功</td>
<td></td>
</tr>
<tr>
<td><a href="http://store.company.com/dir/inner/another.html" target="_blank" rel="external">http://store.company.com/dir/inner/another.html</a></td>
<td>成功</td>
<td></td>
</tr>
<tr>
<td><a href="https://store.company.com/dir/inner/another.html" target="_blank" rel="external">https://store.company.com/dir/inner/another.html</a></td>
<td>失败</td>
<td>协议不同</td>
</tr>
<tr>
<td><a href="http://store.company.com:81/dir/inner/another.html" target="_blank" rel="external">http://store.company.com:81/dir/inner/another.html</a></td>
<td>失败</td>
<td>端口不同</td>
</tr>
<tr>
<td><a href="http://news.company.com/dir/inner/another.html" target="_blank" rel="external">http://news.company.com/dir/inner/another.html</a></td>
<td>失败</td>
<td>域名不同</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>要解决跨域的问题，我们可以使用以下几种方法：</p>
<h1 id="通过jsonp"><a href="#通过jsonp" class="headerlink" title="通过jsonp"></a>通过jsonp</h1><p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。<br>比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是<a href="http://example.com/data.php" target="_blank" rel="external">http://example.com/data.php</a>, 那么a.html中的代码就可以这样：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">scirpt</span>&gt;</span></div><div class="line">function dosomething(jsondata)&#123;</div><div class="line">    //处理获得的json数据</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">scirpt</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">scirpt</span> <span class="attr">src</span>=<span class="string">"http://example.com/data.php?callback=dosomething"</span>&gt;</span><span class="tag">&lt;/<span class="name">scirpt</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。<br>因为是当做一个js文件来引入的，所以<a href="http://example.com/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的" target="_blank" rel="external">http://example.com/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的</a>:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$callback=&amp;_GET[`callback`];<span class="comment">//获得回调函数名</span></div><div class="line">$data=<span class="keyword">array</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);<span class="comment">//要返回的数据</span></div><div class="line"><span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>;<span class="comment">//输出</span></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>最终那个页面输出的结果是:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dosomething([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</div></pre></td></tr></table></figure></p>
<p>所以通过<a href="http://example.com/data.php?callback=dosomething得到的js文件，就是我们之前定义的dosomething函数,并且它的参数就是我们需要的json数据，这样我们就跨域获得了我们需要的数据。" target="_blank" rel="external">http://example.com/data.php?callback=dosomething得到的js文件，就是我们之前定义的dosomething函数,并且它的参数就是我们需要的json数据，这样我们就跨域获得了我们需要的数据。</a></p>
<p>这样jsonp的原理就很清楚了，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。</p>
<p>知道jsonp跨域的原理后我们就可以用js动态生成script标签来进行跨域操作了，而不用特意的手动的书写那些script标签。如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">scirpt</span>&gt;</span></div><div class="line">$.getJSON('http://example.com/data.php?callback=?',function(jsondata)&#123;</div><div class="line">    ////处理获得的json数据</div><div class="line">&#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">scirpt</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>原理是一样的，只不过我们不需要手动的插入script标签以及定义回掉函数。jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>
<h1 id="通过XHR2"><a href="#通过XHR2" class="headerlink" title="通过XHR2"></a>通过XHR2</h1><p>HTML5中提供的XMLHTTPREQUEST Level2（及XHR2）已经实现了跨域访问。但ie10以下不支持<br>只需要在服务端填上响应头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">header(&quot;Access-Control-Allow-Origin:*&quot;);</div><div class="line">/*星号表示所有的域都可以接受，*/</div><div class="line">header(&quot;Access-Control-Allow-Methods:GET,POST&quot;);</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascirpt </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用cglib生成的代理类取不到注解的问题]]></title>
      <url>/2014/07/19/java-cglib/</url>
      <content type="html"><![CDATA[<blockquote>
<p>经常用cglib来创建代理类来实现aop的功能，可是，当想用反射来取得代理类所代理的类的注解的时候，却怎么也取不到。。。。</p>
</blockquote>
<a id="more"></a>
<p>然后搜了下stackoverflow，<a href="http://stackoverflow.com/questions/1706751/retain-annotations-on-cglib-proxies" target="_blank" rel="external">http://stackoverflow.com/questions/1706751/retain-annotations-on-cglib-proxies</a><br>用<code>@Inherited</code>,注解自己的注解（绕~~）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后用这个注解注解你要代理的类，那样通过反射可以拿到被代理的注解。<br>原来CGLIB 返回的代理类是被代理的类的子类，加上这个标志就可以令子类继承这个注解，<code>@Inherited</code> 字面意思就是有继承的意思。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[maven resource 记录]]></title>
      <url>/2014/02/20/maven-resouce/</url>
      <content type="html"><![CDATA[<blockquote>
<p>今天遇到maven打包的时候发现在main/java里面的xml没有打包进jar上。</p>
</blockquote>
<a id="more"></a>
<p>上网搜了下，maven默认打包main/resource的资源，要想打包main/java的要像下面这样配。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">resources</span>&gt;</span> </div><div class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span> </div><div class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span> </div><div class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span> </div><div class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span> </div><div class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span> </div><div class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.tld<span class="tag">&lt;/<span class="name">include</span>&gt;</span> </div><div class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span> </div><div class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span> </div><div class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;/<span class="name">resources</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>搞定收工。。。不知道有没有更好到方法呢？</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jenkins + git+maven做持续集成]]></title>
      <url>/2014/02/20/jenkins-jenkins-git-maven/</url>
      <content type="html"><![CDATA[<p>1.下个jenkins，官网去下 <a href="http://jenkins-ci.org/，里面提供war包下载，直接部署到tomcat什么上面吧。" target="_blank" rel="external">http://jenkins-ci.org/，里面提供war包下载，直接部署到tomcat什么上面吧。</a><br><a id="more"></a><br>2.部署成功后打开网站例如：<a href="http://localhost/jenkin，默认是不带git的插件的，所以先去下一个先，点击主页的右侧“系统管理”=&gt;&quot;管理插件&quot;=&gt;“可选插件”" target="_blank" rel="external">http://localhost/jenkin，默认是不带git的插件的，所以先去下一个先，点击主页的右侧“系统管理”=&gt;&quot;管理插件&quot;=&gt;“可选插件”</a> 找到”git plungin” 然后点击直接安装。（这可能要花点时间）<br>3.下完git插件后就要配环境了，还是点击右侧“系统管理”=&gt;“系统设置” 主要配jdk和maven的环境。（把自动安装勾掉就可以输路径了），保存下就可以了。<br><a href="/images/jenkins-git-maven-1.png"><img src="/images/jenkins-git-maven-1.png" alt=""></a><br><a href="/images/jenkins-git-maven-2.png"><img src="/images/jenkins-git-maven-2.png" alt=""></a> </p>
<p>4.点击右侧“新建”=&gt;“构建一个maven项目” 输入名字到下一步<br>如下图勾上“丢弃旧的构建”，按照自己的需要配置，否则很占硬盘。<br><a href="/images/jenkins-git-maven-3.png"><img src="/images/jenkins-git-maven-3.png" alt=""></a><br>配置git仓库（如果是私有库，必须添加一个Credentials，点击右侧Add，在弹出界面录入帐号密码）<br><a href="/images/jenkins-git-maven-4.png"><img src="/images/jenkins-git-maven-4.png" alt=""></a><br>接下来配置定时构建（勾上Build periodically,图中设置是每15分钟一次），配置要执行的maven命令 clean install (mvn不用输)<br><a href="/images/jenkins-git-maven-5.png"><img src="/images/jenkins-git-maven-5.png" alt=""></a><br>保存后，一个构建就可以了（可以立即构建试试，也可以定时执行）。jenkins提供了一堆的页面去展示构建的过程，很不错。<br>如果web程序想自动部署到本地的tomcat，可以试下cargo插件，加上下面代码到项目pom上。下面代码改下路径就可以了。当然也可以部署到远程，就不贴了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.cargo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cargo-maven2-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">container</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">containerId</span>&gt;</span>tomcat7x<span class="tag">&lt;/<span class="name">containerId</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">home</span>&gt;</span>/opt/apache-tomcat-7.0.47<span class="tag">&lt;/<span class="name">home</span>&gt;</span></div><div class="line">					<span class="tag">&lt;/<span class="name">container</span>&gt;</span></div><div class="line">					<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">type</span>&gt;</span>existing<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">						<span class="tag">&lt;<span class="name">home</span>&gt;</span>/opt/apache-tomcat-7.0.47<span class="tag">&lt;/<span class="name">home</span>&gt;</span></div><div class="line">					<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">				<span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>tomcat-deploy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span><span class="tag">&lt;<span class="name">goal</span>&gt;</span>deploy<span class="tag">&lt;/<span class="name">goal</span>&gt;</span><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>	</div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这样一个持续集成就配好了。想想那边提交代码，另一边就自动部署到tomcat上，爽歪歪了。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jenkins </tag>
            
            <tag> git </tag>
            
            <tag> maven </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[find 命令]]></title>
      <url>/2014/02/14/linux-find/</url>
      <content type="html"><![CDATA[<blockquote>
<p>mark一下，当笔记，以后忘了查看</p>
</blockquote>
<a id="more"></a>
<p>查找文件<br>find ./ -type f</p>
<p>查找目录<br>find ./ -type d</p>
<p>查找名字为test的文件或目录<br>find ./ -name test</p>
<p>查找名字符合正则表达式的文件,注意前面的‘.<em>’(查找到的文件带有目录)<br>find ./ -regex .</em>so.*.gz</p>
<p>查找目录并列出目录下的文件(为找到的每一个目录单独执行ls命令，没有选项-print时文件列表前一行不会显示目录名称)<br>find ./ -type d -print -exec ls {} \;</p>
<p>查找目录并列出目录下的文件(为找到的每一个目录单独执行ls命令,执行命令前需要确认)<br>find ./ -type d -ok ls {} \;</p>
<p>查找目录并列出目录下的文件(将找到的目录添加到ls命令后一次执行，参数过长时会分多次执行)<br>find ./ -type d -exec ls {} +</p>
<p>查找文件名匹配<em>.c的文件<br>find ./ -name \</em>.c</p>
<p>打印test文件名后，打印test文件的内容<br>find ./ -name test -print -exec cat {} \;</p>
<p>不打印test文件名，只打印test文件的内容<br>find ./ -name test -exec cat {} \;</p>
<p>查找文件更新日时在距现在时刻二天以内的文件<br>find ./ -mtime -2</p>
<p>查找文件更新日时在距现在时刻二天以上的文件<br>find ./ -mtime +2</p>
<p>查找文件更新日时在距现在时刻一天以上二天以内的文件<br>find ./ -mtime 2</p>
<p>查找文件更新日时在距现在时刻二分以内的文件<br>find ./ -mmin -2</p>
<p>查找文件更新日时在距现在时刻二分以上的文件<br>find ./ -mmin +2</p>
<p>查找文件更新日时在距现在时刻一分以上二分以内的文件<br>find ./ -mmin 2</p>
<p>查找文件更新时间比文件abc的内容更新时间新的文件<br>find ./ -newer abc</p>
<p>查找文件访问时间比文件abc的内容更新时间新的文件<br>find ./ -anewer abc</p>
<p>查找空文件或空目录<br>find ./ -empty</p>
<p>查找空文件并删除<br>find ./ -empty -type f -print -delete</p>
<p>查找权限为644的文件或目录(需完全符合)<br>find ./ -perm 664</p>
<p>查找用户/组权限为读写，其他用户权限为读(其他权限不限)的文件或目录<br>find ./ -perm -664</p>
<p>查找用户有写权限或者组用户有写权限的文件或目录<br>find ./ -perm /220<br>find ./ -perm /u+w,g+w<br>find ./ -perm /u=w,g=w</p>
<p>查找所有者权限有读权限的目录或文件<br>find ./ -perm -u=r</p>
<p>查找用户组权限有读权限的目录或文件<br>find ./ -perm -g=r</p>
<p>查找其它用户权限有读权限的目录或文件<br>find ./ -perm -o=r</p>
<p>查找所有者为lzj的文件或目录<br>find ./ -user lzj</p>
<p>查找组名为gname的文件或目录<br>find ./ -group gname</p>
<p>查找文件的用户ID不存在的文件<br>find ./ -nouser</p>
<p>查找文件的组ID不存在的文件<br>find ./ -nogroup</p>
<p>查找有执行权限但没有可读权限的文件<br>find ./ -executable ! -readable</p>
<p>查找文件size小于10个字节的文件或目录<br>find ./ -size -10c</p>
<p>查找文件size等于10个字节的文件或目录<br>find ./ -size 10c</p>
<p>查找文件size大于10个字节的文件或目录<br>find ./ -size +10c</p>
<p>查找文件size小于10k的文件或目录<br>find ./ -size -10k</p>
<p>查找文件size小于10M的文件或目录<br>find ./ -size -10M</p>
<p>查找文件size小于10G的文件或目录<br>find ./ -size -10G</p>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> find </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[crontab 命令]]></title>
      <url>/2014/02/13/linux-crontab/</url>
      <content type="html"><![CDATA[<p>一般编写调度让系统帮你定时做事情有两种方式：</p>
<ul>
<li>在<code>/etc</code>目录下有一个<code>crontab</code>文件，这里存放有<code>系统</code>运行的一些调度程序,可以把自己的调度写在这里。</li>
<li>每个用户可以用<code>crontab</code>命令建立自己的调度,调度文件存放在以用户名为名的文件<code>/usr/spool/cron/crontabs/username</code>。 </li>
</ul>
<a id="more"></a>
<p><code>crontab</code>命令有三种形式的命令行结构： </p>
<ul>
<li>crontab [-u user] [file]  </li>
<li>crontab [-u user] [-e|-l|-r]  </li>
<li>crontab -l -u [-e|-l|-r] </li>
</ul>
<p>第一个命令行中，<code>file</code>是命令文件的名字。如果在命令行中指定了这个文件，那么执行<code>crontab</code>命令，则将这个文件拷贝到<code>crontabs</code>目录下；如果在命令行中没有制定这个文件，<code>crontab</code>命令将接受标准输入（键盘）上键入的命令，并将他们也存放在<code>crontab</code>目录下。  </p>
<p>命令行中<code>-r</code>选项的作用是从<code>/usr/spool/cron/crontabs</code>目录下删除用户定义的文件crontab；  </p>
<p>命令行中<code>-l</code>选项的作用是显示用户<code>crontab</code>文件的内容。  </p>
<p>使用命令<code>crontab -u user -e</code>命令编辑用户user的cron(c)作业。用户通过编辑文件来增加或修改任何作业请求。  </p>
<p>执行命令<code>crontab -u user -r</code>即可删除当前用户的所有的cron作业。  </p>
<p>作业与它们预定的时间储存在文件<code>/usr/spool/cron/crontabs/username</code>里。username使用户名，在相应的文件中存放着该用户所要运行的命令。命令执行的结果，无论是标准输出还是错误输出，都将以邮件形式发给用户。文件里的每一个请求必须包含以spaces和tabs分割的六个域。前五个字段可以取整数值，指定何时开始工作，第六个域是字符串，称为命令字段，其中包括了crontab调度执行的命令。  </p>
<p>第一道第五个字段的整数取值范围及意义是：  </p>
<ul>
<li>0～59 表示分  </li>
<li>1～23 表示小时  </li>
<li>1～31 表示日  </li>
<li>1～12 表示月份  </li>
<li>0～6 表示星期（其中0表示星期日）  </li>
</ul>
<p><code>/usr/lib/cron/cron.allow</code>表示谁能使用<code>crontab</code>命令。如果它是一个空文件表明没有一个用户能安排作业。如果这个文件不存在，而有另外一个文件<code>/usr/lib/cron/cron.deny</code>,则只有不包括在这个文件中的用户才可以使用<code>crontab</code>命令。如果它是一个空文件表明任何用户都可安排作业。两个文件同时存在时<code>cron.allow</code>优先，如果都不存在，只有超级用户可以安排作业。 </p>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> crontab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery.extend 函数详解]]></title>
      <url>/2014/02/05/jquery-extend/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Jquery的扩展方法extend是我们在写插件的过程中常用的方法，该方法有一些重载原型，在此，我们一起去了解了解。 </p>
</blockquote>
<a id="more"></a>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>Jquery的扩展方法原型是:　　　<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extend(dest,src1,src2,src3...);</div></pre></td></tr></table></figure></p>
<p>它的含义是将src1,src2,src3…合并到dest中,返回值为合并后的dest,由此可以看出该方法合并后，是修改了dest的结构的。如果想要得到合并的结果却又不想修改dest的结构，可以如下使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newSrc=$.extend(&#123;&#125;,src1,src2,src3...)<span class="comment">//也就是将"&#123;&#125;"作为dest参数。</span></div></pre></td></tr></table></figure></p>
<p>这样就可以将src1,src2,src3…进行合并，然后将合并结果返回给newSrc了。如下例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result=$.extend(&#123;&#125;,&#123;<span class="attr">name</span>:<span class="string">"Tom"</span>,<span class="attr">age</span>:<span class="number">21</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">"Jerry"</span>,<span class="attr">sex</span>:<span class="string">"Boy"</span>&#125;)</div></pre></td></tr></table></figure></p>
<p>那么合并后的结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result=&#123;<span class="attr">name</span>:<span class="string">"Jerry"</span>,<span class="attr">age</span>:<span class="number">21</span>,<span class="attr">sex</span>:<span class="string">"Boy"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>也就是说后面的参数如果和前面的参数存在相同的名称，那么后面的会覆盖前面的参数值。 </p>
<h1 id="省略dest参数"><a href="#省略dest参数" class="headerlink" title="省略dest参数"></a>省略dest参数</h1><p>上述的extend方法原型中的dest参数是可以省略的，如果省略了，则该方法就只能有一个src参数，而且是将该src合并到调用extend方法的对象中去，如： </p>
<h2 id="extend-src"><a href="#extend-src" class="headerlink" title="$.extend(src)"></a>$.extend(src)</h2><p>该方法就是将src合并到jquery的全局对象中去，如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.extend(&#123;</div><div class="line">  <span class="attr">hello</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'hello'</span>);&#125;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<p>就是将hello方法合并到jquery的全局对象中。 </p>
<h2 id="fn-extend-src"><a href="#fn-extend-src" class="headerlink" title="$.fn.extend(src)"></a>$.fn.extend(src)</h2><p>该方法将src合并到jquery的实例对象中去，如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.fn.extend(&#123;</div><div class="line">  <span class="attr">hello</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'hello'</span>);&#125;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure></p>
<p>就是将hello方法合并到jquery的实例对象中。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.extend(&#123;<span class="attr">net</span>:&#123;&#125;&#125;);</div><div class="line"><span class="string">``</span><span class="string">``</span> </div><div class="line">这是在jquery全局对象中扩展一个net命名空间。 </div><div class="line"><span class="string">``</span><span class="string">``</span>javascript</div><div class="line">$.extend($.net,&#123;</div><div class="line">   <span class="attr">hello</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'hello'</span>);&#125;</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<p>这是将hello方法扩展到之前扩展的Jquery的net命名空间中去。</p>
<h1 id="Jquery的extend方法还有一个重载原型"><a href="#Jquery的extend方法还有一个重载原型" class="headerlink" title="Jquery的extend方法还有一个重载原型"></a>Jquery的extend方法还有一个重载原型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">extend(boolean,dest,src1,src2,src3...)</div><div class="line">```` </div><div class="line">第一个参数boolean代表是否进行深度拷贝，其余参数和前面介绍的一致，什么叫深层拷贝，我们看一个例子： </div><div class="line">````javascript</div><div class="line">var result=$.extend( true,  &#123;&#125;,  </div><div class="line">    &#123; name: &quot;John&quot;, location: &#123;city: &quot;Boston&quot;,county:&quot;USA&quot;&#125; &#125;,  </div><div class="line">    &#123; last: &quot;Resig&quot;, location: &#123;state: &quot;MA&quot;,county:&quot;China&quot;&#125; &#125; );</div></pre></td></tr></table></figure>
<p>我们可以看出src1中嵌套子对象location:{city:”Boston”},src2中也嵌套子对象location:{state:”MA”},第一个深度拷贝参数为true，那么合并后的结果就是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">result=&#123;<span class="attr">name</span>:<span class="string">"John"</span>,<span class="attr">last</span>:<span class="string">"Resig"</span>,</div><div class="line">        <span class="attr">location</span>:&#123;<span class="attr">city</span>:<span class="string">"Boston"</span>,<span class="attr">state</span>:<span class="string">"MA"</span>,<span class="attr">county</span>:<span class="string">"China"</span>&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>也就是说它会将src中的嵌套子对象也进行合并，而如果第一个参数boolean为false，我们看看合并的结果是什么，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result=$.extend( <span class="literal">false</span>, &#123;&#125;,  </div><div class="line">&#123; <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">location</span>:&#123;<span class="attr">city</span>: <span class="string">"Boston"</span>,<span class="attr">county</span>:<span class="string">"USA"</span>&#125; &#125;,  </div><div class="line">&#123; <span class="attr">last</span>: <span class="string">"Resig"</span>, <span class="attr">location</span>: &#123;<span class="attr">state</span>: <span class="string">"MA"</span>,<span class="attr">county</span>:<span class="string">"China"</span>&#125; &#125;  </div><div class="line">                    );</div></pre></td></tr></table></figure></p>
<p>那么合并后的结果就是:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result=&#123;<span class="attr">name</span>:<span class="string">"John"</span>,<span class="attr">last</span>:<span class="string">"Resig"</span>,<span class="attr">location</span>:&#123;<span class="attr">state</span>:<span class="string">"MA"</span>,<span class="attr">county</span>:<span class="string">"China"</span>&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>以上就是$.extend()在项目中经常会使用到的一些细节。</p>
]]></content>
      
        <categories>
            
            <category> jQuery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于jQuery新的事件绑定机制on()的使用技巧]]></title>
      <url>/2014/01/11/jquery-on/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本篇文章介绍了，关于jQuery新的事件绑定机制on()的使用技巧。需要的朋友参考下<br>今天浏览jQuery的deprecated列表，发现live()和die()在里面了，赶紧看了一下，发现从jQuery1.7开始，jQuery引入了全新的事件绑定机制，on()和off()两个函数统一处理事件绑定。因为在此之前有bind(), live(), delegate()等方法来处理事件绑定，jQuery从性能优化以及方式统一方面考虑决定推出新的函数来统一事件绑定方法并且替换掉以前的方法。</p>
</blockquote>
<a id="more"></a>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">on(events,[selector],[data],fn)</div></pre></td></tr></table></figure>
<p>events:一个或多个用空格分隔的事件类型和可选的命名空间，如”click”或”keydown.myPlugin” 。<br>selector:一个选择器字符串用于过滤器的触发事件的选择器元素的后代。如果选择器为null或省略，当它到达选定的元素，事件总是触发。<br>data:当一个事件被触发时要传递event.data给事件处理函数。<br>fn:该事件被触发时执行的函数。 false 值也可以做一个函数的简写，返回false。</p>
<h1 id="替换bind"><a href="#替换bind" class="headerlink" title="替换bind()"></a>替换bind()</h1><p>当第二个参数’selector’为null时，on()和bind()其实在用法上基本上没有任何区别了，所以我们可以认为on()只是比bind()多了一个可选的’selector’参数，所以on()可以非常方便的换掉bind()</p>
<h1 id="替换live"><a href="#替换live" class="headerlink" title="替换live()"></a>替换live()</h1><p>在1.4之前相信大家非常喜欢使用live(),因为它可以把事件绑定到当前以及以后添加的元素上面，当然在1.4之后delegate()也可以做类似的事情了。live()的原理很简单，它是通过document进行事件委派的，因此我们也可以使用on()通过将事件绑定到document来达到live()一样的效果。</p>
<p>live()写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> $(<span class="string">'#list li'</span>).live(<span class="string">'click'</span>, <span class="string">'#list li'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">     <span class="comment">//function code here. </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>on()写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'#list li'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//function code here.</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这里的关键就是第二个参数’selector’在起作用了。它是一个过滤器的作用，只有被选中元素的后代元素才会触发事件。</p>
<h1 id="替换delegate"><a href="#替换delegate" class="headerlink" title="替换delegate()"></a>替换delegate()</h1><p>delegate()是1.4引入的，目的是通过祖先元素来代理委派后代元素的事件绑定问题，某种程度上和live()优点相似。只不过live()是通过document元素委派，而delegate则可以是任意的祖先节点。使用on()实现代理的写法和delegate()基本一致。</p>
<p>delegate()的写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#list'</span>).delegate(<span class="string">'li'</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="comment">//function code here. </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>on()写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#list'</span>).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//function code here.</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>貌似第一个和第二个参数的顺序颠倒了一下，别的基本一样。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>jQuery推出on()的目的有2个，一是为了统一接口，二是为了提高性能，所以从现在开始用on()替换bind(), live(), delegate吧。尤其是不要再用live()了，因为它已经处于不推荐使用列表了，随时会被干掉。如果只绑定一次事件，那接着用one()吧，这个没有变化。</p>
]]></content>
      
        <categories>
            
            <category> jQuery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux awk命令详解]]></title>
      <url>/2014/01/06/linux-awk/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>
<p>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</p>
<p>awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。<br><a id="more"></a></p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;pattern + action&#125;&apos; &#123;filenames&#125;</div></pre></td></tr></table></figure>
<p>尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。</p>
<p>awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。</p>
<p>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</p>
<h1 id="调用awk"><a href="#调用awk" class="headerlink" title="调用awk"></a>调用awk</h1><p>有三种方式调用awk</p>
<p>1.命令行方式<br>awk [-F  field-separator]  ‘commands’  input-file(s)<br>其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。<br>在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。</p>
<p>2.shell脚本方式<br>将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。<br>相当于shell脚本首行的：#!/bin/sh<br>可以换成：#!/bin/awk</p>
<p>3.将所有的awk命令插入一个单独文件，然后调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk -f awk-script-file input-file(s)</div></pre></td></tr></table></figure></p>
<p>其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。</p>
<p>本章重点介绍命令行方式。</p>
<h1 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h1><p>假设last -n 5的输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@www ~]# last -n 5 &lt;==仅取出前五行</div><div class="line">root     pts/1   192.168.1.100  Tue Feb 10 11:21   still logged in</div><div class="line">root     pts/1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)</div><div class="line">root     pts/1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)</div><div class="line">dmtsai   pts/1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)</div><div class="line">root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)</div></pre></td></tr></table></figure>
<p>如果只是显示最近登录的5个帐号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#last -n 5 | awk  &apos;&#123;print $1&#125;&apos;</div><div class="line">root</div><div class="line">root</div><div class="line">root</div><div class="line">dmtsai</div><div class="line">root</div></pre></td></tr></table></figure>
<p>awk工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”,所以$1表示登录用户，$3表示登录用户ip,以此类推。</p>
<p>如果只是显示/etc/passwd的账户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#cat /etc/passwd |awk  -F &apos;:&apos;  &apos;&#123;print $1&#125;&apos;  </div><div class="line">root</div><div class="line">daemon</div><div class="line">bin</div><div class="line">sys</div></pre></td></tr></table></figure>
<p>这种是awk+action的示例，每行都会执行action{print $1}。</p>
<p>-F指定域分隔符为’:’。</p>
<p>如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab键分割</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#cat /etc/passwd |awk  -F &apos;:&apos;  &apos;&#123;print $1&quot;\t&quot;$7&#125;&apos;</div><div class="line">root    /bin/bash</div><div class="line">daemon  /bin/sh</div><div class="line">bin     /bin/sh</div><div class="line">sys     /bin/sh</div></pre></td></tr></table></figure>
<p>如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以逗号分割,而且在所有行添加列名name,shell,在最后一行添加”blue,/bin/nosh”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cat /etc/passwd |awk  -F &apos;:&apos;  &apos;BEGIN &#123;print &quot;name,shell&quot;&#125;  &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,/bin/nosh&quot;&#125;&apos;</div><div class="line">name,shell</div><div class="line">root,/bin/bash</div><div class="line">daemon,/bin/sh</div><div class="line">bin,/bin/sh</div><div class="line">sys,/bin/sh</div><div class="line">....</div><div class="line">blue,/bin/nosh</div></pre></td></tr></table></figure>
<p>awk工作流程是这样的：先执行BEGING，然后读取文件，读入有/n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域， $0则表示所有域,$1表示第一个域,$n表示第n个域 ,随后开始执行模式所对应的动作action。接着开始读入第二条记录······直到所有的记录都读完，最后执行END操作。 </p>
<p>搜索/etc/passwd有root关键字的所有行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#awk -F: &apos;/root/&apos; /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div></pre></td></tr></table></figure>
<p>这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。</p>
<p>搜索支持正则，例如找root开头的: awk -F: ‘/^root/‘ /etc/passwd</p>
<p>搜索/etc/passwd有root关键字的所有行，并显示对应的shell </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># awk -F: &apos;/root/&#123;print $7&#125;&apos; /etc/passwd             </div><div class="line">/bin/bash</div></pre></td></tr></table></figure>
<p>这里指定了action{print $7}</p>
<h1 id="awk内置变量"><a href="#awk内置变量" class="headerlink" title="awk内置变量"></a>awk内置变量</h1><p>awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出了最常用的一些变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ARGC               命令行参数个数</div><div class="line">ARGV               命令行参数排列</div><div class="line">ENVIRON            支持队列中系统环境变量的使用</div><div class="line">FILENAME           awk浏览的文件名</div><div class="line">FNR                浏览文件的记录数</div><div class="line">FS                 设置输入域分隔符，等价于命令行 -F选项</div><div class="line">NF                 浏览记录的域的个数</div><div class="line">NR                 已读的记录数</div><div class="line">OFS                输出域分隔符</div><div class="line">ORS                输出记录分隔符</div><div class="line">RS                 控制记录分隔符</div></pre></td></tr></table></figure>
<p>此外, $0变量是指整条记录。$1表示当前行的第一个域,$2表示当前行的第二个域,……以此类推。</p>
<p>统计/etc/passwd:文件名，每行的行号，每行的列数，对应的完整行内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#awk  -F &apos;:&apos;  &apos;&#123;print &quot;filename:&quot; FILENAME &quot;,linenumber:&quot; NR &quot;,columns:&quot; NF &quot;,linecontent:&quot;$0&#125;&apos; /etc/passwd</div><div class="line">filename:/etc/passwd,linenumber:1,columns:7,linecontent:root:x:0:0:root:/root:/bin/bash</div><div class="line">filename:/etc/passwd,linenumber:2,columns:7,linecontent:daemon:x:1:1:daemon:/usr/sbin:/bin/sh</div><div class="line">filename:/etc/passwd,linenumber:3,columns:7,linecontent:bin:x:2:2:bin:/bin:/bin/sh</div><div class="line">filename:/etc/passwd,linenumber:4,columns:7,linecontent:sys:x:3:3:sys:/dev:/bin/sh</div></pre></td></tr></table></figure>
<p>使用printf替代print,可以让代码更加简洁，易读</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk  -F &apos;:&apos;  &apos;&#123;printf(&quot;filename:%10s,linenumber:%s,columns:%s,linecontent:%s\n&quot;,FILENAME,NR,NF,$0)&#125;&apos; /etc/passwd</div></pre></td></tr></table></figure>
<h1 id="print和printf"><a href="#print和printf" class="headerlink" title="print和printf"></a>print和printf</h1><p>awk中同时提供了print和printf两种打印输出的函数。</p>
<p>其中print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。</p>
<p>printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂。</p>
<h1 id="awk编程"><a href="#awk编程" class="headerlink" title="awk编程"></a>awk编程</h1><p> 变量和赋值</p>
<p>除了awk的内置变量，awk还可以自定义变量。</p>
<p>下面统计/etc/passwd的账户人数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">awk &apos;&#123;count++;print $0;&#125; END&#123;print &quot;user count is &quot;, count&#125;&apos; /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">......</div><div class="line">user count is  40</div></pre></td></tr></table></figure></p>
<p>count是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。</p>
<p>这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">awk &apos;BEGIN &#123;count=0;print &quot;[start]user count is &quot;, count&#125; &#123;count=count+1;print $0;&#125; END&#123;print &quot;[end]user count is &quot;, count&#125;&apos; /etc/passwd</div><div class="line">[start]user count is  0</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">...</div><div class="line">[end]user count is  40</div></pre></td></tr></table></figure>
<p>统计某个文件夹下的文件占用的字节数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls -l |awk &apos;BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print &quot;[end]size is &quot;, size&#125;&apos;</div><div class="line">[end]size is  8657198</div></pre></td></tr></table></figure></p>
<p>如果以M为单位显示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls -l |awk &apos;BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print &quot;[end]size is &quot;, size/1024/1024,&quot;M&quot;&#125;&apos; </div><div class="line">[end]size is  8.25889 M</div></pre></td></tr></table></figure></p>
<p>注意，统计不包括文件夹的子目录。</p>
<p>条件语句<br>awk中的条件语句是从C语言中借鉴来的，见如下声明方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">if (expression) &#123;</div><div class="line">    statement;</div><div class="line">    statement;</div><div class="line">    ... ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (expression) &#123;</div><div class="line">    statement;</div><div class="line">&#125; else &#123;</div><div class="line">    statement2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (expression) &#123;</div><div class="line">    statement1;</div><div class="line">&#125; else if (expression1) &#123;</div><div class="line">    statement2;</div><div class="line">&#125; else &#123;</div><div class="line">    statement3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>统计某个文件夹下的文件占用的字节数,过滤4096大小的文件(一般都是文件夹):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls -l |awk &apos;BEGIN &#123;size=0;print &quot;[start]size is &quot;, size&#125; &#123;if($5!=4096)&#123;size=size+$5;&#125;&#125; END&#123;print &quot;[end]size is &quot;, size/1024/1024,&quot;M&quot;&#125;&apos; </div><div class="line">[end]size is  8.22339 M</div></pre></td></tr></table></figure></p>
<p>循环语句</p>
<p>awk中的循环语句同样借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同。</p>
<p>数组</p>
<p>  因为awk中数组的下标可以是数字和字母，数组的下标通常被称为关键字(key)。值和关键字都存储在内部的一张针对key/value应用hash的表格里。由于hash不是顺序存储，因此在显示数组内容时会发现，它们并不是按照你预料的顺序显示出来的。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等。</p>
<p>显示/etc/passwd的账户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">awk -F &apos;:&apos; &apos;BEGIN &#123;count=0;&#125; &#123;name[count] = $1;count++;&#125;; END&#123;for (i = 0; i &lt; NR; i++) print i, name[i]&#125;&apos; /etc/passwd</div><div class="line">root</div><div class="line">daemon</div><div class="line">bin</div><div class="line">sys</div><div class="line">sync</div><div class="line">games</div><div class="line">......</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> awk </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux sed命令详解]]></title>
      <url>/2014/01/05/linux-sed/</url>
      <content type="html"><![CDATA[<p>功能说明：</p>
<p>利用script来处理文本文件。 </p>
<p>语　　法：</p>
<p>sed [-hnV][-e script][-f script文件][文本文件]<br><a id="more"></a></p>
<p>补充说明：</p>
<p>sed可依照script的指令，来处理、编辑文本文件。 </p>
<p>参　　数：<br>-e script或—expression=script   以选项中指定的script来处理输入的文本文件。<br>-f script文件或—file=script文件   以选项中指定的script文件来处理输入的文本文件。<br>-h或—help 显示帮助。<br>-n或—quiet或–silent 仅显示script处理后的结果。<br>-V或—version 显示版本信息。  </p>
<p>例      子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e <span class="string">'s/123/1234/'</span> a.txt</div></pre></td></tr></table></figure></p>
<p>将a.txt文件中所有行中的123用1234替换（-e表示命令以命令行的方式执行；参数s，表示执行替换操作） </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e <span class="string">'3,5 a4'</span> a.txt</div></pre></td></tr></table></figure>
<p>将a.txt文件中的3行到5行之间所有行的后面添加一行内容为4的行（参数a，表示添加行，参数a后面指定添加的内容） </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e <span class="string">'1 s/12/45/'</span> a.txt</div></pre></td></tr></table></figure>
<p>把第一行的12替换成45 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -i <span class="string">"s/oldstring/newstring/g"</span> `grep oldstring -rl yourdir`</div></pre></td></tr></table></figure>
<p>批量处理通过grep搜索出来的所有文档，将这些文档中所有的oldstring用newstring替换（-i参数表示直接对目标文件操作） </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -n <span class="string">'s/^test/mytest/p'</span> example.file</div></pre></td></tr></table></figure>
<p>(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。(^这是正则表达式中表示开头，该符号后面跟的就是开头的字符串)（参数p表示打印行） </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'s/^wangpan/&amp;19850715/'</span> example.file</div></pre></td></tr></table></figure>
<p>表示被替换换字符串被找到后，被替换的字符串通过＆符号连接给出的字符串组成新字符传替换被替换的字符串,所有以wangpan开头的行都会被替换成它自已加19850715，变成wangpan19850715 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -n <span class="string">'s/\(love\)able/\1rs/p'</span> example.file</div></pre></td></tr></table></figure>
<p>love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。需要将这条命令分解，s/是表示替换操作，(love)表示选中love字符串，(love)able/表示包含loveable的行，(love)able/\l表示love字符串标记为1，表示在替换过程中不变。rs/表示替换的目标字符串。这条命令的操作含义：只打印替换了的行 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'s#10#100#g'</span> example.file</div></pre></td></tr></table></figure>
<p>不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -n <span class="string">'/love/,/unlove/p'</span> example.file</div></pre></td></tr></table></figure>
<p>只打印包含love字符串行到包含unlove字符串行之间的所有行（确定行的范围就是通过逗号实现的） </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -n <span class="string">'5,/^wang/p'</span> example</div></pre></td></tr></table></figure>
<p>只打印从第五行开始到第一个包含以wang开始的行之间的所有行 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'/love/,/unlove/s/$/wangpan/'</span> example.file</div></pre></td></tr></table></figure>
<p>对于包含love字符串的行到包含unlove字符串之间的行，每行的末尾用字符串wangpan替换。<br>字符串$/表示以字符串结尾的行，$/表示每一行的结尾，s/$/wangpan/表示每一行的结尾添加wangpan字符串 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e <span class="string">'11,53d'</span> -e <span class="string">'s/wang/pan/'</span> example.file</div></pre></td></tr></table></figure>
<p>(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除11至53行，第二条命令用pan替换wang。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。(参数d，表示删除指定的行) </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed --expression=<span class="string">'s/wang/pan/'</span> --expression=<span class="string">'/love/d'</span> example.file</div></pre></td></tr></table></figure>
<p>一个比-e更好的命令是–expression。它能给sed表达式赋值。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'/wangpan/r file'</span> example.file</div></pre></td></tr></table></figure>
<p>file里的内容被读进来，显示在与wangpan匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。参数r，表示读出文件，后面空格紧跟文件名称 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -n <span class="string">'/test/w file'</span> example.file</div></pre></td></tr></table></figure>
<p>在example.file中所有包含test的行都被写入file里。参数w，表示将匹配的行写入到指定的文件file中 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'/^test/a\oh! My god!'</span> example.file</div></pre></td></tr></table></figure>
<p>‘oh! My god!’被追加到以test开头的行的后面，sed要求参数a后面有一个反斜杠。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'/test/i\oh! My god!'</span> example.file</div></pre></td></tr></table></figure>
<p>‘oh! My god!’被追加到包含test字符串行的前面，参数i表示添加指定内容到匹配行的前面，sed要求参数i后面有一个反斜杠 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'/test/&#123; n; s/aa/bb/; &#125;'</span> example.file</div></pre></td></tr></table></figure>
<p>如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb。参数n，表示读取匹配行的下一个输入行，用下一个命令处理新的行而不是匹配行。Sed要求参数n后跟分号 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'1,10y/abcde/ABCDE/'</span> example.file</div></pre></td></tr></table></figure>
<p>把1—10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。参数y，表示把一个字符翻译为另外的字符（但是不用于正则表达式） </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -i <span class="string">'s/now/right now/g'</span> test_sed_command.txt</div></pre></td></tr></table></figure>
<p>表示直接操作文件test_sed_command.txt，将文件test_sed_command.txt中所有的now用right now替换。参数-i，表示直接操作修改文件，不输出。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed <span class="string">'2q'</span> test_sed_command.txt</div></pre></td></tr></table></figure>
<p>在打印完第2行后，就直接退出sed。参数q，表示退出 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e <span class="string">'/old/h'</span> -e <span class="string">'/girl-friend/G'</span> test_sed_command.txt</div></pre></td></tr></table></figure>
<p>首先了解参数h，拷贝匹配成功行的内容到内存中的缓冲区。在了解参数G，获得内存缓冲区的内容，并追加到当前模板块文本的后面。上面命令行的含义：将包含old字符串的行的内容保存在缓冲区中，然后将缓冲区的内容拿出来添加到包含girl-friend字符串行的后面。隐含要求搜集到缓冲区的匹配行在需要添加行的前面。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sed -e <span class="string">'/test/h'</span> -e <span class="string">'/wangpan/x'</span> example.file</div></pre></td></tr></table></figure>
<p>将包含test字符串的行的内容保存在缓冲区中，然后再将缓冲区的内容替换包含wangpan字符串的行。参数x，表示行替换操作。隐含要求搜集到缓冲区的匹配行在需要被替换行的前面。 </p>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> sed </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux grep命令详解]]></title>
      <url>/2014/01/04/linux-grep/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<p>Unix的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。<br><a id="more"></a></p>
<h1 id="grep常用用法"><a href="#grep常用用法" class="headerlink" title="grep常用用法"></a>grep常用用法</h1><p>grep [-acinv] [–color=auto] ‘搜寻字符串’ filename<br>选项与参数：<br>-a ：将 binary 文件以 text 文件的方式搜寻数据<br>-c ：计算找到 ‘搜寻字符串’ 的次数<br>-i ：忽略大小写的不同，所以大小写视为相同<br>-n ：顺便输出行号<br>-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！<br>–color=auto ：可以将找到的关键词部分加上颜色的显示喔！</p>
<p>将/etc/passwd，有出现 root 的行取出来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">grep root /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">operator:x:11:0:operator:/root:/sbin/nologin</div><div class="line">或</div><div class="line">cat /etc/passwd | grep root </div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">operator:x:11:0:operator:/root:/sbin/nologin</div></pre></td></tr></table></figure></p>
<p>将/etc/passwd，有出现 root 的行取出来,同时显示这些行在/etc/passwd的行号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep -n root /etc/passwd</div><div class="line">1:root:x:0:0:root:/root:/bin/bash</div><div class="line">30:operator:x:11:0:operator:/root:/sbin/nologin</div></pre></td></tr></table></figure></p>
<p>在关键字的显示方面，grep 可以使用 –color=auto 来将关键字部分使用颜色显示。 这可是个很不错的功能啊！但是如果每次使用 grep 都得要自行加上 –color=auto 又显的很麻烦～ 此时那个好用的 alias 就得来处理一下啦！你可以在 ~/.bashrc 内加上这行：<code>alias grep=&#39;grep --color=auto&#39;</code>再以<code>source ~/.bashrc</code>来立即生效即可喔！ 这样每次运行 grep 他都会自动帮你加上颜色显示啦</p>
<p>将/etc/passwd，将没有出现 root 的行取出来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep -v root /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">operator:x:11:0:operator:/root:/sbin/nologin</div></pre></td></tr></table></figure></p>
<p>将/etc/passwd，将没有出现 root 和nologin的行取出来<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep -v root /etc/passwd | grep -v nologin</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">operator:x:11:0:operator:/root:/sbin/nologin</div></pre></td></tr></table></figure></p>
<p>用 dmesg 列出核心信息，再以 grep 找出内含 eth 那行,要将捉到的关键字显色，且加上行号来表示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># dmesg | grep -n --color=auto 'eth'</span></div><div class="line">247:eth0: RealTek RTL8139 at 0xee846000, 00:90:cc:a6:34:84, IRQ 10</div><div class="line">248:eth0: Identified 8139 chip <span class="built_in">type</span> <span class="string">'RTL-8139C'</span></div><div class="line">294:eth0: link up, 100Mbps, full-duplex, lpa 0xC5E1</div><div class="line">305:eth0: no IPv6 routers present</div></pre></td></tr></table></figure></p>
<p>你会发现除了 eth 会有特殊颜色来表示之外，最前面还有行号喔！<br>在关键字的显示方面，grep 可以使用 –color=auto 来将关键字部分使用颜色显示。 这可是个很不错的功能啊！但是如果每次使用 grep 都得要自行加上 –color=auto 又显的很麻烦～ 此时那个好用的 alias 就得来处理一下啦！你可以在 ~/.bashrc 内加上这行：<code>alias grep=&#39;grep --color=auto&#39;</code>再以<code>source ~/.bashrc</code>来立即生效即可喔！ 这样每次运行 grep 他都会自动帮你加上颜色显示啦</p>
<p>用 dmesg 列出核心信息，再以 grep 找出内含 eth 那行,在关键字所在行的前两行与后三行也一起捉出来显示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># dmesg | grep -n -A3 -B2 --color=auto 'eth'</span></div><div class="line">245-PCI: setting IRQ 10 as level-triggered</div><div class="line">246-ACPI: PCI Interrupt 0000:00:0e.0[A] -&gt; Link [LNKB] ...</div><div class="line">247:eth0: RealTek RTL8139 at 0xee846000, 00:90:cc:a6:34:84, IRQ 10</div><div class="line">248:eth0: Identified 8139 chip <span class="built_in">type</span> <span class="string">'RTL-8139C'</span></div><div class="line">249-input: PC Speaker as /class/input/input2</div><div class="line">250-ACPI: PCI Interrupt 0000:00:01.4[B] -&gt; Link [LNKB] ...</div><div class="line">251-hdb: ATAPI 48X DVD-ROM DVD-R-RAM CD-R/RW drive, 2048kB Cache, UDMA(66)</div></pre></td></tr></table></figure></p>
<p>如上所示，你会发现关键字 247 所在的前两行及 248 后三行也都被显示出来！<br>这样可以让你将关键字前后数据捉出来进行分析啦！</p>
<p>根据文件内容递归查找目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep ‘energywise’ *           <span class="comment">#在当前目录搜索带'energywise'行的文件</span></div><div class="line">grep -r ‘energywise’ *        <span class="comment">#在当前目录及其子目录下搜索'energywise'行的文件</span></div><div class="line">grep -l -r ‘energywise’ *     <span class="comment">#在当前目录及其子目录下搜索'energywise'行的文件，但是不显示匹配的行，只显示匹配的文件</span></div></pre></td></tr></table></figure></p>
<h1 id="grep与正规表达式"><a href="#grep与正规表达式" class="headerlink" title="grep与正规表达式"></a>grep与正规表达式</h1><p>字符类</p>
<p>字符类的搜索：如果我想要搜寻 test 或 taste 这两个单字时，可以发现到，其实她们有共通的 ‘t?st’ 存在～这个时候，我可以这样来搜寻：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 't[ae]st' regular_express.txt</span></div><div class="line">8:I can<span class="string">'t finish the test.</span></div><div class="line">9:Oh! The soup taste good.</div></pre></td></tr></table></figure></p>
<p>其实 [] 里面不论有几个字节，他都谨代表某<code>一个</code>字节， 所以，上面的例子说明了，我需要的字串是<code>tast</code>或<code>test</code>两个字串而已！</p>
<p>字符类的反向选择 [^] ：如果想要搜索到有 oo 的行，但不想要 oo 前面有 g，如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '[^g]oo' regular_express.txt</span></div><div class="line">2:apple is my favorite food.</div><div class="line">3:Football game is not use feet only.</div><div class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>第 2,3 行没有疑问，因为 foo 与 Foo 均可被接受！</p>
<p>但是第 18 行明明有 google 的 goo 啊～别忘记了，因为该行后面出现了 tool 的 too 啊！所以该行也被列出来～ 也就是说， 18 行里面虽然出现了我们所不要的项目 (goo) 但是由於有需要的项目 (too) ， 因此，是符合字串搜寻的喔！</p>
<p>至於第 19 行，同样的，因为 goooooogle 里面的 oo 前面可能是 o ，例如： go(ooo)oogle ，所以，这一行也是符合需求的！</p>
<p>字符类的连续：再来，假设我 oo 前面不想要有小写字节，所以，我可以这样写 [^abcd….z]oo ， 但是这样似乎不怎么方便，由於小写字节的 ASCII 上编码的顺序是连续的， 因此，我们可以将之简化为底下这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '[^a-z]oo' regular_express.txt</span></div><div class="line">3:Football game is not use feet only.</div></pre></td></tr></table></figure></p>
<p>也就是说，当我们在一组集合字节中，如果该字节组是连续的，例如大写英文/小写英文/数字等等， 就可以使用[a-z],[A-Z],[0-9]等方式来书写，那么如果我们的要求字串是数字与英文呢？ 呵呵！就将他全部写在一起，变成：[a-zA-Z0-9]。</p>
<p>我们要取得有数字的那一行，就这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '[0-9]' regular_express.txt</span></div><div class="line">5:However, this dress is about $ 3183 dollars.</div><div class="line">15:You are the best is mean you are the no. 1.</div></pre></td></tr></table></figure></p>
<p>行首与行尾字节 ^ $<br>行首字符：如果我想要让 the 只在行首列出呢？ 这个时候就得要使用定位字节了！我们可以这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '^the' regular_express.txt</span></div><div class="line">12:the symbol <span class="string">'*'</span> is represented as start.</div></pre></td></tr></table></figure></p>
<p>此时，就只剩下第 12 行，因为只有第 12 行的行首是 the 开头啊～此外， 如果我想要开头是小写字节的那一行就列出呢？可以这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '^[a-z]' regular_express.txt</span></div><div class="line">2:apple is my favorite food.</div><div class="line">4:this dress doesn<span class="string">'t fit me.</span></div><div class="line">10:motorcycle is cheap than car.</div><div class="line">12:the symbol '*<span class="string">' is represented as start.</span></div><div class="line">18:google is the best tools for search keyword.</div><div class="line">19:goooooogle yes!</div><div class="line">20:go! go! Let's go.</div></pre></td></tr></table></figure></p>
<p>如果我不想要开头是英文字母，则可以是这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '^[^a-zA-Z]' regular_express.txt</span></div><div class="line">1:<span class="string">"Open Source"</span> is a good mechanism to develop programs.</div><div class="line">21:<span class="comment"># I am VBird</span></div></pre></td></tr></table></figure></p>
<p>^ 符号，在字符类符号(括号[])之内与之外是不同的！ 在 [] 内代表<code>反向选择</code>，在 [] 之外则代表定位在行首的意义！</p>
<p>那如果我想要找出来，行尾结束为小数点 (.) 的那一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '\.$' regular_express.txt</span></div><div class="line">1:<span class="string">"Open Source"</span> is a good mechanism to develop programs.</div><div class="line">2:apple is my favorite food.</div><div class="line">3:Football game is not use feet only.</div><div class="line">4:this dress doesn<span class="string">'t fit me.</span></div><div class="line">10:motorcycle is cheap than car.</div><div class="line">11:This window is clear.</div><div class="line">12:the symbol '*<span class="string">' is represented as start.</span></div><div class="line">15:You are the best is mean you are the no. 1.</div><div class="line">16:The world &lt;Happy&gt; is the same with "glad".</div><div class="line">17:I like dog.</div><div class="line">18:google is the best tools for search keyword.</div><div class="line">20:go! go! Let's go.</div></pre></td></tr></table></figure></p>
<p>特别注意到，因为小数点具有其他意义(底下会介绍)，所以必须要使用转义字符(\)来加以解除其特殊意义！</p>
<p>找出空白行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '^$' regular_express.txt</span></div><div class="line">22:</div></pre></td></tr></table></figure></p>
<p>因为只有行首跟行尾 (^$)，所以，这样就可以找出空白行啦！</p>
<p>任意一个字节 . 与重复字节 *<br>这两个符号在正则表达式的意义如下：</p>
<p>. (小数点)：代表<code>一定有一个任意字节</code>的意思；<br>* (星号)：代表<code>重复前一个字符， 0 到无穷多次</code>的意思，为组合形态</p>
<p>假设我需要找出 g??d 的字串，亦即共有四个字节， 起头是 g 而结束是 d ，我可以这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'g..d' regular_express.txt</span></div><div class="line">1:<span class="string">"Open Source"</span> is a good mechanism to develop programs.</div><div class="line">9:Oh! The soup taste good.</div><div class="line">16:The world &lt;Happy&gt; is the same with <span class="string">"glad"</span>.</div></pre></td></tr></table></figure></p>
<p>因为强调 g 与 d 之间一定要存在两个字节，因此，第 13 行的 god 与第 14 行的 gd 就不会被列出来啦！</p>
<p>如果我想要列出有 oo, ooo, oooo 等等的数据， 也就是说，至少要有两个(含) o 以上，该如何是好？</p>
<p>因为 * 代表的是<code>重复 0 个或多个前面的 RE 字符</code>的意义， 因此 <code>o*</code> 代表的是：<code>拥有空字节或一个 o 以上的字节</code>，因此，<code>grep -n &#39;o*&#39; regular_express.txt</code>将会把所有的数据都列印出来终端上！</p>
<p>当我们需要<code>至少两个 o 以上的字串</code>时，就需要 <code>ooo*</code> ，亦即是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'ooo*' regular_express.txt</span></div><div class="line">1:<span class="string">"Open Source"</span> is a good mechanism to develop programs.</div><div class="line">2:apple is my favorite food.</div><div class="line">3:Football game is not use feet only.</div><div class="line">9:Oh! The soup taste good.</div><div class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>如果我想要字串开头与结尾都是 g，但是两个 g 之间仅能存在至少一个 o ，亦即是 gog, goog, gooog…. 等等，那该如何？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'goo*g' regular_express.txt</span></div><div class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>如果我想要找出 g 开头与 g 结尾的行，当中的字符可有可无<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'g.*g' regular_express.txt</span></div><div class="line">1:<span class="string">"Open Source"</span> is a good mechanism to develop programs.</div><div class="line">14:The gd software is a library <span class="keyword">for</span> drafting programs.</div><div class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</div><div class="line">19:goooooogle yes!</div><div class="line">20:go! go! Let<span class="string">'s go.</span></div></pre></td></tr></table></figure></p>
<p>因为是代表 g 开头与 g 结尾，中间任意字节均可接受，所以，第 1, 14, 20 行是可接受的喔！ 这个 .* 的 RE 表示任意字符是很常见的.</p>
<p>如果我想要找出<code>任意数字</code>的行？因为仅有数字，所以就成为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n '[0-9][0-9]*' regular_express.txt</span></div><div class="line">5:However, this dress is about $ 3183 dollars.</div><div class="line">15:You are the best is mean you are the no. 1.</div></pre></td></tr></table></figure></p>
<p>限定连续 RE 字符范围 {}<br>我们可以利用 . 与 RE 字符及 <code>*</code> 来配置 0 个到无限多个重复字节， 那如果我想要限制一个范围区间内的重复字节数呢？</p>
<p>举例来说，我想要找出两个到五个 o 的连续字串，该如何作？这时候就得要使用到限定范围的字符 {} 了。 但因为 { 与 } 的符号在 shell 是有特殊意义的，因此， 我们必须要使用字符 <code>\</code> 来让他失去特殊意义才行。 至於 {} 的语法是这样的，假设我要找到两个 o 的字串，可以是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'o\&#123;2\&#125;' regular_express.txt</span></div><div class="line">1:<span class="string">"Open Source"</span> is a good mechanism to develop programs.</div><div class="line">2:apple is my favorite food.</div><div class="line">3:Football game is not use feet only.</div><div class="line">9:Oh! The soup taste good.</div><div class="line">18:google is the best tools <span class="keyword">for</span> search ke</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>假设我们要找出 g 后面接 2 到 5 个 o ，然后再接一个 g 的字串，他会是这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'go\&#123;2,5\&#125;g' regular_express.txt</span></div><div class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</div></pre></td></tr></table></figure></p>
<p>如果我想要的是 2 个 o 以上的 goooo….g 呢？除了可以是 gooo*g ，也可以是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@www ~]<span class="comment"># grep -n 'go\&#123;2,\&#125;g' regular_express.txt</span></div><div class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</div><div class="line">19:goooooogle yes!</div></pre></td></tr></table></figure></p>
<p>扩展grep(grep -E 或者 egrep)：<br>使用扩展grep的主要好处是增加了额外的正则表达式元字符集。</p>
<p>打印所有包含NW或EA的行。如果不是使用egrep，而是grep，将不会有结果查出。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">egrep <span class="string">'NW|EA'</span> testfile     </div><div class="line">    northwest       NW      Charles Main        3.0     .98     3       34</div><div class="line">    eastern         EA      TB Savage           4.4     .84     5       20</div></pre></td></tr></table></figure></p>
<p>对于标准grep，如果在扩展元字符前面加\，grep会自动启用扩展选项-E。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grep <span class="string">'NW\|EA'</span> testfile</div><div class="line">northwest       NW      Charles Main        3.0     .98     3       34</div><div class="line">eastern         EA      TB Savage           4.4     .84     5       20</div></pre></td></tr></table></figure></p>
<p>搜索所有包含一个或多个3的行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">egrep <span class="string">'3+'</span> testfile</div><div class="line">grep -E <span class="string">'3+'</span> testfile</div><div class="line">grep <span class="string">'3\+'</span> testfile        </div><div class="line"><span class="comment">#这3条命令将会</span></div><div class="line">northwest       NW      Charles Main          3.0     .98     3       34</div><div class="line">western         WE      Sharon Gray           5.3     .97     5       23</div><div class="line">northeast       NE      AM Main Jr.           5.1     .94     3       13</div><div class="line">central         CT      Ann Stephens          5.7     .94     5       13</div></pre></td></tr></table></figure></p>
<p>搜索所有包含0个或1个小数点字符的行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">egrep <span class="string">'2\.?[0-9]'</span> testfile </div><div class="line">grep -E <span class="string">'2\.?[0-9]'</span> testfile</div><div class="line">grep <span class="string">'2\.\?[0-9]'</span> testfile </div><div class="line"><span class="comment">#首先含有2字符，其后紧跟着0个或1个点，后面再是0和9之间的数字。</span></div><div class="line">western         WE       Sharon Gray          5.3     .97     5       23</div><div class="line">southwest       SW      Lewis Dalsass         2.7     .8      2       18</div><div class="line">eastern         EA       TB Savage             4.4     .84     5       20</div></pre></td></tr></table></figure></p>
<p>搜索一个或者多个连续的no的行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">egrep <span class="string">'(no)+'</span> testfile</div><div class="line">grep -E <span class="string">'(no)+'</span> testfile</div><div class="line">grep <span class="string">'\(no\)\+'</span> testfile   <span class="comment">#3个命令返回相同结果，</span></div><div class="line">northwest       NW      Charles Main        3.0     .98     3       34</div><div class="line">northeast       NE       AM Main Jr.        5.1     .94     3       13</div><div class="line">north           NO      Margot Weber        4.5     .89     5       9</div></pre></td></tr></table></figure></p>
<p>不使用正则表达式</p>
<p>fgrep 查询速度比grep命令快，但是不够灵活：它只能找固定的文本，而不是规则表达式。</p>
<p>如果你想在一个文件或者输出中找到包含星号字符的行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fgrep  <span class="string">'*'</span> /etc/profile</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh ; <span class="keyword">do</span></div><div class="line">或</div><div class="line">grep -F <span class="string">'*'</span> /etc/profile</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh ; <span class="keyword">do</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> grep </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery的.bind()、.live()和.delegate()之间区别]]></title>
      <url>/2014/01/04/jquery-bind-delegate/</url>
      <content type="html"><![CDATA[<p><code>摘要: jQuery的.bind()、.live()和.delegate()之间的区别并非总是那么明显的，然而，如果我们对所有的不同之处都有清晰的理解的话，那么这将会有助于我们编写出更加简洁的代码，以及防止在交互应用中弹出错误。</code></p>
<p><a href="/images/jquery-1.jpg"><img src="/images/jquery-1.jpg" alt=""></a><br><a id="more"></a></p>
<p>DOM树</p>
<p>首先，可视化一个HMTL文档的DOM树是很有帮助的。一个简单的HTML页面看起来就像是这个样子：<br><a href="/images/jquery-2.png"><img src="/images/jquery-2.png" alt=""></a> </p>
<p>事件冒泡(又称事件传播)</p>
<p>当我们点击一个链接时，其触发了链接元素的单击事件，该事件则引发任何我们已绑定到该元素的单击事件上的函数的执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'a'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"That tickles!"</span>) &#125;);</div></pre></td></tr></table></figure>
<p>因此一个单击操作会触发alert函数的执行。<br><a href="/images/jquery-3.png"><img src="/images/jquery-3.png" alt=""></a> </p>
<p>click事件接着会向树的根方向传播，广播到父元素，然后接着是每个祖先元素，只要是它的某个后代元素上的单击事件被触发，事件就会传给它。</p>
<p><a href="/images/jquery-4.png"><img src="/images/jquery-4.png" alt=""></a> </p>
<p>在操纵DOM的语境中，document是根节点。</p>
<p>现在我们可以较容易地说明.bind()、.live()和.delegate()的不同之处了。</p>
<p>.bind()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'a'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"That tickles!"</span>) &#125;);</div></pre></td></tr></table></figure>
<p>这是最简单的绑定方法了。JQuery扫描文档找出所有的$(‘a’)元素，并把alert函数绑定到每个元素的click事件上。</p>
<p>.live()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'a'</span>).live(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"That tickles!"</span>) &#125;);</div></pre></td></tr></table></figure>
<p>JQuery把alert函数绑定到$(document)元素上，并使用’click’和’a’作为参数。任何时候只要有事件冒泡到document节点上，它就查看该事件是否是一个click事件，以及该事件的目标元素与’a’这一CSS选择器是否匹配，如果都是的话，则执行函数。</p>
<p>live方法还可以被绑定到具体的元素(或“context”)而不是document上，像这样：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'a'</span>, $(<span class="string">'#container'</span>)[<span class="number">0</span>]).live(...);</div></pre></td></tr></table></figure>
<p>.delegate()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#container'</span>).delegate(<span class="string">'a'</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"That tickles!"</span>) &#125;);</div></pre></td></tr></table></figure>
<p>JQuery扫描文档查找$(‘#container’)，并使用click事件和’a’这一CSS选择器作为参数把alert函数绑定到$(‘#container’)上。任何时候只要有事件冒泡到$(‘#container’)上，它就查看该事件是否是click事件，以及该事件的目标元素是否与CCS选择器相匹配。如果两种检查的结果都为真的话，它就执行函数。</p>
<p>可以注意到，这一过程与.live()类似，但是其把处理程序绑定到具体的元素而非document这一根上。精明的JS’er们可能会做出这样的结论，即$(‘a’).live() == $(document).delegate(‘a’)，是这样吗?嗯，不，不完全是。</p>
<p>为什么.delegate()要比.live()好用</p>
<p>基于几个原因，人们通常更愿意选用jQuery的delegate方法而不是live方法。考虑下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'a'</span>).live(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; blah() &#125;);     </div><div class="line"><span class="comment">// 或者   </span></div><div class="line">$(<span class="built_in">document</span>).delegate(<span class="string">'a'</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; blah() &#125;);</div></pre></td></tr></table></figure>
<p>速度</p>
<p>后者实际上要快过前者，因为前者首先要扫描整个的文档查找所有的$(‘a’)元素，把它们存成jQuery对象。尽管live函数仅需要把’a’作为串参数传递以用做之后的判断，但是$()函数并未“知道”被链接的方法将会是.live()。</p>
<p>而另一方面，delegate方法仅需要查找并存储$(document)元素。</p>
<p>一种寻求避开这一问题的方法是调用在$(document).ready()之外绑定的live，这样它就会立即执行。在这种方式下，其会在DOM获得填充之前运行，因此就不会查找元素或是创建jQuery对象了。</p>
<p>灵活性和链能力</p>
<p>live函数也挺令人费解的。想想看，它被链到$(‘a’)对象集上，但其实际上是在$(document)对象上发生作用。由于这个原因，它能够试图以一种吓死人的方式来把方法链到自身上。实际上，我想说的是，以$.live(‘a’,…)这一形式作为一种全局性的jQuery方法，live方法会更具意义一些。</p>
<p>仅支持CSS选择器</p>
<p>最后一点，live方法有一个非常大的缺点，那就是它仅能针对直接的CSS选择器做操作，这使得它变得非常的不灵活。</p>
<p>欲了解更多关于CSS选择器的缺点，请参阅Exploring jQuery .live() and .die()一文。</p>
<p>更新：感谢Hacker News上的pedalpete和后面评论中的Ellsass提醒我加入接下来的这一节内容。</p>
<p>为什么选择.live()或.delegate()而不是.bind()</p>
<p>毕竟，bind看起来似乎更加的明确和直接，难道不是吗?嗯，有两个原因让我们更愿意选择delegate或live而不是bind：</p>
<p>为了把处理程序附加到可能还未存在于DOM中的DOM元素之上。因为bind是直接把处理程序绑定到各个元素上，它不能把处理程序绑定到还未存在于页面中的元素之上。</p>
<p>如果你运行了$(‘a’).bind(…)，而后新的链接经由AJAX加入到了页面中，则你的bind处理程序对于这些新加入的链接来说是无效的。而另一方面live和delegate则是被绑定到另一个祖先节点上，因此其对于任何目前或是将来存在于该祖先元素之内的元素都是有效的。</p>
<p>或者为了把处理程序附加到单个元素上或是一小组元素之上，监听后代元素上的事件而不是循环遍历并把同一个函数逐个附加到DOM中的100个元素上。把处理程序附加到一个(或是一小组)祖先元素上而不是直接把处理程序附加到页面中的所有元素上，这种做法带来了性能上的好处。</p>
<p>停止传播</p>
<p>最后一个我想做的提醒与事件传播有关。通常情况下，我们可以通过使用这样的事件方法来终止处理函数的执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'a'</span>).bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;      </div><div class="line">e.preventDefault();   </div><div class="line"><span class="comment">// 或者   </span></div><div class="line">e.stopPropagation();   </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>不过，当我们使用live或是delegate方法的时候，处理函数实际上并没有在运行，需要等到事件冒泡到处理程序实际绑定的元素上时函数才会运行。而到此时为止，我们的其他的来自.bind()的处理函数早已运行了。</p>
<p>原文地址：<a href="http://developer.51cto.com/art/201103/249694.htm" target="_blank" rel="external">http://developer.51cto.com/art/201103/249694.htm</a></p>
]]></content>
      
        <categories>
            
            <category> jQuery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[正确理解ThreadLocal]]></title>
      <url>/2014/01/04/threadlocal-understanding/</url>
      <content type="html"><![CDATA[<p>首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。 各个线程中访问的是不同的对象。  </p>
<p>另外，说ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()来实现的，而是通过每个线程中的new 对象 的操作来创建的对象，每个线程创建一个，不是什么对象的拷贝或副本。 通过ThreadLocal.set()将这个新创建的对象的引用保存到各线程的自己的一个map中，每个线程都有这样一个map，执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象，因此取出来的是各自自己线程中的对象，ThreadLocal实例是作为map的key来使用的。<br><a id="more"></a><br>如果ThreadLocal.set()进去的东西本来就是多个线程共享的同一个对象，那么多个线程的ThreadLocal.get()取得的还是这个共享对象本身，还是有并发访问问题。  </p>
<p>下面来看一个hibernate中典型的ThreadLocal的应用： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</div><div class="line">        Session s = (Session) threadSession.get();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</div><div class="line">                s = getSessionFactory().openSession();</div><div class="line">                threadSession.set(s);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到在getSession()方法中，首先判断当前线程中有没有放进去session，如果还没有，那么通过sessionFactory().openSession()来创建一个session，再将session set到线程中，实际是放到当前线程的ThreadLocalMap这个map中，这时，对于这个session的唯一引用就是当前线程中的那个ThreadLocalMap（下面会讲到），而threadSession作为这个值的key，要取得这个session可以通过threadSession.get()来得到，里面执行的操作实际是先取得当前线程中的ThreadLocalMap，然后将threadSession作为key将对应的值取出。这个session相当于线程的私有变量，而不是public的。<br>显然，其他线程中是取不到这个session的，他们也只能取到自己的ThreadLocalMap中的东西。要是session是多个线程共享使用的，那还不乱套了。<br>试想如果不用ThreadLocal怎么来实现呢？可能就要在action中创建session，然后把session一个个传到service和dao中，这可够麻烦的。或者可以自己定义一个静态的map，将当前thread作为key，创建的session作为值，put到map中，应该也行，这也是一般人的想法，但事实上，ThreadLocal的实现刚好相反，它是在每个线程中有一个map，而将ThreadLocal实例作为key，这样每个map中的项数很少，而且当线程销毁时相应的东西也一起销毁了，不知道除了这些还有什么其他的好处。  </p>
<p>总之，ThreadLocal不是用来解决对象共享访问问题的，而主要是提供了保持对象的方法和避免参数传递的方便的对象访问方式。归纳了两点：<br>1。每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。<br>2。将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。   </p>
<p>当然如果要把本来线程共享的对象通过ThreadLocal.set()放到线程中也可以，可以实现避免参数传递的访问方式，但是要注意get()到的是那同一个共享对象，并发访问问题要靠其他手段来解决。但一般来说线程共享的对象通过设置为某类的静态变量就可以实现方便的访问了，似乎没必要放到线程中。  </p>
<p>ThreadLocal的应用场合，我觉得最适合的是按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。   </p>
<p>下面来看看ThreadLocal的实现原理（jdk1.5源码）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * ThreadLocals rely on per-thread hash maps attached to each thread</div><div class="line">     * (Thread.threadLocals and inheritableThreadLocals).  The ThreadLocal</div><div class="line">     * objects act as keys, searched via threadLocalHashCode.  This is a</div><div class="line">     * custom hash code (useful only within ThreadLocalMaps) that eliminates</div><div class="line">     * collisions in the common case where consecutively constructed</div><div class="line">     * ThreadLocals are used by the same threads, while remaining well-behaved</div><div class="line">     * in less common cases.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The next hash code to be given out. Accessed only by like-named method.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextHashCode = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The difference between successively generated hash codes - turns</div><div class="line">     * implicit sequential thread-local IDs into near-optimally spread</div><div class="line">     * multiplicative hash values for power-of-two-sized tables.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Compute the next hash code. The static synchronization used here</div><div class="line">     * should not be a performance bottleneck. When ThreadLocals are</div><div class="line">     * generated in different threads at a fast enough rate to regularly</div><div class="line">     * contend on this lock, memory contention is by far a more serious</div><div class="line">     * problem than lock contention.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = nextHashCode;</div><div class="line">        nextHashCode = h + HASH_INCREMENT;</div><div class="line">        <span class="keyword">return</span> h;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a thread local variable.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the value in the current thread's copy of this thread-local</div><div class="line">     * variable.  Creates and initializes the copy if this is the first time</div><div class="line">     * the thread has called this method.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> the current thread's value of this thread-local</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> (T)map.get(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Maps are constructed lazily.  if the map for this thread</span></div><div class="line">        <span class="comment">// doesn't exist, create it, with this ThreadLocal and its</span></div><div class="line">        <span class="comment">// initial value as its only entry.</span></div><div class="line">        T value = initialValue();</div><div class="line">        createMap(t, value);</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sets the current thread's copy of this thread-local variable</div><div class="line">     * to the specified value.  Many applications will have no need for</div><div class="line">     * this functionality, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</div><div class="line">     * method to set the values of thread-locals.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> value the value to be stored in the current threads' copy of</div><div class="line">     *        this thread-local.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            createMap(t, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Get the map associated with a ThreadLocal. Overridden in</div><div class="line">     * InheritableThreadLocal.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span>  t the current thread</div><div class="line">     * <span class="doctag">@return</span> the map</div><div class="line">     */</div><div class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> t.threadLocals;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Create the map associated with a ThreadLocal. Overridden in</div><div class="line">     * InheritableThreadLocal.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> t the current thread</div><div class="line">     * <span class="doctag">@param</span> firstValue value for the initial entry of the map</div><div class="line">     * <span class="doctag">@param</span> map the map to store.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .......</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * ThreadLocalMap is a customized hash map suitable only for</div><div class="line">     * maintaining thread local values. No operations are exported</div><div class="line">     * outside of the ThreadLocal class. The class is package private to</div><div class="line">     * allow declaration of fields in class Thread.  To help deal with</div><div class="line">     * very large and long-lived usages, the hash table entries use</div><div class="line">     * WeakReferences for keys. However, since reference queues are not</div><div class="line">     * used, stale entries are guaranteed to be removed only when</div><div class="line">     * the table starts running out of space.</div><div class="line">     */</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</div><div class="line"></div><div class="line">    ........</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到ThreadLocal类中的变量只有这3个int型： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextHashCode = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</div></pre></td></tr></table></figure>
<p>而作为ThreadLocal实例的变量只有 threadLocalHashCode 这一个，nextHashCode 和HASH_INCREMENT 是ThreadLocal类的静态变量，实际上HASH_INCREMENT是一个常量，表示了连续分配的两个ThreadLocal实例的threadLocalHashCode值的增量，而nextHashCode 的表示了即将分配的下一个ThreadLocal实例的threadLocalHashCode 的值。  </p>
<p>可以来看一下创建一个ThreadLocal实例即new ThreadLocal()时做了哪些操作，从上面看到构造函数ThreadLocal()里什么操作都没有，唯一的操作是这句： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</div></pre></td></tr></table></figure>
<p>那么nextHashCode()做了什么呢： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> h = nextHashCode;</div><div class="line">        nextHashCode = h + HASH_INCREMENT;</div><div class="line">        <span class="keyword">return</span> h;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>就是将ThreadLocal类的下一个hashCode值即nextHashCode的值赋给实例的threadLocalHashCode，然后nextHashCode的值增加HASH_INCREMENT这个值。  </p>
<p>因此ThreadLocal实例的变量只有这个threadLocalHashCode，而且是final的，用来区分不同的ThreadLocal实例，ThreadLocal类主要是作为工具类来使用，那么ThreadLocal.set()进去的对象是放在哪儿的呢？  </p>
<p>看一下上面的set()方法，两句合并一下成为 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ThreadLocalMap map = Thread.currentThread().threadLocals;</div></pre></td></tr></table></figure>
<p>这个ThreadLocalMap 类是ThreadLocal中定义的内部类，但是它的实例却用在Thread类中： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line">     * by the ThreadLocal class. */</div><div class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;  </div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再看这句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">            map.set(<span class="keyword">this</span>, value);</div></pre></td></tr></table></figure></p>
<p>也就是将该ThreadLocal实例作为key，要保持的对象作为值，设置到当前线程的ThreadLocalMap 中，get()方法同样大家看了代码也就明白了，ThreadLocalMap 类的代码太多了，我就不帖了，自己去看源码吧。 </p>
<p>贴个例子吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">0</span>;   <span class="comment">//年龄</span></div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">//创建线程局部变量studentLocal，在后面你会发现用来保存Student对象</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal studentLocal = <span class="keyword">new</span> ThreadLocal();</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> </span>&#123;</div><div class="line">        ThreadLocalDemo td = <span class="keyword">new</span> ThreadLocalDemo();</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(td, <span class="string">"a"</span>);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(td, <span class="string">"b"</span>);</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        accessStudent();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 示例业务方法，用来测试</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accessStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//获取当前线程的名字</span></div><div class="line">        String currentThreadName = Thread.currentThread().getName();</div><div class="line">        System.out.println(currentThreadName + <span class="string">" is running!"</span>);</div><div class="line">        <span class="comment">//产生一个随机数并打印</span></div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">int</span> age = random.nextInt(<span class="number">100</span>);</div><div class="line">        System.out.println(<span class="string">"thread "</span> + currentThreadName + <span class="string">" set age to:"</span> + age);</div><div class="line">        <span class="comment">//获取一个Student对象，并将随机数年龄插入到对象属性中</span></div><div class="line">        Student student = getStudent();</div><div class="line">        student.setAge(age);</div><div class="line">        System.out.println(<span class="string">"thread "</span> + currentThreadName + <span class="string">" first read age is:"</span> + student.getAge());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">500</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">            ex.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"thread "</span> + currentThreadName + <span class="string">" second read age is:"</span> + student.getAge());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">protected</span> Student <span class="title">getStudent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//获取本地线程变量并强制转换为Student类型</span></div><div class="line">        Student student = (Student) studentLocal.get();</div><div class="line">        <span class="comment">//线程首次执行此方法的时候，studentLocal.get()肯定为null</span></div><div class="line">        <span class="keyword">if</span> (student == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//创建一个Student对象，并保存到本地线程变量studentLocal中</span></div><div class="line">            student = <span class="keyword">new</span> Student();</div><div class="line">            studentLocal.set(student);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> student;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a is running! </div><div class="line">thread a <span class="built_in">set</span> age to:76 </div><div class="line">b is running! </div><div class="line">thread b <span class="built_in">set</span> age to:27 </div><div class="line">thread a first <span class="built_in">read</span> age is:76 </div><div class="line">thread b first <span class="built_in">read</span> age is:27 </div><div class="line">thread a second <span class="built_in">read</span> age is:76 </div><div class="line">thread b second <span class="built_in">read</span> age is:27</div></pre></td></tr></table></figure></p>
<p>原文地址：<a href="http://www.iteye.com/topic/103804" target="_blank" rel="external">http://www.iteye.com/topic/103804</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> threadlocal </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vi/vim 编辑器命令]]></title>
      <url>/2014/01/03/linux-vi/</url>
      <content type="html"><![CDATA[<blockquote>
<p>vi/vim 用法笔记。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>按 <code>i</code> 进入编辑模式 （一开始是命令模式的）</li>
<li>按 <code>esc</code> 进入命令模式</li>
<li>在命令模式中输入<code>:wq</code> 保存 （write and quit）</li>
<li>在命令模式中输入<code>:q</code> 退出</li>
<li>在命令模式中输入<code>:q!</code> 强制退出 (不保存)</li>
<li>在命令模式中输入<code>/</code>后接<code>关键字</code>搜索，<code>n</code>下一个匹配，<code>N</code>上一个匹配</li>
<li>在命令模式中输入<code>gg</code> 回到顶部，<code>GG</code>到底部</li>
<li>在命令模式中输入<code>dd</code> 删除当前行</li>
<li>在命令模式中输入<code>x</code> 删除后一个字符，<code>X</code>删除前一个字符</li>
<li>在命令模式中输入<code>u</code> undo最后一次修改</li>
<li>在命令模式中输入<code>yy</code> 复制当前行</li>
<li>在命令模式中输入<code>p</code> 粘贴到光标后面，<code>P</code>粘贴到光标前面</li>
</ul>
<blockquote>
<p>未完待续…</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> vi </tag>
            
            <tag> vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2014/01/01/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to my blog, This is my first post.so hello world<br><a id="more"></a></p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hello </tag>
            
            <tag> world </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
