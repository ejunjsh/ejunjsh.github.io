<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IdiotSky</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://idiotsky.me/"/>
  <updated>2018-01-18T14:40:52.912Z</updated>
  <id>http://idiotsky.me/</id>
  
  <author>
    <name>ejunjsh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何实现一个malloc</title>
    <link href="http://idiotsky.me/2018/01/16/c-malloc/"/>
    <id>http://idiotsky.me/2018/01/16/c-malloc/</id>
    <published>2018-01-16T15:46:42.000Z</published>
    <updated>2018-01-18T14:40:52.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章很好的总结了很多关于内存的知识，虽然它将的只是一个c函数，mark之👿</p>
</blockquote>
<p>任何一个用过或学过C的人对malloc都不会陌生。大家都知道malloc可以分配一段连续的内存空间，并且在不再使用时可以通过free释放掉。但是，许多程序员对malloc背后的事情并不熟悉，许多人甚至把malloc当做操作系统所提供的系统调用或C的关键字。实际上，malloc只是C的标准库中提供的一个普通函数，而且实现malloc的<strong>基本</strong>思想并不复杂，任何一个对C和操作系统有些许了解的程序员都可以很容易理解。</p>
<p>这篇文章通过实现一个简单的malloc来描述malloc背后的机制。当然与现有C的标准库实现（例如glibc）相比，我们实现的malloc并不是特别高效，但是这个实现比目前真实的malloc实现要简单很多，因此易于理解。重要的是，这个实现和真实实现在基本原理上是一致的。</p>
<p>这篇文章将首先介绍一些所需的基本知识，如操作系统对进程的内存管理以及相关的系统调用，然后逐步实现一个简单的malloc。为了简单起见，这篇文章将只考虑x86_64体系结构，操作系统为Linux。</p>
<a id="more"></a>
<h1 id="什么是malloc"><a href="#什么是malloc" class="headerlink" title="什么是malloc"></a>什么是malloc</h1><p>在实现malloc之前，先要相对正式地对malloc做一个定义。</p>
<p>根据标准C库函数的定义，malloc具有如下原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：</p>
<ul>
<li>malloc分配的内存大小<strong>至少</strong>为size参数所指定的字节数</li>
<li>malloc的返回值是一个指针，指向一段可用内存的起始地址</li>
<li>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</li>
<li>malloc应该尽快完成内存分配并返回（不能使用<a href="http://en.wikipedia.org/wiki/NP-hard" target="_blank" rel="external">NP-hard</a>的内存分配算法）</li>
<li>实现malloc时应同时实现内存大小调整和内存释放函数（即realloc和free）</li>
</ul>
<p>对于malloc更多的说明可以在命令行中键入以下命令查看：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man malloc</div></pre></td></tr></table></figure></p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>在实现malloc之前，需要先解释一些Linux系统内存相关的知识。</p>
<h2 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h2><h3 id="虚拟内存地址与物理内存地址"><a href="#虚拟内存地址与物理内存地址" class="headerlink" title="虚拟内存地址与物理内存地址"></a>虚拟内存地址与物理内存地址</h3><p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时，都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片2^N字节的内存，其中N是机器位数。例如在64位CPU和64位操作系统下，每个进程的虚拟地址空间为2^64Byte.</p>
<p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p>
<p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫<a href="http://en.wikipedia.org/wiki/Memory_management_unit" target="_blank" rel="external">MMU</a>（Memory Management Unit）的硬件完成。</p>
<h3 id="页与地址构成"><a href="#页与地址构成" class="headerlink" title="页与地址构成"></a>页与地址构成</h3><p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p>
<p>所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：<br><a href="http://idiotsky.me/images2/c-malloc-1.png"><img src="http://idiotsky.me/images2/c-malloc-1.png" alt=""></a></p>
<p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内便宜都是用低12位表示，而剩下的高地址表示页号。</p>
<p>MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构<a href="http://en.wikipedia.org/wiki/Page_table" target="_blank" rel="external">页表</a>来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank" rel="external">TLB</a>等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。<br><a href="http://idiotsky.me/images2/c-malloc-2.png"><img src="http://idiotsky.me/images2/c-malloc-2.png" alt=""></a></p>
<h3 id="内存页与磁盘页"><a href="#内存页与磁盘页" class="headerlink" title="内存页与磁盘页"></a>内存页与磁盘页</h3><p>我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。<br><a href="http://idiotsky.me/images2/c-malloc-3.png"><img src="http://idiotsky.me/images2/c-malloc-3.png" alt=""></a></p>
<h2 id="Linux进程级内存管理"><a href="#Linux进程级内存管理" class="headerlink" title="Linux进程级内存管理"></a>Linux进程级内存管理</h2><h3 id="内存排布"><a href="#内存排布" class="headerlink" title="内存排布"></a>内存排布</h3><p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p>
<p>以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p>
<p>根据<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt" target="_blank" rel="external">Linux内核相关文档</a>描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：<br><a href="http://idiotsky.me/images2/c-malloc-4.png"><img src="http://idiotsky.me/images2/c-malloc-4.png" alt=""></a></p>
<p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p>
<ul>
<li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li>
<li>Data：这里存放的是初始化过的全局变量</li>
<li>BSS：这里存放的是未初始化的全局变量</li>
<li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li>
<li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li>
<li>Stack：这是栈区域，自高地址向低地址增长</li>
</ul>
<p>下面我们主要关注Heap区域的操作。对整个Linux内存排布有兴趣的同学可以参考其它资料。</p>
<h3 id="Heap内存模型"><a href="#Heap内存模型" class="headerlink" title="Heap内存模型"></a>Heap内存模型</h3><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p>
<p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：<br><a href="http://idiotsky.me/images2/c-malloc-5.png"><img src="http://idiotsky.me/images2/c-malloc-5.png" alt=""></a></p>
<p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p>
<h3 id="brk与sbrk"><a href="#brk与sbrk" class="headerlink" title="brk与sbrk"></a>brk与sbrk</h3><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;</div></pre></td></tr></table></figure></p>
<p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p>
<p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p>
<p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</p>
<h3 id="资源限制与rlimit"><a href="#资源限制与rlimit" class="headerlink" title="资源限制与rlimit"></a>资源限制与rlimit</h3><p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> *<span class="title">limit</span> = (<span class="title">struct</span> <span class="title">rlimit</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">rlimit</span>));</span></div><div class="line">    getrlimit(RLIMIT_AS, limit);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"soft limit: %ld, hard limit: %ld\n"</span>, limit-&gt;rlim_cur, limit-&gt;rlim_max);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中rlimit是一个结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></div><div class="line">    <span class="keyword">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></div><div class="line">    <span class="keyword">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p>
<h1 id="实现malloc"><a href="#实现malloc" class="headerlink" title="实现malloc"></a>实现malloc</h1><h2 id="玩具实现"><a href="#玩具实现" class="headerlink" title="玩具实现"></a>玩具实现</h2><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 一个玩具malloc */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *p;</div><div class="line">    p = sbrk(<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (sbrk(size) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p>
<h2 id="正式实现"><a href="#正式实现" class="headerlink" title="正式实现"></a>正式实现</h2><p>下面严肃点讨论malloc的实现方案。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p>
<p>可以用如下结构体定义一个block：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></div><div class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></div><div class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></div><div class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></div><div class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：<br><a href="http://idiotsky.me/images2/c-malloc-6.png"><img src="http://idiotsky.me/images2/c-malloc-6.png" alt=""></a></p>
<h3 id="寻找合适的block"><a href="#寻找合适的block" class="headerlink" title="寻找合适的block"></a>寻找合适的block</h3><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p>
<ul>
<li><strong>First fit</strong>：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块</li>
<li><strong>Best fit</strong>：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</li>
</ul>
<p>两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* First fit */</span></div><div class="line"><span class="function">t_block <span class="title">find_block</span><span class="params">(t_block *last, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    t_block b = first_block;</div><div class="line">    <span class="keyword">while</span>(b &amp;&amp; !(b-&gt;<span class="built_in">free</span> &amp;&amp; b-&gt;size &gt;= size)) &#123;</div><div class="line">        *last = b;</div><div class="line">        b = b-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到这返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新block使用的，具体会在接下来的一节用到。</p>
<h3 id="开辟新的block"><a href="#开辟新的block" class="headerlink" title="开辟新的block"></a>开辟新的block</h3><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE 24 <span class="comment">/* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */</span></span></div><div class="line"> </div><div class="line"><span class="function">t_block <span class="title">extend_heap</span><span class="params">(t_block last, <span class="keyword">size_t</span> s)</span> </span>&#123;</div><div class="line">    t_block b;</div><div class="line">    b = sbrk(<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(sbrk(BLOCK_SIZE + s) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    b-&gt;size = s;</div><div class="line">    b-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span>(last)</div><div class="line">        last-&gt;next = b;</div><div class="line">    b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="分裂block"><a href="#分裂block" class="headerlink" title="分裂block"></a>分裂block</h3><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：<br><a href="http://idiotsky.me/images2/c-malloc-7.png"><img src="http://idiotsky.me/images2/c-malloc-7.png" alt=""></a></p>
<p>实现代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_block</span><span class="params">(t_block b, <span class="keyword">size_t</span> s)</span> </span>&#123;</div><div class="line">    t_block <span class="keyword">new</span>;</div><div class="line">    <span class="keyword">new</span> = b-&gt;data + s;</div><div class="line">    <span class="keyword">new</span>-&gt;size = b-&gt;size - s - BLOCK_SIZE ;</div><div class="line">    <span class="keyword">new</span>-&gt;next = b-&gt;next;</div><div class="line">    <span class="keyword">new</span>-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">    b-&gt;size = s;</div><div class="line">    b-&gt;next = <span class="keyword">new</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="malloc的实现"><a href="#malloc的实现" class="headerlink" title="malloc的实现"></a>malloc的实现</h3><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p>
<p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> align8(<span class="keyword">size_t</span> s) &#123;</div><div class="line">    <span class="keyword">if</span>(s &amp; <span class="number">0x7</span> == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    <span class="keyword">return</span> ((s &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE 24</span></div><div class="line"><span class="keyword">void</span> *first_block=<span class="literal">NULL</span>;</div><div class="line"> </div><div class="line"><span class="comment">/* other functions... */</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    t_block b, last;</div><div class="line">    <span class="keyword">size_t</span> s;</div><div class="line">    <span class="comment">/* 对齐地址 */</span></div><div class="line">    s = align8(size);</div><div class="line">    <span class="keyword">if</span>(first_block) &#123;</div><div class="line">        <span class="comment">/* 查找合适的block */</span></div><div class="line">        last = first_block;</div><div class="line">        b = find_block(&amp;last, s);</div><div class="line">        <span class="keyword">if</span>(b) &#123;</div><div class="line">            <span class="comment">/* 如果可以，则分裂 */</span></div><div class="line">            <span class="keyword">if</span> ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + <span class="number">8</span>))</div><div class="line">                split_block(b, s);</div><div class="line">            b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* 没有合适的block，开辟一个新的 */</span></div><div class="line">            b = extend_heap(last, s);</div><div class="line">            <span class="keyword">if</span>(!b)</div><div class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        b = extend_heap(<span class="literal">NULL</span>, s);</div><div class="line">        <span class="keyword">if</span>(!b)</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        first_block = b;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b-&gt;data;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="calloc的实现"><a href="#calloc的实现" class="headerlink" title="calloc的实现"></a>calloc的实现</h3><p>有了malloc，实现calloc只要两步：</p>
<ol>
<li>malloc一段内存</li>
<li>将数据区内容置为0</li>
</ol>
<p>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> number, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> *<span class="keyword">new</span>;</div><div class="line">    <span class="keyword">size_t</span> s8, i;</div><div class="line">    <span class="keyword">new</span> = <span class="built_in">malloc</span>(number * size);</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>) &#123;</div><div class="line">        s8 = align8(number * size) &gt;&gt; <span class="number">3</span>;</div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s8; i++)</div><div class="line">            <span class="keyword">new</span>[i] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="free的实现"><a href="#free的实现" class="headerlink" title="free的实现"></a>free的实现</h3><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p>
<ol>
<li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li>
<li>如何解决碎片问题</li>
</ol>
<p>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</p>
<ol>
<li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li>
<li>这个地址确实是之前通过我们自己的malloc分配的</li>
</ol>
<p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p>
<p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></div><div class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></div><div class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></div><div class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></div><div class="line">    <span class="keyword">void</span> *ptr;    <span class="comment">/* Magic pointer，指向data */</span></div><div class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>然后我们定义检查地址合法性的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function">t_block <span class="title">get_block</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> *tmp;  </div><div class="line">    tmp = p;</div><div class="line">    <span class="keyword">return</span> (p = tmp -= BLOCK_SIZE);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">valid_addr</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(first_block) &#123;</div><div class="line">        <span class="keyword">if</span>(p &gt; first_block &amp;&amp; p &lt; sbrk(<span class="number">0</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> p == (get_block(p))-&gt;ptr;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p>
<p>一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></div><div class="line">    t_block prev; <span class="comment">/* 指向上个块的指针 */</span></div><div class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></div><div class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></div><div class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></div><div class="line">    <span class="keyword">void</span> *ptr;    <span class="comment">/* Magic pointer，指向data */</span></div><div class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>合并方法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">t_block <span class="title">fusion</span><span class="params">(t_block b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (b-&gt;next &amp;&amp; b-&gt;next-&gt;<span class="built_in">free</span>) &#123;</div><div class="line">        b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size;</div><div class="line">        b-&gt;next = b-&gt;next-&gt;next;</div><div class="line">        <span class="keyword">if</span>(b-&gt;next)</div><div class="line">            b-&gt;next-&gt;prev = b;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</div><div class="line">    t_block b;</div><div class="line">    <span class="keyword">if</span>(valid_addr(p)) &#123;</div><div class="line">        b = get_block(p);</div><div class="line">        b-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;<span class="built_in">free</span>)</div><div class="line">            b = fusion(b-&gt;prev);</div><div class="line">        <span class="keyword">if</span>(b-&gt;next)</div><div class="line">            fusion(b);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(b-&gt;prev)</div><div class="line">                b-&gt;prev-&gt;prev = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                first_block = <span class="literal">NULL</span>;</div><div class="line">            brk(b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="realloc的实现"><a href="#realloc的实现" class="headerlink" title="realloc的实现"></a>realloc的实现</h3><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_block</span><span class="params">(t_block src, t_block dst)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> *sdata, *ddata;</div><div class="line">    <span class="keyword">size_t</span> i;</div><div class="line">    sdata = src-&gt;ptr;</div><div class="line">    ddata = dst-&gt;ptr;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; (i * <span class="number">8</span>) &lt; src-&gt;size &amp;&amp; (i * <span class="number">8</span>) &lt; dst-&gt;size; i++)</div><div class="line">        ddata[i] = sdata[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p>
<ul>
<li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li>
<li>如果新的size变小了，考虑split</li>
<li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li>
</ul>
<p>下面是realloc的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> s;</div><div class="line">    t_block b, <span class="keyword">new</span>;</div><div class="line">    <span class="keyword">void</span> *newp;</div><div class="line">    <span class="keyword">if</span> (!p)</div><div class="line">        <span class="comment">/* 根据标准库文档，当p传入NULL时，相当于调用malloc */</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</div><div class="line">    <span class="keyword">if</span>(valid_addr(p)) &#123;</div><div class="line">        s = align8(size);</div><div class="line">        b = get_block(p);</div><div class="line">        <span class="keyword">if</span>(b-&gt;size &gt;= s) &#123;</div><div class="line">            <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))</div><div class="line">                split_block(b,s);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* 看是否可进行合并 */</span></div><div class="line">            <span class="keyword">if</span>(b-&gt;next &amp;&amp; b-&gt;next-&gt;<span class="built_in">free</span></div><div class="line">                    &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) &#123;</div><div class="line">                fusion(b);</div><div class="line">                <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))</div><div class="line">                    split_block(b, s);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* 新malloc */</span></div><div class="line">                newp = <span class="built_in">malloc</span> (s);</div><div class="line">                <span class="keyword">if</span> (!newp)</div><div class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">                <span class="keyword">new</span> = get_block(newp);</div><div class="line">                copy_block(b, <span class="keyword">new</span>);</div><div class="line">                <span class="built_in">free</span>(p);</div><div class="line">                <span class="keyword">return</span>(newp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (p);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="遗留问题和优化"><a href="#遗留问题和优化" class="headerlink" title="遗留问题和优化"></a>遗留问题和优化</h2><p>以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p>
<ul>
<li>同时兼容32位和64位系统</li>
<li>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效</li>
<li>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度</li>
<li>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率</li>
</ul>
<p>还有很多可能的优化，这里不一一赘述。</p>
<p>from <a href="http://blog.codinglabs.org/articles/a-malloc-tutorial.html" target="_blank" rel="external">http://blog.codinglabs.org/articles/a-malloc-tutorial.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章很好的总结了很多关于内存的知识，虽然它将的只是一个c函数，mark之👿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;任何一个用过或学过C的人对malloc都不会陌生。大家都知道malloc可以分配一段连续的内存空间，并且在不再使用时可以通过free释放掉。但是，许多程序员对malloc背后的事情并不熟悉，许多人甚至把malloc当做操作系统所提供的系统调用或C的关键字。实际上，malloc只是C的标准库中提供的一个普通函数，而且实现malloc的&lt;strong&gt;基本&lt;/strong&gt;思想并不复杂，任何一个对C和操作系统有些许了解的程序员都可以很容易理解。&lt;/p&gt;
&lt;p&gt;这篇文章通过实现一个简单的malloc来描述malloc背后的机制。当然与现有C的标准库实现（例如glibc）相比，我们实现的malloc并不是特别高效，但是这个实现比目前真实的malloc实现要简单很多，因此易于理解。重要的是，这个实现和真实实现在基本原理上是一致的。&lt;/p&gt;
&lt;p&gt;这篇文章将首先介绍一些所需的基本知识，如操作系统对进程的内存管理以及相关的系统调用，然后逐步实现一个简单的malloc。为了简单起见，这篇文章将只考虑x86_64体系结构，操作系统为Linux。&lt;/p&gt;
    
    </summary>
    
      <category term="c" scheme="http://idiotsky.me/categories/c/"/>
    
    
      <category term="c" scheme="http://idiotsky.me/tags/c/"/>
    
      <category term="malloc" scheme="http://idiotsky.me/tags/malloc/"/>
    
  </entry>
  
  <entry>
    <title>深入go接口</title>
    <link href="http://idiotsky.me/2018/01/15/go-interface/"/>
    <id>http://idiotsky.me/2018/01/15/go-interface/</id>
    <published>2018-01-15T07:44:21.000Z</published>
    <updated>2018-01-16T15:42:06.008Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>接口在go里面是一个抽象类型，它是一系列抽象方法的集合，它的具体实现类型具有类似多态或者泛型的功能</p>
</blockquote>
<h1 id="接口是一个抽象类型"><a href="#接口是一个抽象类型" class="headerlink" title="接口是一个抽象类型"></a>接口是一个抽象类型</h1><h1 id="接口是一个方法集合"><a href="#接口是一个方法集合" class="headerlink" title="接口是一个方法集合"></a>接口是一个方法集合</h1><h1 id="接口实现多态"><a href="#接口实现多态" class="headerlink" title="接口实现多态"></a>接口实现多态</h1><h1 id="接口实现泛型"><a href="#接口实现泛型" class="headerlink" title="接口实现泛型"></a>接口实现泛型</h1><p><a href="https://zhuanlan.zhihu.com/p/27652856" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/27652856</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;接口在go里面是一个抽象类型，它是一系列抽象方法的集合，它的具体实现类型具有类似多态或者泛型的功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;接口是一个抽象类型&quot;&gt;&lt;a href=&quot;#接口是一个抽象类型&quot; class=&quot;headerlin
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>使用scroll实现Elasticsearch数据遍历和深度分页</title>
    <link href="http://idiotsky.me/2018/01/11/elasticsearch-scroll/"/>
    <id>http://idiotsky.me/2018/01/11/elasticsearch-scroll/</id>
    <published>2018-01-11T02:09:18.000Z</published>
    <updated>2018-01-11T12:40:46.639Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>之前面试被问到深分页的问题，现在mark一下吧</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Elasticsearch 是一个实时的分布式搜索与分析引擎，被广泛用来做全文搜索、结构化搜索、分析。在使用过程中，有一些典型的使用场景，比如分页、遍历等。在使用关系型数据库中，我们被告知要注意甚至被明确禁止使用深度分页，同理，在 Elasticsearch 中，也应该尽量避免使用深度分页。这篇文章主要介绍 Elasticsearch 中使用分页的方式、Elasticsearch 搜索执行过程以及为什么深度分页应该被禁止，最后再介绍使用 scroll 的方式遍历数据。</p>
<h1 id="Elasticsearch-搜索内部执行原理"><a href="#Elasticsearch-搜索内部执行原理" class="headerlink" title="Elasticsearch 搜索内部执行原理"></a>Elasticsearch 搜索内部执行原理</h1><p>一个最基本的 Elasticsearch 查询语句是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST /my_index/my_type/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,</div><div class="line">    &quot;from&quot;: 100,</div><div class="line">    &quot;size&quot;:  10</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的查询表示从搜索结果中取第100条开始的10条数据。下面讲解搜索过程时也以这个请求为例。</p>
<p>那么，这个查询语句在 Elasticsearch 集群内部是怎么执行的呢？为了方便描述，我们假设该 index 只有primary shards，没有 replica shards。</p>
<p>在 Elasticsearch 中，搜索一般包括两个阶段，query 和 fetch 阶段，可以简单的理解，query 阶段确定要取哪些doc，fetch 阶段取出具体的 doc。<br><a id="more"></a></p>
<h2 id="Query-阶段"><a href="#Query-阶段" class="headerlink" title="Query 阶段"></a>Query 阶段</h2><p><a href="http://idiotsky.me/images2/es-scroll-1.jpg"><img src="http://idiotsky.me/images2/es-scroll-1.jpg" alt=""></a></p>
<p>如上图所示，描述了一次搜索请求的 query 阶段。</p>
<ol>
<li>Client 发送一次搜索请求，node1 接收到请求，然后，node1 创建一个大小为 from + size 的优先级队列用来存结果，我们管 node1 叫 coordinating node。</li>
<li>coordinating node将请求广播到涉及到的 shards，每个 shard 在内部执行搜索请求，然后，将结果存到内部的大小同样为 from + size 的优先级队列里，可以把优先级队列理解为一个包含 top N 结果的列表。</li>
<li>每个 shard 把暂存在自身优先级队列里的数据返回给 coordinating node，coordinating node 拿到各个 shards 返回的结果后对结果进行一次合并，产生一个全局的优先级队列，存到自身的优先级队列里。</li>
</ol>
<p>在上面的例子中，coordinating node 拿到 (from + size) * 6 条数据，然后合并并排序后选择前面的 from + size 条数据存到优先级队列，以便 fetch 阶段使用。另外，各个分片返回给 coordinating node 的数据用于选出前 from + size 条数据，所以，只需要返回唯一标记 doc 的 _id 以及用于排序的 _score 即可，这样也可以保证返回的数据量足够小。</p>
<p>coordinating node 计算好自己的优先级队列后，query 阶段结束，进入 fetch 阶段。</p>
<h2 id="Fetch-阶段"><a href="#Fetch-阶段" class="headerlink" title="Fetch 阶段"></a>Fetch 阶段</h2><p>query 阶段知道了要取哪些数据，但是并没有取具体的数据，这就是 fetch 阶段要做的。<br><a href="http://idiotsky.me/images2/es-scroll-2.jpg"><img src="http://idiotsky.me/images2/es-scroll-2.jpg" alt=""></a></p>
<p>上图展示了 fetch 过程：</p>
<ol>
<li>coordinating node 发送 GET 请求到相关shards。</li>
<li>shard 根据 doc 的 _id 取到数据详情，然后返回给 coordinating node。</li>
<li>coordinating node 返回数据给 Client。</li>
</ol>
<p>coordinating node 的优先级队列里有 from + size 个 _doc _id，但是，在 fetch 阶段，并不需要取回所有数据，在上面的例子中，前100条数据是不需要取的，只需要取优先级队列里的第101到110条数据即可。</p>
<p>需要取的数据可能在不同分片，也可能在同一分片，coordinating node 使用 multi-get 来避免多次去同一分片取数据，从而提高性能。</p>
<h1 id="深度分页的问题"><a href="#深度分页的问题" class="headerlink" title="深度分页的问题"></a>深度分页的问题</h1><p>Elasticsearch 的这种方式提供了分页的功能，同时，也有相应的限制。举个例子，一个索引，有10亿数据，分10个 shards，然后，一个搜索请求，from=1,000,000，size=100，这时候，会带来严重的性能问题：</p>
<ul>
<li>CPU</li>
<li>内存</li>
<li>IO</li>
<li>网络带宽</li>
</ul>
<p>CPU、内存和IO消耗容易理解，网络带宽问题稍难理解一点。在 query 阶段，每个shards需要返回 1,000,100 条数据给 coordinating node，而 coordinating node 需要接收 10 * 1,000,100 条数据，即使每条数据只有 _doc _id 和 _score，这数据量也很大了，而且，这才一个查询请求，那如果再乘以100呢？</p>
<p>在另一方面，我们意识到，这种深度分页的请求并不合理，因为我们是很少人为的看很后面的请求的，在很多的业务场景中，都直接限制分页，比如只能看前100页。</p>
<p>不过，这种深度分页确实存在，比如，被爬虫了，这个时候，直接干掉深度分页就好；又或者，业务上有遍历数据的需要，比如，有1千万粉丝的微信大V，要给所有粉丝群发消息，或者给某省粉丝群发，这时候就需要取得所有符合条件的粉丝，而最容易想到的就是利用 from + size 来实现，不过，这个是不现实的，这时，可以采用 Elasticsearch 提供的 scroll 方式来实现遍历。</p>
<h1 id="利用-scroll-遍历数据"><a href="#利用-scroll-遍历数据" class="headerlink" title="利用 scroll 遍历数据"></a>利用 scroll 遍历数据</h1><p>可以把 scroll 理解为关系型数据库里的 cursor，因此，scroll 并不适合用来做实时搜索，而更适用于后台批处理任务，比如群发。</p>
<p>可以把 scroll 分为初始化和遍历两步，初始化时将所有符合搜索条件的搜索结果缓存起来，可以想象成快照，在遍历时，从这个快照里取数据，也就是说，在初始化后对索引插入、删除、更新数据都不会影响遍历结果。</p>
<h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><p>下面介绍下scroll的使用，可以通过 Elasticsearch 的 HTTP 接口做试验下，包括初始化和遍历两个部分。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">POST ip:port/my_index/my_type/_search?scroll=1m</div><div class="line">&#123;</div><div class="line">	&quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化时需要像普通 search 一样，指明 index 和 type (当然，search 是可以不指明 index 和 type 的)，然后，加上参数 scroll，表示暂存搜索结果的时间，其它就像一个普通的search请求一样。</p>
<p>初始化返回一个 _scroll_id，_scroll_id 用来下次取数据用。</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">POST /_search?scroll=1m</div><div class="line">&#123;</div><div class="line">    &quot;scroll_id&quot;:&quot;XXXXXXXXXXXXXXXXXXXXXXX I am scroll id XXXXXXXXXXXXXXX&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 scroll_id 即 上一次遍历取回的 _scroll_id 或者是初始化返回的 _scroll_id，同样的，需要带 scroll 参数。 重复这一步骤，直到返回的数据为空，即遍历完成。注意，每次都要传参数 scroll，刷新搜索结果的缓存时间。另外，不需要指定 index 和 type。</p>
<p>设置scroll的时候，需要使搜索结果缓存到下一次遍历完成，同时，也不能太长，毕竟空间有限。</p>
<h2 id="Scroll-Scan"><a href="#Scroll-Scan" class="headerlink" title="Scroll-Scan"></a>Scroll-Scan</h2><p>Elasticsearch 提供了 Scroll-Scan 方式进一步提高遍历性能。还是上面的例子，微信大V要给粉丝群发这种后台任务，是不需要关注顺序的，只要能遍历所有数据即可，这时候，就可以用Scroll-Scan。</p>
<p>Scroll-Scan 的遍历与普通 Scroll 一样，初始化存在一点差别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">POST ip:port/my_index/my_type/_search?search_type=scan&amp;scroll=1m&amp;size=50</div><div class="line">&#123;</div><div class="line">	&quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要指明参数：</p>
<ul>
<li>search_type。赋值为scan，表示采用 Scroll-Scan 的方式遍历，同时告诉 Elasticsearch 搜索结果不需要排序。</li>
<li>scroll。同上，传时间。</li>
<li>size。与普通的 size 不同，这个 size 表示的是每个 shard 返回的 size 数，最终结果最大为 number_of_shards * size。</li>
</ul>
<p>Scroll-Scan 方式与普通 scroll 有几点不同：</p>
<ol>
<li>Scroll-Scan 结果没有排序，按 index 顺序返回，没有排序，可以提高取数据性能。</li>
<li>初始化时只返回 _scroll_id，没有具体的 hits 结果。</li>
<li>size 控制的是每个分片的返回的数据量而不是整个请求返回的数据量。</li>
</ol>
<h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><p>用 Java 举个例子。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    response = esClient.prepareSearch(index)</div><div class="line">            .setTypes(type)</div><div class="line">            .setSearchType(SearchType.SCAN)</div><div class="line">            .setQuery(query)</div><div class="line">            .setScroll(<span class="keyword">new</span> TimeValue(timeout))</div><div class="line">            .setSize(size)</div><div class="line">            .execute()</div><div class="line">            .actionGet();</div><div class="line">&#125; <span class="keyword">catch</span> (ElasticsearchException e) &#123;</div><div class="line">    <span class="comment">// handle Exception</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化返回 _scroll_id，然后，用 _scroll_id 去遍历，注意，上面的query是一个JSONObject，不过这里很多种实现方式，我这儿只是个例子。</p>
<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    response = esClient.prepareSearchScroll(scrollId)</div><div class="line">            .setScroll(<span class="keyword">new</span> TimeValue(timeout))</div><div class="line">            .execute()</div><div class="line">            .actionGet();</div><div class="line">&#125; <span class="keyword">catch</span> (ElasticsearchException e) &#123;</div><div class="line">    <span class="comment">// handle Exception</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>深度分页不管是关系型数据库还是Elasticsearch还是其他搜索引擎，都会带来巨大性能开销，特别是在分布式情况下。</li>
<li>有些问题可以考业务解决而不是靠技术解决，比如很多业务都对页码有限制，google 搜索，往后翻到一定页码就不行了。</li>
<li>Elasticsearch 提供的 Scroll 接口专门用来获取大量数据甚至全部数据，在顺序无关情况下，首推Scroll-Scan。</li>
<li>描述搜索过程时，为了简化描述，假设 index 没有备份，实际上，index 肯定会有备份，这时候，就涉及到选择 shard。</li>
</ol>
<p>from <a href="http://lxwei.github.io/posts/%E4%BD%BF%E7%94%A8scroll%E5%AE%9E%E7%8E%B0Elasticsearch%E6%95%B0%E6%8D%AE%E9%81%8D%E5%8E%86%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5.html" target="_blank" rel="external">http://lxwei.github.io/posts/%E4%BD%BF%E7%94%A8scroll%E5%AE%9E%E7%8E%B0Elasticsearch%E6%95%B0%E6%8D%AE%E9%81%8D%E5%8E%86%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前面试被问到深分页的问题，现在mark一下吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Elasticsearch 是一个实时的分布式搜索与分析引擎，被广泛用来做全文搜索、结构化搜索、分析。在使用过程中，有一些典型的使用场景，比如分页、遍历等。在使用关系型数据库中，我们被告知要注意甚至被明确禁止使用深度分页，同理，在 Elasticsearch 中，也应该尽量避免使用深度分页。这篇文章主要介绍 Elasticsearch 中使用分页的方式、Elasticsearch 搜索执行过程以及为什么深度分页应该被禁止，最后再介绍使用 scroll 的方式遍历数据。&lt;/p&gt;
&lt;h1 id=&quot;Elasticsearch-搜索内部执行原理&quot;&gt;&lt;a href=&quot;#Elasticsearch-搜索内部执行原理&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch 搜索内部执行原理&quot;&gt;&lt;/a&gt;Elasticsearch 搜索内部执行原理&lt;/h1&gt;&lt;p&gt;一个最基本的 Elasticsearch 查询语句是这样的：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;POST /my_index/my_type/_search&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;quot;query&amp;quot;: &amp;#123; &amp;quot;match_all&amp;quot;: &amp;#123;&amp;#125;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;quot;from&amp;quot;: 100,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;quot;size&amp;quot;:  10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的查询表示从搜索结果中取第100条开始的10条数据。下面讲解搜索过程时也以这个请求为例。&lt;/p&gt;
&lt;p&gt;那么，这个查询语句在 Elasticsearch 集群内部是怎么执行的呢？为了方便描述，我们假设该 index 只有primary shards，没有 replica shards。&lt;/p&gt;
&lt;p&gt;在 Elasticsearch 中，搜索一般包括两个阶段，query 和 fetch 阶段，可以简单的理解，query 阶段确定要取哪些doc，fetch 阶段取出具体的 doc。&lt;br&gt;
    
    </summary>
    
      <category term="elasticsearch" scheme="http://idiotsky.me/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="http://idiotsky.me/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>用go小试websocket</title>
    <link href="http://idiotsky.me/2018/01/10/go-websocket/"/>
    <id>http://idiotsky.me/2018/01/10/go-websocket/</id>
    <published>2018-01-10T07:44:21.000Z</published>
    <updated>2018-01-10T14:02:38.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是websocket"><a href="#什么是websocket" class="headerlink" title="什么是websocket"></a>什么是websocket</h1><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？<br>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p>
<p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。<br>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p>
<p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p>
<p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href="https://en.wikipedia.org/wiki/Push_technology" target="_blank" rel="external">服务器推送</a>技术的一种。<br><a href="http://idiotsky.me/images2/go-websocket-1.png"><img src="http://idiotsky.me/images2/go-websocket-1.png" alt=""></a></p>
<a id="more"></a>
<p>其他特点包括：</p>
<ol>
<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
<li>数据格式比较轻量，性能开销小，通信高效。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ws://example.com:80/some/path</div></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="http://idiotsky.me/images2/go-websocket-2.jpg"><img src="http://idiotsky.me/images2/go-websocket-2.jpg" alt=""></a></p>
<h1 id="小试"><a href="#小试" class="headerlink" title="小试"></a>小试</h1><p>用一个echo的例子来试一下websocket</p>
<h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></div><div class="line">        var ws;</div><div class="line">        function connect() &#123;</div><div class="line">            ws= new WebSocket("ws://localhost:8080/echo");</div><div class="line">            ws.onopen = function()</div><div class="line">            &#123;</div><div class="line">                alert("connection is successful");</div><div class="line">            &#125;;</div><div class="line">            ws.onmessage = function (e)</div><div class="line">            &#123;</div><div class="line">                var msg = e.data;</div><div class="line">                var li=document.createElement("li");</div><div class="line">                li.innerText=msg;</div><div class="line">                document.getElementsByTagName("ul")[0].appendChild(li);</div><div class="line">            &#125;;</div><div class="line">            ws.onclose = function()</div><div class="line">            &#123;</div><div class="line">                // websocket is closed.</div><div class="line">                alert("Connection is closed...");</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        function send() &#123;</div><div class="line">            if(ws)&#123;</div><div class="line">                var msg=document.getElementById("txt").value;</div><div class="line">                ws.send(msg);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            alert("connect first!!!");</div><div class="line">        &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:connect()"</span>&gt;</span>connect<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"txt"</span> <span class="attr">style</span>=<span class="string">"width: 100%"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"sendBtn"</span> <span class="attr">onclick</span>=<span class="string">"send()"</span>&gt;</span>send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>代码很简单，就是用<code>new WebSocket(&quot;ws://localhost:8080/echo&quot;)</code>初始化websocket，然后注册相关事件，就可以完成一个简单websocket客户端了。</p>
<h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>go的标准库没有实现websocket的功能，所以要用<code>github.com/gorilla/websocket</code>这个库来实现服务端<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/gorilla/websocket"</span></div><div class="line"></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> upgrader = websocket.Upgrader&#123;</div><div class="line">	ReadBufferSize:  <span class="number">1024</span>,</div><div class="line">	WriteBufferSize: <span class="number">1024</span>,</div><div class="line">	CheckOrigin: <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span> <span class="title">bool</span></span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">	&#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	static := http.FileServer(http.Dir(<span class="string">"./static"</span>))</div><div class="line">	http.Handle(<span class="string">"/"</span>, static)</div><div class="line"></div><div class="line">	http.HandleFunc(<span class="string">"/echo"</span>, echo)</div><div class="line"></div><div class="line">	log.Printf(<span class="string">"Service started on %d \n"</span>, <span class="number">8080</span>)</div><div class="line">	log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line">	conn, err := upgrader.Upgrade(w, r, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Println(<span class="string">"upgrade error:"</span>, err.Error())</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	log.Println(<span class="string">"Connected..."</span>)</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		messageType, p, err := conn.ReadMessage()</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			log.Println(<span class="string">"read message error:"</span>, err.Error())</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> err := conn.WriteMessage(messageType, p); err != <span class="literal">nil</span> &#123;</div><div class="line">			log.Println(<span class="string">"write message error:"</span>, err.Error())</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	log.Println(<span class="string">"Disconnect."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先创建一个http服务，然后把上面的html作为静态资源，同时定义一个<code>echo</code>的处理函数。函数里面对请求进行<code>upgrade</code>，表示从普通的请求变成websocket（前提是请求头里面要包含<code>upgrade</code>标记），之后就获取了connection，接下来就跟平常tcp的连接那样读写数据了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>用go实现的websocket简直是简单到爆了，基本第三方库已经封装好了👿</p>
<p>所有代码在 <a href="https://github.com/ejunjsh/go-code/tree/master/websocket" target="_blank" rel="external">https://github.com/ejunjsh/go-code/tree/master/websocket</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是websocket&quot;&gt;&lt;a href=&quot;#什么是websocket&quot; class=&quot;headerlink&quot; title=&quot;什么是websocket&quot;&gt;&lt;/a&gt;什么是websocket&lt;/h1&gt;&lt;p&gt;初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？&lt;br&gt;答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。&lt;/p&gt;
&lt;p&gt;举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。&lt;br&gt;这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。&lt;/p&gt;
&lt;p&gt;轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。&lt;/p&gt;
&lt;p&gt;WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。&lt;/p&gt;
&lt;p&gt;它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于&lt;a href=&quot;https://en.wikipedia.org/wiki/Push_technology&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;服务器推送&lt;/a&gt;技术的一种。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images2/go-websocket-1.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images2/go-websocket-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
      <category term="websocket" scheme="http://idiotsky.me/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>go基础-nil</title>
    <link href="http://idiotsky.me/2018/01/03/go-nil/"/>
    <id>http://idiotsky.me/2018/01/03/go-nil/</id>
    <published>2018-01-03T15:48:13.000Z</published>
    <updated>2018-01-06T06:43:45.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nil是什么"><a href="#nil是什么" class="headerlink" title="nil是什么"></a>nil是什么</h1><blockquote>
<p>The “nil” identifier can be used as the “zero value” for interfaces, functions, pointers, maps, slices, and channels</p>
</blockquote>
<p>这是对nil的官方解释，意思就是说nil是接口，函数，指针，map，slice和管道的零值。零值，zero value，在Go语言中，如果你声明了一个变量但是没有对它进行赋值操作，那么这个变量就会有一个类型的默认零值。这是每种类型对应的零值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span>      -&gt; <span class="literal">false</span>                              </div><div class="line">numbers -&gt; <span class="number">0</span>                                 </div><div class="line"><span class="keyword">string</span>    -&gt; <span class="string">""</span>      </div><div class="line"></div><div class="line">pointers -&gt; <span class="literal">nil</span></div><div class="line">slices -&gt; <span class="literal">nil</span></div><div class="line">maps -&gt; <span class="literal">nil</span></div><div class="line">channels -&gt; <span class="literal">nil</span></div><div class="line">functions -&gt; <span class="literal">nil</span></div><div class="line">interfaces -&gt; <span class="literal">nil</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>举个例子，当你定义了一个struct：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</div><div class="line">  AgeYears <span class="keyword">int</span></div><div class="line">  Name <span class="keyword">string</span></div><div class="line">  Friends []Person</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p Person <span class="comment">// Person&#123;0, "", nil&#125;</span></div></pre></td></tr></table></figure></p>
<p>上面官方解释还有一句<code>The &quot;nil&quot; identifier</code>,意思就是说nil是一个标识符（变量），连go的关键字都不算，是一个预定义的变量而已，你甚至可以改变它<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="literal">nil</span> = errors.New(<span class="string">"hi"</span>)</div></pre></td></tr></table></figure></p>
<p>这样是完全可以编译得过的，但是最好不要这样子去做。</p>
<h1 id="nil有什么用"><a href="#nil有什么用" class="headerlink" title="nil有什么用"></a>nil有什么用</h1><p>在了解了什么是nil之后，再来说说nil有什么用。</p>
<h2 id="pointers"><a href="#pointers" class="headerlink" title="pointers"></a>pointers</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></div><div class="line">p == <span class="literal">nil</span>    <span class="comment">// true</span></div><div class="line">*p          <span class="comment">// panic: invalid memory address or nil pointer dereference</span></div></pre></td></tr></table></figure>
<p>指针表示指向内存的地址，如果对为nil的指针进行解引用的话就会导致panic。那么为nil的指针有什么用呢？先来看一个计算二叉树和的例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</div><div class="line">  v <span class="keyword">int</span></div><div class="line">  l *tree</div><div class="line">  r *tree</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// first solution</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">  sum := t.v</div><div class="line">  <span class="keyword">if</span> t.l != <span class="literal">nil</span> &#123;</div><div class="line">    sum += t.l.Sum()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> t.r != <span class="literal">nil</span> &#123;</div><div class="line">    sum += t.r.Sum()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sum</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码有两个问题，一个是代码重复：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> t.l != <span class="literal">nil</span> &#123;</div><div class="line">  <span class="comment">//....</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> t.r != <span class="literal">nil</span> &#123;</div><div class="line">  <span class="comment">//....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一个是当t是nil的时候会panic：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t *tree</div><div class="line">sum := t.Sum()   <span class="comment">// panic: invalid memory address or nil pointer dereference</span></div></pre></td></tr></table></figure></p>
<p>怎么解决上面的问题？我们先来看看一个指针接收器的例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">(p *person)</span></span> &#123; fmt.Println(<span class="string">"hi"</span>) &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">sayHi</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">"hi"</span>) &#125;</div><div class="line"><span class="keyword">var</span> p *person</div><div class="line">p.sayHi() <span class="comment">// hi</span></div></pre></td></tr></table></figure></p>
<p>这里就有点疑问，为什么<code>t.sum()</code>会报错，而<code>p.sayHi()</code>不报错，其实是因为<code>t.sum()</code>函数里面<code>sum := t.v</code>这句，其实它相当于<code>sum := (*t).v</code>,所以，对于指针对象的方法来说，就算指针的值为nil也是可以调用它们的方法,至于方法执行过程会不会报错就要做处理了，基于此，我们可以对刚刚计算二叉树和的例子进行一下改造：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(t *tree)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> t.v + t.l.Sum() + t.r.Sum()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>跟刚才的代码一对比是不是简洁了很多？对于nil指针，只需要在方法前面判断一下就ok了，无需重复判断。换成打印二叉树的值或者查找二叉树的某个值都是一样的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(t *tree)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> fmt.Sprint(t.l, t.v, t.r)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// nil receivers are useful: Find</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">Find</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> t.v == v || t.l.Find(v) || t.r.Find(v)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以如果不是很需要的话，不要用NewX()去初始化值，而是使用它们的默认值。</p>
<h2 id="slices"><a href="#slices" class="headerlink" title="slices"></a>slices</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// nil slices</span></div><div class="line"><span class="keyword">var</span> s []slice</div><div class="line"><span class="built_in">len</span>(s)  <span class="comment">// 0</span></div><div class="line"><span class="built_in">cap</span>(s)  <span class="comment">// 0</span></div><div class="line"><span class="keyword">for</span> <span class="keyword">range</span> s  <span class="comment">// iterates zero times</span></div><div class="line">s[i]  <span class="comment">// panic: index out of range</span></div></pre></td></tr></table></figure>
<p>一个为nil的slice，除了不能索引外，其他的操作都是可以的，当你需要填充值的时候可以使用append函数，slice会自动进行扩充。那么为nil的slice的底层结构是怎样的呢？根据官方的文档，slice有三个元素，分别是长度、容量、指向数组的指针：<br><a href="http://idiotsky.me/images2/go-nil.png"><img src="http://idiotsky.me/images2/go-nil.png" alt=""></a></p>
<p>当有元素的时候：<br><a href="http://idiotsky.me/images2/go-nil-1.png"><img src="http://idiotsky.me/images2/go-nil-1.png" alt=""></a></p>
<p>所以我们并不需要担心slice的大小，使用append的话slice会自动扩容。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// nil maps</span></div><div class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[t]u</div><div class="line"><span class="built_in">len</span>(m)  <span class="comment">// 0</span></div><div class="line"><span class="keyword">for</span> <span class="keyword">range</span> m <span class="comment">// iterates zero times</span></div><div class="line">v, ok := m[i] <span class="comment">// zero(u), false</span></div><div class="line">m[i] = x <span class="comment">// panic: assignment to entry in nil map</span></div></pre></td></tr></table></figure>
<p>对于nil的map，我们可以简单把它看成是一个只读的map，不能进行写操作，否则就会panic。那么nil的map有什么用呢？看一下这个例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGet</span><span class="params">(url <span class="keyword">string</span>, headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="params">(*http.Request, error)</span></span> &#123;</div><div class="line">  req, err := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</div><div class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> headers &#123;</div><div class="line">    req.Header.Set(k, v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> req, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于NewGet来说，我们需要传入一个类型为map的参数，并且这个函数只是对这个参数进行读取，我们可以传入一个非空的值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NewGet(<span class="string">"http://google.com"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</div><div class="line">  <span class="string">"USER_AGENT"</span>: <span class="string">"golang/gopher"</span>,</div><div class="line">&#125;,)</div></pre></td></tr></table></figure></p>
<p>或者这样传：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NewGet(<span class="string">"http://google.com"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;)</div></pre></td></tr></table></figure></p>
<p>但是前面也说了，map的零值是nil，所以当header为空的时候，我们也可以直接传入一个nil：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NewGet(<span class="string">"http://google.com"</span>, <span class="literal">nil</span>)</div></pre></td></tr></table></figure></p>
<p>是不是简洁很多？所以，把nil map作为一个只读的空的map进行读取吧。</p>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// nil channels</span></div><div class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> t</div><div class="line">&lt;- c      <span class="comment">// blocks forever</span></div><div class="line">c &lt;- x    <span class="comment">// blocks forever</span></div><div class="line"><span class="built_in">close</span>(c)  <span class="comment">// panic: close of nil channel</span></div></pre></td></tr></table></figure>
<p>举个例子，假如现在有两个channel负责输入，一个channel负责汇总，简单的实现代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> &#123;</div><div class="line">    <span class="keyword">select</span> &#123;</div><div class="line">      <span class="keyword">case</span> v := &lt;-a:</div><div class="line">        out &lt;- v</div><div class="line">      <span class="keyword">case</span> v := &lt;- b:</div><div class="line">        out &lt;- v</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果在外部调用中关闭了a或者b，那么就会不断地从a或者b中读出0，这和我们想要的不一样，我们想关闭a和b后就停止汇总了，修改一下代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> a != <span class="literal">nil</span> || b != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">select</span> &#123;</div><div class="line">      <span class="keyword">case</span> v, ok := &lt;-a:</div><div class="line">          <span class="keyword">if</span> !ok &#123;</div><div class="line">            a = <span class="literal">nil</span></div><div class="line">            fmt.Println(<span class="string">"a is nil"</span>)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">          &#125;</div><div class="line">          out &lt;- v</div><div class="line">      <span class="keyword">case</span> v, ok := &lt;-b:</div><div class="line">          <span class="keyword">if</span> !ok &#123;</div><div class="line">            b = <span class="literal">nil</span></div><div class="line">            fmt.Println(<span class="string">"b is nil"</span>)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">          &#125;</div><div class="line">          out &lt;- v</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  fmt.Println(<span class="string">"close out"</span>)</div><div class="line">  <span class="built_in">close</span>(out)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在知道channel关闭后，将channel的值设为nil，这样子就相当于将这个select case子句停用了，因为nil的channel是永远阻塞的。</p>
<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>interface并不是一个指针，它的底层实现由两部分组成，一个是类型，一个值，也就是类似于：(Type, Value)。只有当类型和值都是nil的时候，才等于nil。看看下面的代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> doError <span class="keyword">struct</span> &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *doError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> <span class="title">error</span></span> &#123;   <span class="comment">// error(*doError, nil)</span></div><div class="line">	<span class="keyword">var</span> err *doError</div><div class="line">	<span class="keyword">return</span> err  <span class="comment">// nil of type *doError</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	err := do()</div><div class="line">	fmt.Println(err == <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果是false。do函数声明了一个*doErro的变量err，然后返回，返回值是error接口，但是这个时候的Type已经变成了：（*doError，nil），所以和nil肯定是不会相等的。所以我们在写函数的时候，不要声明具体的error变量，而是应该直接返回nil：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再来看看这个例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> *<span class="title">doError</span></span> &#123;  <span class="comment">// nil of type *doError</span></div><div class="line">  <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">wrapDo</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="comment">// error (*doError, nil)</span></div><div class="line">  <span class="keyword">return</span> do()       <span class="comment">// nil of type *doError</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  err := wrapDo()   <span class="comment">// error  (*doError, nil)</span></div><div class="line">  fmt.Println(err == <span class="literal">nil</span>) <span class="comment">// false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里最终的输出结果也是false。为什么呢？尽管wrapDo函数返回的是error类型，但是do返回的却是*doError类型，也就是变成了（*doError，nil），自然也就和nil不相等了。因此，不要返回具体的错误类型。遵从这两条建议，才可以放心地使用<code>if x != nil</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>nil指针可以执行方法，nil的map和slice只是可读，nil的chan可以用来做为select的停止标记，而nil的interface可能就是个坑👿</p>
<p>参考 <a href="https://www.jianshu.com/p/dd80f6be7969" target="_blank" rel="external">https://www.jianshu.com/p/dd80f6be7969</a><br>部分代码 <a href="https://github.com/ejunjsh/go-code/tree/master/nil" target="_blank" rel="external">https://github.com/ejunjsh/go-code/tree/master/nil</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;nil是什么&quot;&gt;&lt;a href=&quot;#nil是什么&quot; class=&quot;headerlink&quot; title=&quot;nil是什么&quot;&gt;&lt;/a&gt;nil是什么&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;The “nil” identifier can be used as the “zero value” for interfaces, functions, pointers, maps, slices, and channels&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是对nil的官方解释，意思就是说nil是接口，函数，指针，map，slice和管道的零值。零值，zero value，在Go语言中，如果你声明了一个变量但是没有对它进行赋值操作，那么这个变量就会有一个类型的默认零值。这是每种类型对应的零值：&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;      -&amp;gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;                              &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;numbers -&amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;                                 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;    -&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;      &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;pointers -&amp;gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;slices -&amp;gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;maps -&amp;gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;channels -&amp;gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;functions -&amp;gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;interfaces -&amp;gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>jvm full gc 解惑</title>
    <link href="http://idiotsky.me/2017/11/06/java-fullgc/"/>
    <id>http://idiotsky.me/2017/11/06/java-fullgc/</id>
    <published>2017-11-06T10:03:15.000Z</published>
    <updated>2017-11-07T14:09:00.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一直以来，都觉得full gc就是对old区的gc，然后就打脸了。。。。</p>
</blockquote>
<p>下面先引用R大的原文：</p>
<blockquote>
<p>针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：</p>
<ul>
<li>Partial GC：并不收集整个GC堆的模式<ul>
<li>Young GC：只收集young gen的GC</li>
<li>Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式</li>
<li>Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式</li>
</ul>
</li>
<li>Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。</li>
</ul>
</blockquote>
<a id="more"></a>
<blockquote>
<p>Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。</p>
<p>最简单的分代式GC策略，按HotSpot VM的serial GC的实现来看，触发条件是：</p>
<ul>
<li>young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。</li>
<li>full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。</li>
</ul>
<p>HotSpot VM里其它非并发GC的触发条件复杂一些，不过大致的原理与上面说的其实一样。当然也总有例外。Parallel Scavenge（-XX:+UseParallelGC）框架下，默认是在要触发full GC前先执行一次young GC，并且两次GC之间能让应用程序稍微运行一小下，以期降低full GC的暂停时间（因为young GC会尽量清理了young gen的死对象，减少了full GC的工作量）。控制这个行为的VM参数是-XX:+ScavengeBeforeFullGC。这是HotSpot VM里的奇葩嗯。</p>
<p>并发GC的触发条件就不太一样。以CMS GC为例，它主要是定时去检查old gen的使用量，当使用量超过了触发比例就会启动一次CMS GC，对old gen做并发收集。</p>
</blockquote>
<p>总结一下：</p>
<ol>
<li>full gc 是全区回收(打脸)</li>
<li>full gc 之前不会触发young gc（一般情况）</li>
</ol>
<p>再引用下别的大牛的话：</p>
<blockquote>
<p>先看一下HotSpot VM的GC家族的组合示意图：<br><a href="http://idiotsky.me/images1/java-fullgc-1.jpg"><img src="http://idiotsky.me/images1/java-fullgc-1.jpg" alt=""></a><br>不同的GC组合套装之中，具备Full GC能力的大概有三种：</p>
<ol>
<li>ParallelOld(PSMarkSweep)</li>
<li>Serial Old(MarkSweep)</li>
<li>“?”所代表的G1</li>
</ol>
<p>暂不考虑G1，除了CMS具备在年老代进行Major GC之外，其他情况下年老代的GC都是由Full GC触发的。Full GC的收集范围包含整个Heap区域( Eden + S1 + S2 + Tenured)，它发生时Mutator停止工作——Stop The World。对于Serial Collector，它采用MSC(Mark-Sweep-Compact)的算法对全堆进行Full GC，在HotSpot VM的实现中，主要用MarkSweep这个类来实现；对于Parallel Collector而言，PSMarkSweep是多线程的MarkSweep，名不副实，这玩意儿其实是个实现了Lisp2的Mark-Compact GC算法。PSMarkSweep有个特殊的地方是如果配置了<strong>ScavengeBeforeFullGC</strong> 这个flag，则会在Full GC之前对年轻代进行一次Minor GC；其他情况根本不需要Full GC之前先执行Minor GC，Full GC会对年轻代发起GC。Full GC前后Heap的对比示意参见：<br><a href="http://idiotsky.me/images1/java-fullgc-2.jpg"><img src="http://idiotsky.me/images1/java-fullgc-2.jpg" alt=""></a></p>
<p>可见，一般情况下，年轻代的存活对象都被Compact到了年老代，所以，你看到年轻代都被清空了；只有当年老代满了的时候，才会Compact到Eden区域。</p>
<p>对于Concurrent Collector，CMS在Remark Phase，可以通过设置 <strong>CMSScavengeBeforeRemark</strong> 在remark之前先行YGC，这给了CMS在Major GC时触发Minor GC的机会，但这个Flag默认是false；当CMS发生 <strong>Concurrent Mode Failure</strong> 时，CMS会退化为Serial Old GC，从而采用与Serial Collector相同的算法进行Full GC。CMS发生 <strong>Concurrent Mode Failure</strong> 的原因：1. 因为是并发收集，所以Mutator仍可能在不断占用年老代的空间，当然还包括这一趟无法收集的Float Garbage会占用内存空间，如果年老代空间被占满但并发收集还未结束，就会发生并发模式失败；2. 因为CMS采用的是Mark Sweep算法，本身内存碎片化无法解决，很可能发生大对象分配时没有连续空间，或者本身剩余空间不够大对象分配时，也会发生并发模式失败。</p>
</blockquote>
<p>再总结下:</p>
<ol>
<li>Serial Old 做full gc 时候不会执行young gc，而 ParallelOld 会根据 <strong>ScavengeBeforeFullGC</strong> 来决定是否在full gc前执行一次young gc</li>
<li>CMS 有自己的major gc，单独执行old区的gc，但是如果 <strong>Concurrent Mode Failure</strong> 的话，就还是老老实实做Serial Old的full gc吧。</li>
<li>CMS 的 <strong>CMSScavengeBeforeRemark</strong> 标记决定了是否在remark阶段之前执行一次young gc（网上说这个标记还能解决跨代引用问题），</li>
</ol>
<p>参考 <a href="https://www.zhihu.com/question/62604570" target="_blank" rel="external">https://www.zhihu.com/question/62604570</a><br>参考 <a href="https://www.zhihu.com/question/41922036" target="_blank" rel="external">https://www.zhihu.com/question/41922036</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一直以来，都觉得full gc就是对old区的gc，然后就打脸了。。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面先引用R大的原文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Partial GC：并不收集整个GC堆的模式&lt;ul&gt;
&lt;li&gt;Young GC：只收集young gen的GC&lt;/li&gt;
&lt;li&gt;Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式&lt;/li&gt;
&lt;li&gt;Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="jvm" scheme="http://idiotsky.me/tags/jvm/"/>
    
      <category term="gc" scheme="http://idiotsky.me/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>Git先生的故事</title>
    <link href="http://idiotsky.me/2017/11/05/git-story/"/>
    <id>http://idiotsky.me/2017/11/05/git-story/</id>
    <published>2017-11-05T14:44:05.000Z</published>
    <updated>2017-11-07T14:52:01.852Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>很有意思的通俗的总结了git。👿</p>
</blockquote>
<p>Git先生是一位很出名的摄影专家，他的主要职责是用它强大的拍摄技术帮我们共享成果，共创未来。为此它准备了许许多多的工具来实现这样的目标。下面我们就来看看Git先生的工作场所，和他为我们的一些痛点带来了哪些解决方案吧。</p>
<h1 id="初次见面"><a href="#初次见面" class="headerlink" title="初次见面"></a>初次见面</h1><p>老板（用户自己）新买了一块地皮（创建了一个目录），想聘请Git先生到此开设一个工作室来加快这个地皮的建设工作。老板用<code>git init</code> 招来了Git先生，Git先生在该目录下生成一个.git目录，用来作为自己的办公室，办公室用来记录自己的工作日志和成果。</p>
<p>让我们来从空中俯瞰下这块新的地皮，和Git先生为它所设计的蓝图吧。<br><a href="http://idiotsky.me/images1/git-story-1.jpg"><img src="http://idiotsky.me/images1/git-story-1.jpg" alt=""></a></p>
<p>下面我们来解释下，这几个区域的作用：<br>Working Directory：Git先生的老板所买下的地皮，这个是实实在在物理层面的地皮，我们可以在上面种些花花草草，建点高楼大厦啥的。</p>
<p>Staging Area：Git先生摄影棚所在地，位置位于Git先生的办公室。每当老板完成了某件名垂青史的伟事，他就会命令Git先生把自己这个阶段所干的事情一五一十的搬到摄影棚拍照记录下来。<code>git add</code> 就是把修改搬到摄影棚，<code>git commit</code>就是命令Git先生拍照，而拍完照后，摄影棚马上会被打扫干净。</p>
<p>Repository：Git先生办公室的某个区域，专门用来存储照片用的。</p>
<p>Remote：这是一块云端区域，Git先生会在工作完一段时间后，就把自己的作品上传上去。这样做，一方面是用来保存自己的作品，以备意外发生，另一方面也是提供给其他有兴趣的老板们一起做这个项目。<br><a id="more"></a></p>
<h1 id="Go-to-work"><a href="#Go-to-work" class="headerlink" title="Go to work"></a>Go to work</h1><p>一切准备妥当后，Git先生马上就投入到了紧张的工作当中。老板首先就迫不及待的在地皮上上种了一朵花，然后马上命令Git来拍照留念。<br><a href="http://idiotsky.me/images1/git-story-2.jpg"><img src="http://idiotsky.me/images1/git-story-2.jpg" alt=""></a><br>当然结果是失败的，Git也很苦恼，自己已经把所有流程和老板说过一遍了，但老板还是会鲁莽行事。然后Git先生又向老板耐心的解释了一下针对Git目录下某个修改的4种状态。</p>
<blockquote>
<p>Untracked/Tracked<br>Not Staged/Staged<br>比如你新建一个文件，它的状态就是 Untracked 的，你不能对 Untracked 的文件进行任何Git操作，除了先使用<code>git add</code> 让它先变为Tracked 状态。一个文件被Track后，以后的修改如果未用<code>git add</code>，那这个修改就叫Not Staged，需要add后，让它变为Staged才能进行Commit。</p>
</blockquote>
<p>老板按照Git先生的说法又执行了一遍，这次他成功了。Git又向老板说，你可以用<code>git log</code>来查看我已经拍过的照片。</p>
<p>老板学会这招后，又给这块地皮创建了树、草，并且也都分别让Git先生拍了照片保存。</p>
<p><code>git log</code>后我们看到了这三张照片，如果要查看详情还可以使用<code>git log -p</code>。<br><a href="http://idiotsky.me/images1/git-story-3.jpg"><img src="http://idiotsky.me/images1/git-story-3.jpg" alt=""></a></p>
<blockquote>
<p>导演注：Commit的id为对当前文件夹内容做SHA-1得来。</p>
</blockquote>
<h1 id="上点儿色吧"><a href="#上点儿色吧" class="headerlink" title="上点儿色吧"></a>上点儿色吧</h1><p>老板想把树涂成红色的，再给树取个名字叫big tree。他记得Git先生告诉过他可以用<code>git diff</code>来查看自己所做的改动<br><a href="http://idiotsky.me/images1/git-story-4.jpg"><img src="http://idiotsky.me/images1/git-story-4.jpg" alt=""></a><br>看到了自己的修改后，老板满意的点点头，然后用<code>git add .</code>把它们都丢进了摄影棚。过后就出去忙其他事情了，回来后他发现自己忘记离开前做了啥事情了。此时他再用<code>git diff</code>查看，发现里面空空如也。老板愤怒的叫来了Git先生问他是咋回事。Git先生友善的解释了原因。</p>
<p>“<code>git diff</code>显示了您当前修改和我办公室中所记录的最新一张照片之间的差异，但是您已经把这些改动都挪到我的摄影棚里了，git diff就没法查看了，如果您想看我摄影棚里摆了哪些东西。你可以使用<code>git diff --staged/cached</code>哦”</p>
<p>老板按照Git先生所说，果然看到了他以前的修改记录。</p>
<blockquote>
<p>导演注：stage相关的命令一般都与Staging Area相关，git add 也可以写成 git stage，这两个命令是一样的。</p>
</blockquote>
<p>不过当老板看到他把树设成了红色，觉得不合理，想放弃这次修改。他要如何去做呢？</p>
<p><code>git reset &lt;file&gt;</code> 把这个文件的修改从Staging Area中去除<br><code>git checkout -- &lt;file&gt;</code> 放弃工作区文件的修改</p>
<blockquote>
<p>导演注：这里使用 <code>git checkout &lt;file&gt;</code> 也行，之所以使用–，因为该命令与切换分支的命令一样，万一这个文件名和某个分支名重名，则<code>git checkout &lt;file&gt;</code>就变成切换分支了。</p>
</blockquote>
<p>老板不禁感叹，幸好自己没有进行commit。Git先生告诉老板说，即使你commit了，也不用怕，我也有几种解决方案。<br>一，放弃整张照片<br><code>git reset HEAD~1</code> HEAD表示指向最新那张照片的指针，～1表示要想起回退一张，此时我们有三种回退方式可选<code>--soft</code>表示只删除照片，照片的修改恢复到Staging Area中,<code>--mixed</code>不但删除照片，也不恢复Staging Area中的状态（不加选项时就为此中方法）,<code>--hard</code>不但删除照片，而且连工作区域的修改也被回退掉</p>
<p>二，我们再产生一张想放弃的照片的反修改的照片<br><code>git revert &lt;commit-id&gt;</code> 产生此commit的反修改，并提交此处commit-id不必是最新一次，可以是任意处的。<br>第一种方案适用于，你的commit还未push到云端的场景，第二种，如果你的修改已经push到云端，那么为了尊重历史记录，最好就是生成一个方向修改来回退错误部分，让其他人知道历史。</p>
<blockquote>
<p>导演注：HEAD指针记录了正在操作的节点的commit id，每个分支都有属于自己的HEAD指针，并且只有一个</p>
</blockquote>
<h1 id="拨弄你的指针"><a href="#拨弄你的指针" class="headerlink" title="拨弄你的指针"></a>拨弄你的指针</h1><p>老板经过上次的事件，发现自己可能会因为一时冲动做出一些错误的决定。就问Git先生是否有办法把自己所有操作行为都记录下来，而且还允许自己撤销任何一种错误的操作。Git先生向老板解释说：所有对HEAD指针的操作都会被记录下来。</p>
<p>可以用<code>git reflog</code>查看到老板的所有HEAD操作<br><a href="http://idiotsky.me/images1/git-story-5.jpg"><img src="http://idiotsky.me/images1/git-story-5.jpg" alt=""></a><br>最上面，我们可以看到是老板彻底回退了给树添加名字和颜色修改，执行了<code>git reset --hard HEAD~1</code>，而如果老板突然又后悔了，想恢复添加名字和颜色的修改。那么我们就可以通过执行<code>git reset --hard HEAD@{1}</code>来把操作回退到<code>HEAD@{1}</code>时，也就是加入名字和颜色那次commit。</p>
<blockquote>
<p>这里的reset也有三个选项，<code>--soft</code>，<code>--mixed</code>，<code>--hard</code>，因为这里执行的是恢复操作，所以这三个选项在这里的作用也需要反过来理解，hard自不用说，就是完全恢复到某个操作时的状态，而soft表示，虽然把HEAD指针拨到了某个操作时的状态，但在staging area中会产生可以让恢复后的状态重新修改回来的修改，就像物质与反物质那样。mixed同理。</p>
</blockquote>
<p>以上可能难以理解，这里我们再举个应用场景来说明下：<br>我们知道<code>git revert</code>每次只能回退某个commit，那我们如何同时revert掉多个commit呢。针对这种场景我们就可以进行以下操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//拨动HEAD指针到5add0e9</div><div class="line">git reset --hard 5add0e9 </div><div class="line">//恢复到以前的commit处信息，并且在staging area生成了中反修改</div><div class="line">git reset --soft HEAD@&#123;1&#125; </div><div class="line">// 注意此处用了--soft</div><div class="line">git commit -m &apos;revert to 5add0e9&apos;</div></pre></td></tr></table></figure></p>
<h1 id="多干点事"><a href="#多干点事" class="headerlink" title="多干点事"></a>多干点事</h1><p>老板：地皮准备好了， 我们既要种花，种草，还要盖个楼房啥的，种花要花几天功夫，种草好又得花几天。这几样事咱能不能一起干呢？干完了，分别拍个照片再合一块岂不美哉。</p>
<p>Git先生：老板英明，针对这种情况我也早有准备。</p>
<p><code>git branch &lt;branch-name&gt;</code> 创建一个分支，不加<code>&lt;branch-name&gt;</code>则为列出当前所有分支<code>git branch -d &lt;branch-name&gt;</code>删除分支 -D 为强制删除分支<code>git checkout &lt;branch-name&gt;</code> 切换到该分支下<code>git merge &lt;branch-name&gt;</code> 合并<code>&lt;branch-name&gt;</code>分支内容到本分支下</p>
<blockquote>
<p>针对老板说的这种情况，我们只需要创建如下分支。然后分别在flower里种花，grass中种草，building中盖楼，最后在master分支中把完成的照片merge过来就行。<br>➜ GitTestRepo git:(master) git branch flower<br>➜ GitTestRepo git:(master) git branch grass<br>➜ GitTestRepo git:(master) git branch building<br>➜ GitTestRepo git:(master) git branch<br>building<br>flower<br>grass<br>* master</p>
<p>导演注：分支前加*号的为当前工作分支</p>
</blockquote>
<h1 id="合作共赢"><a href="#合作共赢" class="headerlink" title="合作共赢"></a>合作共赢</h1><p>Git先生：报告老板，您这块地皮很大，要是只有我们开发，那得花上很久时间，何不把它开放出去，让其他老板们一起进来把这块蛋糕做大呢。</p>
<p>老板：好主意，我们要怎么做呢？</p>
<p>Git先生：一切交给我，不过因为地皮开放出去后，涉及到多方共同开发。有些注意事项还希望老板能听我说道说道，否则危害甚大。</p>
<p>老板：请讲请讲！</p>
<p>如我们第一张图所示，我们可以利用git push来把自己所有的照片上传到云端，让其他人也可以参与进来开发。既然是云端，那么首先我们就需要指明下这个云端地皮的地址是哪里。</p>
<p><code>git remote add origin https://github.com/CPPAlien/GitTestRepo.git</code>//这里一般用origin，当然你可以换成其他任何名，你也可以添加多个remote地址git remote -v 可以用来查看所有云端地址信息<br><code>git push -u &lt;remote&gt; &lt;branch&gt; git push --set-upstream &lt;remote&gt; &lt;branch&gt;</code>用这两个命令来指明某个分支所对应到的remote地址。如果不指定，你在执行git push时需要明确写出remote和branch。<br><a href="http://idiotsky.me/images1/git-story-6.jpg"><img src="http://idiotsky.me/images1/git-story-6.jpg" alt=""></a></p>
<p>因为是多人合作，所以就有可能别人在云端先与你提交了一些修改，而此时就需要进行git pull操作，把别人的修改拉取下来合并到本地。但直接git pull行为是不太安全的，因为它会直接产生merge行为，可能会导致你本地数据错乱。所以我们一般用git fetch，正确流程如下</p>
<p><code>git fetch origin master</code>//获取origin上的master分支，会在本地自动创建一个的origin/master的临时分支。<br><code>git log -p master..origin/master</code>//比较本地的master分支和远端的master分支，看下差别。<br><code>git merge origin/master</code> 或 <code>git rebase origin/master</code> //如果差别是在自己的认知范围，那么就进行合并操作，这样本地的master分支就与云端保持一致了。如果本地有未push的commit，则会产生Merge的commit行为。Merge的过程中有可能因为多人对同一个文件的修改而造成冲突。<br><code>git mergetool</code>//打开merge工具，merge完后保存，然后手动提交merge后的结果。完成上述操作后，就可以把自己本地的commit提交到云端了。</p>
<blockquote>
<p>导演注：git merge 和 git rebase的区别，rebase是找到两者共同的commit处，把它者的修改接上去，然后再把自己的修改接在它者的修改后面，不会产生merge行为。看历史图时也不会像merge那样有分叉。</p>
</blockquote>
<p>从以下执行rebase后的提示，也可知二三</p>
<blockquote>
<p>➜ GitTest git:(master) git rebase origin/masterFirst<br>rewinding head to replay your work on top of it…Fast-forwarded master to origin/master.</p>
</blockquote>
<h1 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h1><p><code>git cherry-pick &lt;commit-id&gt;</code><br>老板如果想把其他分支上的一些照片拣过来使用，可以使用此命令。如果该照片与本分支无冲突，则直接会在本分支上加上一条commit，如果有冲突，则需要解决冲突后重新提交。<br><code>git stash/ git stash pop</code><br>如果老板当前有些工作没有commit。但有些云端的commit或者其他分支的commit是自己后续开发所要依赖的，那就可以使用git stash把当前未提交的修改放入到缓存栈，等合并操作完成后，再用git stash pop，把修改再加回来，你可以用git stash list查看当前的缓存栈。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Git和Mercurial 都是在2005年时出现，分别由Linus和Matt主导开发。而两者的出现也源于一个共同的事件，2005年初BitKeeper宣布向开源社区收费。Mercurial在英语中有反复无常的意思，而Git也可以翻译成无用之人，Matt直接说他取名Mercurial的用意就是讽刺BitKeeper的开发者。</p>
<p>from <a href="https://www.toutiao.com/i6484504341452440077/" target="_blank" rel="external">https://www.toutiao.com/i6484504341452440077/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;很有意思的通俗的总结了git。👿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git先生是一位很出名的摄影专家，他的主要职责是用它强大的拍摄技术帮我们共享成果，共创未来。为此它准备了许许多多的工具来实现这样的目标。下面我们就来看看Git先生的工作场所，和他为我们的一些痛点带来了哪些解决方案吧。&lt;/p&gt;
&lt;h1 id=&quot;初次见面&quot;&gt;&lt;a href=&quot;#初次见面&quot; class=&quot;headerlink&quot; title=&quot;初次见面&quot;&gt;&lt;/a&gt;初次见面&lt;/h1&gt;&lt;p&gt;老板（用户自己）新买了一块地皮（创建了一个目录），想聘请Git先生到此开设一个工作室来加快这个地皮的建设工作。老板用&lt;code&gt;git init&lt;/code&gt; 招来了Git先生，Git先生在该目录下生成一个.git目录，用来作为自己的办公室，办公室用来记录自己的工作日志和成果。&lt;/p&gt;
&lt;p&gt;让我们来从空中俯瞰下这块新的地皮，和Git先生为它所设计的蓝图吧。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images1/git-story-1.jpg&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images1/git-story-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我们来解释下，这几个区域的作用：&lt;br&gt;Working Directory：Git先生的老板所买下的地皮，这个是实实在在物理层面的地皮，我们可以在上面种些花花草草，建点高楼大厦啥的。&lt;/p&gt;
&lt;p&gt;Staging Area：Git先生摄影棚所在地，位置位于Git先生的办公室。每当老板完成了某件名垂青史的伟事，他就会命令Git先生把自己这个阶段所干的事情一五一十的搬到摄影棚拍照记录下来。&lt;code&gt;git add&lt;/code&gt; 就是把修改搬到摄影棚，&lt;code&gt;git commit&lt;/code&gt;就是命令Git先生拍照，而拍完照后，摄影棚马上会被打扫干净。&lt;/p&gt;
&lt;p&gt;Repository：Git先生办公室的某个区域，专门用来存储照片用的。&lt;/p&gt;
&lt;p&gt;Remote：这是一块云端区域，Git先生会在工作完一段时间后，就把自己的作品上传上去。这样做，一方面是用来保存自己的作品，以备意外发生，另一方面也是提供给其他有兴趣的老板们一起做这个项目。&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://idiotsky.me/categories/git/"/>
    
    
      <category term="git" scheme="http://idiotsky.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>TCP 的那些事儿</title>
    <link href="http://idiotsky.me/2017/11/01/tcp-something/"/>
    <id>http://idiotsky.me/2017/11/01/tcp-something/</id>
    <published>2017-11-01T14:56:41.000Z</published>
    <updated>2017-11-11T07:14:37.652Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>tcp看了很多的文章，这篇总结的很好。此文有点长👿</p>
</blockquote>
<p>tcp在网络OSI的七层模型中的第四层——Transport(传输)层，IP在第三层——Network(网络)层，ARP在第二层——Data Link(数据链路)层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。</p>
<p>首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p>
<h1 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h1><p>接下来，我们来看一下TCP头的格式<br><a href="http://idiotsky.me/images1/tcp-something-1.jpg"><img src="http://idiotsky.me/images1/tcp-something-1.jpg" alt=""></a><br>你需要注意这么几点：</p>
<ul>
<li>TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</li>
<li>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：<ul>
<li>Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。</li>
<li>Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。</li>
<li>Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。</li>
<li>TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>关于其它的东西，可以参看下面的图示<br><a href="http://idiotsky.me/images1/tcp-something-2.jpg"><img src="http://idiotsky.me/images1/tcp-something-2.jpg" alt=""></a></p>
<h1 id="TCP的状态机"><a href="#TCP的状态机" class="headerlink" title="TCP的状态机"></a>TCP的状态机</h1><p>其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。</p>
<p>下面是：“TCP协议的状态机”  和 “TCP建链接”、“TCP断链接”、“传数据” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。<br><a href="http://idiotsky.me/images1/tcp-something-3.png"><img src="http://idiotsky.me/images1/tcp-something-3.png" alt=""></a><br><a href="http://idiotsky.me/images1/tcp-something-4.jpg"><img src="http://idiotsky.me/images1/tcp-something-4.jpg" alt=""></a><br>很多人会问，为什么建链接要3次握手，断链接需要4次挥手？</p>
<ul>
<li><strong>对于建链接的3次握手</strong>，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</li>
<li><strong>对于4次挥手</strong>，其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。下图是双方同时断连接的示意图（你同样可以对照着TCP状态机看）：</li>
</ul>
<p><a href="http://idiotsky.me/images1/tcp-something-5.png"><img src="http://idiotsky.me/images1/tcp-something-5.png" alt=""></a><br>另外，有几个事情需要注意一下：</p>
<ul>
<li><strong>关于建连接时SYN超时</strong>。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</li>
<li><strong>关于SYN Flood攻击</strong>。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</li>
<li><strong>关于ISN的初始化</strong>。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。<a href="http://tools.ietf.org/html/rfc793" target="_blank" rel="external">RFC793</a>中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – <a href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime" target="_blank" rel="external">Wikipedia语条</a>），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</li>
<li><strong>关于 MSL 和 TIME_WAIT</strong>。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（RFC793定义了MSL为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《<a href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html" target="_blank" rel="external">TIME_WAIT and its design implications for protocols and scalable client server systems</a>》</li>
<li><strong>关于TIME_WAIT数量太多</strong>。从上面的描述我们可以知道，TIME_WAIT是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫tcp_tw_reuse，另一个叫tcp_tw_recycle的参数，这两个参数默认值都是被关闭的，后者recyle比前者resue更为激进，resue要温柔一些。另外，如果使用tcp_tw_reuse，必需设置tcp_timestamps=1，否则无效。这里，你一定要注意，打开这两个参数会有比较大的坑——可能会让TCP连接出一些诡异的问题（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如官方文档上说的一样“<strong>It should not be changed without advice/request of technical experts</strong>”）。<ul>
<li><strong>关于tcp_tw_reuse</strong>。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下<a href="http://lxr.free-electrons.com/ident?i=tcp_twsk_unique" target="_blank" rel="external">tcp_twsk_unique</a>的源码 ）。我个人估计还是有一些场景会有问题。</li>
<li><strong>关于tcp_tw_recycle</strong>。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建链接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）（如果你想观摩一下Linux的内核代码，请参看源码 <a href="http://lxr.free-electrons.com/ident?i=tcp_timewait_state_process" target="_blank" rel="external">tcp_timewait_state_process</a>）。</li>
<li><strong>关于tcp_max_tw_buckets</strong>。这个是控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗DDoS攻击的。也说的默认值180000并不小。这个还是需要根据实际情况考虑。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Again，使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（<a href="http://tools.ietf.org/html/rfc1122" target="_blank" rel="external">RFC 1122</a>）</p>
</blockquote>
<p>其实，TIME_WAIT表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于HTTP服务器，那么设置一个<a href="http://en.wikipedia.org/wiki/HTTP_persistent_connection" target="_blank" rel="external">HTTP的KeepAlive</a>有多重要（浏览器会重用一个TCP连接来处理多个HTTP请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。</p>
<h1 id="数据传输中的Sequence-Number"><a href="#数据传输中的Sequence-Number" class="headerlink" title="数据传输中的Sequence Number"></a>数据传输中的Sequence Number</h1><p>下图是我从Wireshark中截了个我在访问coolshell.cn时的有数据传输的图给你看一下，SeqNum是怎么变的。（使用Wireshark菜单中的Statistics -&gt;Flow Graph… ）<br><a href="http://idiotsky.me/images1/tcp-something-6.jpg"><img src="http://idiotsky.me/images1/tcp-something-6.jpg" alt=""></a><br>你可以看到，<strong>SeqNum的增加是和传输的字节数相关的</strong>。上图中，三次握手后，来了两个Len:1440的包，而第二个包的SeqNum就成了1441。然后第一个ACK回的是1441，表示第一个1440收到了。</p>
<p><strong>注意</strong>：如果你用Wireshark抓包程序看3次握手，你会发现SeqNum总是为0，不是这样的，Wireshark为了显示更友好，使用了Relative SeqNum——相对序号，你只要在右键菜单中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p>
<h1 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h1><p>TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。</p>
<h2 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h2><p>一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。</p>
<p>但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。</p>
<p>对此有两种选择：</p>
<ul>
<li>一种是仅重传timeout的包。也就是第3份数据。</li>
<li>另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。</li>
</ul>
<p>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的）</p>
<h2 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h2><p>于是，TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。</p>
<p>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：<br><a href="http://idiotsky.me/images1/tcp-something-7.png"><img src="http://idiotsky.me/images1/tcp-something-7.png" alt=""></a><br>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p>
<h2 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h2><p>另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看<a href="http://tools.ietf.org/html/rfc2018" target="_blank" rel="external">RFC 2018</a>），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：<br><a href="http://idiotsky.me/images1/tcp-something-8.jpg"><img src="http://idiotsky.me/images1/tcp-something-8.jpg" alt=""></a></p>
<p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。</p>
<p>这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。</p>
<p>注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《<a href="http://www.ibm.com/developerworks/cn/linux/l-tcp-sack/" target="_blank" rel="external">TCP SACK的性能权衡</a>》</p>
<h2 id="Duplicate-SACK-–-重复收到数据的问题"><a href="#Duplicate-SACK-–-重复收到数据的问题" class="headerlink" title="Duplicate SACK – 重复收到数据的问题"></a>Duplicate SACK – 重复收到数据的问题</h2><p>Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了。<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank" rel="external">RFC-2883</a> 里有详细描述和示例。下面举几个例子（来源于<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank" rel="external">RFC-2883</a>）</p>
<p>D-SACK使用了SACK的第一个段来做标志，</p>
<ul>
<li>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK</li>
<li>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK</li>
</ul>
<h3 id="示例一：ACK丢包"><a href="#示例一：ACK丢包" class="headerlink" title="示例一：ACK丢包"></a>示例一：ACK丢包</h3><p>下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Transmitted  Received    ACK Sent</div><div class="line">Segment      Segment     (Including SACK Blocks)</div><div class="line"> </div><div class="line">3000-3499    3000-3499   3500 (ACK dropped)</div><div class="line">3500-3999    3500-3999   4000 (ACK dropped)</div><div class="line">3000-3499    3000-3499   4000, SACK=3000-3500</div><div class="line">                                    ---------</div></pre></td></tr></table></figure></p>
<h3 id="示例二，网络延误"><a href="#示例二，网络延误" class="headerlink" title="示例二，网络延误"></a>示例二，网络延误</h3><p>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D-SACK——标识收到了重复的包。</p>
<p>这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Transmitted    Received    ACK Sent</div><div class="line">Segment        Segment     (Including SACK Blocks)</div><div class="line"> </div><div class="line">500-999        500-999     1000</div><div class="line">1000-1499      (delayed)</div><div class="line">1500-1999      1500-1999   1000, SACK=1500-2000</div><div class="line">2000-2499      2000-2499   1000, SACK=1500-2500</div><div class="line">2500-2999      2500-2999   1000, SACK=1500-3000</div><div class="line">1000-1499      1000-1499   3000</div><div class="line">               1000-1499   3000, SACK=1000-1500</div><div class="line">                                      ---------</div></pre></td></tr></table></figure></p>
<p>可见，引入了D-SACK，有这么几个好处：</p>
<ol>
<li>可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</li>
<li>是不是自己的timeout太小了，导致重传。</li>
<li>网络上出现了先发的包后到的情况（又称reordering）</li>
<li>网络上是不是把我的数据包给复制了。</li>
</ol>
<p>知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控。<br>Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开）</p>
<h1 id="TCP的RTT算法"><a href="#TCP的RTT算法" class="headerlink" title="TCP的RTT算法"></a>TCP的RTT算法</h1><p>从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。</p>
<ul>
<li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p>
<h2 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h2><p><a href="http://tools.ietf.org/html/rfc793" target="_blank" rel="external">RFC793</a>中定义的经典算法是这样的：</p>
<ol>
<li>首先，先采样RTT，记下最近好几次的RTT值。</li>
<li>然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）<br>SRTT = ( α <em> SRTT ) + ((1- α) </em> RTT)</li>
<li>开始计算RTO。公式如下：<br>RTO = min [ UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]</li>
</ol>
<p>其中：</p>
<ul>
<li>UBOUND是最大的timeout时间，上限值</li>
<li>LBOUND是最小的timeout时间，下限值</li>
<li>β 值一般在1.3到2.0之间。</li>
</ul>
<h2 id="Karn-Partridge-算法"><a href="#Karn-Partridge-算法" class="headerlink" title="Karn / Partridge 算法"></a>Karn / Partridge 算法</h2><p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？</p>
<p>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p>
<ul>
<li>情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。</li>
<li>情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。<br><a href="http://idiotsky.me/images1/tcp-something-9.jpg"><img src="http://idiotsky.me/images1/tcp-something-9.jpg" alt=""></a></li>
</ul>
<p>所以1987年的时候，搞了一个叫<a href="http://en.wikipedia.org/wiki/Karn&#39;s_Algorithm" target="_blank" rel="external">Karn / Partridge Algorithm</a>，这个算法的最大特点是——<strong>忽略重传，不把重传的RTT做采样</strong>（你看，你不需要去解决不存在的问题）。</p>
<p>但是，这样一来，又会引发一个大BUG——<strong>如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难</strong>。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。</p>
<h2 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h2><p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看<a href="http://tools.ietf.org/html/rfc6298" target="_blank" rel="external">RFC6289</a>）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）<br>SRTT = SRTT + α (RTT – SRTT)  —— 计算平滑RTT</p>
<p>DevRTT = (1-β)*DevRTT + β*(|RTT-SRTT|) ——计算平滑RTT和真实的差距（加权移动平均）</p>
<p>RTO= µ <em> SRTT + ∂ </em>DevRTT —— 神一样的公式</p>
<p>（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：tcp_rtt_estimator）。</p>
<h1 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h1><p>需要说明一下，如果你不了解TCP的滑动窗口这个事，你等于不了解TCP协议。我们都知道，<strong>TCP必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 前面我们说过，TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：<br><a href="http://idiotsky.me/images1/tcp-something-10.jpg"><img src="http://idiotsky.me/images1/tcp-something-10.jpg" alt=""></a></p>
<p>上图中，我们可以看到：</p>
<ul>
<li>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li>
<li>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</li>
</ul>
<p>于是：</p>
<ul>
<li>接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li>
<li>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</li>
</ul>
<p>下面我们来看一下发送方的滑动窗口示意图：<br><a href="http://idiotsky.me/images1/tcp-something-11.png"><img src="http://idiotsky.me/images1/tcp-something-11.png" alt=""></a></p>
<p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ul>
<li>#1已收到ack确认的数据。</li>
<li>#2发还没收到ack的。</li>
<li>#3在窗口中还没有发出的（接收方还有空间）。</li>
<li>#4窗口以外的数据（接收方没空间）</li>
</ul>
<p>下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：<br><a href="http://idiotsky.me/images1/tcp-something-12.png"><img src="http://idiotsky.me/images1/tcp-something-12.png" alt=""></a></p>
<p>下面我们来看一个接受端控制发送端的图示：<br><a href="http://idiotsky.me/images1/tcp-something-13.png"><img src="http://idiotsky.me/images1/tcp-something-13.png" alt=""></a></p>
<h2 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h2><p>上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？</p>
<p>解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<p><strong>注意</strong>：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a href="http://en.wikipedia.org/wiki/Sockstress" target="_blank" rel="external">Wikipedia的SockStress词条</a>）</p>
<p>另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。</p>
<h2 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h2><p>Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。</p>
<p>要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p>
<p>另外，你需要知道网络上有个MTU，对于以太网来说，MTU是1500字节，除去TCP+IP头的40个字节，真正的数据传输可以有1460，这就是所谓的MSS（Max Segment Size）注意，TCP的RFC定义这个MSS的默认值是536，这是因为 RFC 791里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，而576减去IP头的20个字节就是536）。</p>
<p><strong>如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽</strong>。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。</p>
<p>所以，<strong>Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。</p>
<ul>
<li>如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。</li>
<li>如果这个问题是由Sender端引起的，那么就会使用著名的 Nagle’s algorithm。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的ack回包，他才会发数据，否则就是在攒数据。</li>
</ul>
<p>另外，Nagle算法默认是打开的，所以，对于一些需要小包场景的程序——比如像telnet或ssh这样的交互性比较强的程序，你需要关闭这个算法。你可以在Socket设置TCP_NODELAY选项来关闭这个算法（关闭Nagle算法没有全局参数，需要根据每个应用自己的特点来关闭）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<span class="keyword">char</span> *)&amp;value,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div></pre></td></tr></table></figure></p>
<p>另外，网上有些文章说TCP_CORK的socket option是也关闭Nagle算法，这不对。<strong>TCP_CORK其实是更新激进的Nagle算汉，完全禁止小包发送，而Nagle算法没有禁止小包发送，只是禁止了大量的小包发送</strong>。最好不要两个选项都设置。</p>
<h1 id="TCP的拥塞处理-–-Congestion-Handling"><a href="#TCP的拥塞处理-–-Congestion-Handling" class="headerlink" title="TCP的拥塞处理 – Congestion Handling"></a>TCP的拥塞处理 – Congestion Handling</h1><p>上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。</p>
<p>具体一点，我们知道TCP通过一个timer采样了RTT并计算RTO，但是，<strong>如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络</strong>。这是一个灾难。</p>
<p>所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：<strong>TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了</strong>。</p>
<p>关于拥塞控制的论文请参看《<a href="http://ee.lbl.gov/papers/congavoid.pdf" target="_blank" rel="external">Congestion Avoidance and Control</a> 》(PDF)</p>
<p>拥塞控制主要是四个算法：<strong>1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复</strong>。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:</p>
<ul>
<li>1988年，TCP-Tahoe 提出了1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li>
<li>1990年，TCP Reno 在Tahoe的基础上增加了4）快速恢复</li>
</ul>
<h2 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h2><p>首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</p>
<p>慢启动的算法如下(cwnd全称Congestion Window)：</p>
<ol>
<li>连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</li>
<li>每当收到一个ACK，cwnd++; 呈线性上升</li>
<li>每当过了一个RTT，cwnd = cwnd*2; 呈指数让升</li>
<li>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</li>
</ol>
<p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。<br><a href="http://idiotsky.me/images1/tcp-something-14.jpg"><img src="http://idiotsky.me/images1/tcp-something-14.jpg" alt=""></a></p>
<p>这里，我需要提一下的是一篇Google的论文《<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf" target="_blank" rel="external">An Argument for Increasing TCP’s Initial Congestion Window</a>》Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。 而Linux 3.0以前，比如2.6，Linux采用了<a href="http://www.rfc-editor.org/rfc/rfc3390.txt" target="_blank" rel="external">RFC3390</a>，cwnd是跟MSS的值来变的，如果MSS&lt; 1095，则cwnd = 4；如果MSS&gt;2190，则cwnd=2；其它情况下，则是3。</p>
<h2 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h2><p>前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p>
<ol>
<li>收到一个ACK时，cwnd = cwnd + 1/cwnd</li>
<li>当每过一个RTT时，cwnd = cwnd + 1</li>
</ol>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<h2 id="拥塞状态时的算法"><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h2><p>前面我们说过，当丢包的时候，会有两种情况：</p>
<ol>
<li>等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。<ul>
<li>sshthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>进入慢启动过程</li>
</ul>
</li>
<li>Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时<ul>
<li>TCP Tahoe的实现和RTO超时一样。</li>
<li>TCP Reno的实现是：<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法——Fast Recovery</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>
<h2 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h2><h3 id="TCP-Reno"><a href="#TCP-Reno" class="headerlink" title="TCP Reno"></a>TCP Reno</h3><p>这个算法定义在<a href="http://tools.ietf.org/html/rfc5681" target="_blank" rel="external">RFC5681</a>。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：</p>
<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
</ul>
<p>然后，真正的Fast Recovery算法如下：</p>
<ul>
<li>cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）</li>
<li>重传Duplicated ACKs指定的数据包</li>
<li>如果再收到 duplicated Acks，那么cwnd = cwnd +1</li>
<li>如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
<p>如果你仔细思考一下上面的这个算法，你就会知道，<strong>上面这个算法也有问题，那就是——它依赖于3个重复的Acks</strong>。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。</p>
<p>通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK（后面会讲）</p>
<h3 id="TCP-New-Reno"><a href="#TCP-New-Reno" class="headerlink" title="TCP New Reno"></a>TCP New Reno</h3><p>于是，1995年，TCP New Reno（参见 <a href="http://tools.ietf.org/html/rfc6582" target="_blank" rel="external">RFC 6582</a> ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的——</p>
<ul>
<li>当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。</li>
<li>一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程</li>
</ul>
<p>我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。</p>
<h2 id="算法示意图"><a href="#算法示意图" class="headerlink" title="算法示意图"></a>算法示意图</h2><p>下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：<br><a href="http://idiotsky.me/images1/tcp-something-15.jpg"><img src="http://idiotsky.me/images1/tcp-something-15.jpg" alt=""></a></p>
<h2 id="FACK算法"><a href="#FACK算法" class="headerlink" title="FACK算法"></a>FACK算法</h2><p>FACK全称Forward Acknowledgment 算法，论文地址在这里（PDF）<a href="http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf" target="_blank" rel="external">Forward Acknowledgement: Refining TCP Congestion Control</a> 这个算法是其于SACK的，前面我们说过SACK是使用了TCP扩展字段Ack了有哪些数据收到，哪些数据没有收到，他比Fast Retransmit的3 个duplicated acks好处在于，前者只知道有包丢了，不知道是一个还是多个，而SACK可以准确的知道有哪些包丢了。 所以，SACK可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK用来做重传过程中的拥塞流控。</p>
<ul>
<li>这个算法会把SACK中最大的Sequence Number 保存在snd.fack这个变量中，snd.fack的更新由ack带秋，如果网络一切安好则和snd.una一样（snd.una就是还没有收到ack的地方，也就是前面sliding window里的category #2的第一个地方）</li>
<li>然后定义一个awnd = snd.nxt – snd.fack（snd.nxt指向发送端sliding window中正在要被发送的地方——前面sliding windows图示的category#3第一个位置），这样awnd的意思就是在网络上的数据。（所谓awnd意为：actual quantity of data outstanding in the network）</li>
<li>如果需要重传数据，那么，awnd = snd.nxt – snd.fack + retran_data，也就是说，awnd是传出去的数据 + 重传的数据。</li>
<li>然后触发Fast Recovery 的条件是： ( ( snd.fack – snd.una ) &gt; (3*MSS) ) || (dupacks == 3) ) 。这样一来，就不需要等到3个duplicated acks才重传，而是只要sack中的最大的一个数据和ack的数据比较长了（3个MSS），那就触发重传。在整个重传过程中cwnd不变。直到当第一次丢包的snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd线性上涨。</li>
</ul>
<p>我们可以看到如果没有FACK在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的window的大小，而需要几个RTT的时间才会完成恢复，而FACK会比较激进地来干这事。 但是，FACK如果在一个网络包会被 reordering的网络里会有很大的问题。</p>
<h1 id="其它拥塞控制算法简介"><a href="#其它拥塞控制算法简介" class="headerlink" title="其它拥塞控制算法简介"></a>其它拥塞控制算法简介</h1><h2 id="TCP-Vegas-拥塞控制算法"><a href="#TCP-Vegas-拥塞控制算法" class="headerlink" title="TCP Vegas 拥塞控制算法"></a>TCP Vegas 拥塞控制算法</h2><p>这个算法1994年被提出，它主要对TCP Reno 做了些修改。这个算法通过对RTT的非常重的监控来计算一个基准RTT。然后通过这个基准RTT来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加cwnd的大小。如果这个计算出来的RTT大于了Timeout后，那么，不等ack超时就直接重传。（Vegas 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《TCP Vegas: End to End Congestion Avoidance on a Global Internet》这篇论文给了Vegas和 New Reno的对比：<br><a href="http://idiotsky.me/images1/tcp-something-16.jpg"><img src="http://idiotsky.me/images1/tcp-something-16.jpg" alt=""></a></p>
<p>关于这个算法实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h" target="_blank" rel="external">/net/ipv4/tcp_vegas.h</a>， <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c" target="_blank" rel="external">/net/ipv4/tcp_vegas.c</a></p>
<h2 id="HSTCP-High-Speed-TCP-算法"><a href="#HSTCP-High-Speed-TCP-算法" class="headerlink" title="HSTCP(High Speed TCP) 算法"></a>HSTCP(High Speed TCP) 算法</h2><p>这个算法来自<a href="http://tools.ietf.org/html/rfc3649" target="_blank" rel="external">RFC 3649</a>（<a href="http://en.wikipedia.org/wiki/HSTCP" target="_blank" rel="external">Wikipedia词条</a>）。其对最基础的算法进行了更改，他使得Congestion Window涨得快，减得慢。其中：</p>
<ul>
<li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li>
<li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li>
</ul>
<p>注：α(cwnd)和β(cwnd)都是函数，如果你要让他们和标准的TCP一样，那么让α(cwnd)=1，β(cwnd)=0.5就可以了。 对于α(cwnd)和β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c" target="_blank" rel="external">/net/ipv4/tcp_highspeed.c</a></p>
<h2 id="TCP-BIC-算法"><a href="#TCP-BIC-算法" class="headerlink" title="TCP BIC 算法"></a>TCP BIC 算法</h2><p>2004年，产内出BIC算法。现在你还可以查得到相关的新闻《Google：<a href="https://www.google.com/search?lr=lang_zh-CN%7Clang_zh-TW&amp;newwindow=1&amp;biw=1366&amp;bih=597&amp;tbs=lr%3Alang_1zh-CN%7Clang_1zh-TW&amp;q=美科学家研发BIC-TCP协议+速度是DSL六千倍&amp;oq=美科学家研发BIC-TCP协议+速度是DSL六千倍" target="_blank" rel="external">美科学家研发BIC-TCP协议 速度是DSL六千倍</a>》 BIC全称<a href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic" target="_blank" rel="external">Binary Increase Congestion control</a>，在Linux 2.6.8中是默认拥塞控制算法。BIC的发明者发这么多的拥塞控制算法都在努力找一个合适的cwnd – Congestion Window，而且BIC-TCP的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以BIC这个算法主要用的是Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看Linux源码：<a href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic" target="_blank" rel="external">/net/ipv4/tcp_bic.c</a></p>
<h2 id="TCP-WestWood算法"><a href="#TCP-WestWood算法" class="headerlink" title="TCP WestWood算法"></a>TCP WestWood算法</h2><p>westwood采用和Reno相同的慢启动算法、拥塞避免算法。westwood的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个RTT时间，会测量一次带宽，测量带宽的公式很简单，就是这段RTT内成功被ack了多少字节。因为，这个带宽和用RTT计算RTO一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送X个字节，而RTT是一个数据发出去后确认需要的时候，所以，X <em> RTT应该是我们缓冲区大小。所以，在这个算法中，ssthresh的值就是est_BD </em> min-RTT(最小的RTT值)，如果丢包是Duplicated ACKs引起的，那么如果cwnd &gt; ssthresh，则 cwin = ssthresh。如果是RTO引起的，cwnd = 1，进入慢启动。   关于这个算法实现，你可以参看Linux源码： <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c" target="_blank" rel="external">/net/ipv4/tcp_westwood.c</a></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>更多的算法，你可以从Wikipedia的 <a href="http://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm" target="_blank" rel="external">TCP Congestion Avoidance Algorithm</a>词条中找到相关的线索</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>好了，到这里我想可以结束了，TCP发展到今天，里面的东西可以写上好几本书。本文主要目的，还是把你带入这些古典的基础技术和知识中，希望本文能让你了解TCP，更希望本文能让你开始有学习这些基础或底层知识的兴趣和信心。</p>
<p>当然，TCP东西太多了，不同的人可能有不同的理解，而且本文可能也会有一些荒谬之言甚至错误，还希望得到您的反馈和批评。</p>
<p>（全文完）</p>
<blockquote>
<p>好长的文章</p>
</blockquote>
<p>from <a href="https://coolshell.cn" target="_blank" rel="external">酷壳</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;tcp看了很多的文章，这篇总结的很好。此文有点长👿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;tcp在网络OSI的七层模型中的第四层——Transport(传输)层，IP在第三层——Network(网络)层，ARP在第二层——Data Link(数据链路)层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。&lt;/p&gt;
&lt;p&gt;首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。&lt;/p&gt;
&lt;h1 id=&quot;TCP头格式&quot;&gt;&lt;a href=&quot;#TCP头格式&quot; class=&quot;headerlink&quot; title=&quot;TCP头格式&quot;&gt;&lt;/a&gt;TCP头格式&lt;/h1&gt;&lt;p&gt;接下来，我们来看一下TCP头的格式&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images1/tcp-something-1.jpg&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images1/tcp-something-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;你需要注意这么几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。&lt;/li&gt;
&lt;li&gt;一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。&lt;/li&gt;
&lt;li&gt;注意上图中的四个非常重要的东西：&lt;ul&gt;
&lt;li&gt;Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。&lt;/li&gt;
&lt;li&gt;Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。&lt;/li&gt;
&lt;li&gt;Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。&lt;/li&gt;
&lt;li&gt;TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tcp" scheme="http://idiotsky.me/categories/tcp/"/>
    
    
      <category term="tcp" scheme="http://idiotsky.me/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>正向代理和反向代理</title>
    <link href="http://idiotsky.me/2017/10/19/proxy-reverse-proxy/"/>
    <id>http://idiotsky.me/2017/10/19/proxy-reverse-proxy/</id>
    <published>2017-10-18T16:29:53.000Z</published>
    <updated>2017-10-18T16:48:30.729Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一直用反向代理，可不知道为什么叫反向，还有何为正向代理</p>
</blockquote>
<h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 <a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a> 时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结果再返回给我。所以说，很多翻墙工具用到的服务器基本都是正向代理服务器<br><a href="http://idiotsky.me/images1/proxy-reverse-proxy-1.jpg"><img src="http://idiotsky.me/images1/proxy-reverse-proxy-1.jpg" alt=""></a><br><a id="more"></a></p>
<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>反向代理隐藏了真实的服务端，www.baidu.com 的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。<br><a href="http://idiotsky.me/images1/proxy-reverse-proxy-2.jpg"><img src="http://idiotsky.me/images1/proxy-reverse-proxy-2.jpg" alt=""></a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>两者的区别在于代理的对象不一样：<strong>正向代理</strong>代理的对象是客户端，<strong>反向代理</strong>代理的对象是服务端</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一直用反向代理，可不知道为什么叫反向，还有何为正向代理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h1&gt;&lt;p&gt;我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 &lt;a href=&quot;http://www.google.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.google.com&lt;/a&gt; 时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求google.com，代理把请求返回的相应结果再返回给我。所以说，很多翻墙工具用到的服务器基本都是正向代理服务器&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images1/proxy-reverse-proxy-1.jpg&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images1/proxy-reverse-proxy-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="proxy" scheme="http://idiotsky.me/categories/proxy/"/>
    
    
      <category term="proxy" scheme="http://idiotsky.me/tags/proxy/"/>
    
      <category term="正向代理" scheme="http://idiotsky.me/tags/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="反向代理" scheme="http://idiotsky.me/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript是如何工作的(三)</title>
    <link href="http://idiotsky.me/2017/10/05/javascript-how-work-3/"/>
    <id>http://idiotsky.me/2017/10/05/javascript-how-work-3/</id>
    <published>2017-10-05T12:01:15.000Z</published>
    <updated>2017-10-07T13:22:50.983Z</updated>
    
    <content type="html"><![CDATA[<p>几个礼拜之前我们开始一系列对于JavaScript以及其本质工作原理的深入挖掘：我们认为通过了解JavaScript的构建方式以及它们是如何共同合作的，你就能够写出更好的代码以及应用。</p>
<p>这个系列的第一篇博客专注于介绍<a href="http://idiotsky.me/2017/08/26/javascript-how-work/">对于引擎，运行时以及调用栈的概述</a>。<a href="http://idiotsky.me/2017/08/26/javascript-how-work-2/">第二篇博客近距离地检测了Google V8 引擎的内部</a>并且提供了一些如何写出更好的JavaScript代码的建议。</p>
<p>在第三篇博客中，我们将会讨论另外一个关键的话题。这个话题由于随着编程语言的逐渐成熟和复杂化，越来越被开发者所忽视，这个话题就是在日常工作中使用到的——内存管理。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>语言，比如C，具有低层次的内存管理方法，比如<code>malloc()</code>以及<code>free()</code>。开发者利用这些方法精确地为操作系统分配以及释放内存。</p>
<p>同时，JavaScript会在创建一些变量（对象，字符串等等）的时候分配内存，并且会在这些不被使用之后“自动地”释放这些内存，这个过程被称为<em>垃圾收集</em>。这个看起来“自动化的”特性其实就是产生误解的原因，并且给JavaScript（以及其他高层次语言）开发者一个假象，他们不需要关心内存管理。<strong>大错特错。</strong></p>
<p>即使是使用高层次语言，开发者应该对于内存管理有一定的理解（或者最基本的理解）。有时候自动的内存管理会存在一些问题（比如一些bug或者垃圾收集器的一些限制等等），对于这些开发者必须能够理解从而能够合适地处理（或者使用最小的代价以及代码债务去绕过这个问题）。<br><a id="more"></a></p>
<h1 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h1><p>不管你在使用什么编程语言，内存的生命周期基本上都是一样的：</p>
<p><a href="http://idiotsky.me/images1/javascript-how-work-3-1.png"><img src="http://idiotsky.me/images1/javascript-how-work-3-1.png" alt=""></a></p>
<p>下面是对于周期中每一步所发生的情况的概述：</p>
<ul>
<li><strong>分配内存</strong>——操作系统为你的程序分配内存并且允许其使用。在低层次语言中（比如C），这正是开发者应该处理的操作。在高层次的语言，然而，就由语言帮你实现了。</li>
<li><strong>使用内存</strong>——当你的程序确实在使用之前分配的内存的阶段。当你在使用你代码里面分配的变量的时候会发生<strong>读</strong>以及<strong>写</strong>操作。</li>
<li><strong>释放内存</strong>——这个阶段就是释放你不再需要的内存，从而这些内存被释放并且能够再次被使用。和<strong>分配内存</strong>操作一样，这在低层次的语言也是开发者需要明确的操作。</li>
</ul>
<p>对于调用栈以及内存堆有一个快速的概念认识，你可以阅读我们<a href="http://idiotsky.me/2017/08/26/javascript-how-work/">关于这个话题的第一篇博客</a>。</p>
<h2 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a>什么是内存？</h2><p>在我们讲述JavaScript内存之前，我们将简要地讨论一下内存是什么以及它们是如何在 nutshell 中工作的。</p>
<p>在硬件层次上，计算机内存由大量的 <a href="https://en.wikipedia.org/wiki/Flip-flop_%28electronics%29" target="_blank" rel="external">寄存器</a> 组成。每一个寄存器都包含一些晶体管并且能够存储一比特。单独的寄存器可以通过<strong>独特的标识符</strong>去访问，因此我们能够读取以及重写它们。因此，从概念上来说，我们可以认为我们的整个计算机内存就是一个我们能够读写的大型比特数组。</p>
<p>因为作为人类，我们不擅长直接基于比特进行思考以及算术，我们将它们组织成大规模群组，它们在一起可以代表一个数字。8个比特称为一个字节。除了字节，还有词（有时候是16比特，有时候是32比特）。</p>
<p>内存中存储了很多东西：</p>
<ol>
<li>所有程序使用的变量和其他数据</li>
<li>程序的代码，包括操作系统的代码。</li>
</ol>
<p>编译器和操作系统共同合作为你处理大部分的内存管理，但是我们建议你应该了解其内部的运行原理。</p>
<p>当你编译你的代码的时候，编译器将会检查原始数据类型并且提前计算好它们需要多少内存。需要的内存被分配给程序，这被称为<strong>栈空间</strong>。这些被分配给变量的空间被称为栈空间，因为一旦函数被调用，它们的内存就会增加到现有内存的上面。当它们终止的时候，它们就会以后进先出(LIFO)的顺序移除。比如，考虑下面的声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n; <span class="comment">// 4 bytes</span></div><div class="line"><span class="keyword">int</span> x[<span class="number">4</span>]; <span class="comment">// array of 4 elements, each 4 bytes</span></div><div class="line"><span class="keyword">double</span> m; <span class="comment">// 8 bytes</span></div></pre></td></tr></table></figure>
<p>编译器能够立即计算出代码需要</p>
<p>4 + 4 × 4 + 8 = 28 字节</p>
<blockquote>
<p>那就是它如何对于现有的整形以及双浮点型工作。大约20年前，整形典型都是2个字节，双浮点型是4个字节。你的代码不应该取决于当下基本数据类型的大小。</p>
</blockquote>
<p>编译器将会插入能够与操作系统交互的代码，从而在栈上获取你需要存储变量需要的字节数。</p>
<p>在上述的例子中，编译器知道每一个变量的准确的内存地址。事实上，无论我们何时写变量 n ，这都会在内部转化为类似于“内存地址 4127963”的东西。</p>
<p>注意如果我们希望在这访问 x[4] 我们将会需要访问和 m 相关联的数据。这是因为我们在访问数组里面并不存在的元素——它比数组实际分配的最后一个元素 x[3] 要多4个字节，并且最后可能是阅读（或者重写）一些 m 的比特。这将很可能给程序的其他部分带来一些不良的后果。<br><a href="http://idiotsky.me/images1/javascript-how-work-3-2.png"><img src="http://idiotsky.me/images1/javascript-how-work-3-2.png" alt=""></a></p>
<p>当函数调用其它函数的时候，当它被调用的时候都会获取它自己的堆栈块。它在那保存了它所有的局部变量，但是还会有一个程序计数器记录它执行的位置。当这个函数执行完毕，它的内存块就可以再次用于其他目的。</p>
<h2 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h2><p>不幸的是，当我们在编译的时候不知道变量需要多少内存的话事情可能就不那么简单。假设我们想做下面的事情：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span> n = readInput(); <span class="comment">// reads input from the user</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// create an array with "n" elements</span></div></pre></td></tr></table></figure></p>
<p>在此，在编译阶段中，编译器就没有办法知道数组需要多少内存，因为它取决于用户的输入。</p>
<p>因此，它就不能够为栈上的变量分配空间。相反，我们的程序需要明确地询问操作运行时需要的空间数量。这个内存是从<strong>堆空间</strong>中分配出来的。动态内存和静态内存分配的区别总结如下表格：<br><a href="http://idiotsky.me/images1/javascript-how-work-3-3.png"><img src="http://idiotsky.me/images1/javascript-how-work-3-3.png" alt=""></a></p>
<p>为了深入地理解动态内存分配是如何工作的，我们需要花费更多的时间在<strong>指针</strong>，这个可能有点偏离这篇博客的话题。如果你感兴趣了解更多，在评论里面告诉我，我将会在后续的博客中挖掘更多的细节。</p>
<h2 id="JavaScript中的分配"><a href="#JavaScript中的分配" class="headerlink" title="JavaScript中的分配"></a>JavaScript中的分配</h2><p>现在我们将解释JavaScript中的第一步（分配内存）。</p>
<p>JavaScript 将开发者从内存分配的处理中解放出来——JavaScript自身可以利用声明变量来完成这些任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n = <span class="number">374</span>; <span class="comment">// allocates memory for a number</span></div><div class="line"><span class="keyword">var</span> s = <span class="string">'sessionstack'</span>; <span class="comment">// allocates memory for a string </span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">b</span>: <span class="literal">null</span></div><div class="line">&#125;; <span class="comment">// allocates memory for an object and its contained values</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">'str'</span>];  <span class="comment">// (like object) allocates memory for the</span></div><div class="line">                           <span class="comment">// array and its contained values</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + <span class="number">3</span>;</div><div class="line">&#125; <span class="comment">// allocates a function (which is a callable object)</span></div><div class="line"></div><div class="line"><span class="comment">// function expressions also allocate an object</span></div><div class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>一些函数调用也会导致一些对象的分配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// allocates a Date object</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">// allocates a DOM element</span></div></pre></td></tr></table></figure>
<p>能够分配新的值或者对象的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">'sessionstack'</span>;</div><div class="line"><span class="keyword">var</span> s2 = s1.substr(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 is a new string</span></div><div class="line"><span class="comment">// Since strings are immutable, </span></div><div class="line"><span class="comment">// JavaScript may decide to not allocate memory, </span></div><div class="line"><span class="comment">// but just store the [0, 3] range.</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a1 = [<span class="string">'str1'</span>, <span class="string">'str2'</span>];</div><div class="line"><span class="keyword">var</span> a2 = [<span class="string">'str3'</span>, <span class="string">'str4'</span>];</div><div class="line"><span class="keyword">var</span> a3 = a1.concat(a2); </div><div class="line"><span class="comment">// new array with 4 elements being</span></div><div class="line"><span class="comment">// the concatenation of a1 and a2 elements</span></div></pre></td></tr></table></figure>
<h2 id="在JavaScript中使用内存"><a href="#在JavaScript中使用内存" class="headerlink" title="在JavaScript中使用内存"></a>在JavaScript中使用内存</h2><p>基本上在JavaScript中分配内存，就意味着在其中读写。</p>
<p>这可以通过对一个变量或者一个对象的属性甚至是向函数传递一个参数来完成。</p>
<h2 id="当内存不再需要的时候释放它"><a href="#当内存不再需要的时候释放它" class="headerlink" title="当内存不再需要的时候释放它"></a>当内存不再需要的时候释放它</h2><p>大多数的内存管理的问题就来自于这个阶段。</p>
<p>最困难的任务就是如何知道何时被分配的不再需要了。它经常需要开发者决定在程序的什么地方某段内存不再需要了并且对其进行释放。</p>
<p>高层次语言内嵌了一个称为<strong>垃圾收集器</strong>的软件，他的任务就是跟踪内存分配并且用于需找不再需要的分配过的内存，并且自动地对其进行释放。</p>
<p>不幸的是，这个过程是一个近似，因为知道是否某块内存是需要的问题是<a href="http://en.wikipedia.org/wiki/Decidability_%28logic%29" target="_blank" rel="external">不可决定的</a>（无法通过算法解决）</p>
<p>大多数的垃圾收集器通过收集再也无法访问的内存工作，比如：指向它的所有变量都超出了作用域。然而，这依然是对于可以收集的内存空间的预估，因为在任何位置仍可能一些变量在作用域内指向这个内存，然而它再也不能被访问了。</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>由于找到一些是“不再需要的”是不可决定的事实，垃圾收集实现了对一般问题的解决方案的限制。这一节将会解释理解主要的垃圾收集算法以及它们的限制的需要注意的事项。</p>
<h2 id="内存引用"><a href="#内存引用" class="headerlink" title="内存引用"></a>内存引用</h2><p>垃圾收集算法依赖的主要概念之一就是<strong>引用</strong>。</p>
<p>在内存管理的上下文中，一个对象被称为是对于另外一个对象的引用，如果前者可以访问后者（隐含或明确的）。例如，一个JavaScript对象都有一个指向其<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain" target="_blank" rel="external">原型</a>的引用（<strong>隐含的引用</strong>）</p>
<p>在这个上下文中，“对象”的概念扩展到比普通的JavaScript对象要广并且包括函数作用域（或者全局<strong>词法作用域</strong>）。</p>
<blockquote>
<p> 词法作用域定义了变量名称是如何在嵌套函数中解析的：内部函数包含了父函数的作用域即使父函数已经返回了。</p>
</blockquote>
<h2 id="基于引用计数的垃圾收集器"><a href="#基于引用计数的垃圾收集器" class="headerlink" title="基于引用计数的垃圾收集器"></a>基于引用计数的垃圾收集器</h2><p>这是最简单的垃圾收集器算法。如果没有引用指向这个对象的时候，这个对象就被认为是“可以作为垃圾收集”。</p>
<p>请看如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = &#123;</div><div class="line">  <span class="attr">o2</span>: &#123;</div><div class="line">    <span class="attr">x</span>: <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 2 objects are created. </span></div><div class="line"><span class="comment">// 'o2' is referenced by 'o1' object as one of its properties.</span></div><div class="line"><span class="comment">// None can be garbage-collected</span></div><div class="line"><span class="keyword">var</span> o3 = o1; <span class="comment">// the 'o3' variable is the second thing that </span></div><div class="line">            <span class="comment">// has a reference to the object pointed by 'o1'. </span></div><div class="line">o1 = <span class="number">1</span>;      <span class="comment">// now, the object that was originally in 'o1' has a         </span></div><div class="line">            <span class="comment">// single reference, embodied by the 'o3' variable</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o4 = o3.o2; <span class="comment">// reference to 'o2' property of the object.</span></div><div class="line">                <span class="comment">// This object has now 2 references: one as</span></div><div class="line">                <span class="comment">// a property. </span></div><div class="line">                <span class="comment">// The other as the 'o4' variable</span></div><div class="line"></div><div class="line">o3 = <span class="string">'374'</span>; <span class="comment">// The object that was originally in 'o1' has now zero</span></div><div class="line">            <span class="comment">// references to it. </span></div><div class="line">            <span class="comment">// It can be garbage-collected.</span></div><div class="line">            <span class="comment">// However, what was its 'o2' property is still</span></div><div class="line">            <span class="comment">// referenced by the 'o4' variable, so it cannot be</span></div><div class="line">            <span class="comment">// freed.</span></div><div class="line"></div><div class="line">o4 = <span class="literal">null</span>; <span class="comment">// what was the 'o2' property of the object originally in</span></div><div class="line">           <span class="comment">// 'o1' has zero references to it. </span></div><div class="line">           <span class="comment">// It can be garbage collected.</span></div></pre></td></tr></table></figure>
<h2 id="循环在产生问题"><a href="#循环在产生问题" class="headerlink" title="循环在产生问题"></a>循环在产生问题</h2><p>当遇到循环的时候就会有一个限制。在下面的实例之中，创建两个对象，并且互相引用，因此就会产生一个循环。当函数调用结束之后它们会走出作用域之外，因此它们就没什么用并且可以被释放。但是，基于引用计数的算法认为这两个对象都会被至少引用一次，所以它俩都不会被垃圾收集器收集。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> o1 = &#123;&#125;;</div><div class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</div><div class="line">  o1.p = o2; <span class="comment">// o1 references o2</span></div><div class="line">  o2.p = o1; <span class="comment">// o2 references o1. This creates a cycle.</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<p><a href="http://idiotsky.me/images1/javascript-how-work-3-4.png"><img src="http://idiotsky.me/images1/javascript-how-work-3-4.png" alt=""></a></p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>为了决定哪个对象是需要的，算法会决定是否这个对象是可访问的。</p>
<p>这个算法由以下步骤组成：</p>
<ol>
<li>这个垃圾收集器构建一个“roots”列表。Root是全局变量，被代码中的引用所保存。在 JavaScript中，“window”就是这样的作为root的全局变量的例子。</li>
<li>所有的root都会被监测并且被标志成活跃的（比如不是垃圾）。所有的子代也会递归地被监测。所有能够由root访问的一切都不会被认为是垃圾。</li>
<li>所有不再被标志成活跃的内存块都被认为是垃圾。这个收集器现在就可以释放这些内存并将它们返还给操作系统。</li>
</ol>
<p><a href="http://idiotsky.me/images1/javascript-how-work-3-5.gif"><img src="http://idiotsky.me/images1/javascript-how-work-3-5.gif" alt=""></a></p>
<p>这个算法要优于之前的因为“一个具有0引用的对象”可以让一个对象不能够再被访问。但是相反的却不一定成立，比如我们遇到循环的时候。</p>
<p>在2012年，所有的现代浏览器都使用标记-清除垃圾收集器。过去几年，JavaScript垃圾收集（代数/增量/并行/并行垃圾收集）领域的所有改进都是对该算法（标记和扫描）的实现进行了改进，但并没有对垃圾收集算法本身的改进， 其目标是确定一个对象是否可达。</p>
<p><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="external">在这篇文章中</a>，你可以得到更多关于垃圾收集追踪并且也覆盖到了关于标记-清除算法的优化。</p>
<h2 id="循环不再是一个问题"><a href="#循环不再是一个问题" class="headerlink" title="循环不再是一个问题"></a>循环不再是一个问题</h2><p>在上述的第一个例子中，在函数调用返回之后，这两个对象不能够被全局对象所访问。因此，垃圾收集器就会发现它们不能够被访问了。</p>
<p><a href="http://idiotsky.me/images1/javascript-how-work-3-6.png"><img src="http://idiotsky.me/images1/javascript-how-work-3-6.png" alt=""></a></p>
<p>即使在这两个对象之间存在着引用，它们再也不能从root访问了。</p>
<h2 id="列举垃圾收集器的直观行为"><a href="#列举垃圾收集器的直观行为" class="headerlink" title="列举垃圾收集器的直观行为"></a>列举垃圾收集器的直观行为</h2><p>虽然垃圾收集器很方便，但它们自己也有自己的代价。 其中一个是非确定论。 换句话说，GC是不可预测的。 你不能真正地告诉你什么时候会收集。 这意味着在某些情况下，程序会使用实际需要的更多内存。 在其他情况下，特别敏感的应用程序可能会引起短暂暂停。 虽然非确定性意味着在执行集合时无法确定，但大多数GC实现共享在分配期间执行收集遍历的常见模式。 如果没有执行分配，大多数GC保持空闲状态。 考虑以下情况：</p>
<ol>
<li>执行相当大的一组分配。</li>
<li>这些元素中的大多数（或全部）被标记为不可访问（假设我们将指向我们不再需要的缓存的引用置空）。</li>
<li>不再执行分配。</li>
</ol>
<p>在这种情况下，大多数GC不会再运行收集处理。换句话说，即使存在对于收集器来说不可访问的引用，它们也不会被收集器所认领。严格意义来说这并不是泄露，但是依然会导致比平常更多的内存使用。</p>
<h1 id="什么是内存泄露？"><a href="#什么是内存泄露？" class="headerlink" title="什么是内存泄露？"></a>什么是内存泄露？</h1><p>实质上，内存泄漏可以被定义为应用程序不再需要的内存，但是由于某些原因不会返回到操作系统或可用内存池。</p>
<p><a href="http://idiotsky.me/images1/javascript-how-work-3-7.jpg"><img src="http://idiotsky.me/images1/javascript-how-work-3-7.jpg" alt=""></a></p>
<p>编程语言有支持管理内存的不同方法。 然而，某块内存是否被使用实际上是一个<a href="ttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Release_when_the_memory_is_not_needed_anymore" target="_blank" rel="external">不可判定的问题</a>。 换句话说，只有开发人员可以清楚一个内存是否可以返回到操作系统。</p>
<p>某些编程语言提供了帮助开发者执行此操作的功能。其他的则期望开发人员能够完全明确何时使用一块内存。 维基百科有关于<a href="https://en.wikipedia.org/wiki/Manual_memory_management" target="_blank" rel="external">手动</a>和<a href="https://en.wikipedia.org/wiki/Manual_memory_management" target="_blank" rel="external">自动</a>内存管理的好文章。</p>
<h2 id="四种常见的JavaScript泄露"><a href="#四种常见的JavaScript泄露" class="headerlink" title="四种常见的JavaScript泄露"></a>四种常见的JavaScript泄露</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>JavaScript 使用一种有趣的方式处理未声明的变量：一个未声明变量的引用会在<em>全局</em>对象内部产生一个新的变量。在浏览器的情况，这个全局变量就会是window。换句话说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">    bar = <span class="string">"some text"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">    <span class="built_in">window</span>.bar = <span class="string">"some text"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果bar被期望仅仅在foo函数作用域内保持对变量的引用，并且你忘记使用var去声明它，一个意想不到的全局变量就产生了。</p>
<p>在这个例子中，泄露就仅仅是一个字符串并不会带来太多危害，但是它可能会变得更糟。</p>
<p>另外一种可能产生意外的全局变量的方式是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.var1 = <span class="string">"potential accidental global"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Foo called on its own, this points to the global object (window)</span></div><div class="line"><span class="comment">// rather than being undefined.</span></div><div class="line">foo();</div></pre></td></tr></table></figure>
<blockquote>
<p> 为了阻止这些错误的发生，可以在js文件头部添加’use strict’。这将会使用严格模式来解析 JavaScript 从而阻止意外的全局变量。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="external">了解更多</a>关于JavaScript执行的模式。</p>
</blockquote>
<p>即使我们讨论了未预期的全局变量，但仍然有很多代码用显式的全局变量填充。 这些定义是不可收集的（除非分配为null或重新分配）。 特别是，用于临时存储和处理大量信息的全局变量值得关注。 如果你必须使用全局变量来存储大量数据，请确保在完成之后<strong>将其分配为null或重新分配</strong>。</p>
<h3 id="被遗忘的计时器和回调"><a href="#被遗忘的计时器和回调" class="headerlink" title="被遗忘的计时器和回调"></a>被遗忘的计时器和回调</h3><p><code>setInterval</code> 在 JavaScript 中是经常被使用的。</p>
<p>大多数提供观察者和其他模式的回调函数库都会在调用自己的实例变得无法访问之后对其任何引用也设置为不可访问。 但是在<code>setInterval</code>的情况下，这样的代码很常见：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> serverData = loadData();</div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> renderer = <span class="built_in">document</span>.getElementById(<span class="string">'renderer'</span>);</div><div class="line">    <span class="keyword">if</span>(renderer) &#123;</div><div class="line">        renderer.innerHTML = <span class="built_in">JSON</span>.stringify(serverData);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">5000</span>); <span class="comment">//This will be executed every ~5 seconds.</span></div></pre></td></tr></table></figure>
<p>这个例子说明了计时器可能发生的情况：计时器可能会产生再也不被需要的节点或者数据的引用。</p>
<p><code>renderer</code>所代表的对象在未来可能被移除，让部分interval 处理器中代码变得不再被需要。然而，这个处理器不能够被收集因为interval依然活跃的（这个interval需要被停止从而表面这种情况）。如果这个interval处理器不能够被收集，那么它的依赖也不能够被收集。这意味这存储大量数据的<code>severData</code>也不能够被收集。</p>
<p>在这种观察者的情况下，做出准确的调用从而在不需要它们的时候立即将其移除是非常重要的（或者相关的对象被置为不可访问的）。</p>
<p>过去，以前特别重要的是某些浏览器（好的老IE 6）无法管理好循环引用（有关更多信息，请参见下文）。 如今，大多数浏览器一旦观察到的对象变得无法访问，就能收集观察者处理器，即使侦听器没有被明确删除。 但是，在处理对象之前，明确删除这些观察者仍然是一个很好的做法。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'launch-button'</span>);</div><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">   counter++;</div><div class="line">   element.innerHtml = <span class="string">'text '</span> + counter;</div><div class="line">&#125;</div><div class="line"></div><div class="line">element.addEventListener(<span class="string">'click'</span>, onClick);</div><div class="line"></div><div class="line"><span class="comment">// Do stuff</span></div><div class="line"></div><div class="line">element.removeEventListener(<span class="string">'click'</span>, onClick);</div><div class="line">element.parentNode.removeChild(element);</div><div class="line"></div><div class="line"><span class="comment">// Now when element goes out of scope,</span></div><div class="line"><span class="comment">// both element and onClick will be collected even in old browsers // that don't handle cycles well.</span></div></pre></td></tr></table></figure>
<p>当今，现在浏览器（报错IE和Edge）都使用了现代的垃圾收集算法，其能够检测到这些循环并且进行适宜的处理。换句话说，再也不是严格需要在将节点置为不可访问之前调用removeEventListener 。</p>
<p>框架和库（如jQuery）在处理节点之前（在为其使用特定的API时）会删除侦听器。 这是由库内部处理的，这也确保没有泄漏，即使在有问题的浏览器下运行，如…是的，IE 6。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>JavaScript 开发的一个关键方面是闭包：一个可以访问外部（封闭）函数变量的内部函数。 由于JavaScript运行时的实现细节，可以通过以下方式泄漏内存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> theThing = <span class="literal">null</span>;</div><div class="line"> <span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> 	<span class="keyword">var</span> originalThing = theThing;</div><div class="line"> 	<span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    	<span class="keyword">if</span> (originalThing) <span class="comment">// a reference to 'originalThing'</span></div><div class="line">      		<span class="built_in">console</span>.log(<span class="string">"hi"</span>);</div><div class="line">  	&#125;;</div><div class="line"></div><div class="line">  	theThing = &#123;</div><div class="line">    	<span class="attr">longStr</span>: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</div><div class="line">    	<span class="attr">someMethod</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      		<span class="built_in">console</span>.log(<span class="string">"message"</span>);</div><div class="line">    	&#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">setInterval(replaceThing, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>这个代码段会做一件事情：每次 <code>replaceThing</code> 被调用时，<code>theThing</code> 都会获取一个一个包含一个大数组的以及一个新的闭包（<code>someMethod</code>）。同时，<code>unused</code> 会保持一个指向<code>originalThing</code>引用的闭包（从上一个调用的<code>theThing</code>到<code>replaceThing</code>）。可能已经很迷惑了，是不是？重要的事情是<strong>一旦在相同的父级作用域为闭包产生作用域，这个作用域就会被共享</strong>。</p>
<p>在这种情况下，为<code>someMethod</code>闭包产生的作用域就会被<code>unused</code> 所共享。<code>unused</code> 具有对于<code>originaThing</code>的引用。即使 <code>unused</code>  不再被使用，<code>someMethod</code>依然可以通过<code>replaceThing</code>作用域之外的<code>theThing</code>来使用。并且由于<code>somethod</code>和<code>unused</code> 共享闭包作用域，unused指向originalThing的引用强迫其保持活跃（两个闭包之间的整个共享作用域）。这将会阻止垃圾手机。</p>
<p>当这个代码段重复运行时，可以观察到内存使用量的稳定增长。 当GC运行时，这不会变小。 实质上，创建了一个关闭的链接列表（其root以TheThing变量的形式），并且这些闭包的范围中的每一个都对大数组进行间接引用，导致相当大的泄漏。</p>
<p>这个问题由Meteor团队发现，他们有<a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" target="_blank" rel="external">一篇很好的文章</a>，详细描述了这个问题。</p>
<h3 id="DOM-之外的引用"><a href="#DOM-之外的引用" class="headerlink" title="DOM 之外的引用"></a>DOM 之外的引用</h3><p>有时将DOM节点存储在数据结构中可能是有用的。 假设要快速更新表中的几行内容。 存储对字典或数组中每个DOM行的引用可能是有意义的。 当发生这种情况时，会保留对同一DOM元素的两个引用：一个在DOM树中，另一个在字典中。 如果将来某个时候您决定删除这些行，则需要使两个引用置为不可访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elements = &#123;</div><div class="line">    <span class="attr">button</span>: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</div><div class="line">    <span class="attr">image</span>: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    image.src = <span class="string">'http://example.com/image_name.png'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeImage</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// The image is a direct child of the body element.</span></div><div class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'image'</span>));</div><div class="line"></div><div class="line">    <span class="comment">// At this point, we still have a reference to #button in the</span></div><div class="line">    <span class="comment">//global elements object. In other words, the button element is</span></div><div class="line">    <span class="comment">//still in memory and cannot be collected by the GC.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一个额外的考虑，当涉及对DOM树内部的内部或叶节点的引用时，必须考虑这一点。 假设你在JavaScript代码中保留对表格特定单元格（<code>&lt;td&gt;</code>标记）的引用。 有一天，你决定从DOM中删除该表，但保留对该单元格的引用。 直观地，可以假设GC将收集除了该单元格之外的所有内容。 实际上，这不会发生：该单元格是该表的子节点，并且孩子们保持对父代的引用。 也就是说，从JavaScript代码引用表格单元会导致整个表保留在内存中。 保持对DOM元素的引用时需要仔细考虑。</p>
<p>参考 <a href="https://segmentfault.com/a/1190000011229300" target="_blank" rel="external">https://segmentfault.com/a/1190000011229300</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个礼拜之前我们开始一系列对于JavaScript以及其本质工作原理的深入挖掘：我们认为通过了解JavaScript的构建方式以及它们是如何共同合作的，你就能够写出更好的代码以及应用。&lt;/p&gt;
&lt;p&gt;这个系列的第一篇博客专注于介绍&lt;a href=&quot;http://idiotsky.me/2017/08/26/javascript-how-work/&quot;&gt;对于引擎，运行时以及调用栈的概述&lt;/a&gt;。&lt;a href=&quot;http://idiotsky.me/2017/08/26/javascript-how-work-2/&quot;&gt;第二篇博客近距离地检测了Google V8 引擎的内部&lt;/a&gt;并且提供了一些如何写出更好的JavaScript代码的建议。&lt;/p&gt;
&lt;p&gt;在第三篇博客中，我们将会讨论另外一个关键的话题。这个话题由于随着编程语言的逐渐成熟和复杂化，越来越被开发者所忽视，这个话题就是在日常工作中使用到的——内存管理。&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;语言，比如C，具有低层次的内存管理方法，比如&lt;code&gt;malloc()&lt;/code&gt;以及&lt;code&gt;free()&lt;/code&gt;。开发者利用这些方法精确地为操作系统分配以及释放内存。&lt;/p&gt;
&lt;p&gt;同时，JavaScript会在创建一些变量（对象，字符串等等）的时候分配内存，并且会在这些不被使用之后“自动地”释放这些内存，这个过程被称为&lt;em&gt;垃圾收集&lt;/em&gt;。这个看起来“自动化的”特性其实就是产生误解的原因，并且给JavaScript（以及其他高层次语言）开发者一个假象，他们不需要关心内存管理。&lt;strong&gt;大错特错。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即使是使用高层次语言，开发者应该对于内存管理有一定的理解（或者最基本的理解）。有时候自动的内存管理会存在一些问题（比如一些bug或者垃圾收集器的一些限制等等），对于这些开发者必须能够理解从而能够合适地处理（或者使用最小的代价以及代码债务去绕过这个问题）。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://idiotsky.me/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://idiotsky.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化原理</title>
    <link href="http://idiotsky.me/2017/09/29/mysql-optimization-mechanism/"/>
    <id>http://idiotsky.me/2017/09/29/mysql-optimization-mechanism/</id>
    <published>2017-09-29T15:20:35.000Z</published>
    <updated>2017-10-02T08:03:13.579Z</updated>
    
    <content type="html"><![CDATA[<p>说起MySQL的查询优化，相信大家收藏了一堆奇技淫巧：不能使用SELECT *、不使用NULL字段、合理创建索引、为字段选择合适的数据类型….. 你是否真的理解这些优化技巧？是否理解其背后的工作原理？在实际场景下性能真有提升吗？我想未必。因而理解这些优化建议背后的原理就尤为重要，希望本文能让你重新审视这些优化建议，并在实际业务场景下合理的运用。</p>
<h1 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h1><p>如果能在头脑中构建一幅MySQL各组件之间如何协同工作的架构图，有助于深入理解MySQL服务器。下图展示了MySQL的逻辑架构图。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-1.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-1.jpg" alt=""></a><br><a id="more"></a><br>MySQL逻辑架构整体分为三层，最上层为客户端层，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。</p>
<p>MySQL大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。</p>
<p>最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。</p>
<h1 id="MySQL查询过程"><a href="#MySQL查询过程" class="headerlink" title="MySQL查询过程"></a>MySQL查询过程</h1><p>我们总是希望MySQL能够获得更高的查询性能，最好的办法是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，就会发现：很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。</p>
<p>当向MySQL发送一个请求的时候，MySQL到底做了些什么呢？<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-2.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-2.jpg" alt=""></a></p>
<h2 id="客户端-服务端通信协议"><a href="#客户端-服务端通信协议" class="headerlink" title="客户端/服务端通信协议"></a>客户端/服务端通信协议</h2><p>MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。</p>
<p>客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置max_allowed_packet参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p>
<p>与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用SELECT *以及加上LIMIT限制的原因之一。</p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>在解析一个查询语句前，如果查询缓存是打开的，那么MySQL会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p>
<p>MySQL将缓存存放在一个引用表（不要理解成table，可以认为是类似于HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</p>
<p>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果都不会被缓存。比如函数NOW()或者CURRENT_DATE()会因为不同的查询时间，返回不同的查询结果，再比如包含CURRENT_USER或者CONNECION_ID()的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。</p>
<p>既然是缓存，就会失效，那查询缓存何时失效呢？MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿。而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外：</p>
<ol>
<li>任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存</li>
<li>如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗</li>
</ol>
<p>基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。但要如何评估打开缓存是否能够带来性能提升是一件非常困难的事情，也不在本文讨论的范畴内。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如：</p>
<ol>
<li>用多个小表代替一个大表，注意不要过度设计</li>
<li>批量插入代替循环单条插入</li>
<li>合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适</li>
<li>可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存</li>
</ol>
<p>最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。</p>
<p>当然查询缓存系统本身是非常复杂的，这里讨论的也只是很小的一部分，其他更深入的话题，比如：缓存是如何使用内存的？如何控制内存的碎片化？事务对查询缓存有何影响等等，读者可以自行阅读相关资料，这里权当抛砖引玉吧。</p>
<h2 id="语法解析和预处理"><a href="#语法解析和预处理" class="headerlink" title="语法解析和预处理"></a>语法解析和预处理</h2><p>MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等。</p>
<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><p>经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。</p>
<p>MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在MySQL可以通过查询当前会话的last_query_cost的值来得到其计算当前查询的成本。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from t_message limit 10;</div><div class="line">...省略结果集</div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show status like 'last_query_cost';</div><div class="line">+-----------------+-------------+</div><div class="line">| Variable_name   | Value       |</div><div class="line">+-----------------+-------------+</div><div class="line">| Last_query_cost | 6391.799000 |</div><div class="line">+-----------------+-------------+</div></pre></td></tr></table></figure>
<p>示例中的结果表示优化器认为大概需要做6391个数据页的随机查找才能完成上面的查询。这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。</p>
<p>有非常多的原因会导致MySQL选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、MySQL认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但MySQL值选择它认为成本小的，但成本小并不意味着执行时间短）等等。</p>
<p>MySQL的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：</p>
<ul>
<li>重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）</li>
<li>优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值，具体原理见下文）</li>
<li>提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询）</li>
<li>优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多）</li>
</ul>
<p>随着MySQL的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略，其他的优化策略，大家自行查阅吧。</p>
<h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>在完成解析和优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为handler API。查询过程中的每一张表由一个handler实例表示。实际上，MySQL在查询优化阶段就为每一张表创建了一个handler实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。</p>
<h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等。</p>
<p>如果查询缓存被打开且这个查询可以被缓存，MySQL也会将结果存放到缓存中。</p>
<p>结果集返回客户端是一个增量且逐步返回的过程。有可能MySQL在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。需要注意的是，结果集中的每一行都会以一个满足①中所描述的通信协议的数据包发送，再通过TCP协议进行传输，在传输过程中，可能对MySQL的数据包进行缓存然后批量发送。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回头总结一下MySQL整个查询执行过程，总的来说分为6个步骤：</p>
<ul>
<li>客户端向MySQL服务器发送一条查询请求</li>
<li>服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li>
<li>服务器进行SQL解析、预处理、再由优化器生成对应的执行计划</li>
<li>MySQL根据执行计划，调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端，同时缓存查询结果</li>
</ul>
<h1 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h1><p>看了这么多，你可能会期待给出一些优化手段，是的，下面会从3个不同方面给出一些优化建议。但请等等，还有一句忠告要先送给你：不要听信你看到的关于优化的“绝对真理”，包括本文所讨论的内容，而应该是在实际的业务场景下通过测试来验证你关于执行计划以及响应时间的假设。</p>
<h2 id="Scheme设计与数据类型优化"><a href="#Scheme设计与数据类型优化" class="headerlink" title="Scheme设计与数据类型优化"></a>Scheme设计与数据类型优化</h2><p>选择数据类型只要遵循小而简单的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的CPU周期也更少。越简单的数据类型在计算时需要更少的CPU周期，比如，整型就比字符操作代价低，因而会使用整型来存储ip地址，使用DATETIME来存储时间，而不是使用字符串。</p>
<p>这里总结几个可能容易理解错误的技巧：</p>
<ol>
<li>通常来说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为NOT NULL。</li>
<li>对整数类型指定宽度，比如INT(11)，没有任何卵用。INT使用32位（4个字节）存储空间，那么它的表示范围已经确定，所以INT(1)和INT(20)对于存储和计算是相同的。</li>
<li>UNSIGNED表示不允许负值，大致可以使正数的上限提高一倍。比如TINYINT存储范围是-128 ~ 127，而UNSIGNED TINYINT存储的范围却是0 - 255。</li>
<li>通常来讲，没有太大的必要使用DECIMAL数据类型。即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用BIGINT存储。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题。</li>
<li>TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节存储空间。因而，TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。</li>
<li>大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用ALTER TABLE（如果只只是在列表末尾追加元素，不需要重建表）。</li>
<li>schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。如果列太多而实际使用的列又很少的话，有可能会导致CPU占用过高。</li>
<li>大表ALTER TABLE非常耗时，MySQL执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。当然有一些奇技淫巧可以解决这个问题，有兴趣可自行查阅。</li>
</ol>
<h2 id="创建高性能索引"><a href="#创建高性能索引" class="headerlink" title="创建高性能索引"></a>创建高性能索引</h2><p>索引是提高MySQL查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的SQL才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。</p>
<p>接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。</p>
<h3 id="索引相关的数据结构和算法"><a href="#索引相关的数据结构和算法" class="headerlink" title="索引相关的数据结构和算法"></a>索引相关的数据结构和算法</h3><p>通常我们所说的索引是指B-Tree索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用B-Tree这个术语，是因为MySQL在CREATE TABLE或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如InnoDB就是使用的B+Tree。</p>
<p>B+Tree中的B是指balance，意为平衡。需要注意的是，B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<p>在介绍B+Tree前，先了解一下二叉查找树，它是一种经典的数据结构，其左子树的值总是小于根的值，右子树的值总是大于根的值，如下图①。如果要在这课树中查找值为5的记录，其大致流程：先找到根，其值为6，大于5，所以查找左子树，找到3，而5大于3，接着找3的右子树，总共找了3次。同样的方法，如果查找值为8的记录，也需要查找3次。所以二叉查找树的平均查找次数为(3 + 3 + 3 + 2 + 2 + 1) / 6 = 2.3次，而顺序查找的话，查找值为2的记录，仅需要1次，但查找值为8的记录则需要6次，所以顺序查找的平均查找次数为：(1 + 2 + 3 + 4 + 5 + 6) / 6 = 3.3次，因此大多数情况下二叉查找树的平均查找速度比顺序查找要快。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-3.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-3.jpg" alt=""></a></p>
<p>由于二叉查找树可以任意构造，同样的值，可以构造出如图②的二叉查找树，显然这棵二叉树的查询效率和顺序查找差不多。若想二叉查找数的查询性能最高，需要这棵二叉查找树是平衡的，也即平衡二叉树（AVL树）。</p>
<p>平衡二叉树首先需要符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度差不能大于1。显然图②不满足平衡二叉树的定义，而图①是一课平衡二叉树。平衡二叉树的查找性能是比较高的（性能最好的是最优二叉树），查询性能越好，维护的成本就越大。比如图①的平衡二叉树，当用户需要插入一个新的值9的节点时，就需要做出如下变动。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-4.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-4.jpg" alt=""></a></p>
<p>通过一次左旋操作就将插入后的树重新变为平衡二叉树是最简单的情况了，实际应用场景中可能需要旋转多次。至此我们可以考虑一个问题，平衡二叉树的查找效率还不错，实现也非常简单，相应的维护成本还能接受，为什么MySQL索引不直接使用平衡二叉树？</p>
<p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的I/O读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的I/O存取次数？</p>
<p>一种行之有效的解决方法是减少树的深度，将二叉树变为m叉树（多路搜索树），而B+Tree就是一种多路搜索树。理解B+Tree时，只需要理解其最重要的两个特征即可：第一，所有的关键字（可以理解为数据）都存储在叶子节点（Leaf Page），非叶子节点（Index Page）并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。其次，所有的叶子节点由指针连接。如下图为高度为2的简化了的B+Tree。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-5.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-5.jpg" alt=""></a></p>
<p>怎么理解这两个特征？MySQL将每个节点的大小设置为一个页的整数倍（原因下文会介绍），也就是在节点空间大小一定的情况下，每个节点可以存储更多的内结点，这样每个结点能索引的范围更大更精确。所有的叶子节点使用指针链接的好处是可以进行区间访问，比如上图中，如果查找大于20而小于30的记录，只需要找到节点20，就可以遍历指针依次找到25、30。如果没有链接指针的话，就无法进行区间查找。这也是MySQL使用B+Tree作为索引存储结构的重要原因。</p>
<p>MySQL为何将节点大小设置为页的整数倍，这就需要理解磁盘的存储原理。磁盘本身存取就比主存慢很多，在加上机械运动损耗（特别是普通的机械硬盘），磁盘的存取速度往往是主存的几百万分之一，为了尽量减少磁盘I/O，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存，预读的长度一般为页的整数倍。</p>
<p>“页是计算机管理存储器的逻辑块，硬件及OS往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（许多OS中，页的大小通常为4K）。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后一起返回，程序继续运行。”</p>
<p>MySQL巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了读取一个节点只需一次I/O。假设B+Tree的高度为h，一次检索最多需要h-1I/O（根节点常驻内存），复杂度$O(h) = O(log_{M}N)$。实际应用场景中，M通常较大，常常超过100，因此树的高度一般都比较小，通常不超过3。</p>
<p>最后简单了解下B+Tree节点的操作，在整体上对索引的维护有一个大概的了解，虽然索引可以大大提高查询效率，但维护索引仍要花费很大的代价，因此合理的创建索引也就尤为重要。</p>
<p>仍以上面的树为例，我们假设每个节点只能存储4个内节点。首先要插入第一个节点28，如下图所示。</p>
<p><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-6.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-6.jpg" alt=""></a><br>接着插入下一个节点70，在Index Page中查询后得知应该插入到50 - 70之间的叶子节点，但叶子节点已满，这时候就需要进行也分裂的操作，当前的叶子节点起点为50，所以根据中间值来拆分叶子节点，如下图所示。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-7.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-7.jpg" alt=""></a><br>最后插入一个节点95，这时候Index Page和Leaf Page都满了，就需要做两次拆分，如下图所示。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-8.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-8.jpg" alt=""></a><br>拆分后最终形成了这样一颗树。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-9.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-9.jpg" alt=""></a><br>B+Tree为了保持平衡，对于新插入的值需要做大量的拆分页操作，而页的拆分需要I/O操作，为了尽可能的减少页的拆分操作，B+Tree也提供了类似于平衡二叉树的旋转功能。当Leaf Page已满但其左右兄弟节点没有满的情况下，B+Tree并不急于去做拆分操作，而是将记录移到当前所在页的兄弟节点上。通常情况下，左兄弟会被先检查用来做旋转操作。就比如上面第二个示例，当插入70的时候，并不会去做页拆分，而是左旋操作。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-10.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-10.jpg" alt=""></a></p>
<p>通过旋转操作可以最大限度的减少页分裂，从而减少索引维护过程中的磁盘的I/O操作，也提高索引维护效率。需要注意的是，删除节点跟插入节点类似，仍然需要旋转和拆分操作，这里就不再说明。</p>
<h3 id="高性能策略"><a href="#高性能策略" class="headerlink" title="高性能策略"></a>高性能策略</h3><p>通过上文，相信你对B+Tree的数据结构已经有了大致的了解，但MySQL中索引是如何组织数据的存储呢？以一个简单的示例来说明，假如有如下数据表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People(</div><div class="line">last_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">first_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">dob <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">gender enum(<span class="string">`m`</span>,<span class="string">`f`</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line"><span class="keyword">key</span>(last_name,first_name,dob)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>对于表中每一行数据，索引中包含了last_name、first_name、dob列的值，下图展示了索引是如何组织数据存储的。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-11.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-11.jpg" alt=""></a></p>
<p>可以看到，索引首先根据第一个字段来排列顺序，当名字相同时，则根据第三个字段，即出生日期来排序，正是因为这个原因，才有了索引的“最左原则”。</p>
<h4 id="MySQL不会使用索引的情况：非独立的列"><a href="#MySQL不会使用索引的情况：非独立的列" class="headerlink" title="MySQL不会使用索引的情况：非独立的列"></a>MySQL不会使用索引的情况：非独立的列</h4><p>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。比如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">where</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">5</span></div></pre></td></tr></table></figure></p>
<p>我们很容易看出其等价于 id = 4，但是MySQL无法自动解析这个表达式，使用函数是同样的道理。</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>如果列很长，通常可以索引开始的部分字符，这样可以有效节约索引空间，从而提高索引效率。</p>
<h4 id="多列索引和索引顺序"><a href="#多列索引和索引顺序" class="headerlink" title="多列索引和索引顺序"></a>多列索引和索引顺序</h4><p>在多数情况下，在多个列上建立独立的索引并不能提高查询性能。理由非常简单，MySQL不知道选择哪个索引的查询效率更好，所以在老版本，比如MySQL5.0之前就会随便选择一个列的索引，而新的版本会采用合并索引的策略。举个简单的例子，在一张电影演员表中，在actor_id和film_id两个列上都建立了独立的索引，然后有如下查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> film_id,actor_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">or</span> film_id = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>老版本的MySQL会随机选择一个索引，但新版本做如下的优化：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> film_id,actor_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span></div><div class="line"><span class="keyword">union</span> all</div><div class="line"><span class="keyword">select</span> film_id,actor_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> film_id = <span class="number">1</span> <span class="keyword">and</span> actor_id &lt;&gt; <span class="number">1</span></div></pre></td></tr></table></figure></p>
<ul>
<li>当出现多个索引做相交操作时（多个AND条件），通常来说一个包含所有相关列的索引要优于多个独立索引。</li>
<li>当出现多个索引做联合操作时（多个OR条件），对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描。</li>
</ul>
<p>因此explain时如果发现有索引合并（Extra字段出现Using union），应该好好检查一下查询和表结构是不是已经是最优的，如果查询和表都没有问题，那只能说明索引建的非常糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的多列索引更适合。</p>
<p>前面我们提到过索引如何组织数据存储的，从图中可以看到多列索引时，索引的顺序对于查询是至关重要的，很明显应该把选择性更高的字段放到索引的前面，这样通过第一个字段就可以过滤掉大多数不符合条件的数据。</p>
<p>索引选择性是指不重复的索引值和数据表的总记录数的比值，选择性越高查询效率越高，因为选择性越高的索引可以让MySQL在查询时过滤掉更多的行。唯一索引的选择性是1，这时最好的索引选择性，性能也是最好的。</p>
<p>理解索引选择性的概念后，就不难确定哪个字段的选择性较高了，查一下就知道了，比如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> payment <span class="keyword">where</span> staff_id = <span class="number">2</span> <span class="keyword">and</span> customer_id = <span class="number">584</span></div></pre></td></tr></table></figure></p>
<p>是应该创建(staff_id,customer_id)的索引还是应该颠倒一下顺序？执行下面的查询，哪个字段的选择性更接近1就把哪个字段索引前面就好。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> staff_id)/<span class="keyword">count</span>(*) <span class="keyword">as</span> staff_id_selectivity,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> customer_id)/<span class="keyword">count</span>(*) <span class="keyword">as</span> customer_id_selectivity,</div><div class="line"><span class="keyword">count</span>(*) <span class="keyword">from</span> payment</div></pre></td></tr></table></figure></p>
<p>多数情况下使用这个原则没有任何问题，但仍然注意你的数据中是否存在一些特殊情况。举个简单的例子，比如要查询某个用户组下有过交易的用户信息：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> user_id <span class="keyword">from</span> trade <span class="keyword">where</span> user_group_id = <span class="number">1</span> <span class="keyword">and</span> trade_amount &gt; <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>MySQL为这个查询选择了索引(user_group_id,trade_amount)，如果不考虑特殊情况，这看起来没有任何问题，但实际情况是这张表的大多数数据都是从老系统中迁移过来的，由于新老系统的数据不兼容，所以就给老系统迁移过来的数据赋予了一个默认的用户组。这种情况下，通过索引扫描的行数跟全表扫描基本没什么区别，索引也就起不到任何作用。</p>
<p>推广开来说，经验法则和推论在多数情况下是有用的，可以指导我们开发和设计，但实际情况往往会更复杂，实际业务场景下的某些特殊情况可能会摧毁你的整个设计。</p>
<h4 id="避免多个范围条件"><a href="#避免多个范围条件" class="headerlink" title="避免多个范围条件"></a>避免多个范围条件</h4><p>实际开发中，我们会经常使用多个范围条件，比如想查询某个时间段内登录过的用户：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> user.* <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> login_time &gt; <span class="string">'2017-04-01'</span> <span class="keyword">and</span> age <span class="keyword">between</span> <span class="number">18</span> <span class="keyword">and</span> <span class="number">30</span>;</div></pre></td></tr></table></figure></p>
<p>这个查询有一个问题：它有两个范围条件，login_time列和age列，MySQL可以使用login_time列的索引或者age列的索引，但无法同时使用它们。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含或者说覆盖所有需要查询的字段的值，那么就没有必要再回表查询，这就称为覆盖索引。覆盖索引是非常有用的工具，可以极大的提高性能，因为查询只需要扫描索引会带来许多好处：</p>
<ul>
<li>索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量</li>
<li>索引是有按照列值顺序存储的，对于I/O密集型的范围查询要比随机从磁盘读取每一行数据的IO要少的多</li>
</ul>
<h4 id="使用索引扫描来排序"><a href="#使用索引扫描来排序" class="headerlink" title="使用索引扫描来排序"></a>使用索引扫描来排序</h4><p>MySQL有两种方式可以生产有序的结果集，其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的。如果explain的结果中type列的值为index表示使用了索引扫描来做排序。</p>
<p>扫描索引本身很快，因为只需要从一条索引记录移动到相邻的下一条记录。但如果索引本身不能覆盖所有需要查询的列，那么就不得不每扫描一条索引记录就回表查询一次对应的行。这个读取操作基本上是随机I/O，因此按照索引顺序读取数据的速度通常要比顺序地全表扫描要慢。</p>
<p>在设计索引时，如果一个索引既能够满足排序，又满足查询，是最好的。</p>
<p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向也一样时，才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有ORDER BY子句引用的字段全部为第一张表时，才能使用索引做排序。ORDER BY子句和查询的限制是一样的，都要满足最左前缀的要求（有一种情况例外，就是最左的列被指定为常数，下面是一个简单的示例），其它情况下都需要执行排序操作，而无法利用索引排序。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 最左列为常数，索引：(date,staff_id,customer_id)</span></div><div class="line"><span class="keyword">select</span> staff_id,customer_id <span class="keyword">from</span> demo <span class="keyword">where</span> <span class="built_in">date</span> = <span class="string">'2015-06-01'</span> <span class="keyword">order</span> <span class="keyword">by</span> staff_id,customer_id</div></pre></td></tr></table></figure></p>
<h4 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h4><p>冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引(A,B)，再创建索引(A)就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引(A,B)，但这个索引不是扩展已有的索引(A)。</p>
<p>大多数情况下都应该尽量扩展已有的索引而不是创建新索引。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。</p>
<h4 id="删除长期未使用的索引"><a href="#删除长期未使用的索引" class="headerlink" title="删除长期未使用的索引"></a>删除长期未使用的索引</h4><p>定期删除一些长时间未使用过的索引是一个非常好的习惯。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>关于索引这个话题打算就此打住，最后要说一句，索引并不总是最好的工具，只有当索引帮助提高查询速度带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，简单的全表扫描更高效。对于中到大型的表，索引就非常有效。对于超大型的表，建立和维护索引的代价随之增长，这时候其他技术也许更有效，比如分区表。最后的最后，explain后再提测是一种美德。</p>
<h2 id="特定类型查询优化"><a href="#特定类型查询优化" class="headerlink" title="特定类型查询优化"></a>特定类型查询优化</h2><h3 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT()查询"></a>优化COUNT()查询</h3><p>COUNT()可能是被大家误解最多的函数了，它有两种不同的作用，其一是统计某个列值的数量，其二是统计行数。统计列值时，要求列值是非空的，它不会统计NULL。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用COUNT(*)时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计所有的行数。</p>
<p>我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用COUNT(*)，意义清晰，且性能更好。</p>
<p>有时候某些业务场景并不需要完全精确的COUNT值，可以用近似值来代替，EXPLAIN出来的行数就是一个不错的近似值，而且执行EXPLAIN并不需要真正地去执行查询，所以成本非常低。通常来说，执行COUNT()都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用redis这样的外部缓存系统。</p>
<h3 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h3><p>在大数据场景下，表与表之间通过一个冗余字段来关联，要比直接使用JOIN有更好的性能。如果确实需要使用关联查询的情况下，需要特别注意的是：</p>
<ol>
<li>确保ON和USING字句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表A和表B用列c关联的时候，如果优化器关联的顺序是A、B，那么就不需要在A表的对应列上创建索引。没有用到的索引会带来额外的负担，一般来说，除非有其他理由，只需要在关联顺序中的第二张表的相应列上创建索引（具体原因下文分析）。</li>
<li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化。</li>
</ol>
<p>要理解优化关联查询的第一个技巧，就需要理解MySQL是如何执行关联查询的。当前MySQL关联执行的策略非常简单，它对任何的关联都执行嵌套循环关联操作，即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列。</p>
<p>太抽象了？以上面的示例来说明，比如有这样的一个查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> A.xx,B.yy</div><div class="line"><span class="keyword">FROM</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B <span class="keyword">USING</span>(c)</div><div class="line"><span class="keyword">WHERE</span> A.xx <span class="keyword">IN</span> (<span class="number">5</span>,<span class="number">6</span>)</div></pre></td></tr></table></figure></p>
<p>假设MySQL按照查询中的关联顺序A、B来进行关联操作，那么可以用下面的伪代码表示MySQL如何完成这个查询：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">outer_iterator = SELECT A.xx,A.c FROM A WHERE A.xx IN (5,6);</div><div class="line">outer_row = outer_iterator.next;</div><div class="line">while(outer_row) &#123;</div><div class="line">    inner_iterator = SELECT B.yy FROM B WHERE B.c = outer_row.c;</div><div class="line">    inner_row = inner_iterator.next;</div><div class="line">    while(inner_row) &#123;</div><div class="line">        output[inner_row.yy,outer_row.xx];</div><div class="line">        inner_row = inner_iterator.next;</div><div class="line">    &#125;</div><div class="line">    outer_row = outer_iterator.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，最外层的查询是根据A.xx列来查询的，A.c上如果有索引的话，整个关联查询也不会使用。再看内层的查询，很明显B.c上如果有索引的话，能够加速查询，因此只需要在关联顺序中的第二张表的相应列上创建索引即可。</p>
<h3 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h3><p>当需要分页操作时，通常会使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY字句。如果有对应的索引，通常效率会不错，否则，MySQL需要做大量的文件排序操作。</p>
<p>一个常见的问题是当偏移量非常大的时候，比如：LIMIT 10000 20这样的查询，MySQL需要查询10020条记录然后只返回20条记录，前面的10000条都将被抛弃，这样的代价非常高。</p>
<p>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> film_id,description <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span>;</div></pre></td></tr></table></figure></p>
<p>如果这张表非常大，那么这个查询最好改成下面的样子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> film.film_id,film.description</div><div class="line"><span class="keyword">FROM</span> film <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</div><div class="line"><span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span></div><div class="line">) <span class="keyword">AS</span> tmp <span class="keyword">USING</span>(film_id);</div></pre></td></tr></table></figure></p>
<p>这里的延迟关联将大大提升查询效率，让MySQL扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。</p>
<p>有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET，比如下面的查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t <span class="keyword">LIMIT</span> <span class="number">10000</span>, <span class="number">10</span>;</div></pre></td></tr></table></figure></p>
<p>改为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">10000</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</div></pre></td></tr></table></figure></p>
<p>其它优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。</p>
<h3 id="优化UNION"><a href="#优化UNION" class="headerlink" title="优化UNION"></a>优化UNION</h3><p>MySQL处理UNION的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在UNION查询中都没有办法很好的时候。经常需要手动将WHERE、LIMIT、ORDER BY等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。</p>
<p>除非确实需要服务器去重，否则就一定要使用UNION ALL，如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用ALL关键字，MySQL总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把每个子查询的结果返回给客户端。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>理解查询是如何执行以及时间都消耗在哪些地方，再加上一些优化过程的知识，可以帮助大家更好的理解MySQL，理解常见优化技巧背后的原理。希望本文中的原理、示例能够帮助大家更好的将理论和实践联系起来，更多的将理论知识运用到实践中。</p>
<p>其他也没啥说的了，给大家留两个思考题吧，可以在脑袋里想想答案，这也是大家经常挂在嘴边的，但很少有人会思考为什么？</p>
<ol>
<li>有非常多的程序员在分享时都会抛出这样一个观点：尽可能不要使用存储过程，存储过程非常不容易维护，也会增加使用成本，应该把业务逻辑放到客户端。既然客户端都能干这些事，那为什么还要存储过程？</li>
<li>JOIN本身也挺方便的，直接查询就好了，为什么还需要视图呢？</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起MySQL的查询优化，相信大家收藏了一堆奇技淫巧：不能使用SELECT *、不使用NULL字段、合理创建索引、为字段选择合适的数据类型….. 你是否真的理解这些优化技巧？是否理解其背后的工作原理？在实际场景下性能真有提升吗？我想未必。因而理解这些优化建议背后的原理就尤为重要，希望本文能让你重新审视这些优化建议，并在实际业务场景下合理的运用。&lt;/p&gt;
&lt;h1 id=&quot;MySQL逻辑架构&quot;&gt;&lt;a href=&quot;#MySQL逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL逻辑架构&quot;&gt;&lt;/a&gt;MySQL逻辑架构&lt;/h1&gt;&lt;p&gt;如果能在头脑中构建一幅MySQL各组件之间如何协同工作的架构图，有助于深入理解MySQL服务器。下图展示了MySQL的逻辑架构图。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images1/mysql-optimization-mechanism-1.jpg&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images1/mysql-optimization-mechanism-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://idiotsky.me/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://idiotsky.me/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>从一个 NullPointerException 探究 Java 的自动装箱拆箱机制</title>
    <link href="http://idiotsky.me/2017/09/28/java-box-unbox/"/>
    <id>http://idiotsky.me/2017/09/28/java-box-unbox/</id>
    <published>2017-09-28T12:35:44.000Z</published>
    <updated>2017-09-28T15:54:46.025Z</updated>
    
    <content type="html"><![CDATA[<p>前天遇到了一个 NullPointerException，触发的代码类似下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Long value = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        test(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>main 方法里的代码实际上相当于调用 <code>test(null);</code>，为什么不直接这样写呢？因为编译不过，会报 <code>错误: 不兼容的类型: &lt;空值&gt;无法转换为long</code>。</p>
<h1 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h1><p>运行时提示 <code>test(value);</code> 这一行抛出 NullPointerException，但是看着以上代码会有些许困惑：以上代码里一个对象方法都没有调用啊，NullPointerException 从何而来？<br><a id="more"></a></p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>这时，如果留意到 test 方法接受的参数是 long 类型，而我们传入的是 Long 类型（虽然其实是 null），就会想到这会经历一次从类型 Long 到基本数据类型 long 的自动拆箱过程，那会不会是这个过程中抛出的 NullPointerException 呢？因为以前只知道 Java 为一些基础数据类型与对应的包装器类型之间提供了自动装箱拆箱机制，而并不知这机制的具体实现方法是怎么样的，正好学习一下。</p>
<p>用命令 <code>javap -c Test</code> 将以上代码编译出的 Test.class 文件进行反汇编，可以看到如下输出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Compiled from "Test.java"</div><div class="line">public class Test &#123;</div><div class="line">  public Test();</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</div><div class="line">       4: return</div><div class="line"></div><div class="line">  public static long test(long);</div><div class="line">    Code:</div><div class="line">       0: lload_0</div><div class="line">       1: lreturn</div><div class="line"></div><div class="line">  public static void main(java.lang.String[]);</div><div class="line">    Code:</div><div class="line">       0: aconst_null</div><div class="line">       1: astore_1</div><div class="line">       2: aload_1</div><div class="line">       3: invokevirtual #2                  // Method java/lang/Long.longValue:()J</div><div class="line">       6: invokestatic  #3                  // Method test:(J)J</div><div class="line">       9: pop2</div><div class="line">      10: return</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从以上字节码及对应的注释可以看出，<code>test(value);</code> 这一行被编译后等同于如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> primitive = value.longValue();</div><div class="line">test(promitive);</div></pre></td></tr></table></figure></p>
<p>相比实际代码，多出的 <code>long primitive = value.longValue();</code> 这一行看起来就是自动拆箱的过程了，而我们传入的 <code>value</code> 为 null，<code>value.longValue()</code> 会抛出 NullPointerException，一切就解释得通了。用更简洁的代码表达出了更丰富的含义，这就是所谓的语法糖了。</p>
<h1 id="证实猜想"><a href="#证实猜想" class="headerlink" title="证实猜想"></a>证实猜想</h1><p>那么我们上面得出的自动拆箱机制的结论是否正确呢？选择一种其它基本数据类型，比如 int，来佐证一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Integer value = <span class="number">10</span>;</div><div class="line">        <span class="keyword">int</span> primitive = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>反汇编后对应的字节码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Compiled from "Test.java"</div><div class="line">public class Test &#123;</div><div class="line">  public Test();</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</div><div class="line">       4: return</div><div class="line"></div><div class="line">  public static void main(java.lang.String[]);</div><div class="line">    Code:</div><div class="line">       0: bipush        10</div><div class="line">       2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</div><div class="line">       5: astore_1</div><div class="line">       6: aload_1</div><div class="line">       7: invokevirtual #3                  // Method java/lang/Integer.intValue:()I</div><div class="line">      10: istore_2</div><div class="line">      11: return</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由以上字节码我们可以印证下文里的知识点了。</p>
<h1 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h1><p>自动装箱与拆箱是 Java 1.5 引入的新特性，是一种语法糖。</p>
<p>在此之前，我们要创建一个值为 10 的 Integer 对象，只能写作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer value = <span class="keyword">new</span> Integer(<span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<p>而现在，我们可以更方便地写为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer value = <span class="number">10</span>;</div></pre></td></tr></table></figure></p>
<h1 id="定义与实现机制"><a href="#定义与实现机制" class="headerlink" title="定义与实现机制"></a>定义与实现机制</h1><p>自动装箱，是指从基本数据类型值到其对应的包装类对象的自动转换。比如 <code>Integer value = 10;</code>，是通过调用 Integer.valueOf 方法实现转换的。</p>
<p>自动拆箱，是指从包装类对象到其对应的基本数据类型值的自动转换。比如 <code>int primitive = value;</code>，是通过调用 Integer.intValue 方法实现转换的。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
<th>装箱方法</th>
<th>拆箱方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>Boolean</td>
<td>Boolean.valueOf(boolean)</td>
<td>Boolean.booleanValue()</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
<td>Byte.valueOf(byte)</td>
<td>Byte.byteValue()</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td>Character.valueOf(char)</td>
<td>Character.charValue()</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>Short.valueOf(short)</td>
<td>Short.shortValue()</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>Integer.valueOf(int)</td>
<td>Integer.intValue()</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>Long.valueOf(long)</td>
<td>Long.longValue()</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>Float.valueOf(float)</td>
<td>Float.floatValue()</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>Double.valueOf(double)</td>
<td>Double.doubleValue()</td>
</tr>
</tbody>
</table>
<h1 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h1><p>自动装箱与拆箱主要发生在以下四种时机：</p>
<ol>
<li><p>赋值时；</p>
</li>
<li><p>比较时；</p>
</li>
<li><p>算术运算时；</p>
</li>
<li><p>方法调用时。</p>
</li>
</ol>
<h1 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h1><h2 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer value = <span class="number">10</span>; <span class="comment">// 自动装箱（赋值时）</span></div><div class="line"><span class="keyword">int</span> primitive = value; <span class="comment">// 自动拆箱（方法调用时）</span></div></pre></td></tr></table></figure>
<h2 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Integer value = <span class="number">1000</span>;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">if</span> (value &lt;= <span class="number">1000</span>) &#123; <span class="comment">// 自动拆箱（比较时）</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Case-3"><a href="#Case-3" class="headerlink" title="Case 3"></a>Case 3</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">list.add(<span class="number">10</span>); <span class="comment">// 自动装箱（方法调用时）</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> i = list.get(<span class="number">0</span>); <span class="comment">// 自动拆箱（赋值时）</span></div></pre></td></tr></table></figure>
<p><strong>注：集合（Collections）里不能直接放入原始类型，集合只接收对象。</strong></p>
<h2 id="Case-4"><a href="#Case-4" class="headerlink" title="Case 4"></a>Case 4</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</div><div class="line">local.set(<span class="number">10</span>); <span class="comment">// 自动装箱（方法调用时）</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> i = local.get(); <span class="comment">// 自动拆箱（赋值时）</span></div></pre></td></tr></table></figure>
<p><strong>注：ThreadLocal 不能存储基本数据类型，只接收引用类型。</strong></p>
<h2 id="Case-5"><a href="#Case-5" class="headerlink" title="Case 5"></a>Case 5</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(Integer value)</span> </span>&#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">    fun1(<span class="number">10</span>); <span class="comment">// 自动装箱（方法调用时）</span></div><div class="line"></div><div class="line">    Integer value = <span class="number">10</span>;</div><div class="line">    fun2(value); <span class="comment">// 自动拆箱（方法调用时）</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Case-6"><a href="#Case-6" class="headerlink" title="Case 6"></a>Case 6</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Integer v1 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</div><div class="line">Integer v2 = <span class="keyword">new</span> Integer(<span class="number">20</span>);</div><div class="line"><span class="keyword">int</span> v3 = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> sum = v1 + v2; <span class="comment">// 自动拆箱（算术运算时）</span></div><div class="line">sum = v1 + <span class="number">30</span>; <span class="comment">// 自动拆箱（算术运算时）</span></div></pre></td></tr></table></figure>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>除 <code>==</code> 以外，包装类对象与基本数据类型值的比较，包装类对象与包装类对象之间的比较，都是自动拆箱后对基本数据类型值进行比较，所以，<strong>要注意这些类型间进行比较时自动拆箱可能引发的 NullPointerException</strong>。</p>
<p><code>==</code> 比较特殊，因为可以用于判断左右是否为同一对象，所以两个包装类对象之间 <code>==</code>，会用于判断是否为同一对象，而不会进行自动拆箱操作；包装类对象与基本数据类型值之间 <code>==</code>，会自动拆箱。</p>
<p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Integer v1 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</div><div class="line">Integer v2 = <span class="keyword">new</span> Integer(<span class="number">20</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (v1 &lt; v2) &#123; <span class="comment">// 自动拆箱</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (v1 == v2) &#123; <span class="comment">// 不拆箱</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (v1 == <span class="number">10</span>) &#123; <span class="comment">// 自动拆箱</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Java 为整型值包装类 Byte、Character、Short、Integer、Long 设置了缓存，用于存储一定范围内的值，详细如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>缓存值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>Byte</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>Character</td>
<td>0 ~ 127</td>
</tr>
<tr>
<td>Short</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>Integer</td>
<td>-128 ~ 127（可配置）</td>
</tr>
<tr>
<td>Long</td>
<td>-128 ~ 127</td>
</tr>
</tbody>
</table>
<p>在一些情况下，比如自动装箱时，如果值在缓存值范围内，将不创建新对象，直接从缓存里取出对象返回，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Integer v1 = <span class="number">10</span>;</div><div class="line">Integer v2 = <span class="number">10</span>;</div><div class="line">Integer v3 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</div><div class="line">Integer v4 = <span class="number">128</span>;</div><div class="line">Integer v5 = <span class="number">128</span>;</div><div class="line">Integer v6 = Integer.valueOf(<span class="number">10</span>);</div><div class="line"></div><div class="line">System.out.println(v1 == v2); <span class="comment">// true</span></div><div class="line">System.out.println(v1 == v3); <span class="comment">// false</span></div><div class="line">System.out.println(v4 == v5); <span class="comment">// false</span></div><div class="line">System.out.println(v1 == v6); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h3 id="缓存实现机制"><a href="#缓存实现机制" class="headerlink" title="缓存实现机制"></a>缓存实现机制</h3><p>这里使用了设计模式享元模式。</p>
<p>以 Short 类实现源码为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Short</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Short</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCache</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ShortCache</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Short cache[] = <span class="keyword">new</span> Short[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</div><div class="line">                cache[i] = <span class="keyword">new</span> Short((<span class="keyword">short</span>)(i - <span class="number">128</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</div><div class="line">        <span class="keyword">int</span> sAsInt = s;</div><div class="line">        <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></div><div class="line">            <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在第一次调用到 <code>Short.valueOf(short)</code> 方法时，将创建 -128 ~ 127 对应的 256 个对象缓存到堆内存里。</p>
<p>这种设计，在频繁用到这个范围内的值的时候效率较高，可以避免重复创建和回收对象，否则有可能闲置较多对象在内存中。</p>
<h3 id="使用不当的情况"><a href="#使用不当的情况" class="headerlink" title="使用不当的情况"></a>使用不当的情况</h3><p>自动装箱和拆箱这种语法糖为我们写代码带来了简洁和便利，但如果使用不当，也有可能带来负面影响。</p>
<ol>
<li>性能的损耗<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Integer sum = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1000</span>; i &lt; <span class="number">5000</span>; i++) &#123;</div><div class="line">       <span class="comment">// 1. 先对 sum 进行自动拆箱</span></div><div class="line">       <span class="comment">// 2. 加法</span></div><div class="line">       <span class="comment">// 3. 自动装箱赋值给 sum，无法命中缓存，会 new Integer(int)</span></div><div class="line">       sum = sum + i;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在循环过程中会分别调用 4000 次 Integer.intValue() 和 Integer.valueOf(int)，并 new 4000 个 Integer 对象，而这些操作将 sum 的类型改为 int 即可避免，节约运行时间和空间，提升性能。</p>
<ol>
<li>java.lang.NullPointerException<br>尝试对一个值为 null 的包装类对象进行自动拆箱，就有可能造成 NullPointerException。<br>比如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Integer v1 = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">int</span> v2 = v1; <span class="comment">// NullPointerException</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (v1 &gt; <span class="number">10</span>) &#123; <span class="comment">// NullPointerException</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> v3 = v1 + <span class="number">10</span>; <span class="comment">// NullPointerException</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>还有一种更隐蔽的情形<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> value = <span class="keyword">true</span> ? <span class="keyword">null</span> : <span class="number">1</span>; <span class="comment">// NullPointerException</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这实际上还是对一个值为 null 的 Long 类型进行自动拆箱，反汇编代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Compiled from "Test.java"</div><div class="line">public class Test &#123;</div><div class="line">  public Test();</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</div><div class="line">       4: return</div><div class="line"></div><div class="line">  public static void main(java.lang.String[]);</div><div class="line">    Code:</div><div class="line">       0: aconst_null</div><div class="line">       1: checkcast     #2                  // class java/lang/Long</div><div class="line">       4: invokevirtual #3                  // Method java/lang/Long.longValue:()J</div><div class="line">       7: lstore_1</div><div class="line">       8: return</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>转载 <a href="http://mazhuang.org/2017/08/20/java-auto-boxing-unboxing/" target="_blank" rel="external">http://mazhuang.org/2017/08/20/java-auto-boxing-unboxing/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前天遇到了一个 NullPointerException，触发的代码类似下面这样：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Long value = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        test(value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;main 方法里的代码实际上相当于调用 &lt;code&gt;test(null);&lt;/code&gt;，为什么不直接这样写呢？因为编译不过，会报 &lt;code&gt;错误: 不兼容的类型: &amp;lt;空值&amp;gt;无法转换为long&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;抛出问题&quot;&gt;&lt;a href=&quot;#抛出问题&quot; class=&quot;headerlink&quot; title=&quot;抛出问题&quot;&gt;&lt;/a&gt;抛出问题&lt;/h1&gt;&lt;p&gt;运行时提示 &lt;code&gt;test(value);&lt;/code&gt; 这一行抛出 NullPointerException，但是看着以上代码会有些许困惑：以上代码里一个对象方法都没有调用啊，NullPointerException 从何而来？&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="装箱" scheme="http://idiotsky.me/tags/%E8%A3%85%E7%AE%B1/"/>
    
      <category term="拆箱" scheme="http://idiotsky.me/tags/%E6%8B%86%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>go基础-iota</title>
    <link href="http://idiotsky.me/2017/09/18/go-basic-iota/"/>
    <id>http://idiotsky.me/2017/09/18/go-basic-iota/</id>
    <published>2017-09-18T07:44:21.000Z</published>
    <updated>2017-09-19T13:18:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>iota这个关键字，用来实现枚举的功能，但是用起来很奇怪，其实最后表示的还是常量。</p>
</blockquote>
<h1 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span>(</div><div class="line">    a= <span class="number">10</span>+<span class="literal">iota</span></div><div class="line">    b</div><div class="line">    c</div><div class="line">    d</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(a)</div><div class="line">	fmt.Println(b)</div><div class="line">	fmt.Println(c)</div><div class="line">	fmt.Println(d)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td></tr></table></figure></p>
<p>其实上面代码等价于<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span>(</div><div class="line">    a= <span class="number">10</span>+<span class="number">0</span></div><div class="line">    b= <span class="number">10</span>+<span class="number">1</span></div><div class="line">    c= <span class="number">10</span>+<span class="number">2</span></div><div class="line">    d= <span class="number">10</span>+<span class="number">3</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>看出规律了吧，只要iota出现一次，就累加一次，而且一旦出现一次，就算后面不使用这个iota关键字，接下来的变量都会套用前面的表达式来计算，所以b,c,d用的就是a的表达式<br><a id="more"></a></p>
<h1 id="再上代码"><a href="#再上代码" class="headerlink" title="再上代码"></a>再上代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span>(</div><div class="line">    a= <span class="number">10</span>+<span class="literal">iota</span></div><div class="line">    b</div><div class="line">    c</div><div class="line">    d</div><div class="line">	  e=<span class="number">1</span>+<span class="literal">iota</span></div><div class="line">	  f</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(a)</div><div class="line">	fmt.Println(b)</div><div class="line">	fmt.Println(c)</div><div class="line">	fmt.Println(d)</div><div class="line">	fmt.Println(e)</div><div class="line">	fmt.Println(f)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个的输出，应该能猜出来了吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">5</div><div class="line">6</div></pre></td></tr></table></figure></p>
<p>f很明显是由于e的表达式变了，所以是套用了e的表达式，而不用a的表达式</p>
<h1 id="最后的代码"><a href="#最后的代码" class="headerlink" title="最后的代码"></a>最后的代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span>(</div><div class="line">    a= <span class="number">10</span>+<span class="literal">iota</span></div><div class="line">    b</div><div class="line">    c</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span>(</div><div class="line">	d=<span class="number">1</span>+<span class="literal">iota</span></div><div class="line">	e</div><div class="line">	f</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(a)</div><div class="line">	fmt.Println(b)</div><div class="line">	fmt.Println(c)</div><div class="line">	fmt.Println(d)</div><div class="line">	fmt.Println(e)</div><div class="line">	fmt.Println(f)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>很明显，iota只能在一个代码块累加，在另外的代码块就又重置了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实iota在go就是一个常量，定义在builtin.go这个源文件<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// iota is a predeclared identifier representing the untyped integer ordinal</span></div><div class="line"><span class="comment">// number of the current const specification in a (usually parenthesized)</span></div><div class="line"><span class="comment">// const declaration. It is zero-indexed.</span></div><div class="line"><span class="keyword">const</span> <span class="literal">iota</span> = <span class="number">0</span> <span class="comment">// Untyped int.</span></div></pre></td></tr></table></figure></p>
<p>本文代码在 <a href="https://github.com/ejunjsh/go-code/tree/master/iota" target="_blank" rel="external">https://github.com/ejunjsh/go-code/tree/master/iota</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iota这个关键字，用来实现枚举的功能，但是用起来很奇怪，其实最后表示的还是常量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;先上代码&quot;&gt;&lt;a href=&quot;#先上代码&quot; class=&quot;headerlink&quot; title=&quot;先上代码&quot;&gt;&lt;/a&gt;先上代码&lt;/h1&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    a= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;+&lt;span class=&quot;literal&quot;&gt;iota&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    b&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    c&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    d&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	fmt.Println(a)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	fmt.Println(b)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	fmt.Println(c)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	fmt.Println(d)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结果：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其实上面代码等价于&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    a= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    b= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    c= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    d= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看出规律了吧，只要iota出现一次，就累加一次，而且一旦出现一次，就算后面不使用这个iota关键字，接下来的变量都会套用前面的表达式来计算，所以b,c,d用的就是a的表达式&lt;br&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-对象</title>
    <link href="http://idiotsky.me/2017/09/18/redis-object/"/>
    <id>http://idiotsky.me/2017/09/18/redis-object/</id>
    <published>2017-09-17T17:29:58.000Z</published>
    <updated>2017-10-07T13:24:55.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面的数个章节里， 我们陆续介绍了 Redis 用到的所有主要数据结构， 比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合， 等等。</p>
<p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p>
<p>通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 使用对象的另一个好处是， 我们可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</p>
<p>除此之外， Redis 的对象系统还实现了基于引用计数技术的内存回收机制： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放； 另外， Redis 还通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。</p>
<p>最后， Redis 的对象带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。</p>
<p>本章接下来将逐一介绍以上提到的 Redis 对象系统的各个特性。<br><a id="more"></a></p>
<h1 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h1><p>Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p>
<p>举个例子， 以下 SET 命令在数据库中创建了一个新的键值对， 其中键值对的键是一个包含了字符串值 “msg” 的对象， 而键值对的值则是一个包含了字符串值 “hello world” 的对象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello world"</span></span></div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 类型</span></div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 编码</span></div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125; robj;</div></pre></td></tr></table></figure></p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>对象的 type 属性记录了对象的类型， 这个属性的值可以是表 8-1 列出的常量的其中一个。</p>
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象的名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>字符串对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>列表对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>哈希对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>有序集合对象</td>
</tr>
</tbody>
</table>
<p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：</p>
<ul>
<li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；</li>
<li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”，</li>
</ul>
<p>诸如此类。</p>
<p>TYPE 命令的实现方式也与此类似， 当我们对一个数据库键执行 TYPE 命令时， 命令返回的结果为数据库键对应的值对象的类型， 而不是键对象的类型：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 键为字符串对象，值为字符串对象</span></div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> SET msg <span class="string">"hello world"</span></span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> TYPE msg</span></div><div class="line">string</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 键为字符串对象，值为列表对象</span></div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> RPUSH numbers 1 3 5</span></div><div class="line">(integer) 6</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> TYPE numbers</span></div><div class="line">list</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 键为字符串对象，值为哈希对象</span></div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> HMSET profile name Tome age 25 career Programmer</span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> TYPE profile</span></div><div class="line">hash</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 键为字符串对象，值为集合对象</span></div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> SADD fruits apple banana cherry</span></div><div class="line">(integer) 3</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> TYPE fruits</span></div><div class="line">set</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 键为字符串对象，值为有序集合对象</span></div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> ZADD price 8.5 apple 5.0 banana 6.0 cherry</span></div><div class="line">(integer) 3</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> TYPE price</span></div><div class="line">zset</div></pre></td></tr></table></figure></p>
<p>表 8-2 列出了 TYPE 命令在面对不同类型的值对象时所产生的输出。</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>对象 type 属性的值</th>
<th>TYPE 命令的输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串对象</td>
<td>REDIS_STRING</td>
<td>“string”</td>
</tr>
<tr>
<td>列表对象</td>
<td>REDIS_LIST</td>
<td>“list”</td>
</tr>
<tr>
<td>哈希对象</td>
<td>REDIS_HASH</td>
<td>“hash”</td>
</tr>
<tr>
<td>集合对象</td>
<td>REDIS_SET</td>
<td>“set”</td>
</tr>
<tr>
<td>有序集合对象</td>
<td>REDIS_ZSET</td>
<td>“zset”</td>
</tr>
</tbody>
</table>
<h2 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h2><p>对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。</p>
<p>encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现， 这个属性的值可以是表 8-3 列出的常量的其中一个。</p>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>long 类型的整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
</tr>
</tbody>
</table>
<p>每种类型的对象都至少使用了两种不同的编码， 表 8-4 列出了每种类型的对象可以使用的编码。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET</td>
<td>使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
<p>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello wrold"</span></span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING msg</span></div><div class="line">"embstr"</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> SET story <span class="string">"long long long long long long ago ..."</span></span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING story</span></div><div class="line">"raw"</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> SADD numbers 1 3 5</span></div><div class="line">(integer) 3</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING numbers</span></div><div class="line">"intset"</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> SADD numbers <span class="string">"seven"</span></span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING numbers</span></div><div class="line">"hashtable"</div></pre></td></tr></table></figure></p>
<p>表 8-5 列出了不同编码的对象所对应的 OBJECT ENCODING 命令输出。</p>
<table>
<thead>
<tr>
<th>对象所使用的底层数据结构</th>
<th>编码常量</th>
<th>OBJECT ENCODING 命令输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数</td>
<td>REDIS_ENCODING_INT</td>
<td>“int”</td>
</tr>
<tr>
<td>embstr 编码的简单动态字符串（SDS）</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>“embstr”</td>
</tr>
<tr>
<td>简单动态字符串</td>
<td>REDIS_ENCODING_RAW</td>
<td>“raw”</td>
</tr>
<tr>
<td>字典</td>
<td>REDIS_ENCODING_HT</td>
<td>“hashtable”</td>
</tr>
<tr>
<td>双端链表</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>“linkedlist”</td>
</tr>
<tr>
<td>压缩列表</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>“ziplist”</td>
</tr>
<tr>
<td>整数集合</td>
<td>REDIS_ENCODING_INTSET</td>
<td>“intset”</td>
</tr>
<tr>
<td>跳跃表和字典</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>“skiplist”</td>
</tr>
</tbody>
</table>
<p>通过 encoding 属性来设定对象所使用的编码， 而不是为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的灵活性和效率， 因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。</p>
<p>举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：</p>
<ul>
<li>因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li>
<li>随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li>
</ul>
<p>其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p>
<p>在接下来的内容中， 我们将分别介绍 Redis 中的五种不同类型的对象， 说明这些对象底层所使用的编码方式， 列出对象从一种编码转换成另一种编码所需的条件， 以及同一个命令在多种不同编码上的实现方法。</p>
<h1 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h1><p>字符串对象的编码可以是 int 、 raw 或者 embstr 。</p>
<p>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。</p>
<p>举个例子， 如果我们执行以下 SET 命令， 那么服务器将创建一个如图 8-1 所示的 int 编码的字符串对象作为 number 键的值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SET number 10086</span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING number</span></div><div class="line">"int"</div></pre></td></tr></table></figure></p>
<p><a href="http://idiotsky.me/images1/redis-object-1.png"><img src="http://idiotsky.me/images1/redis-object-1.png" alt=""></a><br>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。</p>
<p>举个例子， 如果我们执行以下命令， 那么服务器将创建一个如图 8-2 所示的 raw 编码的字符串对象作为 story 键的值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SET story <span class="string">"Long, long, long ago there lived a king ..."</span></span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> STRLEN story</span></div><div class="line">(integer) 43</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING story</span></div><div class="line">"raw"</div></pre></td></tr></table></figure></p>
<p><a href="http://idiotsky.me/images1/redis-object-2.png"><img src="http://idiotsky.me/images1/redis-object-2.png" alt=""></a><br>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</p>
<p>embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构， 如图 8-3 所示。<br><a href="http://idiotsky.me/images1/redis-object-3.png"><img src="http://idiotsky.me/images1/redis-object-3.png" alt=""></a><br>embstr 编码的字符串对象在执行命令时， 产生的效果和 raw 编码的字符串对象执行命令时产生的效果是相同的， 但使用 embstr 编码的字符串对象来保存短字符串值有以下好处：</p>
<p>embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。<br>释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。<br>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势。<br>作为例子， 以下命令创建了一个 embstr 编码的字符串对象作为 msg 键的值， 值对象的样子如图 8-4 所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello"</span></span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING msg</span></div><div class="line">"embstr"</div></pre></td></tr></table></figure></p>
<p><a href="http://idiotsky.me/images1/redis-object-4.png"><img src="http://idiotsky.me/images1/redis-object-4.png" alt=""></a><br>最后要说的是， 可以用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。</p>
<p>举个例子， 执行以下代码将创建一个包含 3.14 的字符串表示 “3.14” 的字符串对象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SET pi 3.14</span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING pi</span></div><div class="line">"embstr"</div></pre></td></tr></table></figure></p>
<p>在有需要的时候， 程序会将保存在字符串对象里面的字符串值转换回浮点数值， 执行某些操作， 然后再将执行操作所得的浮点数值转换回字符串值， 并继续保存在字符串对象里面。</p>
<p>举个例子， 如果我们执行以下代码的话：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> INCRBYFLOAT pi 2.0</span></div><div class="line">"5.14"</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING pi</span></div><div class="line">"embstr"</div></pre></td></tr></table></figure></p>
<p>那么程序首先会取出字符串对象里面保存的字符串值 “3.14” ， 将它转换回浮点数值 3.14 ， 然后把 3.14 和 2.0 相加得出的值 5.14 转换成字符串 “5.14” ， 并将这个 “5.14” 保存到字符串对象里面。</p>
<p>表 8-6 总结并列出了字符串对象保存各种不同类型的值所使用的编码方式。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>可以用 long 类型保存的整数。</td>
<td>int</td>
</tr>
<tr>
<td>可以用 long double 类型保存的浮点数。</td>
<td>embstr 或者 raw</td>
</tr>
<tr>
<td>字符串值， 或者因为长度太大而没办法用 long 类型表示的整数， 又或者因为长度太大而没办法用 long double 类型表示的浮点数。</td>
<td>embstr 或者 raw</td>
</tr>
</tbody>
</table>
<h2 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。</p>
<p>对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。</p>
<p>在下面的示例中， 我们通过 APPEND 命令， 向一个保存整数值的字符串对象追加了一个字符串值， 因为追加操作只能对字符串值执行， 所以程序会先将之前保存的整数值 10086 转换为字符串值 “10086” ， 然后再执行追加操作， 操作的执行结果就是一个 raw 编码的、保存了字符串值的字符串对象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SET number 10086</span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING number</span></div><div class="line">"int"</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> APPEND number <span class="string">" is a good number!"</span></span></div><div class="line">(integer) 23</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> GET number</span></div><div class="line">"10086 is a good number!"</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING number</span></div><div class="line">"raw"</div></pre></td></tr></table></figure></p>
<p>另外， 因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</p>
<p>以下代码展示了一个 embstr 编码的字符串对象在执行 APPEND 命令之后， 对象的编码从 embstr 变为 raw 的例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello world"</span></span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING msg</span></div><div class="line">"embstr"</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> APPEND msg <span class="string">" again!"</span></span></div><div class="line">(integer) 18</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING msg</span></div><div class="line">"raw"</div></pre></td></tr></table></figure></p>
<h1 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h1><p>列表对象的编码可以是 ziplist 或者 linkedlist 。</p>
<p>ziplist 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素。</p>
<p>举个例子， 如果我们执行以下 RPUSH 命令， 那么服务器将创建一个列表对象作为 numbers 键的值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH numbers 1 <span class="string">"three"</span> 5</span></div><div class="line">(integer) 3</div></pre></td></tr></table></figure></p>
<p>如果 numbers 键的值对象使用的是 ziplist 编码， 这个这个值对象将会是图 8-5 所展示的样子。<br><a href="http://idiotsky.me/images1/redis-object-5.png"><img src="http://idiotsky.me/images1/redis-object-5.png" alt=""></a><br>另一方面， linkedlist 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素。</p>
<p>举个例子， 如果前面所说的 numbers 键创建的列表对象使用的不是 ziplist 编码， 而是 linkedlist 编码， 那么 numbers 键的值对象将是图 8-6 所示的样子。<br><a href="http://idiotsky.me/images1/redis-object-6.png"><img src="http://idiotsky.me/images1/redis-object-6.png" alt=""></a><br>注意， linkedlist 编码的列表对象在底层的双端链表结构中包含了多个字符串对象， 这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现， 字符串对象是 Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。</p>
<h2 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h2><p>当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li>
<li>列表对象保存的元素数量小于 512 个；</li>
</ol>
<p>不能满足这两个条件的列表对象需要使用 linkedlist 编码。</p>
<blockquote>
<p><strong>注意</strong><br>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 list-max-ziplist-value 选项和 list-max-ziplist-entries 选项的说明。</p>
</blockquote>
<p>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面， 对象的编码也会从 ziplist 变为 linkedlist 。</p>
<p>以下代码展示了列表对象因为保存了长度太大的元素而进行编码转换的情况：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 所有元素的长度都小于 64 字节</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH blah <span class="string">"hello"</span> <span class="string">"world"</span> <span class="string">"again"</span></span></div><div class="line">(integer) 3</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING blah</span></div><div class="line">"ziplist"</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 将一个 65 字节长的元素推入列表对象中</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH blah <span class="string">"wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww"</span></span></div><div class="line">(integer) 4</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 编码已改变</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING blah</span></div><div class="line">"linkedlist"</div></pre></td></tr></table></figure></p>
<p>除此之外， 以下代码展示了列表对象因为保存的元素数量过多而进行编码转换的情况：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 列表对象包含 512 个元素</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> EVAL <span class="string">"for i=1,512 do redis.call('RPUSH', KEYS[1], i) end"</span> 1 <span class="string">"integers"</span></span></div><div class="line">(nil)</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> LLEN integers</span></div><div class="line">(integer) 512</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING integers</span></div><div class="line">"ziplist"</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 再向列表对象推入一个新元素，使得对象保存的元素数量达到 513 个</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH integers 513</span></div><div class="line">(integer) 513</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 编码已改变</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING integers</span></div><div class="line">"linkedlist"</div></pre></td></tr></table></figure></p>
<h1 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h1><p>哈希对象的编码可以是 ziplist 或者 hashtable 。</p>
<p>ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：</p>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li>
</ul>
<p>举个例子， 如果我们执行以下 HSET 命令， 那么服务器将创建一个列表对象作为 profile 键的值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET profile name <span class="string">"Tom"</span></span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> HSET profile age 25</span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> HSET profile career <span class="string">"Programmer"</span></span></div><div class="line">(integer) 1</div></pre></td></tr></table></figure></p>
<p>如果 profile 键的值对象使用的是 ziplist 编码， 那么这个值对象将会是图 8-9 所示的样子， 其中对象所使用的压缩列表如图 8-10 所示。<br><a href="http://idiotsky.me/images1/redis-object-9.png"><img src="http://idiotsky.me/images1/redis-object-9.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-object-10.png"><img src="http://idiotsky.me/images1/redis-object-10.png" alt=""></a></p>
<p>另一方面， hashtable 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ul>
<p>举个例子， 如果前面 profile 键创建的不是 ziplist 编码的哈希对象， 而是 hashtable 编码的哈希对象， 那么这个哈希对象应该会是图 8-11 所示的样子。<br><a href="http://idiotsky.me/images1/redis-object-11.png"><img src="http://idiotsky.me/images1/redis-object-11.png" alt=""></a></p>
<h2 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h2><p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li>
<li>哈希对象保存的键值对数量小于 512 个；</li>
</ol>
<p>不能满足这两个条件的哈希对象需要使用 hashtable 编码。</p>
<blockquote>
<p><strong>注意</strong><br>这两个条件的上限值是可以修改的， 具体请看配置文件中关于 hash-max-ziplist-value 选项和 hash-max-ziplist-entries 选项的说明。</p>
</blockquote>
<p>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面， 对象的编码也会从 ziplist 变为 hashtable 。</p>
<p>以下代码展示了哈希对象因为键值对的键长度太大而引起编码转换的情况：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 哈希对象只包含一个键和值都不超过 64 个字节的键值对</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET book name <span class="string">"Mastering C++ in 21 days"</span></span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING book</span></div><div class="line">"ziplist"</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 向哈希对象添加一个新的键值对，键的长度为 66 字节</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET book long_long_long_long_long_long_long_long_long_long_long_description <span class="string">"content"</span></span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 编码已改变</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING book</span></div><div class="line">"hashtable"</div></pre></td></tr></table></figure></p>
<p>除了键的长度太大会引起编码转换之外， 值的长度太大也会引起编码转换， 以下代码展示了这种情况的一个示例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 哈希对象只包含一个键和值都不超过 64 个字节的键值对</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET blah greeting <span class="string">"hello world"</span></span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING blah</span></div><div class="line">"ziplist"</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 向哈希对象添加一个新的键值对，值的长度为 68 字节</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET blah story <span class="string">"many string ... many string ... many string ... many string ... many"</span></span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 编码已改变</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING blah</span></div><div class="line">"hashtable"</div></pre></td></tr></table></figure></p>
<p>最后， 以下代码展示了哈希对象因为包含的键值对数量过多而引起编码转换的情况：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 创建一个包含 512 个键值对的哈希对象</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> EVAL <span class="string">"for i=1, 512 do redis.call('HSET', KEYS[1], i, i) end"</span> 1 <span class="string">"numbers"</span></span></div><div class="line">(nil)</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> HLEN numbers</span></div><div class="line">(integer) 512</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING numbers</span></div><div class="line">"ziplist"</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 再向哈希对象添加一个新的键值对，使得键值对的数量变成 513 个</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> HMSET numbers <span class="string">"key"</span> <span class="string">"value"</span></span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> HLEN numbers</span></div><div class="line">(integer) 513</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 编码改变</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></div><div class="line">"hashtable"</div></pre></td></tr></table></figure></p>
<h1 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h1><p>集合对象的编码可以是 intset 或者 hashtable 。</p>
<p>intset 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。</p>
<p>举个例子， 以下代码将创建一个如图 8-12 所示的 intset 编码集合对象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers 1 3 5</span></div><div class="line">(integer) 3</div></pre></td></tr></table></figure></p>
<p><a href="http://idiotsky.me/images1/redis-object-12.png"><img src="http://idiotsky.me/images1/redis-object-12.png" alt=""></a><br>另一方面， hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 。</p>
<p>举个例子， 以下代码将创建一个如图 8-13 所示的 hashtable 编码集合对象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD fruits <span class="string">"apple"</span> <span class="string">"banana"</span> <span class="string">"cherry"</span></span></div><div class="line">(integer) 3</div></pre></td></tr></table></figure></p>
<p><a href="http://idiotsky.me/images1/redis-object-13.png"><img src="http://idiotsky.me/images1/redis-object-13.png" alt=""></a></p>
<h2 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 512 个；</li>
</ol>
<p>不能满足这两个条件的集合对象需要使用 hashtable 编码。</p>
<blockquote>
<p><strong>注意</strong><br>第二个条件的上限值是可以修改的， 具体请看配置文件中关于 set-max-intset-entries 选项的说明。</p>
</blockquote>
<p>对于使用 intset 编码的集合对象来说， 当使用 intset 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 intset 变为 hashtable 。</p>
<p>举个例子， 以下代码创建了一个只包含整数元素的集合对象， 该对象的编码为 intset ：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers 1 3 5</span></div><div class="line">(integer) 3</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING numbers</span></div><div class="line">"intset"</div></pre></td></tr></table></figure></p>
<p>不过， 只要我们向这个只包含整数元素的集合对象添加一个字符串元素， 集合对象的编码转移操作就会被执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers <span class="string">"seven"</span></span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING numbers</span></div><div class="line">"hashtable"</div></pre></td></tr></table></figure></p>
<p>除此之外， 如果我们创建一个包含 512 个整数元素的集合对象， 那么对象的编码应该会是 intset ：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> EVAL <span class="string">"for i=1, 512 do redis.call('SADD', KEYS[1], i) end"</span> 1 integers</span></div><div class="line">(nil)</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> SCARD integers</span></div><div class="line">(integer) 512</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING integers</span></div><div class="line">"intset"</div></pre></td></tr></table></figure></p>
<p>但是， 只要我们再向集合添加一个新的整数元素， 使得这个集合的元素数量变成 513 ， 那么对象的编码转换操作就会被执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD integers 10086</span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> SCARD integers</span></div><div class="line">(integer) 513</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING integers</span></div><div class="line">"hashtable"</div></pre></td></tr></table></figure></p>
<h1 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h1><p>有序集合的编码可以是 ziplist 或者 skiplist 。</p>
<p>ziplist 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。</p>
<p>举个例子， 如果我们执行以下 ZADD 命令， 那么服务器将创建一个有序集合对象作为 price 键的值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD price 8.5 apple 5.0 banana 6.0 cherry</span></div><div class="line">(integer) 3</div></pre></td></tr></table></figure></p>
<p>如果 price 键的值对象使用的是 ziplist 编码， 那么这个值对象将会是图 8-14 所示的样子， 而对象所使用的压缩列表则会是 8-15 所示的样子。<br><a href="http://idiotsky.me/images1/redis-object-14.png"><img src="http://idiotsky.me/images1/redis-object-14.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-object-15.png"><img src="http://idiotsky.me/images1/redis-object-15.png" alt=""></a><br>skiplist 编码的有序集合对象使用 zset 结构作为底层实现， 一个 zset 结构同时包含一个字典和一个跳跃表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></div><div class="line"></div><div class="line">    zskiplist *zsl;</div><div class="line"></div><div class="line">    dict *dict;</div><div class="line"></div><div class="line">&#125; zset;</div></pre></td></tr></table></figure></p>
<p>zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 object 属性保存了元素的成员， 而跳跃表节点的 score 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。</p>
<p>除此之外， zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。</p>
<p>有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 double 类型的浮点数。 值得一提的是， 虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</p>
<blockquote>
<p><strong>为什么有序集合需要同时使用跳跃表和字典来实现？</strong><br>在理论上来说， 有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现， 但无论单独使用字典还是跳跃表， 在性能上对比起同时使用字典和跳跃表都会有所降低。</p>
<p>举个例子， 如果我们只使用字典来实现有序集合， 那么虽然以 O(1) 复杂度查找成员的分值这一特性会被保留， 但是， 因为字典以无序的方式来保存集合元素， 所以每次在执行范围型操作 —— 比如 ZRANK 、 ZRANGE 等命令时， 程序都需要对字典保存的所有元素进行排序， 完成这种排序需要至少 O(N \log N) 时间复杂度， 以及额外的 O(N) 内存空间 （因为要创建一个数组来保存排序后的元素）。</p>
<p>另一方面， 如果我们只使用跳跃表来实现有序集合， 那么跳跃表执行范围型操作的所有优点都会被保留， 但因为没有了字典， 所以根据成员查找分值这一操作的复杂度将从 O(1) 上升为 O(\log N) 。</p>
<p>因为以上原因， 为了让有序集合的查找和范围型操作都尽可能快地执行， Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</p>
</blockquote>
<p>举个例子， 如果前面 price 键创建的不是 ziplist 编码的有序集合对象， 而是 skiplist 编码的有序集合对象， 那么这个有序集合对象将会是图 8-16 所示的样子， 而对象所使用的 zset 结构将会是图 8-17 所示的样子。<br><a href="http://idiotsky.me/images1/redis-object-16.png"><img src="http://idiotsky.me/images1/redis-object-16.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-object-17.png"><img src="http://idiotsky.me/images1/redis-object-17.png" alt=""></a></p>
<blockquote>
<p><strong>注意</strong><br>为了展示方便， 图 8-17 在字典和跳跃表中重复展示了各个元素的成员和分值， 但在实际中， 字典和跳跃表会共享元素的成员和分值， 所以并不会造成任何数据重复， 也不会因此而浪费任何内存。</p>
</blockquote>
<h2 id="编码的转换-2"><a href="#编码的转换-2" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码：</p>
<ol>
<li>有序集合保存的元素数量小于 128 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 64 字节；</li>
</ol>
<p>不能满足以上两个条件的有序集合对象将使用 skiplist 编码。</p>
<blockquote>
<p><strong>注意</strong><br>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 zset-max-ziplist-entries 选项和 zset-max-ziplist-value 选项的说明。</p>
</blockquote>
<p>对于使用 ziplist 编码的有序集合对象来说， 当使用 ziplist 编码所需的两个条件中的任意一个不能被满足时， 程序就会执行编码转换操作， 将原本储存在压缩列表里面的所有集合元素转移到 zset 结构里面， 并将对象的编码从 ziplist 改为 skiplist 。</p>
<p>以下代码展示了有序集合对象因为包含了过多元素而引发编码转换的情况：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 对象包含了 128 个元素</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> EVAL <span class="string">"for i=1, 128 do redis.call('ZADD', KEYS[1], i, i) end"</span> 1 numbers</span></div><div class="line">(nil)</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> ZCARD numbers</span></div><div class="line">(integer) 128</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING numbers</span></div><div class="line">"ziplist"</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 再添加一个新元素</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD numbers 3.14 pi</span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 对象包含的元素数量变为 129 个</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> ZCARD numbers</span></div><div class="line">(integer) 129</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 编码已改变</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></div><div class="line">"skiplist"</div></pre></td></tr></table></figure></p>
<p>以下代码则展示了有序集合对象因为元素的成员过长而引发编码转换的情况：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 向有序集合添加一个成员只有三字节长的元素</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD blah 1.0 www</span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING blah</span></div><div class="line">"ziplist"</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 向有序集合添加一个成员为 66 字节长的元素</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD blah 2.0 oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo</span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 编码已改变</span></div><div class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING blah</span></div><div class="line">"skiplist"</div></pre></td></tr></table></figure></p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>Redis 数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
</ul>
<p>参考 <a href="http://redisbook.com" target="_blank" rel="external">http://redisbook.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在前面的数个章节里， 我们陆续介绍了 Redis 用到的所有主要数据结构， 比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合， 等等。&lt;/p&gt;
&lt;p&gt;Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。&lt;/p&gt;
&lt;p&gt;通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 使用对象的另一个好处是， 我们可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。&lt;/p&gt;
&lt;p&gt;除此之外， Redis 的对象系统还实现了基于引用计数技术的内存回收机制： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放； 另外， Redis 还通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。&lt;/p&gt;
&lt;p&gt;最后， Redis 的对象带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。&lt;/p&gt;
&lt;p&gt;本章接下来将逐一介绍以上提到的 Redis 对象系统的各个特性。&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-压缩列表</title>
    <link href="http://idiotsky.me/2017/09/17/redis-ziplist/"/>
    <id>http://idiotsky.me/2017/09/17/redis-ziplist/</id>
    <published>2017-09-17T14:07:30.000Z</published>
    <updated>2017-09-29T15:15:01.029Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。<br>当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。</p>
</blockquote>
<h1 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h1><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。<br>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。<br>图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。<br><a href="http://idiotsky.me/images1/redis-ziplist-1.png"><img src="http://idiotsky.me/images1/redis-ziplist-1.png" alt=""></a></p>
<p>表 7-1 压缩列表各个组成部分的详细说明</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2 字节</td>
<td>记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td>entryX</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1 字节</td>
<td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>图 7-2 展示了一个压缩列表示例：</p>
<ul>
<li>列表 zlbytes 属性的值为 0x50 （十进制 80）， 表示压缩列表的总长为 80 字节。</li>
<li>列表 zltail 属性的值为 0x3c （十进制 60）， 这表示如果我们有一个指向压缩列表起始地址的指针 p ， 那么只要用指针 p 加上偏移量 60 ， 就可以计算出表尾节点 entry3 的地址。</li>
<li>列表 zllen 属性的值为 0x3 （十进制 3）， 表示压缩列表包含三个节点。</li>
</ul>
<p><a href="http://idiotsky.me/images1/redis-ziplist-2.png"><img src="http://idiotsky.me/images1/redis-ziplist-2.png" alt=""></a><br>图 7-3 展示了另一个压缩列表示例：</p>
<ul>
<li>列表 zlbytes 属性的值为 0xd2 （十进制 210）， 表示压缩列表的总长为 210 字节。</li>
<li>列表 zltail 属性的值为 0xb3 （十进制 179）， 这表示如果我们有一个指向压缩列表起始地址的指针 p ， 那么只要用指针 p 加上偏移量 179 ， 就可以计算出表尾节点 entry5 的地址。</li>
<li>列表 zllen 属性的值为 0x5 （十进制 5）， 表示压缩列表包含五个节点。</li>
</ul>
<p><a href="http://idiotsky.me/images1/redis-ziplist-3.png"><img src="http://idiotsky.me/images1/redis-ziplist-3.png" alt=""></a></p>
<h1 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h1><p>每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种：</p>
<ol>
<li>长度小于等于 63 （2^{6}-1）字节的字节数组；</li>
<li>长度小于等于 16383 （2^{14}-1） 字节的字节数组；</li>
<li>长度小于等于 4294967295 （2^{32}-1）字节的字节数组；</li>
</ol>
<p>而整数值则可以是以下六种长度的其中一种：</p>
<ol>
<li>4 位长，介于 0 至 12 之间的无符号整数；</li>
<li>1 字节长的有符号整数；</li>
<li>3 字节长的有符号整数；</li>
<li>int16_t 类型整数；</li>
<li>int32_t 类型整数；</li>
<li>int64_t 类型整数。</li>
</ol>
<p>每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成， 如图 7-4 所示。<br><a href="http://idiotsky.me/images1/redis-ziplist-4.png"><img src="http://idiotsky.me/images1/redis-ziplist-4.png" alt=""></a><br>接下来的内容将分别介绍这三个组成部分。</p>
<h2 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h2><p>节点的 previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。</p>
<p>previous_entry_length 属性的长度可以是 1 字节或者 5 字节：</p>
<ul>
<li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</li>
</ul>
<p>图 7-5 展示了一个包含一字节长 previous_entry_length 属性的压缩列表节点， 属性的值为 0x05 ， 表示前一节点的长度为 5 字节。<br><a href="http://idiotsky.me/images1/redis-ziplist-5.png"><img src="http://idiotsky.me/images1/redis-ziplist-5.png" alt=""></a><br>图 7-6 展示了一个包含五字节长 previous_entry_length 属性的压缩节点， 属性的值为 0xFE00002766 ， 其中值的最高位字节 0xFE 表示这是一个五字节长的 previous_entry_length 属性， 而之后的四字节 0x00002766 （十进制值 10086 ）才是前一节点的实际长度。<br><a href="http://idiotsky.me/images1/redis-ziplist-6.png"><img src="http://idiotsky.me/images1/redis-ziplist-6.png" alt=""></a></p>
<p>因为节点的 previous_entry_length 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。</p>
<p>举个例子， 如果我们有一个指向当前节点起始地址的指针 c ， 那么我们只要用指针 c 减去当前节点 previous_entry_length 属性的值， 就可以得出一个指向前一个节点起始地址的指针 p ， 如图 7-7 所示。<br><a href="http://idiotsky.me/images1/redis-ziplist-7.png"><img src="http://idiotsky.me/images1/redis-ziplist-7.png" alt=""></a></p>
<p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的： 只要我们拥有了一个指向某个节点起始地址的指针， 那么通过这个指针以及这个节点的 previous_entry_length 属性， 程序就可以一直向前一个节点回溯， 最终到达压缩列表的表头节点。</p>
<p>图 7-8 展示了一个从表尾节点向表头节点进行遍历的完整过程：</p>
<ul>
<li>首先，我们拥有指向压缩列表表尾节点 entry4 起始地址的指针 p1 （指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上 zltail 属性的值得出）；</li>
<li>通过用 p1 减去 entry4 节点 previous_entry_length 属性的值， 我们得到一个指向 entry4 前一节点 entry3 起始地址的指针 p2 ；</li>
<li>通过用 p2 减去 entry3 节点 previous_entry_length 属性的值， 我们得到一个指向 entry3 前一节点 entry2 起始地址的指针 p3 ；</li>
<li>通过用 p3 减去 entry2 节点 previous_entry_length 属性的值， 我们得到一个指向 entry2 前一节点 entry1 起始地址的指针 p4 ， entry1 为压缩列表的表头节点；</li>
<li>最终， 我们从表尾节点向表头节点遍历了整个列表。</li>
</ul>
<p><a href="http://idiotsky.me/images1/redis-ziplist-8.png"><img src="http://idiotsky.me/images1/redis-ziplist-8.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-9.png"><img src="http://idiotsky.me/images1/redis-ziplist-9.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-10.png"><img src="http://idiotsky.me/images1/redis-ziplist-10.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-11.png"><img src="http://idiotsky.me/images1/redis-ziplist-11.png" alt=""></a></p>
<h2 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h2><p>节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度：</p>
<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</li>
<li>一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</li>
</ul>
<p>表 7-2 记录了所有可用的字节数组编码， 而表 7-3 则记录了所有可用的整数编码。 表格中的下划线 _ 表示留空， 而 b 、 x 等变量则代表实际的二进制数据， 为了方便阅读， 多个字节之间用空格隔开。</p>
<p>表 7-2 字节数组编码</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content 属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>00bbbbbb</td>
<td>1 字节</td>
<td>长度小于等于 63 字节的字节数组。</td>
</tr>
<tr>
<td>01bbbbbb xxxxxxxx</td>
<td>2 字节</td>
<td>长度小于等于 16383 字节的字节数组。</td>
</tr>
<tr>
<td>10<strong>__</strong> aaaaaaaa bbbbbbbb cccccccc dddddddd</td>
<td>5 字节</td>
<td>长度小于等于 4294967295 的字节数组。</td>
</tr>
</tbody>
</table>
<p>表 7-3 整数编码</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content 属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>11000000</td>
<td>1 字节</td>
<td>int16_t 类型的整数。</td>
</tr>
<tr>
<td>11010000</td>
<td>1 字节</td>
<td>int32_t 类型的整数。</td>
</tr>
<tr>
<td>11100000</td>
<td>1 字节</td>
<td>int64_t 类型的整数。</td>
</tr>
<tr>
<td>11110000</td>
<td>1 字节</td>
<td>24 位有符号整数。</td>
</tr>
<tr>
<td>11111110</td>
<td>1 字节</td>
<td>8 位有符号整数。</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1 字节</td>
<td>使用这一编码的节点没有相应的 content 属性， 因为编码本身的 xxxx 四个位已经保存了一个介于 0 和 12 之间的值， 所以它无须 content 属性。</td>
</tr>
</tbody>
</table>
<h2 id="content"><a href="#content" class="headerlink" title="content"></a>content</h2><p>节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定。</p>
<p>图 7-9 展示了一个保存字节数组的节点示例：</p>
<ul>
<li>编码的最高两位 00 表示节点保存的是一个字节数组；</li>
<li>编码的后六位 001011 记录了字节数组的长度 11 ；</li>
<li>content 属性保存着节点的值 “hello world” 。</li>
</ul>
<p><a href="http://idiotsky.me/images1/redis-ziplist-12.png"><img src="http://idiotsky.me/images1/redis-ziplist-12.png" alt=""></a></p>
<p>图 7-10 展示了一个保存整数值的节点示例：</p>
<ul>
<li>编码 11000000 表示节点保存的是一个 int16_t 类型的整数值；</li>
<li>content 属性保存着节点的值 10086 。</li>
</ul>
<p><a href="http://idiotsky.me/images1/redis-ziplist-13.png"><img src="http://idiotsky.me/images1/redis-ziplist-13.png" alt=""></a></p>
<h1 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h1><p>前面说过， 每个节点的 previous_entry_length 属性都记录了前一个节点的长度：</p>
<ul>
<li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性需要用 1 字节长的空间来保存这个长度值。</li>
<li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性需要用 5 字节长的空间来保存这个长度值。</li>
</ul>
<p>现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 250 字节到 253 字节之间的节点 e1 至 eN ， 如图 7-11 所示。<br><a href="http://idiotsky.me/images1/redis-ziplist-14.png"><img src="http://idiotsky.me/images1/redis-ziplist-14.png" alt=""></a><br>因为 e1 至 eN 的所有节点的长度都小于 254 字节， 所以记录这些节点的长度只需要 1 字节长的 previous_entry_length 属性， 换句话说， e1 至 eN 的所有节点的 previous_entry_length 属性都是 1 字节长的。</p>
<p>这时， 如果我们将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的表头节点， 那么 new 将成为 e1 的前置节点， 如图 7-12 所示。<br><a href="http://idiotsky.me/images1/redis-ziplist-15.png"><img src="http://idiotsky.me/images1/redis-ziplist-15.png" alt=""></a></p>
<p>因为 e1 的 previous_entry_length 属性仅长 1 字节， 它没办法保存新节点 new 的长度， 所以程序将对压缩列表执行空间重分配操作， 并将 e1 节点的 previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长。</p>
<p>现在， 麻烦的事情来了 —— e1 原本的长度介于 250 字节至 253 字节之间， 在为 previous_entry_length 属性新增四个字节的空间之后， e1 的长度就变成了介于 254 字节至 257 字节之间， 而这种长度使用 1 字节长的 previous_entry_length 属性是没办法保存的。</p>
<p>因此， 为了让 e2 的 previous_entry_length 属性可以记录下 e1 的长度， 程序需要再次对压缩列表执行空间重分配操作， 并将 e2 节点的 previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长。</p>
<p>正如扩展 e1 引发了对 e2 的扩展一样， 扩展 e2 也会引发对 e3 的扩展， 而扩展 e3 又会引发对 e4 的扩展……为了让每个节点的 previous_entry_length 属性都符合压缩列表对节点的要求， 程序需要不断地对压缩列表执行空间重分配操作， 直到 eN 为止。</p>
<p>Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）， 图 7-13 展示了这一过程。<br><a href="http://idiotsky.me/images1/redis-ziplist-16.png"><img src="http://idiotsky.me/images1/redis-ziplist-16.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-17.png"><img src="http://idiotsky.me/images1/redis-ziplist-17.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-18.png"><img src="http://idiotsky.me/images1/redis-ziplist-18.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-19.png"><img src="http://idiotsky.me/images1/redis-ziplist-19.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-20.png"><img src="http://idiotsky.me/images1/redis-ziplist-20.png" alt=""></a></p>
<p>除了添加新节点可能会引发连锁更新之外， 删除节点也可能会引发连锁更新。</p>
<p>考虑图 7-14 所示的压缩列表， 如果 e1 至 eN 都是大小介于 250 字节至 253 字节的节点， big 节点的长度大于等于 254 字节（需要 5 字节的 previous_entry_length 来保存）， 而 small 节点的长度小于 254 字节（只需要 1 字节的 previous_entry_length 来保存）， 那么当我们将 small 节点从压缩列表中删除之后， 为了让 e1 的 previous_entry_length 属性可以记录 big 节点的长度， 程序将扩展 e1 的空间， 并由此引发之后的连锁更新。<br><a href="http://idiotsky.me/images1/redis-ziplist-21.png"><img src="http://idiotsky.me/images1/redis-ziplist-21.png" alt=""></a><br>因为连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2) 。</p>
<p>要注意的是， 尽管连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的：</p>
<ul>
<li>首先， 压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；</li>
<li>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；</li>
</ul>
<p>因为以上原因， ziplistPush 等命令的平均复杂度仅为 O(N) ， 在实际中， 我们可以放心地使用这些函数， 而不必担心连锁更新会影响压缩列表的性能。</p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li>
<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>
<li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li>
<li>添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。</li>
</ul>
<p>参考 <a href="http://redisbook.com" target="_blank" rel="external">http://redisbook.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;压缩列表（ziplist）是列表键和哈希键的底层实现之一。&lt;br&gt;当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;压缩列表的构成&quot;&gt;&lt;a href=&quot;#压缩列表的构成&quot; class=&quot;headerlink&quot; title=&quot;压缩列表的构成&quot;&gt;&lt;/a&gt;压缩列表的构成&lt;/h1&gt;&lt;p&gt;压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。&lt;br&gt;一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。&lt;br&gt;图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images1/redis-ziplist-1.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images1/redis-ziplist-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表 7-1 压缩列表各个组成部分的详细说明&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;长度&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;zlbytes&lt;/td&gt;
&lt;td&gt;uint32_t&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zltail&lt;/td&gt;
&lt;td&gt;uint32_t&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zllen&lt;/td&gt;
&lt;td&gt;uint16_t&lt;/td&gt;
&lt;td&gt;2 字节&lt;/td&gt;
&lt;td&gt;记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;entryX&lt;/td&gt;
&lt;td&gt;列表节点&lt;/td&gt;
&lt;td&gt;不定&lt;/td&gt;
&lt;td&gt;压缩列表包含的各个节点，节点的长度由节点保存的内容决定。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zlend&lt;/td&gt;
&lt;td&gt;uint8_t&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
      <category term="压缩列表" scheme="http://idiotsky.me/tags/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-整数集合</title>
    <link href="http://idiotsky.me/2017/09/17/redis-intset/"/>
    <id>http://idiotsky.me/2017/09/17/redis-intset/</id>
    <published>2017-09-17T04:07:30.000Z</published>
    <updated>2017-09-24T06:34:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
</blockquote>
<h1 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h1><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。</p>
<p>每个 intset.h/intset 结构表示一个整数集合：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 编码方式</span></div><div class="line">    <span class="keyword">uint32_t</span> encoding;</div><div class="line"></div><div class="line">    <span class="comment">// 集合包含的元素数量</span></div><div class="line">    <span class="keyword">uint32_t</span> length;</div><div class="line"></div><div class="line">    <span class="comment">// 保存元素的数组</span></div><div class="line">    <span class="keyword">int8_t</span> contents[];</div><div class="line"></div><div class="line">&#125; intset;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
<p>length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。</p>
<p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：</p>
<ul>
<li>如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。</li>
<li>如果 encoding 属性的值为 INTSET_ENC_INT32 ， 那么 contents 就是一个 int32_t 类型的数组， 数组里的每个项都是一个 int32_t 类型的整数值 （最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。</li>
<li>如果 encoding 属性的值为 INTSET_ENC_INT64 ， 那么 contents 就是一个 int64_t 类型的数组， 数组里的每个项都是一个 int64_t 类型的整数值 （最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）。</li>
</ul>
<p>图 6-1 展示了一个整数集合示例：<br>encoding 属性的值为 INTSET_ENC_INT16 ， 表示整数集合的底层实现为 int16_t 类型的数组， 而集合保存的都是 int16_t 类型的整数值。<br>length 属性的值为 5 ， 表示整数集合包含五个元素。<br>contents 数组按从小到大的顺序保存着集合中的五个元素。<br>因为每个集合元素都是 int16_t 类型的整数值， 所以 contents 数组的大小等于 sizeof(int16_t) <em> 5 = 16 </em> 5 = 80 位。<br><a href="http://idiotsky.me/images/redis-intset-1.png"><img src="http://idiotsky.me/images/redis-intset-1.png" alt=""></a><br>图 6-2 展示了另一个整数集合示例：<br>encoding 属性的值为 INTSET_ENC_INT64 ， 表示整数集合的底层实现为 int64_t 类型的数组， 而数组中保存的都是 int64_t 类型的整数值。<br>length 属性的值为 4 ， 表示整数集合包含四个元素。<br>contents 数组按从小到大的顺序保存着集合中的四个元素。<br>因为每个集合元素都是 int64_t 类型的整数值， 所以 contents 数组的大小为 sizeof(int64_t) <em> 4 = 64 </em> 4 = 256 位。<br><a href="http://idiotsky.me/images/redis-intset-2.png"><img src="http://idiotsky.me/images/redis-intset-2.png" alt=""></a><br>虽然 contents 数组保存的四个整数值中， 只有 -2675256175807981027 是真正需要用 int64_t 类型来保存的， 而其他的 1 、 3 、 5 三个值都可以用 int16_t 类型来保存， 不过根据整数集合的升级规则， 当向一个底层为 int16_t 数组的整数集合添加一个 int64_t 类型的整数值时， 整数集合已有的所有元素都会被转换成 int64_t 类型， 所以 contents 数组保存的四个整数值都是 int64_t 类型的， 不仅仅是 -2675256175807981027 。</p>
<h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ol>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<p>举个例子， 假设现在有一个 INTSET_ENC_INT16 编码的整数集合， 集合中包含三个 int16_t 类型的元素， 如图 6-3 所示。<br><a href="http://idiotsky.me/images/redis-intset-3.png"><img src="http://idiotsky.me/images/redis-intset-3.png" alt=""></a><br>因为每个元素都占用 16 位空间， 所以整数集合底层数组的大小为 3 * 16 = 48 位， 图 6-4 展示了整数集合的三个元素在这 48 位里的位置。<br><a href="http://idiotsky.me/images/redis-intset-4.png"><img src="http://idiotsky.me/images/redis-intset-4.png" alt=""></a><br>现在， 假设我们要将类型为 int32_t 的整数值 65535 添加到整数集合里面， 因为 65535 的类型 int32_t 比整数集合当前所有元素的类型都要长， 所以在将 65535 添加到整数集合之前， 程序需要先对整数集合进行升级。</p>
<p>升级首先要做的是， 根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配。</p>
<p>整数集合目前有三个元素， 再加上新元素 65535 ， 整数集合需要分配四个元素的空间， 因为每个 int32_t 整数值需要占用 32 位空间， 所以在空间重分配之后， 底层数组的大小将是 32 * 4 = 128 位， 如图 6-5 所示。<br><a href="http://idiotsky.me/images/redis-intset-5.png"><img src="http://idiotsky.me/images/redis-intset-5.png" alt=""></a><br>虽然程序对底层数组进行了空间重分配， 但数组原有的三个元素 1 、 2 、 3 仍然是 int16_t 类型， 这些元素还保存在数组的前 48 位里面， 所以程序接下来要做的就是将这三个元素转换成 int32_t 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。</p>
<p>首先， 因为元素 3 在 1 、 2 、 3 、 65535 四个元素中排名第三， 所以它将被移动到 contents 数组的索引 2 位置上， 也即是数组 64 位至 95 位的空间内， 如图 6-6 所示。<br><a href="http://idiotsky.me/images/redis-intset-6.png"><img src="http://idiotsky.me/images/redis-intset-6.png" alt=""></a><br>接着， 因为元素 2 在 1 、 2 、 3 、 65535 四个元素中排名第二， 所以它将被移动到 contents 数组的索引 1 位置上， 也即是数组的 32 位至 63 位的空间内， 如图 6-7 所示。<br><a href="http://idiotsky.me/images/redis-intset-7.png"><img src="http://idiotsky.me/images/redis-intset-7.png" alt=""></a><br>之后， 因为元素 1 在 1 、 2 、 3 、 65535 四个元素中排名第一， 所以它将被移动到 contents 数组的索引 0 位置上， 也即是数组的 0 位至 31 位的空间内， 如图 6-8 所示。<br><a href="http://idiotsky.me/images/redis-intset-8.png"><img src="http://idiotsky.me/images/redis-intset-8.png" alt=""></a><br>然后， 因为元素 65535 在 1 、 2 、 3 、 65535 四个元素中排名第四， 所以它将被添加到 contents 数组的索引 3 位置上， 也即是数组的 96 位至 127 位的空间内， 如图 6-9 所示。<br><a href="http://idiotsky.me/images/redis-intset-9.png"><img src="http://idiotsky.me/images/redis-intset-9.png" alt=""></a><br>最后， 程序将整数集合 encoding 属性的值从 INTSET_ENC_INT16 改为 INTSET_ENC_INT32 ， 并将 length 属性的值从 3 改为 4 ， 设置完成之后的整数集合如图 6-10 所示。<br><a href="http://idiotsky.me/images/redis-intset-10.png"><img src="http://idiotsky.me/images/redis-intset-10.png" alt=""></a><br>因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。</p>
<p>其他类型的升级操作， 比如从 INTSET_ENC_INT16 编码升级为 INTSET_ENC_INT64 编码， 或者从 INTSET_ENC_INT32 编码升级为 INTSET_ENC_INT64 编码， 升级的过程都和上面展示的升级过程类似。</p>
<blockquote>
<p>升级之后新元素的摆放位置<br>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：</p>
<ul>
<li>在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 0 ）；</li>
<li>在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 length-1 ）。</li>
</ul>
</blockquote>
<h1 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h1><p>整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。</p>
<h2 id="提升灵活性"><a href="#提升灵活性" class="headerlink" title="提升灵活性"></a>提升灵活性</h2><p>因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。</p>
<p>比如说， 我们一般只使用 int16_t 类型的数组来保存 int16_t 类型的值， 只使用 int32_t 类型的数组来保存 int32_t 类型的值， 诸如此类。</p>
<p>但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 int16_t 、 int32_t 或者 int64_t 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</p>
<h2 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h2><p>当然， 要让一个数组可以同时保存 int16_t 、 int32_t 、 int64_t 三种类型的值， 最简单的做法就是直接使用 int64_t 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 int16_t 类型或者 int32_t 类型的值， 数组都需要使用 int64_t 类型的空间去保存它们， 从而出现浪费内存的情况。</p>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<p>比如说， 如果我们一直只向整数集合添加 int16_t 类型的值， 那么整数集合的底层实现就会一直是 int16_t 类型的数组， 只有在我们要将 int32_t 类型或者 int64_t 类型的值添加到集合时， 程序才会对数组进行升级。</p>
<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<p>举个例子， 对于图 6-11 所示的整数集合来说， 即使我们将集合里唯一一个真正需要使用 int64_t 类型来保存的元素 4294967295 删除了， 整数集合的编码仍然会维持 INTSET_ENC_INT64 ， 底层数组也仍然会是 int64_t 类型的， 如图 6-12 所示。<br><a href="http://idiotsky.me/images/redis-intset-11.png"><img src="http://idiotsky.me/images/redis-intset-11.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-intset-12.png"><img src="http://idiotsky.me/images/redis-intset-12.png" alt=""></a></p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>整数集合是集合键的底层实现之一。</li>
<li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作， 不支持降级操作。</li>
</ul>
<p>参考 <a href="http://redisbook.com" target="_blank" rel="external">http://redisbook.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;整数集合的实现&quot;&gt;&lt;a href=&quot;#整数集合的实现&quot; class=&quot;headerlink&quot; title=&quot;整数集合的实现&quot;&gt;&lt;/a&gt;整数集合的实现&lt;/h1&gt;&lt;p&gt;整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。&lt;/p&gt;
&lt;p&gt;每个 intset.h/intset 结构表示一个整数集合：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;intset&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 编码方式&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; encoding;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 集合包含的元素数量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保存元素的数组&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int8_t&lt;/span&gt; contents[];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; intset;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
      <category term="整数集合" scheme="http://idiotsky.me/tags/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-跳跃表</title>
    <link href="http://idiotsky.me/2017/09/16/redis-skiplist/"/>
    <id>http://idiotsky.me/2017/09/16/redis-skiplist/</id>
    <published>2017-09-16T04:07:30.000Z</published>
    <updated>2017-09-24T06:26:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下， 跳跃表的效率可以和平衡树相媲美， 并且因为跳跃表的实现比平衡树要来得更为简单， 所以有不少程序都使用跳跃表来代替平衡树。<br>Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多， 又或者有序集合中元素的成员（member）是比较长的字符串时， Redis 就会使用跳跃表来作为有序集合键的底层实现。</p>
</blockquote>
<h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h1><p>Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。<br><a href="http://idiotsky.me/images/redis-skiplist.png"><img src="http://idiotsky.me/images/redis-skiplist.png" alt=""></a><br>图 5-1 展示了一个跳跃表示例， 位于图片最左边的是 zskiplist 结构， 该结构包含以下属性：</p>
<ul>
<li>header ：指向跳跃表的表头节点。</li>
<li>tail ：指向跳跃表的表尾节点。</li>
<li>level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li>length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li>
</ul>
<p>位于 zskiplist 结构右方的是四个 zskiplistNode 结构， 该结构包含以下属性：</p>
<ul>
<li>层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。</li>
</ul>
<p>注意表头节点和其他节点的构造是一样的： 表头节点也有后退指针、分值和成员对象， 不过表头节点的这些属性都不会被用到， 所以图中省略了这些部分， 只显示了表头节点的各个层。</p>
<p>本节接下来的内容将对 zskiplistNode 和 zskiplist 两个结构进行更详细的介绍。<br><a id="more"></a></p>
<h1 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h1><p>跳跃表节点的实现由 redis.h/zskiplistNode 结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 后退指针</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 分值</span></div><div class="line">    <span class="keyword">double</span> score;</div><div class="line"></div><div class="line">    <span class="comment">// 成员对象</span></div><div class="line">    robj *obj;</div><div class="line"></div><div class="line">    <span class="comment">// 层</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></div><div class="line"></div><div class="line">        <span class="comment">// 前进指针</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></div><div class="line"></div><div class="line">        <span class="comment">// 跨度</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</div><div class="line"></div><div class="line">    &#125; level[];</div><div class="line"></div><div class="line">&#125; zskiplistNode;</div></pre></td></tr></table></figure></p>
<h2 id="层"><a href="#层" class="headerlink" title="层"></a>层</h2><p>跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。</p>
<p>图 5-2 分别展示了三个高度为 1 层、 3 层和 5 层的节点， 因为 C 语言的数组索引总是从 0 开始的， 所以节点的第一层是 level[0] ， 而第二层是 level[1] ， 以此类推。<br><a href="http://idiotsky.me/images/redis-skiplist-1.png"><img src="http://idiotsky.me/images/redis-skiplist-1.png" alt=""></a></p>
<h2 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h2><p>每个层都有一个指向表尾方向的前进指针（level[i].forward 属性）， 用于从表头向表尾方向访问节点。</p>
<p>图 5-3 用虚线表示出了程序从表头向表尾方向， 遍历跳跃表中所有节点的路径：</p>
<ol>
<li>迭代程序首先访问跳跃表的第一个节点（表头）， 然后从第四层的前进指针移动到表中的第二个节点。</li>
<li>在第二个节点时， 程序沿着第二层的前进指针移动到表中的第三个节点。</li>
<li>在第三个节点时， 程序同样沿着第二层的前进指针移动到表中的第四个节点。</li>
<li>当程序再次沿着第四个节点的前进指针移动时， 它碰到一个 NULL ， 程序知道这时已经到达了跳跃表的表尾， 于是结束这次遍历。</li>
</ol>
<p><a href="http://idiotsky.me/images/redis-skiplist-2.png"><img src="http://idiotsky.me/images/redis-skiplist-2.png" alt=""></a></p>
<h2 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h2><p>层的跨度（level[i].span 属性）用于记录两个节点之间的距离：</p>
<ul>
<li>两个节点之间的跨度越大， 它们相距得就越远。</li>
<li>指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。</li>
</ul>
<p>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p>
<p>举个例子， 图 5-4 用虚线标记了在跳跃表中查找分值为 3.0 、 成员对象为 o3 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 3 ， 所以目标节点在跳跃表中的排位为 3 。<br><a href="http://idiotsky.me/images/redis-skiplist-3.png"><img src="http://idiotsky.me/images/redis-skiplist-3.png" alt=""></a><br>再举个例子， 图 5-5 用虚线标记了在跳跃表中查找分值为 2.0 、 成员对象为 o2 的节点时， 沿途经历的层： 在查找节点的过程中， 程序经过了两个跨度为 1 的节点， 因此可以计算出， 目标节点在跳跃表中的排位为 2 。<br><a href="http://idiotsky.me/images/redis-skiplist-4.png"><img src="http://idiotsky.me/images/redis-skiplist-4.png" alt=""></a></p>
<h2 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h2><p>节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p>
<p>图 5-6 用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点： 程序首先通过跳跃表的 tail 指针访问表尾节点， 然后通过后退指针访问倒数第二个节点， 之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 NULL 的后退指针， 于是访问结束。<br><a href="http://idiotsky.me/images/redis-skiplist-5.png"><img src="http://idiotsky.me/images/redis-skiplist-5.png" alt=""></a></p>
<h2 id="分值和成员"><a href="#分值和成员" class="headerlink" title="分值和成员"></a>分值和成员</h2><p>节点的分值（score 属性）是一个 double 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p>
<p>节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p>
<p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p>
<p>举个例子， 在图 5-7 所示的跳跃表中， 三个跳跃表节点都保存了相同的分值 10086.0 ， 但保存成员对象 o1 的节点却排在保存成员对象 o2 和 o3 的节点之前， 而保存成员对象 o2 的节点又排在保存成员对象 o3 的节点之前， 由此可见， o1 、 o2 、 o3 三个成员对象在字典中的排序为 o1 &lt;= o2 &lt;= o3 。<br><a href="http://idiotsky.me/images/redis-skiplist-6.png"><img src="http://idiotsky.me/images/redis-skiplist-6.png" alt=""></a></p>
<h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表， 如图 5-8 所示。<br><a href="http://idiotsky.me/images/redis-skiplist-7.png"><img src="http://idiotsky.me/images/redis-skiplist-7.png" alt=""></a><br>但通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息， 如图 5-9 所示。<br><a href="http://idiotsky.me/images/redis-skiplist-8.png"><img src="http://idiotsky.me/images/redis-skiplist-8.png" alt=""></a><br>zskiplist 结构的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 表头节点和表尾节点</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 表中节点的数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</div><div class="line"></div><div class="line">    <span class="comment">// 表中层数最大的节点的层数</span></div><div class="line">    <span class="keyword">int</span> level;</div><div class="line"></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure></p>
<p>header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</p>
<p>通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。</p>
<p>level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。</p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。</li>
<li>Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成， 其中 zskiplist 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 zskiplistNode 则用于表示跳跃表节点。</li>
<li>每个跳跃表节点的层高都是 1 至 32 之间的随机数。</li>
<li>在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。</li>
<li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li>
</ul>
<p>参考 <a href="http://redisbook.com" target="_blank" rel="external">http://redisbook.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。&lt;/p&gt;
&lt;p&gt;跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。&lt;/p&gt;
&lt;p&gt;在大部分情况下， 跳跃表的效率可以和平衡树相媲美， 并且因为跳跃表的实现比平衡树要来得更为简单， 所以有不少程序都使用跳跃表来代替平衡树。&lt;br&gt;Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多， 又或者有序集合中元素的成员（member）是比较长的字符串时， Redis 就会使用跳跃表来作为有序集合键的底层实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;概括&quot;&gt;&lt;a href=&quot;#概括&quot; class=&quot;headerlink&quot; title=&quot;概括&quot;&gt;&lt;/a&gt;概括&lt;/h1&gt;&lt;p&gt;Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images/redis-skiplist.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images/redis-skiplist.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;图 5-1 展示了一个跳跃表示例， 位于图片最左边的是 zskiplist 结构， 该结构包含以下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;header ：指向跳跃表的表头节点。&lt;/li&gt;
&lt;li&gt;tail ：指向跳跃表的表尾节点。&lt;/li&gt;
&lt;li&gt;level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。&lt;/li&gt;
&lt;li&gt;length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;位于 zskiplist 结构右方的是四个 zskiplistNode 结构， 该结构包含以下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。&lt;/li&gt;
&lt;li&gt;后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。&lt;/li&gt;
&lt;li&gt;分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。&lt;/li&gt;
&lt;li&gt;成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意表头节点和其他节点的构造是一样的： 表头节点也有后退指针、分值和成员对象， 不过表头节点的这些属性都不会被用到， 所以图中省略了这些部分， 只显示了表头节点的各个层。&lt;/p&gt;
&lt;p&gt;本节接下来的内容将对 zskiplistNode 和 zskiplist 两个结构进行更详细的介绍。&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
      <category term="跳跃表" scheme="http://idiotsky.me/tags/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-字典</title>
    <link href="http://idiotsky.me/2017/09/15/redis-dict/"/>
    <id>http://idiotsky.me/2017/09/15/redis-dict/</id>
    <published>2017-09-14T16:59:31.000Z</published>
    <updated>2017-09-24T06:27:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Redis 的数据库就是使用字典来作为底层实现的, 字典还是哈希键的底层实现之一<br>Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。</p>
</blockquote>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 哈希表数组</span></div><div class="line">    dictEntry **table;</div><div class="line"></div><div class="line">    <span class="comment">// 哈希表大小</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</div><div class="line"></div><div class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></div><div class="line">    <span class="comment">// 总是等于 size - 1</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</div><div class="line"></div><div class="line">    <span class="comment">// 该哈希表已有节点的数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</div><div class="line"></div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure></p>
<p>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。<br>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。<br>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。<br>图 4-1 展示了一个大小为 4 的空哈希表 （没有包含任何键值对）。<br><a href="http://idiotsky.me/images/redis-dict-1.png"><img src="http://idiotsky.me/images/redis-dict-1.png" alt=""></a><br><a id="more"></a></p>
<h1 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h1><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 键</span></div><div class="line">    <span class="keyword">void</span> *key;</div><div class="line"></div><div class="line">    <span class="comment">// 值</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">    &#125; v;</div><div class="line"></div><div class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></div><div class="line"></div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure></p>
<p>key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。<br>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。<br>举个例子， 图 4-2 就展示了如何通过 next 指针， 将两个索引值相同的键 k1 和 k0 连接在一起。<br><a href="http://idiotsky.me/images/redis-dict-2.png"><img src="http://idiotsky.me/images/redis-dict-2.png" alt=""></a></p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 类型特定函数</span></div><div class="line">    dictType *type;</div><div class="line"></div><div class="line">    <span class="comment">// 私有数据</span></div><div class="line">    <span class="keyword">void</span> *privdata;</div><div class="line"></div><div class="line">    <span class="comment">// 哈希表</span></div><div class="line">    dictht ht[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="comment">// rehash 索引</span></div><div class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></div><div class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></div><div class="line"></div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<ul>
<li>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>
<li>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 计算哈希值的函数</span></div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 复制键的函数</span></div><div class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</div><div class="line"></div><div class="line">    <span class="comment">// 复制值的函数</span></div><div class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</div><div class="line"></div><div class="line">    <span class="comment">// 对比键的函数</span></div><div class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</div><div class="line"></div><div class="line">    <span class="comment">// 销毁键的函数</span></div><div class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</div><div class="line"></div><div class="line">    <span class="comment">// 销毁值的函数</span></div><div class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</div><div class="line"></div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure>
<p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p>
<p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p>
<p>图 4-3 展示了一个普通状态下（没有进行 rehash）的字典：<br><a href="http://idiotsky.me/images/redis-dict-3.png"><img src="http://idiotsky.me/images/redis-dict-3.png" alt=""></a></p>
<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis 计算哈希值和索引值的方法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用字典设置的哈希函数，计算键 key 的哈希值</span></div><div class="line">hash = dict-&gt;type-&gt;hashFunction(key);</div><div class="line"></div><div class="line"><span class="comment">//使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></div><div class="line"><span class="comment">//根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></div><div class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</div></pre></td></tr></table></figure></p>
<p><a href="http://idiotsky.me/images/redis-dict-4.png"><img src="http://idiotsky.me/images/redis-dict-4.png" alt=""></a><br>举个例子， 对于图 4-4 所示的字典来说， 如果我们要将一个键值对 k0 和 v0 添加到字典里面， 那么程序会先使用语句：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hash = dict-&gt;type-&gt;hashFunction(k0);</div></pre></td></tr></table></figure></p>
<p>计算键 k0 的哈希值。<br>假设计算得出的哈希值为 8 ， 那么程序会继续使用语句：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">index = hash &amp; dict-&gt;ht[<span class="number">0</span>].sizemask = <span class="number">8</span> &amp; <span class="number">3</span> = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>计算出键 k0 的索引值 0 ， 这表示包含键值对 k0 和 v0 的节点应该被放置到哈希表数组的索引 0 位置上， 如图 4-5 所示。<br><a href="http://idiotsky.me/images/redis-dict-5.png"><img src="http://idiotsky.me/images/redis-dict-5.png" alt=""></a><br>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</p>
<p>MurmurHash 算法最初由 Austin Appleby 于 2008 年发明， 这种算法的优点在于， 即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。</p>
<p>MurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <a href="http://code.google.com/p/smhasher/" target="_blank" rel="external">http://code.google.com/p/smhasher/</a> 。</p>
<h1 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h1><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p>举个例子， 假设程序要将键值对 k2 和 v2 添加到图 4-6 所示的哈希表里面， 并且计算得出 k2 的索引值为 2 ， 那么键 k1 和 k2 将产生冲突， 而解决冲突的办法就是使用 next 指针将键 k2 和 k1 所在的节点连接起来， 如图 4-7 所示。<br><a href="http://idiotsky.me/images/redis-dict-6.png"><img src="http://idiotsky.me/images/redis-dict-6.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-7.png"><img src="http://idiotsky.me/images/redis-dict-7.png" alt=""></a><br>因为 dictEntry 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面。</p>
<h1 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h1><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。<br>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li><p>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）：</p>
<ul>
<li>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；</li>
<li>如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</li>
</ul>
</li>
<li><p>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</p>
</li>
<li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<p>举个例子， 假设程序要对图 4-8 所示字典的 ht[0] 进行扩展操作， 那么程序将执行以下步骤：</p>
<ol>
<li>ht[0].used 当前的值为 4 ， 4 * 2 = 8 ， 而 8 （2^3）恰好是第一个大于等于 4 的 2 的 n 次方， 所以程序会将 ht[1] 哈希表的大小设置为 8 。 图 4-9 展示了 ht[1] 在分配空间之后， 字典的样子。</li>
<li>将 ht[0] 包含的四个键值对都 rehash 到 ht[1] ， 如图 4-10 所示。</li>
<li>释放 ht[0] ，并将 ht[1] 设置为 ht[0] ，然后为 ht[1] 分配一个空白哈希表，如图 4-11 所示。</li>
</ol>
<p>至此， 对哈希表的扩展操作执行完毕， 程序成功将哈希表的大小从原来的 4 改为了现在的 8 。<br><a href="http://idiotsky.me/images/redis-dict-8.png"><img src="http://idiotsky.me/images/redis-dict-8.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-9.png"><img src="http://idiotsky.me/images/redis-dict-9.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-10.png"><img src="http://idiotsky.me/images/redis-dict-10.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-11.png"><img src="http://idiotsky.me/images/redis-dict-11.png" alt=""></a></p>
<h1 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h1><p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<ol>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；</li>
</ol>
<p>其中哈希表的负载因子可以通过公式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span></div><div class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</div></pre></td></tr></table></figure></p>
<p>计算得出。</p>
<p>比如说， 对于一个大小为 4 ， 包含 4 个键值对的哈希表来说， 这个哈希表的负载因子为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">load_factor = <span class="number">4</span> / <span class="number">4</span> = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>又比如说， 对于一个大小为 512 ， 包含 256 个键值对的哈希表来说， 这个哈希表的负载因子为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">load_factor = <span class="number">256</span> / <span class="number">512</span> = <span class="number">0.5</span></div></pre></td></tr></table></figure></p>
<p>根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE 命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制（<a href="http://en.wikipedia.org/wiki/Copy-on-write" target="_blank" rel="external">copy-on-write</a>）技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p>
<p>另一方面， 当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作。</p>
<h1 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h1><p>上一节说过， 扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。</p>
<p>这样做的原因在于， 如果 ht[0] 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1] ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。<br>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</li>
</ol>
<p>图 4-12 至图 4-17 展示了一次完整的渐进式 rehash 过程， 注意观察在整个 rehash 过程中， 字典的 rehashidx 属性是如何变化的。<br><a href="http://idiotsky.me/images/redis-dict-12.png"><img src="http://idiotsky.me/images/redis-dict-12.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-13.png"><img src="http://idiotsky.me/images/redis-dict-13.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-14.png"><img src="http://idiotsky.me/images/redis-dict-14.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-15.png"><img src="http://idiotsky.me/images/redis-dict-15.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-16.png"><img src="http://idiotsky.me/images/redis-dict-16.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-17.png"><img src="http://idiotsky.me/images/redis-dict-17.png" alt=""></a></p>
<h1 id="渐进式-rehash-执行期间的哈希表操作"><a href="#渐进式-rehash-执行期间的哈希表操作" class="headerlink" title="渐进式 rehash 执行期间的哈希表操作"></a>渐进式 rehash 执行期间的哈希表操作</h1><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。</li>
<li>Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用。</li>
<li>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</li>
<li>哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。</li>
<li>在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。</li>
</ul>
<p>参考 <a href="http://redisbook.com" target="_blank" rel="external">http://redisbook.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Redis 的数据库就是使用字典来作为底层实现的, 字典还是哈希键的底层实现之一&lt;br&gt;Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h1&gt;&lt;p&gt;Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dictht&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 哈希表数组&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dictEntry **table;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 哈希表大小&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; size;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 哈希表大小掩码，用于计算索引值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 总是等于 size - 1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; sizemask;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 该哈希表已有节点的数量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; used;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; dictht;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。&lt;br&gt;size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。&lt;br&gt;sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。&lt;br&gt;图 4-1 展示了一个大小为 4 的空哈希表 （没有包含任何键值对）。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images/redis-dict-1.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images/redis-dict-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
      <category term="hashtable" scheme="http://idiotsky.me/tags/hashtable/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-链表</title>
    <link href="http://idiotsky.me/2017/09/14/redis-linkedlist/"/>
    <id>http://idiotsky.me/2017/09/14/redis-linkedlist/</id>
    <published>2017-09-14T15:59:31.000Z</published>
    <updated>2017-09-24T06:30:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>列表键的底层就是一个链表</p>
</blockquote>
<h1 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h1><p>每个链表节点使用一个 adlist.h/listNode 结构来表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 前置节点</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 后置节点</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 节点的值</span></div><div class="line">    <span class="keyword">void</span> *value;</div><div class="line"></div><div class="line">&#125; listNode;</div></pre></td></tr></table></figure></p>
<p>多个 listNode 可以通过 prev 和 next 指针组成双端链表， 如图 3-1 所示。<br><a href="http://idiotsky.me/images/redis-linkedlist-1.png"><img src="http://idiotsky.me/images/redis-linkedlist-1.png" alt=""></a><br><a id="more"></a></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>虽然仅仅使用多个 listNode 结构就可以组成链表， 但使用 adlist.h/list 来持有链表的话， 操作起来会更方便：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 表头节点</span></div><div class="line">    listNode *head;</div><div class="line"></div><div class="line">    <span class="comment">// 表尾节点</span></div><div class="line">    listNode *tail;</div><div class="line"></div><div class="line">    <span class="comment">// 链表所包含的节点数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</div><div class="line"></div><div class="line">    <span class="comment">// 节点值复制函数</span></div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</div><div class="line"></div><div class="line">    <span class="comment">// 节点值释放函数</span></div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</div><div class="line"></div><div class="line">    <span class="comment">// 节点值对比函数</span></div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</div><div class="line"></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure></p>
<p>list 结构为链表提供了表头指针 head 、表尾指针 tail ， 以及链表长度计数器 len ， 而 dup 、 free 和 match 成员则是用于实现多态链表所需的类型特定函数：</p>
<ul>
<li>dup 函数用于复制链表节点所保存的值；</li>
<li>free 函数用于释放链表节点所保存的值；</li>
<li>match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li>
</ul>
<p>图 3-2 是由一个 list 结构和三个 listNode 结构组成的链表：<br><a href="http://idiotsky.me/images/redis-linkedlist-2.png"><img src="http://idiotsky.me/images/redis-linkedlist-2.png" alt=""></a></p>
<p>Redis 的链表实现的特性可以总结如下：</p>
<ul>
<li>双端： 链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。</li>
<li>无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点。</li>
<li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</li>
<li>带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。</li>
<li>多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。</li>
</ul>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。</li>
<li>每个链表节点由一个 listNode 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。</li>
<li>每个链表使用一个 list 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。</li>
<li>因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL ， 所以 Redis 的链表实现是无环链表。</li>
<li>通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。</li>
</ul>
<p>参考 <a href="http://redisbook.com" target="_blank" rel="external">http://redisbook.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;列表键的底层就是一个链表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;链表节点&quot;&gt;&lt;a href=&quot;#链表节点&quot; class=&quot;headerlink&quot; title=&quot;链表节点&quot;&gt;&lt;/a&gt;链表节点&lt;/h1&gt;&lt;p&gt;每个链表节点使用一个 adlist.h/listNode 结构来表示：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;listNode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 前置节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;listNode&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;prev&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 后置节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;listNode&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;next&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 节点的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; listNode;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;多个 listNode 可以通过 prev 和 next 指针组成双端链表， 如图 3-1 所示。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images/redis-linkedlist-1.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images/redis-linkedlist-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
      <category term="链表" scheme="http://idiotsky.me/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM杂谈之JIT</title>
    <link href="http://idiotsky.me/2017/09/14/java-jit/"/>
    <id>http://idiotsky.me/2017/09/14/java-jit/</id>
    <published>2017-09-14T14:41:24.000Z</published>
    <updated>2017-09-19T17:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Just-In-Time"><a href="#Just-In-Time" class="headerlink" title="Just In Time"></a>Just In Time</h1><p>Just in time编译，也叫做运行时编译，不同于 C / C++ 语言直接被翻译成机器指令，javac把java的源文件翻译成了class文件，而class文件中全都是Java字节码。那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。</p>
<p>还有一种，就是把这些Java字节码重新编译优化，生成机器码，让CPU直接执行。这样编出来的代码效率会更高。通常，我们不必把所有的Java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。这种调用最频繁的Java方法就是我们常说的热点方法（Hotspot，说不定这个虚拟机的名字就是从这里来的）。</p>
<p>这种在运行时按需编译的方式就是Just In Time。<br><a id="more"></a></p>
<h1 id="主要技术点"><a href="#主要技术点" class="headerlink" title="主要技术点"></a>主要技术点</h1><p>其实JIT的主要技术点，从大的框架上来说，非常简单，就是申请一块既有写权限又有执行权限的内存，然后把你要编译的Java方法，翻译成机器码，写入到这块内存里。当再需要调用原来的Java方法时，就转向调用这块内存。</p>
<p>我们看一个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, inc(<span class="number">3</span>));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个例子很简单，就是把3加1，然后打印出来，我们通过以下命令，查看一下它的机器码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># gcc -o inc inc.c</div><div class="line"># objdump -d inc</div></pre></td></tr></table></figure></p>
<p>然后在这一堆输出中，可以找到 inc 方法最终被翻译成了这样的机器码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">40052d:	55                   	push   %rbp</div><div class="line">40052e:	48 89 e5             	mov    %rsp,%rbp</div><div class="line">400531:	89 7d fc             	mov    %edi,-0x4(%rbp)</div><div class="line">400534:	8b 45 fc             	mov    -0x4(%rbp),%eax</div><div class="line">400537:	83 c0 01             	add    $0x1,%eax</div><div class="line">40053a:	5d                   	pop    %rbp</div><div class="line">40053b:	c3                   	retq</div></pre></td></tr></table></figure></p>
<p>我来解释一下（读者需要一定的x86汇编语言的知识）。</p>
<p>第一句，保存上一个栈帧的基址，并把当前的栈指针赋给栈基址寄存器，这是进入一个函数的常规操作。我们不去管它。</p>
<p>第三句，把edi存到栈上。在x64处理器上，前6个参数都是使用寄存器传参的。第一个参数会使用rdi，第二个参数使用 rsi，等等。所以 edi 里存的其实就是第一个参数，也就是整数 3，为什么使用rdi的低32位，也就是 edi 呢？因为我们的入参 a 是 int 型啊。大家可以换成 long 型看看效果。</p>
<p>第四句，把上一步存到栈上的那个整数再存进 eax 中。</p>
<p>第五句往后，把 eax 加上 1， 然后就退栈，返回。按照x64的规定（ABI），返回值通过eax传递。</p>
<p>我们看到了，其实第三句，第四句好像根本没有存在的必要，gcc 默认情况下，生成的机器码有点傻，它总要把入参放到栈上，但其实，我们是可以直接把参数从 rdi 中放入到 rax 中的。不满意。那我们可以自己改一下，让它更精简一点。怎么做呢？答案就是运行时修改 inc 的逻辑。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* inc_func)</span><span class="params">(<span class="keyword">int</span> a)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> code[] = &#123; </div><div class="line">        <span class="number">0x55</span>,             <span class="comment">// push rbp</span></div><div class="line">        <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe5</span>, <span class="comment">// mov rsp, rbp</span></div><div class="line">        <span class="number">0x89</span>, <span class="number">0xf8</span>,       <span class="comment">// mov edi, eax</span></div><div class="line">        <span class="number">0x83</span>, <span class="number">0xc0</span>, <span class="number">0x01</span>, <span class="comment">// add $1, eax</span></div><div class="line">        <span class="number">0x5d</span>,             <span class="comment">// pop rbp</span></div><div class="line">        <span class="number">0xc3</span>              <span class="comment">// ret</span></div><div class="line">    &#125;;  </div><div class="line"></div><div class="line">    <span class="keyword">void</span> * temp = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(code), PROT_WRITE | PROT_EXEC,</div><div class="line">            MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>); </div><div class="line"></div><div class="line">    <span class="built_in">memcpy</span>(temp, code, <span class="keyword">sizeof</span>(code));</div><div class="line">    inc_func p_inc = (inc_func)temp;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p_inc(<span class="number">7</span>));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，我们使用了 mmap 来申请了一块有写权限和执行权限的内存，然后把我们手写的机器码拷进去，然后使用一个函数指针指向这块内存，并且调用它。通过这种方式我们就可以执行这一段手写的机器码了。</p>
<p>运行一下看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># gcc -o inc_a inc_a.c </div><div class="line"># ./inc_a</div><div class="line">8</div></pre></td></tr></table></figure></p>
<p>再回想一下这个过程。我们通过手写机器码把原来的 inc 函数代替掉了。在新的例子中，我们是使用程序中定义的数据来重新造了一个 inc 函数。这种在运行的过程创建新的函数的方式，就是JIT的核心操作。</p>
<h1 id="解释器，C1和C2"><a href="#解释器，C1和C2" class="headerlink" title="解释器，C1和C2"></a>解释器，C1和C2</h1><p>在Hotspot中，解释器是为每一个字节码生成一小段机器码，在执行Java方法的过程中，每次取一条指令，然后就去执行这一个指令所对应的那一段机器码。256条指令，就组成了一个表，在这个表里，每一条指令都对应一段机器码，当执行到某一条指令时，就从这个表里去查这段机器码，并且通过 jmp 指令去执行这段机器码就行了。</p>
<p>这种方式被称为模板解释器。</p>
<p>模板解释器生成的代码有很多冗余，就像我们上面的第一个例子那样。为了生成更精简的机器码，我们可以引入编译器优化手段，例如全局值编码，死代码消除，标量展开，公共子表达式消除，常量传播等等。这样生成出来的机器码会更加优化。</p>
<p>但是，生成机器码的质量越高，所需要的时间也就越长。JIT线程也是要挤占Java 应用线程的资源的。所以C1是一个折衷，编译时间既不会太长，生成的机器码的指令也不是最优化的，但肯定比解释器的效率要高很多。</p>
<p>如果一个Java方法调用得足够频繁，那就更值得花大力气去为它生成更优质的机器码，这时就会触发C2编译，c2是一个运行得更慢，但却能生成更高效代码的编译器。</p>
<p>由此，我们看到，其实Java的运行，几乎全部都依赖运行时生成的机器码上。所以，对于文章开头的那个问题“Java是运行在C++上的吗？”，大家应该都有自己的答案了。这个问题无法简单地回答是或者不是，正确答案就是Java的运行依赖模板解释器和JIT编译器。</p>
<h1 id="多说一点优化"><a href="#多说一点优化" class="headerlink" title="多说一点优化"></a>多说一点优化</h1><p>我们这节课所举的例子中，可以做更多的优化，例如，既然我进到inc函数以后，完全没有使用栈，那其实，我就不要再为它开辟栈帧了。所以可以把push rbp, pop rbp的逻辑都去掉。</p>
<p>进一步优化成这样：<br>inc_b.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> code[] = &#123; </div><div class="line">    <span class="number">0x89</span>, <span class="number">0xf8</span>,       <span class="comment">// mov edi, eax</span></div><div class="line">    <span class="number">0x83</span>, <span class="number">0xc0</span>, <span class="number">0x01</span>, <span class="comment">// add $1, eax</span></div><div class="line">    <span class="number">0xc3</span>              <span class="comment">// ret</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以看到，指令更加精简了。我们重新编译运行，还是能成功打印出8。</p>
<p>根据这个问题：<a href="https://www.zhihu.com/question/61724266" target="_blank" rel="external">为什么 lea 会被用来计算？</a></p>
<p>我们还可以写出更优化的代码来：<br>inc_c.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> code[] = &#123; </div><div class="line">    <span class="number">0x8d</span>, <span class="number">0x47</span>, <span class="number">0x01</span>,    <span class="comment">// lea 0x1(rdi), rax</span></div><div class="line">    <span class="number">0xc3</span>                 <span class="comment">// ret</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果开启 gcc 的优化编译，我们也可以得到这样的代码，例如，还是针对这个方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 -O2 优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># gcc -o inc inc.c -O2</div><div class="line"># objdump -d inc</div></pre></td></tr></table></figure></p>
<p>就可以看到，inc 的机器码变成这样了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">00000000004005f0 &lt;inc&gt;:</div><div class="line">  4005f0:	8d 47 01             	lea    0x1(%rdi),%eax</div><div class="line">  4005f3:	c3                   	retq</div></pre></td></tr></table></figure></p>
<p>这和我们手写的优化的机器码是完全一样的了。</p>
<p>实际上，C1和C2所要做的和gcc的优化编译是一样的，就是使用特定的方法生成更高效的机器码。但是从原理上来说，运行时生成机器码这个技术，大家都是相通的。</p>
<p>代码<a href="https://github.com/ejunjsh/c-code/tree/master/inc" target="_blank" rel="external">https://github.com/ejunjsh/c-code/tree/master/inc</a><br>参考<a href="https://zhuanlan.zhihu.com/p/28476709" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/28476709</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Just-In-Time&quot;&gt;&lt;a href=&quot;#Just-In-Time&quot; class=&quot;headerlink&quot; title=&quot;Just In Time&quot;&gt;&lt;/a&gt;Just In Time&lt;/h1&gt;&lt;p&gt;Just in time编译，也叫做运行时编译，不同于 C / C++ 语言直接被翻译成机器指令，javac把java的源文件翻译成了class文件，而class文件中全都是Java字节码。那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。&lt;/p&gt;
&lt;p&gt;还有一种，就是把这些Java字节码重新编译优化，生成机器码，让CPU直接执行。这样编出来的代码效率会更高。通常，我们不必把所有的Java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。这种调用最频繁的Java方法就是我们常说的热点方法（Hotspot，说不定这个虚拟机的名字就是从这里来的）。&lt;/p&gt;
&lt;p&gt;这种在运行时按需编译的方式就是Just In Time。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="jvm" scheme="http://idiotsky.me/tags/jvm/"/>
    
      <category term="jit" scheme="http://idiotsky.me/tags/jit/"/>
    
  </entry>
  
</feed>
