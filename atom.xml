<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IdiotSky</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://idiotsky.me/"/>
  <updated>2017-08-27T06:32:14.000Z</updated>
  <id>http://idiotsky.me/</id>
  
  <author>
    <name>ejunjsh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript是如何工作的(二)</title>
    <link href="http://idiotsky.me/2017/08/26/javascript-how-work-2/"/>
    <id>http://idiotsky.me/2017/08/26/javascript-how-work-2/</id>
    <published>2017-08-26T03:08:09.000Z</published>
    <updated>2017-08-27T06:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>几个星期前，我们开始了一个系列，目标是深入理解javascript和它怎么工作的：通过这些我们可以更容易的写出好代码和apps。</p>
</blockquote>
<p><a href="/2017/08/26/javascript-how-work">系列的第一篇</a>主要是提供一个关于引擎，运行时和调用栈的概括。这篇文章将深入到Google V8 javascript 引擎。同时，还提供一些快速的意见令你能够写出好的javascript代码。<br><a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>一个javascript引擎是一个解释器也是个程序，它执行javascript代码。它可以被实现为一个标准解释器，也可以是一个即时（just-in-time）的编译器（以不同形式编译javascript成字节码）<br>下面是一个流行的javascript引擎的列表：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/V8_%28JavaScript_engine%29" target="_blank" rel="external">V8</a> — 谷歌开源的, 用 C++写的。</li>
<li><a href="https://en.wikipedia.org/wiki/Rhino_%28JavaScript_engine%29" target="_blank" rel="external">Rhino</a> — 由Mozilla基金会管理,开源的, 完全用java写的。</li>
<li><a href="https://en.wikipedia.org/wiki/SpiderMonkey_%28JavaScript_engine%29" target="_blank" rel="external">SpiderMonkey</a> — 第一个javascript引擎 Netscape Navigator开发,现在Firefox维护。</li>
<li><a href="https://en.wikipedia.org/wiki/JavaScriptCore" target="_blank" rel="external">JavaScriptCore</a> — 开源，由Apple开发 ，Safari浏览器的引擎。</li>
<li><a href="https://en.wikipedia.org/wiki/KJS_%28KDE%29" target="_blank" rel="external">KJS</a> — KDE的引擎，由 Harri Porten开发，是Konqueror桌面系统的浏览器引擎。</li>
<li><a href="https://en.wikipedia.org/wiki/Chakra_%28JScript_engine%29" target="_blank" rel="external">Chakra (JScript9)</a> — IE的</li>
<li><a href="https://en.wikipedia.org/wiki/Chakra_%28JavaScript_engine%29" target="_blank" rel="external">Chakra (JavaScript)</a> — 微软Edge</li>
<li><a href="https://en.wikipedia.org/wiki/Nashorn_%28JavaScript_engine%29" target="_blank" rel="external">Nashorn</a> -  OpenJDK的开源一部分, 由Oracle Java 语言和工具组开发</li>
<li><a href="https://en.wikipedia.org/wiki/JerryScript" target="_blank" rel="external">JerryScript</a> — 一个轻量级引擎.</li>
</ul>
<h1 id="为什么要创造一个V8引擎？"><a href="#为什么要创造一个V8引擎？" class="headerlink" title="为什么要创造一个V8引擎？"></a>为什么要创造一个V8引擎？</h1><p>V8引擎由Google创建并开源，c++编写。用于Google的Chrome浏览器。不像其他引擎，V8还是流行的Node.js的运行时引擎。<br><a href="/images/js-how-work-2-1.png"><img src="/images/js-how-work-2-1.png" alt=""></a><br>V8是第一个为了性能提升的浏览器引擎。为了达到更好的性能，相比于使用解释器，V8更倾向于使用编译器编译javascript代码成更高效的机器码。它像其他现代化javascript引擎如SpiderMonkey或者Rhino (Mozilla)一样，使用<strong>JIT(Just-In-Time)</strong>编译器在执行阶段编译代码，唯一不同的是，V8不会生成字节码或任意中间代码。</p>
<h1 id="V8曾经有两个编译器"><a href="#V8曾经有两个编译器" class="headerlink" title="V8曾经有两个编译器"></a>V8曾经有两个编译器</h1><p>在5.9版本发布（今年早些时候）之前，V8曾经有两个编译器：</p>
<ul>
<li>full-codegen — 一个简单快速的编译器，用来生成简单，相对慢的机器码。</li>
<li>Crankshaft - 一个更复杂(Just-In-Time) 优化的编译，用来生成更优的机器码。</li>
</ul>
<p>V8引擎内部也用了一些线程：</p>
<ul>
<li>正如你想的，主线程就是拿到代码，编译代码和执行代码。</li>
<li>还有些线程用来编译和优化代码，协助主线程，让主线程继续执行代码。</li>
<li>一个剖析器线程用来汇报哪些方法需要Crankshaft编译器优化。</li>
<li>其他一些线程用来做垃圾回收</li>
</ul>
<p>当开始执行javascript代码，V8运用<strong>full-codegen</strong>来直接翻译解析过的javascript代码为机器码，这个过程没有任何中间转换，所以执行机器码<strong>非常快</strong>.由于没有用到任何中间的字节码，所以就没有需要解释器的必要了。</p>
<p>当你的代码运行一段时间后，剖析器线程就能收集到足够的数据来确定哪些方法应该被优化。</p>
<p>接下来，<strong>Crankshaft</strong> 优化编译器开始运行在其他线程。它翻译javascript抽象语法树到一个高级别的<a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="external">静态单赋值(SSA)</a> 形态,又叫<strong>Hydrogen(氢？)</strong>。然后优化这个Hydrogen图。大部分的优化都在这个层次上完成。</p>
<h1 id="内联（inlining）"><a href="#内联（inlining）" class="headerlink" title="内联（inlining）"></a>内联（inlining）</h1><p>首个优化方法就是内联，它会提前尽可能的内联更多的代码。内联是一个替换代码的一个过程，用方法体替换到调用的地方（其实就是方法展开）。这样一步简单的优化可以令接下来的优化更有意义。<br><a href="/images/js-how-work-2-2.png"><img src="/images/js-how-work-2-2.png" alt=""></a></p>
<blockquote>
<p>to be continue…</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;几个星期前，我们开始了一个系列，目标是深入理解javascript和它怎么工作的：通过这些我们可以更容易的写出好代码和apps。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/2017/08/26/javascript-how-work&quot;&gt;系列的第一篇&lt;/a&gt;主要是提供一个关于引擎，运行时和调用栈的概括。这篇文章将深入到Google V8 javascript 引擎。同时，还提供一些快速的意见令你能够写出好的javascript代码。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://idiotsky.me/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://idiotsky.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript是如何工作的(一)</title>
    <link href="http://idiotsky.me/2017/08/26/javascript-how-work/"/>
    <id>http://idiotsky.me/2017/08/26/javascript-how-work/</id>
    <published>2017-08-25T17:17:54.000Z</published>
    <updated>2017-08-26T06:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>简评</strong>：JavaScript 是越来越受欢迎了，很多团队都在采用这些语言工作。前端、后端、嵌入式设备等等，都可以看见它的身影。虽然我们知其然，但又知其所以然吗？</p>
</blockquote>
<a id="more"></a>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>大家应该都知道 JavaScript 是单线程的，以及听过 V8 引擎的概念。<br>这篇文章将会介绍这些概念，并解释 JavaScript 是如何运行的。通过了解这些细节，开发者能更好地编写代码，正确利用其提供的 API。</p>
<h1 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h1><p>比较流行的一个 JavaScript 引擎示例就是 Google 的 V8 引擎。下图是 V8 引擎在 Chrome 和 Node.js 中使用的一个简化视图：<br><a href="/images/js-how-work.png"><img src="/images/js-how-work.png" alt=""></a></p>
<p>引擎主要由两个组件组成：</p>
<ul>
<li>内存堆（Memory Heap ）：这是内存分配的地方</li>
<li>调用堆栈（Call Stack）：这是程序运行时函数的调用过程</li>
</ul>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>在浏览器中，例如「setTimeout」这样的 API 已经有很多开发者在用了，然后引擎并没有提供这些 API，所以它们从哪里来的呢？<br>实际情况是这样的：<br><a href="/images/js-how-work-1.png"><img src="/images/js-how-work-1.png" alt=""></a><br>所以，除了引擎之外，还有浏览器提供的 Web API（像 DOM、AJAX、setTimeout 等等）。另外，还有事件循环（event loop）和回调队列（callback queue）。</p>
<h1 id="调用堆栈（Call-Stack）"><a href="#调用堆栈（Call-Stack）" class="headerlink" title="调用堆栈（Call Stack）"></a>调用堆栈（Call Stack）</h1><p>JavaScript 是单线程语言，这意味着它只有一个单一的调用堆栈。因此，它每次只能做一件事。</p>
<p>调用堆栈是一个数据结构，按调用顺序保存所有在运行期被调用的方法。既然是个栈，那么它就满足先入后出的特性。</p>
<p>我们来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * y;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> s = multiply(x, x);</div><div class="line">    <span class="built_in">console</span>.log(s);</div><div class="line">&#125;</div><div class="line">printSquare(<span class="number">5</span>);</div></pre></td></tr></table></figure></p>
<p>当引擎开始执行这段代码时，调用堆栈将为空。然后，就会有以下步骤：<br><a href="/images/js-how-work-2.png"><img src="/images/js-how-work-2.png" alt=""></a></p>
<p>调用堆栈中的每个条目称为堆栈帧（Stack Frame）。当异常发生时，它基本上是调用堆栈的状态。再看看下面这段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'SessionStack will help you resolve crashes :)'</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    foo();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    bar();</div><div class="line">&#125;</div><div class="line">start();</div></pre></td></tr></table></figure></p>
<p>如果这是在 Chrome 中执行（假设此代码位于一个名为 foo.js 的文件中），则会产生这种情况：<br><a href="/images/js-how-work-3.png"><img src="/images/js-how-work-3.png" alt=""></a></p>
<p>当你达到最大调用堆栈时，会容易发生这种情况，特别是在没有测试代码时随意使用递归。<br>看看这个示例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    foo();</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p>
<p>代码执行时，首先调用函数「foo」。然而，这是递归函数，调用自身的同时又没有设置终止条件，所以每一次执行，相同的函数都会被添加进堆栈中，看起来就是这样：<br><a href="/images/js-how-work-4.png"><img src="/images/js-how-work-4.png" alt=""></a><br>某些时候，调用堆栈中的函数调用次数超过了调用堆栈的实际大小，那么浏览器就会抛出一个错误，看起来像这样：<br><a href="/images/js-how-work-5.png"><img src="/images/js-how-work-5.png" alt=""></a><br>单线程上编写代码相对多线程来说会简单得多，你不必考虑死锁这样的复杂场景。但单线程也有许多限制，由于 JavaScript 有调用堆栈，当执行代码需要耗费大量时间时是怎样的呢？</p>
<h1 id="并发和事件循环"><a href="#并发和事件循环" class="headerlink" title="并发和事件循环"></a>并发和事件循环</h1><p>当你在调用堆栈中进行函数调用，有时候需要大量时间才能进行处理。例如在浏览器中使用JavaScript 进行一些复杂的图像转换。在这个过程中又发生了什么？<br>这个问题的产生是因为，虽然调用堆栈具有执行的功能，但浏览器本身是无法渲染也不能运行其他任何代码，它被卡住了。当你想执行一套流畅的 UI 时，就会产生这样的问题。大多数浏览器通过抛出异常处理错误，询问用户是否要终止网页：<br><a href="/images/js-how-work-6.jpg"><img src="/images/js-how-work-6.jpg" alt=""></a><br>这个用户体验很糟糕。那么如何解决呢？答案是异步回调（asynchronous callbacks）。这是后话，下次再讲。</p>
<p>翻译和参考 <a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="external">https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;简评&lt;/strong&gt;：JavaScript 是越来越受欢迎了，很多团队都在采用这些语言工作。前端、后端、嵌入式设备等等，都可以看见它的身影。虽然我们知其然，但又知其所以然吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://idiotsky.me/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://idiotsky.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>openstack安装准备(一)</title>
    <link href="http://idiotsky.me/2017/08/18/openstack-install-prepare-1/"/>
    <id>http://idiotsky.me/2017/08/18/openstack-install-prepare-1/</id>
    <published>2017-08-18T14:50:07.000Z</published>
    <updated>2017-08-27T07:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备VMware"><a href="#准备VMware" class="headerlink" title="准备VMware"></a>准备VMware</h1><p>由于我是习惯了mac上做实验，所以用VMware fusion，随便下个破解版即可。</p>
<h1 id="准备Ubuntu"><a href="#准备Ubuntu" class="headerlink" title="准备Ubuntu"></a>准备Ubuntu</h1><p>Ubuntu去官网下载16.04的服务器版本的ISO即可。</p>
<a id="more"></a>
<h1 id="准备网络"><a href="#准备网络" class="headerlink" title="准备网络"></a>准备网络</h1><p>这次实验用到两台虚拟机： controller,compute</p>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/hostname</div><div class="line">controller</div><div class="line"></div><div class="line">$ cat /etc/hosts</div><div class="line">127.0.0.1	localhost</div><div class="line">192.168.199.11  compute</div><div class="line">192.168.199.10  controller</div><div class="line"></div><div class="line">$ cat /etc/network/interfaces</div><div class="line"><span class="comment"># The loopback network interface</span></div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"><span class="comment"># The primary network interface</span></div><div class="line">auto ens33</div><div class="line">iface ens33 inet static</div><div class="line">address 192.168.199.10</div><div class="line">netmask 255.255.255.0</div><div class="line">gateway 192.168.199.1</div><div class="line">dns-nameservers 192.168.199.1</div><div class="line"></div><div class="line">auto ens34</div><div class="line">iface ens34 inet static</div><div class="line">address 10.170.56.10</div><div class="line">netmask 255.255.255.0</div><div class="line"></div><div class="line">auto ens35</div><div class="line">iface ens35 inet manual</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>接口</th>
<th>ip</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>ens33</td>
<td>192.168.199.10</td>
<td>桥接</td>
</tr>
<tr>
<td>ens34</td>
<td>10.170.56.10</td>
<td>私有</td>
</tr>
<tr>
<td>ens35</td>
<td>网关192.168.112.2</td>
<td>nat</td>
</tr>
</tbody>
</table>
<h2 id="compute"><a href="#compute" class="headerlink" title="compute"></a>compute</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/hostname</div><div class="line">compute</div><div class="line"></div><div class="line">$ cat /etc/hosts</div><div class="line">127.0.0.1	localhost</div><div class="line">192.168.199.11  compute</div><div class="line">192.168.199.10  controller</div><div class="line"></div><div class="line">$ cat /etc/network/interfaces</div><div class="line"><span class="comment"># The loopback network interface</span></div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"><span class="comment"># The primary network interface</span></div><div class="line">auto ens33</div><div class="line">iface ens33 inet static</div><div class="line">address 192.168.199.11</div><div class="line">netmask 255.255.255.0</div><div class="line">gateway 192.168.199.1</div><div class="line">dns-nameservers 192.168.199.1</div><div class="line"></div><div class="line">auto ens34</div><div class="line">iface ens34 inet static</div><div class="line">address 10.170.56.11</div><div class="line">netmask 255.255.255.0</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>接口</th>
<th>ip</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>ens33</td>
<td>192.168.199.11</td>
<td>桥接</td>
</tr>
<tr>
<td>ens34</td>
<td>10.170.56.11</td>
<td>私有</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>PS:</p>
<ul>
<li>桥接模式是虚拟机可以更物理机所在网络共享一套网络，例如跟物理机同一个WiFi里面的设备都可以访问物理机里面的虚拟机。一般用来做管理节点的网络。</li>
<li>私有模式代表虚拟机只能跟物理机作为一个网络，其他设备访问不了，一般可以用来做内部网络</li>
<li>nat模式用来给虚拟机访问互联网用</li>
</ul>
<p>PSPS:<br>接下来会在上面的两台虚拟机安装openstack，安装完openstack后，两台虚拟机对于openstack来说，就是物理机，通过openstack，创建的就是云主机（或者叫租户）了。所以必须要谨记这点。</p>
<p>PSPSPS:</p>
<ul>
<li>桥接模式的ip必须是你电脑所在网络的任意不冲突的同子网的ip</li>
<li>私有模式的ip可以任意一个子网下的ip，这个网络是用来做租户网络的</li>
<li>nat网络不用配ip，这个给租户用来访问外网的，接下来实验会再提及，注意下他的网关即可，它是你的VMware的nat的一个网关。</li>
</ul>
<p>上面网络配置好后，可以开搞了，至于怎么安装虚拟机和配置网络，可以搜索相关文章😈。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备VMware&quot;&gt;&lt;a href=&quot;#准备VMware&quot; class=&quot;headerlink&quot; title=&quot;准备VMware&quot;&gt;&lt;/a&gt;准备VMware&lt;/h1&gt;&lt;p&gt;由于我是习惯了mac上做实验，所以用VMware fusion，随便下个破解版即可。&lt;/p&gt;
&lt;h1 id=&quot;准备Ubuntu&quot;&gt;&lt;a href=&quot;#准备Ubuntu&quot; class=&quot;headerlink&quot; title=&quot;准备Ubuntu&quot;&gt;&lt;/a&gt;准备Ubuntu&lt;/h1&gt;&lt;p&gt;Ubuntu去官网下载16.04的服务器版本的ISO即可。&lt;/p&gt;
    
    </summary>
    
      <category term="openstack" scheme="http://idiotsky.me/categories/openstack/"/>
    
    
      <category term="openstack" scheme="http://idiotsky.me/tags/openstack/"/>
    
      <category term="ubuntu" scheme="http://idiotsky.me/tags/ubuntu/"/>
    
      <category term="kvm" scheme="http://idiotsky.me/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>一张图了解三色标记法</title>
    <link href="http://idiotsky.me/2017/08/16/gc-three-color/"/>
    <id>http://idiotsky.me/2017/08/16/gc-three-color/</id>
    <published>2017-08-15T17:02:35.000Z</published>
    <updated>2017-08-20T03:32:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/gc-1.gif"><img src="/images/gc-1.gif" alt=""></a><br><a id="more"></a><br>三色标记法是传统 Mark-Sweep 的一个改进，它是一个并发的 GC 算法。<br>原理如下，</p>
<ol>
<li>首先创建三个集合：白、灰、黑。</li>
<li>将所有对象放入白色集合中。</li>
<li>然后从根节点开始遍历所有对象（注意这里并不<strong>递归遍历</strong>），把遍历到的对象从白色集合放入灰色集合。</li>
<li>之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</li>
<li>重复 4 直到灰色中无任何对象</li>
<li>通过write-barrier检测对象有变化，重复以上操作</li>
<li>收集所有白色对象（垃圾）</li>
</ol>
<p>这个算法可以实现 “on-the-fly”，也就是在程序执行的同时进行收集，并不需要暂停整个程序。<br>但是也会有一个缺陷，可能程序中的垃圾产生的速度会大于垃圾收集的速度，这样会导致程序中的垃圾越来越多无法被收集掉。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/gc-1.gif&quot;&gt;&lt;img src=&quot;/images/gc-1.gif&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="gc" scheme="http://idiotsky.me/tags/gc/"/>
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>一张图了解标记清除算法</title>
    <link href="http://idiotsky.me/2017/08/16/gc-mark-sweep/"/>
    <id>http://idiotsky.me/2017/08/16/gc-mark-sweep/</id>
    <published>2017-08-15T17:02:21.000Z</published>
    <updated>2017-08-15T17:06:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/gc.gif"><img src="/images/gc.gif" alt=""></a><br><a id="more"></a><br>这个算法分为两步，标记和清除。</p>
<ul>
<li>标记：从程序的根节点开始， 递归地 遍历所有对象，将能遍历到的对象打上标记。</li>
<li>清除：讲所有未标记的的对象当作垃圾销毁。</li>
</ul>
<p>但是这个算法也有一个缺陷，就是人们常常说的 STW 问题（Stop The World）。因为算法在标记时必须暂停整个程序，否则其他线程的代码可能会改变对象状态，从而可能把不应该回收的对象当做垃圾收集掉。<br>当程序中的对象逐渐增多时，递归遍历整个对象树会消耗很多的时间，在大型程序中这个时间可能会是毫秒级别的。让所有的用户等待几百毫秒的 GC 时间这是不能容忍的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/gc.gif&quot;&gt;&lt;img src=&quot;/images/gc.gif&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="gc" scheme="http://idiotsky.me/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>postman的几种body的使用介绍</title>
    <link href="http://idiotsky.me/2017/08/10/postman/"/>
    <id>http://idiotsky.me/2017/08/10/postman/</id>
    <published>2017-08-10T12:11:55.000Z</published>
    <updated>2017-08-15T16:51:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>postman,用来模拟发送http请求的工具，里面涉及的请求body有以下几个类型，所以记下，而且也能理解http body的几种格式，分享之。。</p>
</blockquote>
<a id="more"></a>
<h1 id="form-data"><a href="#form-data" class="headerlink" title="form-data"></a>form-data</h1><p>就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型；content-disposition，用来说明字段的一些信息；<br>由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。</p>
<p><a href="/images/postman-1.png"><img src="/images/postman-1.png" alt=""></a><br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">POST /login HTTP/1.1</div><div class="line">Host: 10.170.56.67</div><div class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Cache-Control: no-cache</div><div class="line">Postman-Token: 9843651a-5bf9-0544-03c1-fcc2a16f484b</div><div class="line"></div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;username&quot;</div><div class="line"></div><div class="line">admin</div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;password&quot;</div><div class="line"></div><div class="line">admin123</div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;abc&quot;; filename=&quot;&quot;</div><div class="line">Content-Type: </div><div class="line"></div><div class="line"></div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;tttt&quot;; filename=&quot;&quot;</div><div class="line">Content-Type: </div><div class="line"></div><div class="line"></div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</div></pre></td></tr></table></figure></p>
<h1 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h1><p>就是application/x-www-from-urlencoded,会将表单内的数据转换为键值对，并以urlencode为格式<br><a href="/images/postman-2.png"><img src="/images/postman-2.png" alt=""></a><br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST /login HTTP/1.1</div><div class="line">Host: 10.170.56.67</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Cache-Control: no-cache</div><div class="line">Postman-Token: e6887900-a46e-2ff4-8232-de878b75f5fd</div><div class="line"></div><div class="line">username=admin&amp;password=admin123</div></pre></td></tr></table></figure></p>
<h1 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h1><p>可以上传任意格式的文本，可以上传text、json、xml、html等<br><a href="/images/postman-3.png"><img src="/images/postman-3.png" alt=""></a><br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">POST /login HTTP/1.1</div><div class="line">Host: 10.170.56.67</div><div class="line">Content-Type: application/json</div><div class="line">Cache-Control: no-cache</div><div class="line">Postman-Token: 233df0e0-c6d9-98c7-4d7e-736329322683</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;abc&quot;:&quot;cba&quot;,</div><div class="line">  &quot;cba&quot;:&quot;abc&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从图片和内容对比，可以发现，基本，粘什么，就发什么，不会进行任何转意。</p>
<h1 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h1><p>相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。</p>
<h1 id="multipart-form-data与x-www-form-urlencoded区别"><a href="#multipart-form-data与x-www-form-urlencoded区别" class="headerlink" title="multipart/form-data与x-www-form-urlencoded区别"></a>multipart/form-data与x-www-form-urlencoded区别</h1><ul>
<li>multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息；</li>
<li>x-www-form-urlencoded：只能上传键值对，并且键值对都是间隔分开的</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;postman,用来模拟发送http请求的工具，里面涉及的请求body有以下几个类型，所以记下，而且也能理解http body的几种格式，分享之。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="http" scheme="http://idiotsky.me/categories/http/"/>
    
    
      <category term="postman" scheme="http://idiotsky.me/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>go的是否需要用goroutine pool？</title>
    <link href="http://idiotsky.me/2017/08/03/go-worker-pool-if-need/"/>
    <id>http://idiotsky.me/2017/08/03/go-worker-pool-if-need/</id>
    <published>2017-08-03T15:10:02.000Z</published>
    <updated>2017-08-05T14:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这几天无聊，想到java有自己的线程池，是否对应go也有它的goroutine pool呢，所以搜了下，标准库没有，github有，但都大同小异，所以自己实现了一个。</p>
</blockquote>
<a id="more"></a>
<h1 id="一个简单的goroutine-pool"><a href="#一个简单的goroutine-pool" class="headerlink" title="一个简单的goroutine pool"></a>一个简单的goroutine pool</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> workerpool</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> task <span class="function"><span class="keyword">func</span><span class="params">()</span></span></div><div class="line"></div><div class="line"><span class="title">type</span> <span class="title">worker</span> <span class="title">struct</span> &#123;</div><div class="line">	stopC <span class="keyword">chan</span> <span class="keyword">bool</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> WorkerPool <span class="keyword">struct</span> &#123;</div><div class="line">	num <span class="keyword">int</span></div><div class="line">	sync.Mutex</div><div class="line">	taskQ <span class="keyword">chan</span> task</div><div class="line">	workers []*worker</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorkerPool</span><span class="params">(workerNum <span class="keyword">int</span>,queueCap <span class="keyword">int</span>)</span> *<span class="title">WorkerPool</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> &amp;WorkerPool&#123;num:workerNum,taskQ:<span class="built_in">make</span>(<span class="keyword">chan</span> task,queueCap),workers:<span class="built_in">make</span>([]*worker,workerNum)&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span> <span class="title">Execute</span><span class="params">(t task)</span></span>&#123;</div><div class="line">	wp.taskQ&lt;-t</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span> <span class="title">Start</span><span class="params">()</span> *<span class="title">WorkerPool</span></span>&#123;</div><div class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;wp.num;i++&#123;</div><div class="line">		wp.workers[i]=&amp;worker&#123; <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)&#125;</div><div class="line">		w:=wp.workers[i]</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> &#123;</div><div class="line">				    stop:=<span class="literal">false</span></div><div class="line">					<span class="keyword">select</span> &#123;</div><div class="line">					    <span class="keyword">case</span> f:=&lt;-wp.taskQ:</div><div class="line">							f()</div><div class="line">					    <span class="keyword">case</span> stop=&lt;-w.stopC:</div><div class="line">						     <span class="keyword">break</span></div><div class="line"></div><div class="line">					&#125;</div><div class="line"></div><div class="line">				<span class="keyword">if</span> stop&#123;</div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			fmt.Println(<span class="string">"stop"</span>)</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> wp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">for</span> _,w:=<span class="keyword">range</span> wp.workers&#123;</div><div class="line">		w.stopC&lt;- <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很简单，就是<code>NewWorkerPool</code>一个池子的时候设置goroutine的数量和任务队列的大小。<code>Start</code>后就创建那么多goroutine去任务队列取任务执行，取不到任务就自循。<code>Execute</code>方法是把任务压进队列，如果队列满了就阻塞。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>要测试性能，肯定要有对比，以下是没有使用pool:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">nopool</span><span class="params">()</span></span> &#123;</div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">    <span class="comment">//执行1000000次，每次都启动一个goroutine</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">defer</span> wg.Done()</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	wg.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下是简单版的只是单纯限制goroutine数量和任务队列的代码，没有任何封装的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopool</span><span class="params">()</span></span> &#123;</div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">    <span class="comment">//队列100</span></div><div class="line">	data := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</div><div class="line"></div><div class="line">    <span class="comment">//goroutine 数量10个</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">defer</span> wg.Done()</div><div class="line">			<span class="keyword">for</span> _ = <span class="keyword">range</span> data &#123;</div><div class="line">				<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</div><div class="line">					<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</div><div class="line"></div><div class="line">					&#125;</div><div class="line">				&#125;()</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="comment">//执行1000000个任务</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</div><div class="line">		data &lt;- i</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">close</span>(data)</div><div class="line">	wg.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是主角:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">workerpool</span><span class="params">()</span></span> &#123;</div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">    <span class="comment">//十个goroutine，队列容量100</span></div><div class="line">	wp:=NewWorkerPool(<span class="number">10</span>,<span class="number">100</span>)</div><div class="line">	wp.Start()</div><div class="line">    <span class="comment">//提交1000000任务</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		wp.Execute(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			wg.Done()</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码基本都是做同样一件事，但是后两个只开10个goroutine，第一个就开了1000000个，结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BenchmarkNopool-8                      1        7966900091 ns/op</div><div class="line">BenchmarkGopool-8                      1        7949844269 ns/op</div><div class="line">BenchmarkWorkerPool-8                  1        7997732135 ns/op</div></pre></td></tr></table></figure></p>
<p>可以看出来，没有区别，重新run几次基本没有多大变化。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于go本身有对goroutine有调度，所以自己实现的池子来调度其实好像没有什么用。还有可能我自己能力实现不好，没发挥池子的作用😀。<br>但是用更少的goroutine能完成同样的事情，应该是一种优化，而且这里的goroutine执行都是简单的循环，没有复杂的业务，一旦业务复杂，更少goroutine能够减少内存和goroutine切换时的cpu资源，有可能上面性能的比较会拉开。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这几天无聊，想到java有自己的线程池，是否对应go也有它的goroutine pool呢，所以搜了下，标准库没有，github有，但都大同小异，所以自己实现了一个。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>利用树莓派搭建一个简易的NAS</title>
    <link href="http://idiotsky.me/2017/07/20/raspberry-nas/"/>
    <id>http://idiotsky.me/2017/07/20/raspberry-nas/</id>
    <published>2017-07-20T14:39:35.000Z</published>
    <updated>2017-08-09T16:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>raspberry pi 3</li>
<li>硬盘（格式化过ext4的）</li>
<li>连接raspberry用的终端</li>
</ul>
<a id="more"></a>
<h1 id="安装samba"><a href="#安装samba" class="headerlink" title="安装samba"></a>安装samba</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install samba samba-common-bin</div></pre></td></tr></table></figure>
<h1 id="配置samba"><a href="#配置samba" class="headerlink" title="配置samba"></a>配置samba</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.back</div><div class="line">sudo vim /etc/samba/smb.conf</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在末尾加入如下内容</span></div><div class="line"><span class="comment"># 分享名称</span></div><div class="line">[MyNAS]</div><div class="line"><span class="comment"># 说明信息</span></div><div class="line">comment = NAS Storage</div><div class="line"><span class="comment"># 可以访问的用户</span></div><div class="line">valid users = pi,root</div><div class="line"><span class="comment"># 共享文件的路径,raspberry pi 会自动将连接到其上的外接存储设备挂载到/media/pi/目录下。</span></div><div class="line">path = /media/pi/</div><div class="line"><span class="comment"># 可被其他人看到资源名称（非内容）</span></div><div class="line">browseable = yes</div><div class="line"><span class="comment"># 可写</span></div><div class="line">writable = yes</div><div class="line"><span class="comment"># 新建文件的权限为 664</span></div><div class="line">create mask = 0664</div><div class="line"><span class="comment"># 新建目录的权限为 775</span></div><div class="line">directory mask = 0775</div></pre></td></tr></table></figure>
<p>可以把配置文件中你不需要的分享名称删除，例如 [homes], [printers] 等。<br>测试配置文件是否有错误，根据提示做相应修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">testparm</div></pre></td></tr></table></figure></p>
<p>添加登陆账户并创建密码，必须是 linux 已存在的用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo smbpasswd -a pi</div></pre></td></tr></table></figure></p>
<p>重启 samba 服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/samba restart</div></pre></td></tr></table></figure></p>
<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>一般树莓派跟你的WiFi相连的话，你的网络就能看到跟上面配置一样的分享名称，如mac上面这样的显示：<br><a href="/images/nas-screenshot.png"><img src="/images/nas-screenshot.png" alt=""></a><br>如果显示没权限，可以断开连接，用你上面添加的账号登录。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;raspberry pi 3&lt;/li&gt;
&lt;li&gt;硬盘（格式化过ext4的）&lt;/li&gt;
&lt;li&gt;连接raspberry用的终端&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="raspberrypi" scheme="http://idiotsky.me/categories/raspberrypi/"/>
    
    
      <category term="python" scheme="http://idiotsky.me/tags/python/"/>
    
      <category term="raspberrypi" scheme="http://idiotsky.me/tags/raspberrypi/"/>
    
      <category term="NAS" scheme="http://idiotsky.me/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>利用树莓派实现一个能播放天气的闹钟</title>
    <link href="http://idiotsky.me/2017/07/18/raspberry-weather-clock/"/>
    <id>http://idiotsky.me/2017/07/18/raspberry-weather-clock/</id>
    <published>2017-07-17T17:12:25.000Z</published>
    <updated>2017-08-10T12:26:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>你要有个pi😄<br><a id="more"></a></p>
<h1 id="获取天气接口"><a href="#获取天气接口" class="headerlink" title="获取天气接口"></a>获取天气接口</h1><p>这里我是用图灵机器人来获取天气的接口，你可以自己上去注册一个，下面代码URL的Key是我注册的机器人给的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getWeatherText</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        response = requests.get(</div><div class="line">            <span class="string">"http://www.tuling123.com/openapi/api?key=652ae4a714794fe6b01faa990d7a981f&amp;info=%s"</span> % <span class="string">"广州今日天气"</span>)</div><div class="line">        json = response.json()</div><div class="line">        <span class="keyword">if</span> json[<span class="string">"code"</span>] == <span class="number">100000</span>:</div><div class="line">            <span class="keyword">return</span> json[<span class="string">"text"</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span></div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span></div></pre></td></tr></table></figure></p>
<h1 id="播放文字"><a href="#播放文字" class="headerlink" title="播放文字"></a>播放文字</h1><p>利用百度的接口可以转换文本为语音。默认只有女声<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2voice</span><span class="params">(text)</span>:</span></div><div class="line">    url = <span class="string">'http://tts.baidu.com/text2audio?idx=1&amp;tex=&#123;0&#125;&amp;cuid=baidu_speech_'</span> \</div><div class="line">          <span class="string">'demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=4&amp;per=4&amp;vol=5&amp;pit=5'</span>.format(text)</div><div class="line">    <span class="comment"># 用mplayer播放语音</span></div><div class="line">    os.system(<span class="string">'mplayer "%s"'</span> % url)</div></pre></td></tr></table></figure></p>
<h1 id="安装播放媒体软件"><a href="#安装播放媒体软件" class="headerlink" title="安装播放媒体软件"></a>安装播放媒体软件</h1><p>上面代码你看到的<code>mplayer</code>,就是用来播放语音的，传个url作为参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mplayer</div><div class="line">usage: mplayer [url]</div></pre></td></tr></table></figure></p>
<h1 id="播放音乐"><a href="#播放音乐" class="headerlink" title="播放音乐"></a>播放音乐</h1><p>有了上面这个神器，你可以给播报语音前后加一首音乐😄<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">playMusic</span><span class="params">(path)</span>:</span></div><div class="line">    os.system(<span class="string">'mplayer %s'</span> % path)</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用上面的东东，可以组合些好玩的东西了，至于闹钟的唤醒，可以crob job 做，也可以代码里面实现，enjoy…😄<br>全部代码地址 <a href="https://github.com/ejunjsh/raspberrypi-code/blob/master/clock/weather.py" target="_blank" rel="external">https://github.com/ejunjsh/raspberrypi-code/blob/master/clock/weather.py</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h1&gt;&lt;p&gt;你要有个pi😄&lt;br&gt;
    
    </summary>
    
      <category term="raspberrypi" scheme="http://idiotsky.me/categories/raspberrypi/"/>
    
    
      <category term="python" scheme="http://idiotsky.me/tags/python/"/>
    
      <category term="raspberrypi" scheme="http://idiotsky.me/tags/raspberrypi/"/>
    
  </entry>
  
  <entry>
    <title>用go实现一个简单的restful接口</title>
    <link href="http://idiotsky.me/2017/07/18/go-first-rest/"/>
    <id>http://idiotsky.me/2017/07/18/go-first-rest/</id>
    <published>2017-07-17T17:01:18.000Z</published>
    <updated>2017-07-22T08:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>go的标准库<code>http</code>已经封装好很多接口，可以很简单实现一个web服务器。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义 handler</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</div><div class="line">    io.WriteString(w, <span class="string">"hello, world!\n"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">//绑定pattern和handler</span></div><div class="line">    http.HandleFunc(<span class="string">"/hello"</span>, HelloServer)</div><div class="line">    err := http.ListenAndServe(<span class="string">":12345"</span>, <span class="literal">nil</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基于上面例子可以封装一个restful接口，不是难事。<br><a id="more"></a></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>从上面例子可以看到，一个url pattern对应一个handler，即对应一个处理，就可以处理http请求了，所以下面的实现是基于对这两个东西的封装开始</p>
<h2 id="封装一个restful-app-结构"><a href="#封装一个restful-app-结构" class="headerlink" title="封装一个restful app 结构"></a>封装一个restful app 结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">//一个map，key是pattern，value是handler</span></div><div class="line">	handlers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(r *HttpRequest,w HttpResponse)</span><span class="title">error</span></span></div><div class="line">    //<span class="title">pattern</span>数组，用来保证加入<span class="title">pattern</span>的顺序，因为上面的<span class="title">map</span>是无顺序的</div><div class="line">	<span class="title">patterns</span> []<span class="title">string</span></div><div class="line">    //一个<span class="title">map</span>，<span class="title">key</span>是<span class="title">pattern</span>，<span class="title">value</span>是<span class="title">http</span> <span class="title">method</span></div><div class="line">	<span class="title">methods</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></div><div class="line">    //用来实现在<span class="title">url</span> <span class="title">path</span>取出参数的。</div><div class="line">	<span class="title">regexps</span> <span class="title">map</span>[<span class="title">string</span>]*<span class="title">regexp</span>.<span class="title">Regexp</span></div><div class="line">	<span class="title">pathparamanmes</span> <span class="title">map</span>[<span class="title">string</span>][]<span class="title">string</span></div><div class="line">    //用来处理异常的<span class="title">handler</span></div><div class="line">	<span class="title">errHandler</span> <span class="title">func</span><span class="params">( err error, r *HttpRequest,w HttpResponse)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApp</span><span class="params">()</span> *<span class="title">App</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;App&#123;</div><div class="line">		handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>),</span></div><div class="line">		<span class="title">patterns</span>:<span class="title">make</span><span class="params">([]<span class="keyword">string</span>,0)</span>,</div><div class="line">		<span class="title">methods</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span>,</div><div class="line">		<span class="title">regexps</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]*regexp.Regexp)</span>,</div><div class="line">		<span class="title">pathparamanmes</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span>,</div><div class="line">        //一个默认的异常处理，直接返回异常内容</div><div class="line">		<span class="title">errHandler</span>: <span class="title">func</span><span class="params">(err error, r *HttpRequest, w HttpResponse)</span> &#123;</div><div class="line">			w.Write( []<span class="keyword">byte</span>(err.Error()))</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="映射绑定"><a href="#映射绑定" class="headerlink" title="映射绑定"></a>映射绑定</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">handle</span><span class="params">(method <span class="keyword">string</span>,pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span> <span class="title">error</span>)</span>&#123;</div><div class="line">    <span class="comment">//绑定pattern和handler</span></div><div class="line">	a.handlers[pattern]=handler</div><div class="line">    <span class="comment">//绑定pattern和method</span></div><div class="line">	a.methods[pattern]=method</div><div class="line">    <span class="comment">//绑定pattern 正则，用来匹配url pattern,和获取url path 参数</span></div><div class="line">	a.regexps[pattern],a.pathparamanmes[pattern]=convertPatterntoRegex(pattern)</div><div class="line">	<span class="keyword">for</span> _,s:=<span class="keyword">range</span> a.patterns&#123;</div><div class="line">		<span class="keyword">if</span> s==pattern&#123;</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//加入数组，方便用此数组确定顺序</span></div><div class="line">	a.patterns=<span class="built_in">append</span>(a.patterns,pattern)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//绑定GET</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Get</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"GET"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定POST</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Post</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"POST"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定DELETE</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Delete</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"DELETE"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定PUT</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Put</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span> <span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"PUT"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Error</span><span class="params">(handler <span class="keyword">func</span>(err error,r *HttpRequest,w HttpResponse)</span>)</span>  &#123;</div><div class="line">	a.errHandler=handler</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了Restful接口的四个方法映射绑定，剩下的就要请求能进到来，所以接下来要写个入口才行。</p>
<h2 id="编写http入口"><a href="#编写http入口" class="headerlink" title="编写http入口"></a>编写http入口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//http 入口</span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">Run</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</div><div class="line">	fmt.Printf(<span class="string">"Server listens on %s"</span>,address)</div><div class="line">	err:=http.ListenAndServe(address,&amp;hodler&#123;app:a&#125;)</div><div class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//https 入口</span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">RunTls</span><span class="params">(address <span class="keyword">string</span>,cert <span class="keyword">string</span>,key <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</div><div class="line">	fmt.Printf(<span class="string">"Server listens on %s"</span>,address)</div><div class="line">	err:=http.ListenAndServeTLS(address,cert,key,&amp;hodler&#123;app:a&#125;)</div><div class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>入口函数主要调用<code>http</code>库来启动http服务，然后把请求处理函数作为<code>ListenAndServe</code>第二个参数传入。这里由<code>holder</code>来实现这个处理函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hodler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</div><div class="line">	<span class="comment">//封装一下，附加更多功能</span></div><div class="line">    request:= newHttpRequest(r)</div><div class="line">	response:=newHttpResponse(w)</div><div class="line">	<span class="comment">//捕获panic，并让errhandler处理返回。</span></div><div class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span>&#123;</div><div class="line">			<span class="keyword">if</span> e,ok:=err.(error);ok&#123;</div><div class="line">				h.app.errHandler(InternalError&#123;e,<span class="string">""</span>&#125;,request,response)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> e,ok:=err.(<span class="keyword">string</span>);ok&#123;</div><div class="line">				h.app.errHandler(InternalError&#123;<span class="literal">nil</span>,e&#125;,request,response)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">    <span class="comment">//根据pattern的添加顺序，循环判断</span></div><div class="line">   <span class="keyword">for</span> _,p:=<span class="keyword">range</span> h.app.patterns&#123;</div><div class="line">       <span class="keyword">if</span> reg,ok:= h.app.regexps[p];ok&#123;</div><div class="line">           <span class="comment">//匹配method</span></div><div class="line">		   <span class="keyword">if</span> method,ok:=h.app.methods[p];ok&amp;&amp;r.Method==method&#123;</div><div class="line">              <span class="comment">//匹配pattern</span></div><div class="line">			   <span class="keyword">if</span> reg.Match([]<span class="keyword">byte</span>(r.URL.Path)) &#123;</div><div class="line">                   <span class="comment">//抽取url path parameters</span></div><div class="line">				   matchers:=reg.FindSubmatch([]<span class="keyword">byte</span>(r.URL.Path))</div><div class="line">				   pathParamMap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</div><div class="line">				   <span class="keyword">if</span> <span class="built_in">len</span>(matchers)&gt;<span class="number">1</span>&#123;</div><div class="line">                       <span class="keyword">if</span> pathParamNames,ok:=h.app.pathparamanmes[p];ok&#123;</div><div class="line">						   <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(matchers);i++&#123;</div><div class="line">							   pathParamMap[pathParamNames[i]]=<span class="keyword">string</span>(matchers[i])</div><div class="line">						   &#125;</div><div class="line">					   &#125;</div><div class="line">				   &#125;</div><div class="line">                   <span class="comment">//PathParams是封装后的request独有的属性</span></div><div class="line">				   request.PathParams=pathParamMap</div><div class="line">				   <span class="keyword">if</span> handler,ok:=h.app.handlers[p];ok&#123;</div><div class="line">                       <span class="comment">//执行handler</span></div><div class="line">					   err:=handler(request,response)</div><div class="line">					   <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">                           <span class="comment">//执行errhandler</span></div><div class="line">						   h.app.errHandler(err,request,response)</div><div class="line">					   &#125;</div><div class="line">					   <span class="keyword">return</span></div><div class="line">				   &#125;</div><div class="line">			   &#125;</div><div class="line">		   &#125;</div><div class="line">	   &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//执行no found errhandler</span></div><div class="line">	h.app.errHandler(NoFoundError&#123;&#125;,request,response)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基本一个请求的流程如下：<br>requset-&gt;ServeHTTP()-&gt;匹配url pattern-&gt;匹配method-&gt;匹配到你的handler-&gt;执行你的handler-&gt;你的handler返回结果</p>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>由于返回结果可以有很多，所以封装了<code>http</code>库的<code>http.ResponseWriter</code>来实现<code>WriteString,WriteJson,WriteXml,WriteFile</code>等方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//封装request，附件一个PathParams来保存url path parameters.</span></div><div class="line"><span class="keyword">type</span> HttpRequest <span class="keyword">struct</span> &#123;</div><div class="line">	*http.Request</div><div class="line">	PathParams <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> HttpResponse <span class="keyword">struct</span> &#123;</div><div class="line">	http.ResponseWriter</div><div class="line">&#125;</div><div class="line"><span class="comment">//用来返回字符</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteString</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回JSON</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteJson</span><span class="params">(jsonObj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回XML</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteXml</span><span class="params">(xmlObj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回文件</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteFile</span><span class="params">(filepath <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回一个模板html</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteTemplates</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;,tplPath ...<span class="keyword">string</span>)</span> <span class="title">error</span></span>  &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//new 一个restful接口</span></div><div class="line">	app:=gorest.NewApp()</div><div class="line">    <span class="comment">//绑定</span></div><div class="line">	app.Get(<span class="string">"/json"</span>, <span class="function"><span class="keyword">func</span><span class="params">(r *gorest.HttpRequest, w gorest.HttpResponse)</span> <span class="title">error</span></span> &#123;</div><div class="line">		a:= <span class="keyword">struct</span> &#123;</div><div class="line">			Abc <span class="keyword">string</span> <span class="string">`json:"abc"`</span></div><div class="line">			Cba <span class="keyword">string</span> <span class="string">`json:"cba"`</span></div><div class="line">		&#125;&#123;<span class="string">"123"</span>,<span class="string">"321"</span>&#125;</div><div class="line">        <span class="comment">//返回json作为结果</span></div><div class="line">		<span class="keyword">return</span> w.WriteJson(a)</div><div class="line">	&#125;)</div><div class="line">	app.Error(<span class="function"><span class="keyword">func</span><span class="params">(err error, r *gorest.HttpRequest, w gorest.HttpResponse)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span> e,ok:=err.(gorest.NoFoundError);ok &#123;</div><div class="line">			w.Write([]<span class="keyword">byte</span>(e.Error()))</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> e,ok:=err.(gorest.InternalError);ok &#123;</div><div class="line">			w.Write([]<span class="keyword">byte</span>(e.Error()))</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">    <span class="comment">//启动</span></div><div class="line">	app.Run(<span class="string">":8081"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>收工😄</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>go的标准库封装了很多了，所以实现这个其实还是比较轻松的😄<br>详细代码见<a href="https://github.com/ejunjsh/gorest" target="_blank" rel="external">https://github.com/ejunjsh/gorest</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;go的标准库&lt;code&gt;http&lt;/code&gt;已经封装好很多接口，可以很简单实现一个web服务器。&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义 handler&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HelloServer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(w http.ResponseWriter, req *http.Request)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    io.WriteString(w, &lt;span class=&quot;string&quot;&gt;&quot;hello, world!\n&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//绑定pattern和handler&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    http.HandleFunc(&lt;span class=&quot;string&quot;&gt;&quot;/hello&quot;&lt;/span&gt;, HelloServer)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    err := http.ListenAndServe(&lt;span class=&quot;string&quot;&gt;&quot;:12345&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        log.Fatal(&lt;span class=&quot;string&quot;&gt;&quot;ListenAndServe: &quot;&lt;/span&gt;, err)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基于上面例子可以封装一个restful接口，不是难事。&lt;br&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
      <category term="restful" scheme="http://idiotsky.me/tags/restful/"/>
    
  </entry>
  
  <entry>
    <title>一张图了解一致性hash</title>
    <link href="http://idiotsky.me/2017/07/16/consistent-hash/"/>
    <id>http://idiotsky.me/2017/07/16/consistent-hash/</id>
    <published>2017-07-16T12:39:20.000Z</published>
    <updated>2017-07-19T12:39:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/consistent-hash.png"><img src="/images/consistent-hash.png" alt="one image describes how consistent-hash works"></a><br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/consistent-hash.png&quot;&gt;&lt;img src=&quot;/images/consistent-hash.png&quot; alt=&quot;one image describes how consistent-hash works&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>一张图了解hashmap</title>
    <link href="http://idiotsky.me/2017/07/15/hashmap/"/>
    <id>http://idiotsky.me/2017/07/15/hashmap/</id>
    <published>2017-07-15T10:03:15.000Z</published>
    <updated>2017-08-12T06:50:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/hashmap.png"><img src="/images/hashmap.png" alt="one image describes how hashmap works"></a><br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/hashmap.png&quot;&gt;&lt;img src=&quot;/images/hashmap.png&quot; alt=&quot;one image describes how hashmap works&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SELECT * ...... FOR UPDATE 锁机制</title>
    <link href="http://idiotsky.me/2016/12/19/mysql-select-for-update/"/>
    <id>http://idiotsky.me/2016/12/19/mysql-select-for-update/</id>
    <published>2016-12-19T12:35:56.000Z</published>
    <updated>2017-08-19T12:45:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>由于InnoDB预设是Row-Level Lock，InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ </p>
</blockquote>
<a id="more"></a>
<p>举个例子:<br>假设有个表单products ，里面有id跟name二个栏位，id是主键。<br>例1: (明确指定主键，并且有此笔资料，row lock)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'3'</span> <span class="keyword">and</span> <span class="keyword">type</span>=<span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure></p>
<p>例2: (明确指定主键，若查无此笔资料，无lock)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'-1'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure></p>
<p>例3: (无主键，table lock)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Mouse'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure></p>
<p>例4: (主键不明确，table lock)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>&lt;&gt;<span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure></p>
<p>例5: (主键不明确，table lock)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">LIKE</span> <span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure></p>
<p>注1: FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。<br>注2: 要测试锁定的状况，可以利用mysql的Command Mode ，开二个视窗来做测试。</p>
<p>在MySql 5.0中测试确实是这样的<br>另外：MyAsim 只支持表级锁，InnerDB支持行级锁<br>添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改（修改、删除）<br>是表级锁时，不管是否查询到记录，都会锁定表</p>
<p>此外，如果A与B都对表id进行查询但查询不到记录，则A与B在查询上不会进行row锁，但A与B都会获取排它锁，此时A再插入一条记录的话则会因为B已经有锁而处于等待中，此时B再插入一条同样的数据则会抛出Deadlock found when trying to get lock; try restarting transaction然后释放锁，此时A就获得了锁而插入成功</p>
<p>上面介绍过SELECT … FOR UPDATE 的用法，不过锁定(Lock)的数据是判别就得要注意一下了。由于InnoDB 预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。</p>
<p>转载 <a href="http://www.cnblogs.com/chenwenbiao/archive/2012/06/06/2537508.html" target="_blank" rel="external">http://www.cnblogs.com/chenwenbiao/archive/2012/06/06/2537508.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于InnoDB预设是Row-Level Lock，InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://idiotsky.me/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://idiotsky.me/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>简单理解Java GC与幽灵引用</title>
    <link href="http://idiotsky.me/2016/09/11/java-gc-reference/"/>
    <id>http://idiotsky.me/2016/09/11/java-gc-reference/</id>
    <published>2016-09-11T14:41:24.000Z</published>
    <updated>2017-08-11T15:03:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Java中一共有4种类型的引用:StrongReference、SoftReference、WeakReference以及PhantomReference (幽灵引用), 这 4 种类型的引用与Java GC有着密切的关系, 让我们逐一来看它们的定义和使用场景。</p>
</blockquote>
<a id="more"></a>
<h1 id="Strong-Reference"><a href="#Strong-Reference" class="headerlink" title="Strong Reference"></a>Strong Reference</h1><p>StrongReference 是 Java 的默认引用实现,它会尽可能长时间的存活于 JVM 内， 当没有任何对象指向它时Java GC 执行后将会被回收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strongReference</span><span class="params">()</span> </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 通过赋值创建 StrongReference   </div><div class="line"> */  </div><div class="line">Object strongReference = referent;   </div><div class="line">   </div><div class="line">assertSame(referent, strongReference);   </div><div class="line">   </div><div class="line">referent = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * StrongReference 在 GC 后不会被回收  </div><div class="line"> */  </div><div class="line">assertNotNull(strongReference);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="WeakReference-amp-WeakHashMap"><a href="#WeakReference-amp-WeakHashMap" class="headerlink" title="WeakReference &amp; WeakHashMap"></a>WeakReference &amp; WeakHashMap</h1><p>WeakReference， 顾名思义,是一个弱引用,当所引用的对象在 JVM 内不再有强引用时, Java GC 后 weak reference 将会被自动回收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakReference</span><span class="params">()</span> </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();   </div><div class="line">WeakReference&lt;Object&gt; weakRerference = <span class="keyword">new</span> WeakReference&lt;Object&gt;(referent);   </div><div class="line"> </div><div class="line">assertSame(referent, weakRerference.get());   </div><div class="line">   </div><div class="line">referent = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 一旦没有指向 referent 的强引用, weak reference 在 GC 后会被自动回收  </div><div class="line"> */  </div><div class="line">assertNull(weakRerference.get());   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WeakHashMap 使用 WeakReference 作为 key， 一旦没有指向 key 的强引用, WeakHashMap 在Java GC 后将自动删除相关的 entry<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakHashMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </div><div class="line">Map&lt;Object, Object&gt; weakHashMap = <span class="keyword">new</span> WeakHashMap&lt;Object, Object&gt;();   </div><div class="line">Object key = <span class="keyword">new</span> Object();   </div><div class="line">Object value = <span class="keyword">new</span> Object();   </div><div class="line">weakHashMap.put(key, value);   </div><div class="line"> </div><div class="line">assertTrue(weakHashMap.containsValue(value));   </div><div class="line">   </div><div class="line">key = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 等待无效 entries 进入 ReferenceQueue 以便下一次调用 getTable 时被清理  </div><div class="line"> */  </div><div class="line">Thread.sleep(<span class="number">1000</span>);   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 一旦没有指向 key 的强引用, WeakHashMap 在 GC 后将自动删除相关的 entry  </div><div class="line"> */  </div><div class="line">assertFalse(weakHashMap.containsValue(value));   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="SoftReference"><a href="#SoftReference" class="headerlink" title="SoftReference"></a>SoftReference</h1><p>SoftReference 于 WeakReference 的特性基本一致， 最大的区别在于 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">softReference</span><span class="params">()</span> </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();   </div><div class="line">SoftReference&lt;Object&gt; softRerference = <span class="keyword">new</span> SoftReference&lt;Object&gt;(referent);   </div><div class="line"> </div><div class="line">assertNotNull(softRerference.get());   </div><div class="line">   </div><div class="line">referent = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> *soft references 只有在 jvm OutOfMemory 之前才会被回收, 所以它非常适合缓存应用  </div><div class="line"> */  </div><div class="line">assertNotNull(softRerference.get());   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Phantom-Reference"><a href="#Phantom-Reference" class="headerlink" title="Phantom Reference"></a>Phantom Reference</h1><p>作为本文主角， Phantom Reference(幽灵引用) 与 WeakReference 和 SoftReference 有很大的不同,因为它的 get() 方法永远返回 null, 这也正是它名字的由来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phantomReferenceAlwaysNull</span><span class="params">()</span> </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();   </div><div class="line">PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(referent, <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;());   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * phantom reference 的 get 方法永远返回 null   </div><div class="line"> */  </div><div class="line">assertNull(phantomReference.get());   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>诸位可能要问, 一个永远返回 null 的 reference 要来何用,请注意构造 PhantomReference 时的第二个参数 ReferenceQueue(事实上 WeakReference &amp; SoftReference 也可以有这个参数)，<br>PhantomReference 唯一的用处就是跟踪 referent何时被 enqueue 到 ReferenceQueue 中.</p>
<h1 id="RererenceQueue"><a href="#RererenceQueue" class="headerlink" title="RererenceQueue"></a>RererenceQueue</h1><p>当一个 WeakReference 开始返回 null 时， 它所指向的对象已经准备被回收， 这时可以做一些合适的清理工作. 将一个 ReferenceQueue 传给一个 Reference 的构造函数， 当对象被回收时， 虚拟机会自动将这个对象插入到 ReferenceQueue 中， WeakHashMap 就是利用 ReferenceQueue 来清除 key 已经没有强引用的 entries.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">referenceQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();  </div><div class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();   </div><div class="line">WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;Object&gt;(referent, referenceQueue);   </div><div class="line">   </div><div class="line">assertFalse(weakReference.isEnqueued());   </div><div class="line">Reference&lt;? extends Object&gt; polled = referenceQueue.poll();   </div><div class="line">assertNull(polled);   </div><div class="line">   </div><div class="line">referent = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line"> </div><div class="line">assertTrue(weakReference.isEnqueued());   </div><div class="line">Reference&lt;? extends Object&gt; removed = referenceQueue.remove();   </div><div class="line">assertNotNull(removed);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Phantom-Reference-vs-Weak-Reference"><a href="#Phantom-Reference-vs-Weak-Reference" class="headerlink" title="Phantom Reference vs Weak Reference"></a>Phantom Reference vs Weak Reference</h1><p>PhantomReference有两个好处， 其一， 它可以让我们准确地知道对象何时被从内存中删除， 这个特性可以被用于一些特殊的需求中(例如 Distributed GC，XWork 和 google-guice 中也使用 PhantomReference 做了一些清理性工作).</p>
<p>其二， 它可以避免 finalization 带来的一些根本性问题, 上文提到 PhantomReference 的唯一作用就是跟踪 referent 何时被 enqueue 到 ReferenceQueue 中,但是 WeakReference 也有对应的功能, 两者的区别到底在哪呢 ?<br>这就要说到 Object 的 finalize 方法, 此方法将在 gc 执行前被调用, 如果某个对象重载了 finalize 方法并故意在方法内创建本身的强引用,这将导致这一轮的 GC 无法回收这个对象并有可能<br>引起任意次 GC， 最后的结果就是明明 JVM 内有很多 Garbage 却 OutOfMemory， 使用 PhantomReference 就可以避免这个问题， 因为 PhantomReference 是在 finalize 方法执行后回收的，也就意味着此时已经不可能拿到原来的引用,也就不会出现上述问题,当然这是一个很极端的例子, 一般不会出现.</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p><strong>Soft vs Weak vs Phantom References</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Purpose</th>
<th>Use</th>
<th>When GCed</th>
<th>Implementing Class</th>
</tr>
</thead>
<tbody>
<tr>
<td>Strong Reference</td>
<td>An ordinary reference. Keeps objects alive as long as they are referenced.</td>
<td>normal reference.</td>
<td>Any object not pointed to can be reclaimed.</td>
<td>default</td>
</tr>
<tr>
<td>Soft Reference</td>
<td>Keeps objects alive provided there’s enough memory.</td>
<td>to keep objects alive even after clients have removed their references (memory-sensitive caches), in case clients start asking for them again by key.</td>
<td>After a first gc pass, the JVM decides it still needs to reclaim more space.</td>
<td>java.lang.ref.SoftReference</td>
</tr>
<tr>
<td>Weak Reference</td>
<td>Keeps objects alive only while they’re in use (reachable) by clients.</td>
<td>Containers that automatically delete objects no longer in use.</td>
<td>After gc determines the object is only weakly reachable</td>
<td>java.lang.ref.WeakReference java.util.WeakHashMap</td>
</tr>
<tr>
<td>Phantom Reference</td>
<td>Lets you clean up after finalization but before the space is reclaimed (replaces or augments the use offinalize())</td>
<td>Special clean up processing</td>
<td>After finalization.</td>
<td>java.lang.ref.PhantomReference</td>
</tr>
</tbody>
</table>
<h1 id="Java-GC小结"><a href="#Java-GC小结" class="headerlink" title="Java GC小结"></a>Java GC小结</h1><p>一般的应用程序不会涉及到 Reference 编程， 但是了解这些知识会对理解Java GC 的工作原理以及性能调优有一定帮助, 在实现一些基础性设施比如缓存时也可能会用到， 希望本文能有所帮助.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Java中一共有4种类型的引用:StrongReference、SoftReference、WeakReference以及PhantomReference (幽灵引用), 这 4 种类型的引用与Java GC有着密切的关系, 让我们逐一来看它们的定义和使用场景。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="gc" scheme="http://idiotsky.me/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>redis的事务和watch</title>
    <link href="http://idiotsky.me/2016/09/03/redis-transaction-watch/"/>
    <id>http://idiotsky.me/2016/09/03/redis-transaction-watch/</id>
    <published>2016-09-03T14:43:12.000Z</published>
    <updated>2017-08-03T14:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis的事务"><a href="#redis的事务" class="headerlink" title="redis的事务"></a>redis的事务</h1><p>严格意义来讲,redis的事务和我们理解的传统数据库(如mysql)的事务是不一样的。<br><a id="more"></a></p>
<h2 id="redis中的事务定义"><a href="#redis中的事务定义" class="headerlink" title="redis中的事务定义"></a>redis中的事务定义</h2><p>Redis中的事务（transaction）是一组命令的集合。</p>
<p>事务同命令一样都是Redis的最小执行单位，一个事务中的命令要么都执行，要么都不执行。<br>事务的原理是先将属于一个事务的命令发送给Redis，然后再让Redis依次执行这些命令。</p>
<blockquote>
<p>Redis保证一个事务中的所有命令要么都执行，要么都不执行。如果在发送EXEC命令前客户端断线了，则Redis会清空事务队列，事务中的所有命令都不会执行。而一旦客户端发送了EXEC命令，所有的命令就都会被执行，即使此后客户端断线也没关系，因为Redis中已经记录了所有要执行的命令。</p>
<p>除此之外，Redis的事务还能保证一个事务内的命令依次执行而不被其他命令插入。试想客户端A需要执行几条命令，同时客户端B发送了一条命令，如果不使用事务，则客户端B的命令可能会插入到客户端A的几条命令中执行。如果不希望发生这种情况，也可以使用事务。</p>
</blockquote>
<h2 id="事务的应用"><a href="#事务的应用" class="headerlink" title="事务的应用"></a>事务的应用</h2><blockquote>
<p>事务的应用非常普遍，如银行转账过程中A给B汇款，首先系统从A的账户中将钱划走，然后向B的账户增加相应的金额。这两个步骤必须属于同一个事务，要么全执行，要么全不执行。否则只执行第一步，钱就凭空消失了，这显然让人无法接受。</p>
</blockquote>
<h2 id="和传统的事务不同"><a href="#和传统的事务不同" class="headerlink" title="和传统的事务不同"></a>和传统的事务不同</h2><blockquote>
<p>和传统的mysql事务不同的事，即使我们的加钱操作失败,我们也无法在这一组命令中让整个状态回滚到操作之前</p>
</blockquote>
<h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h2><p>如果一个事务中的某个命令执行出错，Redis会怎样处理呢？要回答这个问题，首先需要知道什么原因会导致命令执行出错。</p>
<h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p>语法错误指命令不存在或者命令参数的个数不对。比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redis＞MULTI</div><div class="line">OK</div><div class="line">redis＞SET key value</div><div class="line">QUEUED</div><div class="line">redis＞SET key</div><div class="line">(error)ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'set'</span> <span class="built_in">command</span></div><div class="line">redis＞ errorCOMMAND key</div><div class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">'errorCOMMAND'</span></div><div class="line">redis＞ EXEC</div><div class="line">(error) EXECABORT Transaction discarded because of previous errors.</div></pre></td></tr></table></figure></p>
<p>跟在MULTI命令后执行了3个命令：一个是正确的命令，成功地加入事务队列；其余两个命令都有语法错误。而只要有一个命令有语法错误，执行EXEC命令后Redis就会直接返回错误，连语法正确的命令也不会执行。</p>
<h4 id="这里需要注意一点："><a href="#这里需要注意一点：" class="headerlink" title="这里需要注意一点："></a>这里需要注意一点：</h4><p>Redis 2.6.5之前的版本会忽略有语法错误的命令，然后执行事务中其他语法正确的命令。就此例而言，SET key value会被执行，EXEC命令会返回一个结果：1) OK。</p>
<h3 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h3><p>运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前Redis是无法发现的，所以在事务里这样的命令是会被Redis接受并执行的。如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续执行（包括出错命令之后的命令），示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">redis＞MULTI</div><div class="line">OK</div><div class="line">redis＞SET key 1</div><div class="line">QUEUED</div><div class="line">redis＞SADD key 2</div><div class="line">QUEUED</div><div class="line">redis＞SET key 3</div><div class="line">QUEUED</div><div class="line">redis＞EXEC</div><div class="line">1) OK</div><div class="line">2) (error) ERR Operation against a key holding the wrong kind of value</div><div class="line">3) OK</div><div class="line">redis＞GET key</div><div class="line"><span class="string">"3"</span></div></pre></td></tr></table></figure></p>
<p>可见虽然SADD key 2出现了错误，但是SET key 3依然执行了。</p>
<p>Redis的事务没有关系数据库事务提供的回滚（rollback）功能。为此开发者必须在事务执行出错后自己收拾剩下的摊子（将数据库复原回事务执行前的状态等,这里我们一般采取日志记录然后业务补偿的方式来处理，但是一般情况下，在redis做的操作不应该有这种强一致性要求的需求，我们认为这种需求为不合理的设计）。</p>
<h1 id="Watch命令"><a href="#Watch命令" class="headerlink" title="Watch命令"></a>Watch命令</h1><p>大家可能知道redis提供了基于incr命令来操作一个整数型数值的原子递增，那么我们假设如果redis没有这个incr命令，我们该怎么实现这个incr的操作呢？</p>
<p>那么我们下面的正主<code>watch</code>就要上场了。</p>
<h2 id="如何使用watch命令"><a href="#如何使用watch命令" class="headerlink" title="如何使用watch命令"></a>如何使用watch命令</h2><p>正常情况下我们想要对一个整形数值做修改是这么做的(伪代码实现)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val = GET mykey</div><div class="line">val = val + 1</div><div class="line">SET mykey <span class="variable">$val</span></div></pre></td></tr></table></figure></p>
<p>但是上述的代码会出现一个问题,因为上面吧正常的一个incr(原子递增操作)分为了两部分,那么在多线程(分布式)环境中，这个操作就有可能不再具有原子性了。</p>
<p>研究过java的juc包的人应该都知道cas，那么redis也提供了这样的一个机制，就是利用watch命令来实现的。</p>
<h2 id="watch命令描述"><a href="#watch命令描述" class="headerlink" title="watch命令描述"></a>watch命令描述</h2><blockquote>
<p>WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值）</p>
</blockquote>
<h2 id="利用watch实现incr"><a href="#利用watch实现incr" class="headerlink" title="利用watch实现incr"></a>利用watch实现incr</h2><p>具体做法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">WATCH mykey</div><div class="line">val = GET mykey</div><div class="line">val = val + 1</div><div class="line">MULTI</div><div class="line">SET mykey <span class="variable">$val</span></div><div class="line">EXEC</div></pre></td></tr></table></figure></p>
<p>和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前，如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>由于WATCH命令的作用只是当被监控的键值被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一键值，所以在一般的情况下我们需要在EXEC执行失败后重新执行整个函数。</p>
<p>执行EXEC命令后会取消对所有键的监控，如果不想执行事务中的命令也可以使用UNWATCH命令来取消监控。</p>
<h2 id="实现一个hsetNX函数"><a href="#实现一个hsetNX函数" class="headerlink" title="实现一个hsetNX函数"></a>实现一个hsetNX函数</h2><p>我们实现的hsetNX这个功能是：仅当字段存在时才赋值。</p>
<p>为了避免竞态条件我们使用watch和事务来完成这一功能（伪代码）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">WATCH key  </div><div class="line">isFieldExists = HEXISTS key, field  </div><div class="line"><span class="keyword">if</span> isFieldExists is 1  </div><div class="line">MULTI  </div><div class="line">HSET key, field, value  </div><div class="line">EXEC  </div><div class="line"><span class="keyword">else</span>  </div><div class="line">UNWATCH  </div><div class="line"><span class="built_in">return</span> isFieldExists</div></pre></td></tr></table></figure></p>
<p>在代码中会判断要赋值的字段是否存在，如果字段不存在的话就不执行事务中的命令，但需要使用UNWATCH命令来保证下一个事务的执行不会受到影响。</p>
<p>原文地址 <a href="http://www.jianshu.com/p/361cb9cd13d5" target="_blank" rel="external">http://www.jianshu.com/p/361cb9cd13d5</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redis的事务&quot;&gt;&lt;a href=&quot;#redis的事务&quot; class=&quot;headerlink&quot; title=&quot;redis的事务&quot;&gt;&lt;/a&gt;redis的事务&lt;/h1&gt;&lt;p&gt;严格意义来讲,redis的事务和我们理解的传统数据库(如mysql)的事务是不一样的。&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出MappedByteBuffer</title>
    <link href="http://idiotsky.me/2016/08/23/java-mapped-byte-buffer/"/>
    <id>http://idiotsky.me/2016/08/23/java-mapped-byte-buffer/</id>
    <published>2016-08-22T16:36:51.000Z</published>
    <updated>2017-08-22T17:09:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java io操作中通常采用<code>BufferedReader</code>，<code>BufferedInputStream</code>等带缓冲的IO类处理大文件，不过java nio中引入了一种基于<code>MappedByteBuffer</code>操作大文件的方式，其读写性能极高，本文会介绍其性能如此高的内部实现原理。<br><a id="more"></a></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>在深入MappedByteBuffer之前，先看看计算机内存管理的几个术语：</p>
<ul>
<li><strong>MMC</strong>：CPU的内存管理单元。</li>
<li><strong>物理内存</strong>：即内存条的内存空间。</li>
<li><strong>虚拟内存</strong>：计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</li>
<li><strong>页面文件</strong>：操作系统反映构建并使用虚拟内存的硬盘空间大小而创建的文件，在windows下，即pagefile.sys文件，其存在意味着物理内存被占满后，将暂时不用的数据移动到硬盘上。</li>
<li><strong>缺页中断</strong>：当程序试图访问已映射在虚拟地址空间中但未被加载至物理内存的一个分页时，由MMC发出的中断。如果操作系统判断此次访问是有效的，则尝试将相关的页从虚拟内存文件中载入物理内存。</li>
</ul>
<p><strong>为什么会有虚拟内存和物理内存的区别？</strong><br>如果正在运行的一个进程，它所需的内存是有可能大于内存条容量之和的，如内存条是256M，程序却要创建一个2G的数据区，那么所有数据不可能都加载到内存（物理内存），必然有数据要放到其他介质中（比如硬盘），待进程需要访问那部分数据时，再调度进入物理内存。</p>
<p><strong>什么是虚拟内存地址和物理内存地址？</strong><br>假设你的计算机是32位，那么它的地址总线是32位的，也就是它可以寻址0~0xFFFFFFFF（4G）的地址空间，但如果你的计算机只有256M的物理内存0x~0x0FFFFFFF（256M），同时你的进程产生了一个不在这256M地址空间中的地址，那么计算机该如何处理呢？回答这个问题前，先说明计算机的内存分页机制。</p>
<p>计算机会对虚拟内存地址空间（32位为4G）进行分页产生页（page），对物理内存地址空间（假设256M）进行分页产生页帧（page frame），页和页帧的大小一样，所以虚拟内存页的个数势必要大于物理内存页帧的个数。在计算机上有一个页表（page table），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射，而且是一对一的映射。<br>问题来了，虚拟内存页的个数 &gt; 物理内存页帧的个数，岂不是有些虚拟内存页的地址永远没有对应的物理内存地址空间？不是的，操作系统是这样处理的。操作系统有个页面失效（page fault）功能。操作系统找到一个最少使用的页帧，使之失效，并把它写入磁盘，随后把需要访问的页放到页帧中，并修改页表中的映射，保证了所有的页都会被调度。</p>
<p>现在来看看什么是虚拟内存地址和物理内存地址：</p>
<ul>
<li>虚拟内存地址：由页号（与页表中的页号关联）和偏移量（页的小大，即这个页能存多少数据）组成。</li>
</ul>
<p>举个例子，有一个虚拟地址它的页号是4，偏移量是20，那么他的寻址过程是这样的：首先到页表中找到页号4对应的页帧号（比如为8），如果页不在内存中，则用失效机制调入页，接着把页帧号和偏移量传给MMC组成一个物理上真正存在的地址，最后就是访问物理内存的数据了。</p>
<h1 id="MappedByteBuffer是什么"><a href="#MappedByteBuffer是什么" class="headerlink" title="MappedByteBuffer是什么"></a>MappedByteBuffer是什么</h1><p>从继承结构上看，MappedByteBuffer继承自ByteBuffer，内部维护了一个逻辑地址address。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通过MappedByteBuffer读取文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D://data.txt"</span>);</div><div class="line">        <span class="keyword">long</span> len = file.length();</div><div class="line">        <span class="keyword">byte</span>[] ds = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) len];</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            MappedByteBuffer mappedByteBuffer = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>)</div><div class="line">                    .getChannel()</div><div class="line">                    .map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, len);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>; offset &lt; len; offset++) &#123;</div><div class="line">                <span class="keyword">byte</span> b = mappedByteBuffer.get();</div><div class="line">                ds[offset] = b;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Scanner scan = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> ByteArrayInputStream(ds)).useDelimiter(<span class="string">" "</span>);</div><div class="line">            <span class="keyword">while</span> (scan.hasNext()) &#123;</div><div class="line">                System.out.print(scan.next() + <span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="map过程"><a href="#map过程" class="headerlink" title="map过程"></a>map过程</h2><p>FileChannel提供了map方法把文件映射到虚拟内存，通常情况可以映射整个文件，如果文件比较大，可以进行分段映射。</p>
<ul>
<li><strong>FileChannel中的几个变量</strong>：<ul>
<li><strong>MapMode mode</strong>：内存映像文件访问的方式，共三种：<ol>
<li>MapMode.READ_ONLY：只读，试图修改得到的缓冲区将导致抛出异常。</li>
<li>MapMode.READ_WRITE：读/写，对得到的缓冲区的更改最终将写入文件；但该更改对映射到同一文件的其他程序不一定是可见的。</li>
<li>MapMode.PRIVATE：私用，可读可写,但是修改的内容不会写入文件，只是buffer自身的改变，这种能力称之为”copy on write”。</li>
</ol>
</li>
<li><strong>position</strong>：文件映射时的起始位置。</li>
<li><strong>allocationGranularity</strong>：Memory allocation size for mapping buffers，通过native函数initIDs初始化。</li>
</ul>
</li>
</ul>
<p>接下去通过分析源码，了解一下map过程的内部实现。</p>
<ol>
<li><p>通过RandomAccessFile获取FileChannel。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileChannel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</div><div class="line">        channel = FileChannelImpl.open(fd, path, <span class="keyword">true</span>, rw, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> channel;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 上述实现可以看出，由于synchronized ，只有一个线程能够初始化FileChannel。</p>
</li>
<li><p>通过FileChannel.map方法，把文件映射到虚拟内存，并返回逻辑地址address，实现如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">**只保留了核心代码**</div><div class="line"><span class="function"><span class="keyword">public</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode, <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span>  </span></div><div class="line"><span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">int</span> pagePosition = (<span class="keyword">int</span>)(position % allocationGranularity);</div><div class="line">    <span class="keyword">long</span> mapPosition = position - pagePosition;</div><div class="line">    <span class="keyword">long</span> mapSize = size + pagePosition;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        addr = map0(imode, mapPosition, mapSize);</div><div class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</div><div class="line">        System.gc();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">100</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException y) &#123;</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            addr = map0(imode, mapPosition, mapSize);</div><div class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError y) &#123;</div><div class="line">            <span class="comment">// After a second OOME, fail</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Map failed"</span>, y);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> isize = (<span class="keyword">int</span>)size;</div><div class="line">    Unmapper um = <span class="keyword">new</span> Unmapper(addr, mapSize, isize, mfd);</div><div class="line">    <span class="keyword">if</span> ((!writable) || (imode == MAP_RO)) &#123;</div><div class="line">        <span class="keyword">return</span> Util.newMappedByteBufferR(isize,</div><div class="line">                                        addr + pagePosition,</div><div class="line">                                        mfd,</div><div class="line">                                        um);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> Util.newMappedByteBuffer(isize,</div><div class="line">                                        addr + pagePosition,</div><div class="line">                                        mfd,</div><div class="line">                                        um);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 上述代码可以看出，最终map通过native函数map0完成文件的映射工作。</p>
<ol>
<li>如果第一次文件映射导致OOM，则手动触发垃圾回收，休眠100ms后再次尝试映射，如果失败，则抛出异常。</li>
<li><p>通过newMappedByteBuffer方法初始化MappedByteBuffer实例，不过其最终返回的是DirectByteBuffer的实例，实现如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> MappedByteBuffer <span class="title">newMappedByteBuffer</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">long</span> addr, FileDescriptor fd, Runnable unmapper)</span> </span>&#123;</div><div class="line">MappedByteBuffer dbb;</div><div class="line"><span class="keyword">if</span> (directByteBufferConstructor == <span class="keyword">null</span>)</div><div class="line">initDBBConstructor();</div><div class="line">dbb = (MappedByteBuffer)directByteBufferConstructor.newInstance(</div><div class="line"><span class="keyword">new</span> Object[] &#123; <span class="keyword">new</span> Integer(size),</div><div class="line">                <span class="keyword">new</span> Long(addr),</div><div class="line">                fd,</div><div class="line">                unmapper &#125;</div><div class="line"><span class="keyword">return</span> dbb;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 访问权限</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initDBBConstructor</span><span class="params">()</span> </span>&#123;</div><div class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    Class&lt;?&gt; cl = Class.forName(<span class="string">"java.nio.DirectByteBuffer"</span>);</div><div class="line">        Constructor&lt;?&gt; ctor = cl.getDeclaredConstructor(</div><div class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; <span class="keyword">int</span>.class,</div><div class="line">                            <span class="keyword">long</span>.class,</div><div class="line">                            FileDescriptor.class,</div><div class="line">                            Runnable.class &#125;);</div><div class="line">        ctor.setAccessible(<span class="keyword">true</span>);</div><div class="line">        directByteBufferConstructor = ctor;</div><div class="line">&#125;&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 由于FileChannelImpl和DirectByteBuffer不在同一个包中，所以有权限访问问题，通过AccessController类获取DirectByteBuffer的构造器进行实例化。<br> DirectByteBuffer是MappedByteBuffer的一个子类，其实现了对内存的直接操作。</p>
</li>
</ol>
</li>
</ol>
<h2 id="get过程"><a href="#get过程" class="headerlink" title="get过程"></a>get过程</h2><p>MappedByteBuffer的get方法最终通过DirectByteBuffer.get方法实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((unsafe.getByte(ix(nextGetIndex()))));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((unsafe.getByte(ix(checkIndex(i)))));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> address + (i &lt;&lt; <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>map0()函数返回一个地址address，这样就无需调用read或write方法对文件进行读写，通过address就能够操作文件。底层采用unsafe.getByte方法，通过（address + 偏移量）获取指定内存的数据。</p>
<ol>
<li>第一次访问address所指向的内存区域，导致缺页中断，中断响应函数会在交换区中查找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则从硬盘上将文件指定页读取到物理内存中（非jvm堆内存）。</li>
<li>如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘的虚拟内存中。</li>
</ol>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>从代码层面上看，从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，并且数据拷贝操作是由文件系统和硬件驱动实现的，理论上来说，拷贝数据的效率是一样的。<br>但是通过内存映射的方法访问硬盘上的文件，效率要比read和write系统调用高，这是为什么？</p>
<ul>
<li>read()是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝；</li>
<li>map()也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝。</li>
</ul>
<p>所以，采用内存映射的读写效率要比传统的read/write性能高。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>MappedByteBuffer使用虚拟内存，因此分配(map)的内存大小不受JVM的-Xmx参数限制，但是也是有大小限制的。</li>
<li>如果当文件超出1.5G限制时，可以通过position参数重新map文件后面的内容。</li>
<li>MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。<br>javadoc中也提到：<strong>A mapped byte buffer and the file mapping that it represents remain* valid until the buffer itself is garbage-collected</strong>.</li>
</ol>
<p>原文：<a href="http://www.jianshu.com/p/f90866dcbffc" target="_blank" rel="external">http://www.jianshu.com/p/f90866dcbffc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;java io操作中通常采用&lt;code&gt;BufferedReader&lt;/code&gt;，&lt;code&gt;BufferedInputStream&lt;/code&gt;等带缓冲的IO类处理大文件，不过java nio中引入了一种基于&lt;code&gt;MappedByteBuffer&lt;/code&gt;操作大文件的方式，其读写性能极高，本文会介绍其性能如此高的内部实现原理。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程(二) 同步和锁</title>
    <link href="http://idiotsky.me/2016/08/20/java-thread-2-md/"/>
    <id>http://idiotsky.me/2016/08/20/java-thread-2-md/</id>
    <published>2016-08-20T14:55:34.000Z</published>
    <updated>2017-08-20T08:06:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>记录，汇总</p>
</blockquote>
<a id="more"></a>
<h1 id="线程同步问题的产生"><a href="#线程同步问题的产生" class="headerlink" title="线程同步问题的产生"></a>线程同步问题的产生</h1><p>什么是线程同步问题，我们先来看一段卖票系统的代码，然后再分析这个问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> num = <span class="number">100</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    Thread.sleep(<span class="number">10</span>);</div><div class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)</div><div class="line">                &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//输出卖票信息</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">".....sale...."</span>+num--);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面是卖票线程类，下来再来看看执行类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TickeDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        TicketSeller t = <span class="keyword">new</span> TicketSeller();<span class="comment">//创建一个线程任务对象。</span></div><div class="line"></div><div class="line">        <span class="comment">//创建4个线程同时卖票</span></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(t);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(t);</div><div class="line">        Thread t3 = <span class="keyword">new</span> Thread(t);</div><div class="line">        Thread t4 = <span class="keyword">new</span> Thread(t);</div><div class="line">        <span class="comment">//启动线程</span></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        t4.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行程序结果如下（仅截取部分数据）：<br><a href="/images/java-thread-2-1.png"><img src="/images/java-thread-2-1.png" alt=""></a><br>从运行结果，我们就可以看出我们3个售票窗口同时卖出了96号票，这显然是不合逻辑的，其实这个问题就是我们前面所说的线程同步问题。不同的线程都对同一个数据进了操作这就容易导致数据错乱的问题，也就是线程不同步。那么这个问题该怎么解决呢？在给出解决思路之前我们先来分析一下这个问题是怎么产生的？我们声明一个线程类TicketSeller，在这个类中我们又声明了一个成员变量num也就是票的数量，然后我们通过run方法不断的去获取票数并输出，最后我们在外部类TicketDemo中创建了四个线程同时操作这个数据，运行后就出现我们刚才所说的线程同步问题，从这里我们可以看出产生线程同步(线程安全)问题的条件有两个：1.多个线程在操作共享的数据（num），2.操作共享数据的线程代码有多条（4条线程）；既然原因知道了，那该怎么解决？</p>
<blockquote>
<p>解决思路：将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。 好了，思路知道了，我们就用java代码的方式来解决这个问题。</p>
</blockquote>
<h1 id="解决线程同步的两种典型方案"><a href="#解决线程同步的两种典型方案" class="headerlink" title="解决线程同步的两种典型方案"></a>解决线程同步的两种典型方案</h1><p>在java中有两种机制可以防止线程安全的发生，Java语言提供了一个synchronized关键字来解决这问题，同时在Java SE5.0引入了Lock锁对象的相关类，接下来我们分别介绍这两种方法</p>
<h2 id="通过锁（Lock）对象的方式解决线程安全问题"><a href="#通过锁（Lock）对象的方式解决线程安全问题" class="headerlink" title="通过锁（Lock）对象的方式解决线程安全问题"></a>通过锁（Lock）对象的方式解决线程安全问题</h2><p>在给出解决代码前我们先来介绍一个知识点：Lock，锁对象。在java中锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但有的锁可以允许多个线程并发访问共享资源，比如读写锁，后面我们会分析）。在Lock接口出现之前，java程序是靠synchronized关键字（后面分析）实现锁功能的，而JAVA SE5.0之后并发包中新增了Lock接口用来实现锁的功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁，缺点就是缺少像synchronized那样隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。接下来我们就来介绍Lock接口的主要API方便我们学习</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>相关描述内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td>void lock()</td>
<td>获取锁，调用该方法当前线程会获取锁，当获取锁后。从该方法返回</td>
</tr>
<tr>
<td>void lockInterruptibly() throws InterruptedException</td>
<td>可中断获取锁和lock()方法不同的是该方法会响应中断，即在获取锁中可以中断当前线程。例如某个线程在等待一个锁的控制权的这段时间需要中断。</td>
</tr>
<tr>
<td>boolean tryLock()</td>
<td>尝试非阻塞获取锁，调用该方法后立即返回，如果能够获取锁则返回true，否则返回false。</td>
</tr>
<tr>
<td>boolean tryLock(long time,TimeUnit unit) throws  InterruptedException</td>
<td>超时获取锁，当前线程在以下3种情况返回：1.当前线程在超时时间内获取了锁2.当前线程在超时时间被中断3.当前线程超时时间结束，返回false</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
<tr>
<td>Condition newCondition()</td>
<td>条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁。</td>
</tr>
</tbody>
</table>
<p>这里先介绍一下API，接下来我们将结合Lock接口的实现子类ReentrantLock来讲解下他的几个方法。</p>
<h3 id="ReentrantLock（重入锁"><a href="#ReentrantLock（重入锁" class="headerlink" title="ReentrantLock（重入锁)"></a>ReentrantLock（重入锁)</h3><p>重入锁，顾名思义就是支持重新进入的锁，它表示该锁能够支持一个线程对资源的重复加锁，也就是说在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞，同时还支持获取锁的公平性和非公平性。这里的公平是在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平锁，反之，是不公平的(但是如果不是需要，建议不要用公平锁，因为会造成一些资源的没必要等待，浪费性能)。那么该如何使用呢？看范例代码：<br>1.同步执行的代码跟synchronized类似功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//参数默认false，不公平锁    </span></div><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">//公平锁    </span></div><div class="line">    </div><div class="line">lock.lock(); <span class="comment">//如果被其它资源锁定，会在此等待锁释放，达到暂停的效果    </span></div><div class="line"><span class="keyword">try</span> &#123;    </div><div class="line">    <span class="comment">//操作    </span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;    </div><div class="line">    lock.unlock();  <span class="comment">//释放锁  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.防止重复执行代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();    </div><div class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;  <span class="comment">//如果已经被lock，则立即返回false不会等待，达到忽略操作的效果     </span></div><div class="line">    <span class="keyword">try</span> &#123;    </div><div class="line">        <span class="comment">//操作    </span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;    </div><div class="line">        lock.unlock();    </div><div class="line">   &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.尝试等待执行的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">//公平锁    </span></div><div class="line"><span class="keyword">try</span> &#123;    </div><div class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;        </div><div class="line">        <span class="comment">//如果已经被lock，尝试等待5s，看是否可以获得锁，如果5s后仍然无法获得锁则返回false继续执行    </span></div><div class="line">       <span class="keyword">try</span> &#123;    </div><div class="line">            <span class="comment">//操作    </span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;    </div><div class="line">            lock.unlock();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;    </div><div class="line">    e.printStackTrace(); <span class="comment">//当前线程被中断时(interrupt)，会抛InterruptedException                     </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有点需要特别注意的，把解锁操作放在finally代码块内这个十分重要。如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。好了，ReentrantLock我们就简单介绍到这里，接下来我们通过ReentrantLock来解决前面卖票线程的线程同步（安全）问题，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSellerWithLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//创建锁对象</span></div><div class="line">    <span class="keyword">private</span> Lock ticketLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="comment">//创建锁对象(公平锁)</span></div><div class="line">    <span class="comment">//private Lock ticketLock = new ReentrantLock(true);</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> num = <span class="number">100</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            ticketLock.lock();<span class="comment">//获取锁</span></div><div class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    Thread.sleep(<span class="number">10</span>);</div><div class="line">                    <span class="comment">//输出卖票信息</span></div><div class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">".....sale...."</span>+num--);</div><div class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)</div><div class="line">                &#123;</div><div class="line">                    Thread.currentThread().interrupt();<span class="comment">//继续中断异常</span></div><div class="line">                &#125;<span class="keyword">finally</span> &#123;</div><div class="line">                    ticketLock.unlock();<span class="comment">//释放锁</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                ticketLock.unlock();<span class="comment">//释放锁</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TicketDemo类无需变化，线程安全问题就此解决。<br>但是还是要说一下公平锁的问题，上面例子，不开公平锁的结果如下：<br><a href="/images/java-thread-2-2.png"><img src="/images/java-thread-2-2.png" alt=""></a><br>开公平锁的结果如下：<br><a href="/images/java-thread-2-3.png"><img src="/images/java-thread-2-3.png" alt=""></a><br><em>你会发现不开公平锁，cpu钟爱用第一个线程做事情，而开了公平锁后，基本是各个线程交替执行。上面提到公平锁是会消耗性能的，如果CPU调度的时候选择的不是公平调度的那个线程，CPU会放弃本次调度，干别的事情，如果老是调度不到的话，是浪费CPU调度的。</em></p>
<h2 id="通过synchronied关键字的方式解决线程安全问题"><a href="#通过synchronied关键字的方式解决线程安全问题" class="headerlink" title="通过synchronied关键字的方式解决线程安全问题"></a>通过synchronied关键字的方式解决线程安全问题</h2><p>在Java中内置了语言级的同步原语－synchronized，这个可以大大简化了Java中多线程同步的使用。从JAVA SE1.0开始，java中的每一个对象都有一个内部锁，如果一个方法使用synchronized关键字进行声明，那么这个对象将保护整个方法，也就是说调用该方法线程必须获得内部的对象锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> method&#123;  </div><div class="line">  <span class="comment">//method body  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Lock ticketLock = <span class="keyword">new</span> ReentrantLock();  </div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> method&#123;  </div><div class="line"> ticketLock.lock();  </div><div class="line"> <span class="keyword">try</span>&#123;  </div><div class="line">  <span class="comment">//.......  </span></div><div class="line"> &#125;<span class="keyword">finally</span>&#123;  </div><div class="line">   ticketLock.unlock();  </div><div class="line"> &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这里可以看出使用synchronized关键字来编写代码要简洁得多了。当然，要理解这一代码，我们必须知道每个对象有一个内部锁，并且该锁有一个内部条件。由锁来管理那些试图进入synchronized方法的线程，由条件来管那些调用wait的线程(wait()/notifyAll/notify())。同时我们必须明白一旦有一个线程通过synchronied方法获取到内部锁，该类的所有synchronied方法或者代码块都无法被其他线程访问直到当前线程释放了内部锁。刚才上面说的是同步方法，synchronized还有一种同步代码块的实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Object obj = <span class="keyword">new</span> Object();  </div><div class="line"><span class="keyword">synchronized</span>(obj)&#123;  </div><div class="line">  <span class="comment">//需要同步的代码  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中obj是对象锁，可以是任意对象。那么我们就通过其中的一个方法来解决售票系统的线程同步问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> num = <span class="number">100</span>;  </div><div class="line">    Object obj = <span class="keyword">new</span> Object();  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">synchronized</span>(obj)  </div><div class="line">            &#123;  </div><div class="line">                <span class="keyword">if</span>(num&gt;<span class="number">0</span>)  </div><div class="line">                &#123;  </div><div class="line">                    <span class="keyword">try</span>&#123;Thread.sleep(<span class="number">10</span>);&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;&#125;  </div><div class="line">                      </div><div class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">".....sale...."</span>+num--);  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>嗯，同步代码块解决，运行结果也正常。到此同步问题也就解决了，当然代码同步也是要牺牲效率为前提的：<br>同步的好处：解决了线程的安全问题。<br>同步的弊端：相对降低了效率，因为同步外的线程的都会判断同步锁。<br>同步的前提：同步中必须有多个线程并使用同一个锁。</p>
<h1 id="线程间的通信机制"><a href="#线程间的通信机制" class="headerlink" title="线程间的通信机制"></a>线程间的通信机制</h1><p>线程开始运行，拥有自己的栈空间，但是如果每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者是价值很小，如果多线程能够相互配合完成工作的话，这将带来巨大的价值，这也就是线程间的通信啦。在java中多线程间的通信使用的是等待/通知机制来实现的。</p>
<h2 id="synchronied关键字等待-通知机制"><a href="#synchronied关键字等待-通知机制" class="headerlink" title="synchronied关键字等待/通知机制"></a>synchronied关键字等待/通知机制</h2><p>是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述的两个线程通过对象O来完成交互，而对象上的wait()和notify()/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。<br>等待/通知机制主要是用到的函数方法是notify()/notifyAll(),wait()/wait(long),wait(long,int),这些方法在上一篇文章都有说明过，这里就不重复了。当然这是针对synchronied关键字修饰的函数或代码块，因为要使用notify()/notifyAll(),wait()/wait(long),wait(long,int)这些方法的前提是对调用对象加锁，也就是说只能在同步函数或者同步代码块中使用。</p>
<h2 id="条件对象的等待-通知机制"><a href="#条件对象的等待-通知机制" class="headerlink" title="条件对象的等待/通知机制"></a>条件对象的等待/通知机制</h2><p>所谓的条件对象也就是配合前面我们分析的Lock锁对象，通过锁对象的条件对象来实现等待/通知机制。那么条件对象是怎么创建的呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建条件对象  </span></div><div class="line">Condition conditionObj=ticketLock.newCondition();</div></pre></td></tr></table></figure></p>
<p>就这样我们创建了一个条件对象。注意这里返回的对象是与该锁（ticketLock）相关的条件对象。下面是条件对象的API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>函数方法对应的描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>void await()</td>
<td>将该线程放到条件等待池中（对应wait()方法）</td>
</tr>
<tr>
<td>void signalAll()</td>
<td>解除该条件等待池中所有线程的阻塞状态（对应notifyAll()方法）</td>
</tr>
<tr>
<td>void signal()</td>
<td>从该条件的等待池中随机地选择一个线程，解除其阻塞状态（对应notify()方法）</td>
</tr>
</tbody>
</table>
<p>上述方法的过程分析：一个线程A调用了条件对象的await()方法进入等待状态，而另一个线程B调用了条件对象的signal()或者signalAll()方法，线程A收到通知后从条件对象的await()方法返回，进而执行后续操作。上述的两个线程通过条件对象来完成交互，而对象上的await()和signal()/signalAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。当然这样的操作都是必须基于条件对象的锁的，当前线程只有获取了锁，才能调用该条件对象的await()方法，而调用后，当前线程将释放锁。</p>
<p>这里有点要特别注意的是，上述两种等待/通知机制中，无论是调用了signal()/signalAll()方法还是调用了notify()/notifyAll()方法并不会立即激活一个等待线程。它们仅仅都只是解除等待线程的阻塞状态，以便这些线程可以在当前线程解锁或者退出同步方法后，通过争夺CPU执行权实现对对象的访问。到此，线程通信机制的概念分析完，我们下面通过生产者消费者模式来实现等待/通知机制。</p>
<h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><h2 id="单生产者单消费者模式"><a href="#单生产者单消费者模式" class="headerlink" title="单生产者单消费者模式"></a>单生产者单消费者模式</h2><p>顾名思义，就是一个线程消费，一个线程生产。我们先来看看等待/通知机制下的生产者消费者模式：我们假设这样一个场景，我们是卖北京烤鸭店铺，我们现在只有一条生产线也只有一条消费线，也就是说只能生产线程生产完了，再通知消费线程才能去卖，如果消费线程没烤鸭了，就必须通知生产线程去生产，此时消费线程进入等待状态。在这样的场景下，我们不仅要保证共享数据（烤鸭数量）的线程安全，而且还要保证烤鸭数量在消费之前必须有烤鸭。下面我们通过java代码来实现：<br>北京烤鸭生产资源类KaoYaResource：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaoYaResource</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;<span class="comment">//烤鸭的初始数量  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//判断是否有需要线程等待的标志  </span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 生产烤鸭 </div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="comment">//此时有烤鸭，等待  </span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace()</div><div class="line">                ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.name=name+count;<span class="comment">//设置烤鸭的名称  </span></div><div class="line">        count++;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者..."</span>+<span class="keyword">this</span>.name);</div><div class="line">        flag=<span class="keyword">true</span>;<span class="comment">//有烤鸭后改变标志  </span></div><div class="line">        notifyAll();<span class="comment">//通知消费线程可以消费了  </span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 消费烤鸭 </div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(!flag)&#123;<span class="comment">//如果没有烤鸭就等待  </span></div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者........"</span>+<span class="keyword">this</span>.name);<span class="comment">//消费烤鸭1  </span></div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">        notifyAll();<span class="comment">//通知生产者生产烤鸭  </span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个类中我们有两个synchronized的同步方法，一个是生产烤鸭的，一个是消费烤鸭的，之所以需要同步是因为我们操作了共享数据count，同时为了保证生产烤鸭后才能消费也就是生产一只烤鸭后才能消费一只烤鸭，我们使用了等待/通知机制，wait()和notify()。当第一次运行生产现场时调用生产的方法，此时有一只烤鸭，即flag=false，无需等待，因此我们设置可消费的烤鸭名称然后改变flag=true，同时通知消费线程可以消费烤鸭了，即使此时生产线程再次抢到执行权，因为flag=true，所以生产线程会进入等待阻塞状态，消费线程被唤醒后就进入消费方法，消费完成后，又改变标志flag=false，通知生产线程可以生产烤鸭了………以此循环。<br>生产消费执行类Single_Producer_Consumer.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single_Producer_Consumer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        KaoYaResource r = <span class="keyword">new</span> KaoYaResource();</div><div class="line">        Producer pro = <span class="keyword">new</span> Producer(r);</div><div class="line">        Consumer con = <span class="keyword">new</span> Consumer(r);</div><div class="line">        <span class="comment">//生产者线程</span></div><div class="line">        Thread t0 = <span class="keyword">new</span> Thread(pro);</div><div class="line">        <span class="comment">//消费者线程</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(con);</div><div class="line">        <span class="comment">//启动线程</span></div><div class="line">        t0.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> KaoYaResource r;</div><div class="line">    Producer(KaoYaResource r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.r = r;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            r.product(<span class="string">"北京烤鸭"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> KaoYaResource r;</div><div class="line">    Consumer(KaoYaResource r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.r = r;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            r.consume();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个类中我们创建两个线程，一个是消费者线程，一个是生产者线程，我们分别开启这两个线程用于不断的生产消费，运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">hread-0...生产者...北京烤鸭1</div><div class="line">Thread-1...消费者........北京烤鸭1</div><div class="line">Thread-0...生产者...北京烤鸭2</div><div class="line">Thread-1...消费者........北京烤鸭2</div><div class="line">Thread-0...生产者...北京烤鸭3</div><div class="line">Thread-1...消费者........北京烤鸭3</div><div class="line">Thread-0...生产者...北京烤鸭4</div><div class="line">Thread-1...消费者........北京烤鸭4</div><div class="line">Thread-0...生产者...北京烤鸭5</div><div class="line">Thread-1...消费者........北京烤鸭5</div><div class="line">Thread-0...生产者...北京烤鸭6</div><div class="line">Thread-1...消费者........北京烤鸭6</div><div class="line">Thread-0...生产者...北京烤鸭7</div><div class="line">Thread-1...消费者........北京烤鸭7</div><div class="line">Thread-0...生产者...北京烤鸭8</div><div class="line">Thread-1...消费者........北京烤鸭8</div><div class="line">Thread-0...生产者...北京烤鸭9</div><div class="line">Thread-1...消费者........北京烤鸭9</div><div class="line">.....</div></pre></td></tr></table></figure></p>
<p>很显然的情况就是生产一只烤鸭然后就消费一只烤鸭。运行情况完全正常，嗯，这就是单生产者单消费者模式。上面使用的是synchronized关键字的方式实现的，那么接下来我们使用对象锁的方式实现：KaoYaResourceByLock.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaoYaResourceByLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;<span class="comment">//烤鸭的初始数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//判断是否有需要线程等待的标志</span></div><div class="line">    <span class="comment">//创建一个锁对象</span></div><div class="line">    <span class="keyword">private</span> Lock resourceLock=<span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="comment">//创建条件对象</span></div><div class="line">    <span class="keyword">private</span> Condition condition= resourceLock.newCondition();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 生产烤鸭</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">product</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        resourceLock.lock();<span class="comment">//先获取锁</span></div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">if</span>(flag)&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    condition.await();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.name=name+count;<span class="comment">//设置烤鸭的名称</span></div><div class="line">            count++;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者..."</span>+<span class="keyword">this</span>.name);</div><div class="line">            flag=<span class="keyword">true</span>;<span class="comment">//有烤鸭后改变标志</span></div><div class="line">            condition.signalAll();<span class="comment">//通知消费线程可以消费了</span></div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            resourceLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 消费烤鸭</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</div><div class="line">        resourceLock.lock();</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">if</span>(!flag)&#123;<span class="comment">//如果没有烤鸭就等待</span></div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    condition.await();</div><div class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者........"</span>+<span class="keyword">this</span>.name);<span class="comment">//消费烤鸭1</span></div><div class="line">            flag = <span class="keyword">false</span>;</div><div class="line">            condition.signalAll();<span class="comment">//通知生产者生产烤鸭</span></div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            resourceLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码变化不大，我们通过对象锁的方式去实现，首先要创建一个对象锁，我们这里使用的重入锁ReestrantLock类，然后通过手动设置lock()和unlock()的方式去获取锁以及释放锁。为了实现等待/通知机制，我们还必须通过锁对象去创建一个条件对象Condition，然后通过锁对象的await()和signalAll()方法去实现等待以及通知操作。Single_Producer_Consumer.java代码替换一下资源类即可,运行结果一样。</p>
<h2 id="多生产者多消费者模式"><a href="#多生产者多消费者模式" class="headerlink" title="多生产者多消费者模式"></a>多生产者多消费者模式</h2><p>分析完了单生产者单消费者模式，我们再来聊聊多生产者多消费者模式，也就是多条生产线程配合多条消费线程。既然这样的话我们先把上面的代码Single_Producer_Consumer.java类修改成新类，大部分代码不变，仅新增2条线程去跑，一条t1的生产  共享资源类KaoYaResource不作更改，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutil_Producer_Consumer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        KaoYaResource r = <span class="keyword">new</span> KaoYaResource();</div><div class="line">        Mutil_Producer pro = <span class="keyword">new</span> Mutil_Producer(r);</div><div class="line">        Mutil_Consumer con = <span class="keyword">new</span> Mutil_Consumer(r);</div><div class="line">        <span class="comment">//生产者线程</span></div><div class="line">        Thread t0 = <span class="keyword">new</span> Thread(pro);</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(pro);</div><div class="line">        <span class="comment">//消费者线程</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(con);</div><div class="line">        Thread t3 = <span class="keyword">new</span> Thread(con);</div><div class="line">        <span class="comment">//启动线程</span></div><div class="line">        t0.start();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutil_Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> KaoYaResource r;</div><div class="line">    Mutil_Producer(KaoYaResource r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.r = r;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            r.product(<span class="string">"北京烤鸭"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutil_Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> KaoYaResource r;</div><div class="line">    Mutil_Consumer(KaoYaResource r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.r = r;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            r.consume();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就多了两条线程，我们运行代码看看，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Thread-0...生产者...北京烤鸭63</div><div class="line">Thread-2...消费者........北京烤鸭63</div><div class="line">Thread-3...消费者........北京烤鸭63  <span class="comment">#消费两次了</span></div><div class="line">......</div><div class="line">......</div><div class="line">Thread-0...生产者...北京烤鸭67     <span class="comment">#没有被消费</span></div><div class="line">Thread-1...生产者...北京烤鸭68     </div><div class="line">Thread-2...消费者........北京烤鸭68</div><div class="line">Thread-0...生产者...北京烤鸭69</div></pre></td></tr></table></figure></p>
<p>不对呀，我们才生产一只烤鸭，怎么就被消费了2次啊，有的烤鸭生产了也没有被消费啊？难道共享数据源没有进行线程同步？回顾下KaoYaResource.java<br>共享数据count的获取方法都进行synchronized关键字同步了呀！那怎么还会出现数据混乱的现象啊？<br>分析：确实，我们对共享数据也采用了同步措施，而且也应用了等待/通知机制，但是这样的措施只在单生产者单消费者的情况下才能正确应用，但从运行结果来看，我们之前的单生产者单消费者安全处理措施就不太适合多生产者多消费者的情况了。那么问题出在哪里？可以明确的告诉大家，肯定是在资源共享类，下面我们就来分析问题是如何出现，又该如何解决？直接上图<br><a href="/images/java-thread-2-4.png"><img src="/images/java-thread-2-4.png" alt=""></a></p>
<p>解决后的资源代码如下只将if改为了while：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaoYaResourceByMulti</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;<span class="comment">//烤鸭的初始数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//判断是否有需要线程等待的标志</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 生产烤鸭</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">while</span> (flag)&#123;</div><div class="line">            <span class="comment">//此时有烤鸭，等待</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace()</div><div class="line">                ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.name=name+count;<span class="comment">//设置烤鸭的名称</span></div><div class="line">        count++;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者..."</span>+<span class="keyword">this</span>.name);</div><div class="line">        flag=<span class="keyword">true</span>;<span class="comment">//有烤鸭后改变标志</span></div><div class="line">        notifyAll();<span class="comment">//通知消费线程可以消费了</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 消费烤鸭</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span> (!flag)&#123;<span class="comment">//如果没有烤鸭就等待</span></div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者........"</span>+<span class="keyword">this</span>.name);<span class="comment">//消费烤鸭1</span></div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">        notifyAll();<span class="comment">//通知生产者生产烤鸭</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果跟单线程那个一致，就不贴了。<br>到此，多消费者多生产者模式也完成，不过上面用的是synchronied关键字实现的，而锁对象的解决方法也一样将之前单消费者单生产者的资源类中的if判断改为while判断即可代码就不贴了哈。不过下面我们将介绍一种更有效的锁对象解决方法，我们准备使用两组条件对象（Condition也称为监视器）来实现等待/通知机制，也就是说通过已有的锁获取两组监视器，一组监视生产者，一组监视消费者。有了前面的分析这里我们直接上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBy2Condition</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">//创建一个锁对象。  </span></div><div class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="comment">//通过已有的锁获取两组监视器，一组监视生产者，一组监视消费者。  </span></div><div class="line">    Condition producer_con = lock.newCondition();</div><div class="line">    Condition consumer_con = lock.newCondition();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 生产 </div><div class="line">     * <span class="doctag">@param</span> name</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">product</span><span class="params">(String name)</span></span></div><div class="line">    &#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(flag)&#123;</div><div class="line">                <span class="keyword">try</span>&#123;producer_con.await();&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.name = name + count;</div><div class="line">            count++;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者5.0..."</span>+<span class="keyword">this</span>.name);</div><div class="line">            flag = <span class="keyword">true</span>;</div><div class="line"><span class="comment">//          notifyAll();  </span></div><div class="line"><span class="comment">//          con.signalAll();  </span></div><div class="line">            consumer_con.signal();<span class="comment">//直接唤醒消费线程  </span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">finally</span></div><div class="line">        &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 消费 </div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(!flag)&#123;</div><div class="line">                <span class="keyword">try</span>&#123;consumer_con.await();&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者.5.0......."</span>+<span class="keyword">this</span>.name);<span class="comment">//消费烤鸭1  </span></div><div class="line">            flag = <span class="keyword">false</span>;</div><div class="line"><span class="comment">//          notifyAll();  </span></div><div class="line"><span class="comment">//          con.signalAll();  </span></div><div class="line">            producer_con.signal();<span class="comment">//直接唤醒生产线程  </span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">finally</span></div><div class="line">        &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码中可以看到，我们创建了producer_con 和consumer_con两个条件对象，分别用于监听生产者线程和消费者线程，在product()方法中，我们获取到锁后，<br>如果此时flag为true的话，也就是此时还有烤鸭未被消费，因此生产线程需要等待，所以我们调用生产线程的监控器producer_con的<br>await()的方法进入阻塞等待池；但如果此时的flag为false的话，就说明烤鸭已经消费完，需要生产线程去生产烤鸭，那么生产线程将进行烤<br>鸭生产并通过消费线程的监控器consumer_con的signal()方法去通知消费线程对烤鸭进行消费。consume()方法也是同样的道理，这里就不<br>过多分析了。我们可以发现这种方法比我们之前的synchronized同步方法或者是单监视器的锁对象都来得高效和方便些，之前都是使用<br>notifyAll()和signalAll()方法去唤醒池中的线程，然后让池中的线程又进入 竞争队列去抢占CPU资源，这样不仅唤醒了无关的线程而且又让全<br>部线程进入了竞争队列中，而我们最后使用两种监听器分别监听生产者线程和消费者线程，这样的方式恰好解决前面两种方式的问题所在，<br>我们每次唤醒都只是生产者线程或者是消费者线程而不会让两者同时唤醒，这样不就能更高效得去执行程序了吗？好了，到此多生产者多消<br>费者模式也分析完毕。</p>
<h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><p>现在我们再来讨论一下线程死锁问题，从上面的分析，我们知道锁是个非常有用的工具，运用的场景非常多，因为它使用起来非常简单，而<br>且易于理解。但同时它也会带来一些不必要的麻烦，那就是可能会引起死锁，一旦产生死锁，就会造成系统功能不可用。我们先通过一个例<br>子来分析，这个例子会引起死锁，使得线程t1和线程t2互相等待对方释放锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String A=<span class="string">"A"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String B=<span class="string">"B"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        DeadLockDemo deadLock=<span class="keyword">new</span> DeadLockDemo();</div><div class="line"></div><div class="line">        deadLock.deadLock();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span></span>&#123;</div><div class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"static-access"</span>)</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (A) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.currentThread().sleep(<span class="number">2000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (B) &#123;</div><div class="line">                        System.out.println(<span class="string">"1"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread t2 =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (B) &#123;</div><div class="line">                    <span class="keyword">synchronized</span> (A) &#123;</div><div class="line">                        System.out.println(<span class="string">"2"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="comment">//启动线程</span></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码运行基本没有输出，一直卡着。<br>同步嵌套是产生死锁的常见情景，从上面的代码中我们可以看出，当t1线程拿到锁A后，睡眠2秒，此时线程t2刚好拿到了B锁，接着要获取A锁，但是此时A锁正好被t1线程持有，因此只能等待t1线程释放锁A，但遗憾的是在t1线程内又要求获取到B锁，而B锁此时又被t2线程持有，到此结果就是t1线程拿到了锁A同时在等待t2线程释放锁B，而t2线程获取到了锁B也同时在等待t1线程释放锁A，彼此等待也就造成了线程死锁问题。虽然我们现实中一般不会向上面那么写出那样的代码，但是有些更为复杂的场景中，我们可能会遇到这样的问题，比如t1拿了锁之后，因为一些异常情况没有释放锁（死循环），也可能t1拿到一个数据库锁，释放锁的时候抛出了异常，没有释放等等，所以我们应该在写代码的时候多考虑死锁的情况，这样才能有效预防死锁程序的出现。下面我们介绍一下避免死锁的几个常见方法：</p>
<ol>
<li>避免一个线程同时获取多个锁。</li>
<li>避免在一个资源内占用多个 资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用tryLock(timeout)来代替使用内部锁机制。</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
<li>避免同步嵌套的发生</li>
</ol>
<h1 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h1><p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才能从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时的方法表示，如果线程在给定的超时时间里没有终止，那么将会从该超时方法中返回。下面给出一个例子，创建10个线程，编号0~9，每个线程调用前一个线程的join()方法，也就是线程0结束了，线程1才能从join()方法中返回，而0需要等待main线程结束。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread previous = Thread.currentThread();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="comment">//每个线程拥有前一个线程的引用。需要等待前一个线程终止，才能从等待中返回</span></div><div class="line">            Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Domino(previous),String.valueOf(i));</div><div class="line">            thread.start();</div><div class="line">            previous=thread;</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 线程结束"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Domino</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Thread thread;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Domino</span><span class="params">(Thread thread)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.thread=thread;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            thread.join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 线程结束"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">main 线程结束</div><div class="line">0 线程结束</div><div class="line">1 线程结束</div><div class="line">2 线程结束</div><div class="line">3 线程结束</div><div class="line">4 线程结束</div><div class="line">5 线程结束</div><div class="line">6 线程结束</div><div class="line">7 线程结束</div><div class="line">8 线程结束</div><div class="line">9 线程结束</div></pre></td></tr></table></figure></p>
<blockquote>
<p>结束</p>
</blockquote>
<p>参考 <a href="http://blog.csdn.net/javazejian/article/details/50878665" target="_blank" rel="external">http://blog.csdn.net/javazejian/article/details/50878665</a><br>所有代码在 <a href="https://github.com/ejunjsh/java-code/tree/master/com/sky/code/thread" target="_blank" rel="external">https://github.com/ejunjsh/java-code/tree/master/com/sky/code/thread</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录，汇总&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程(一)基础</title>
    <link href="http://idiotsky.me/2016/08/08/java-thread-1-md/"/>
    <id>http://idiotsky.me/2016/08/08/java-thread-1-md/</id>
    <published>2016-08-08T14:06:08.000Z</published>
    <updated>2017-08-20T08:07:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>对多线程复习下，汇总一下</p>
</blockquote>
<a id="more"></a>
<h1 id="什么是线程以及多线程与进程的区别"><a href="#什么是线程以及多线程与进程的区别" class="headerlink" title="什么是线程以及多线程与进程的区别"></a>什么是线程以及多线程与进程的区别</h1><p>在现代操作在运行一个程序时，会为其创建一个进程。例如启动一个QQ程序，操作系统就会为其创建一个进程。而操作系统中调度的最小单位元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器，堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。因此我们可以这样理解：<br>进程：正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。<br>线程：是进程中的单个顺序控制流，是一条执行路径一个进程如果只有一条执行路径，则称为单线程程序。一个进程如果有多条执行路径，则称为多线程程序。</p>
<h1 id="多线程的创建与启动"><a href="#多线程的创建与启动" class="headerlink" title="多线程的创建与启动"></a>多线程的创建与启动</h1><p>创建多线程有两种方法，一种是继承Thread类重写run方法，另一种是实现Runnable接口重写run方法。<br>下面我们分别给出代码示例，继承Thread类重写run方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"I'm a thread that extends Thread!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现Runnable接口重写run方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"I'm a thread that implements Runnable !"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>怎么启动线程？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartThread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        </div><div class="line">        NewThread t1=<span class="keyword">new</span> NewThread();</div><div class="line">        t1.start();</div><div class="line"></div><div class="line">        NewRunnable r=<span class="keyword">new</span> NewRunnable();</div><div class="line">        Thread t2=<span class="keyword">new</span> Thread(r);</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I&apos;m a thread that extends Thread!</div><div class="line">I&apos;m a thread that implements Runnable !</div></pre></td></tr></table></figure></p>
<p>代码相当简单，不过多解释。这里有点需要注意的是调用start()方法后并不是是立即的执行多线程的代码，而是使该线程变为可运行态，什么时候运行多线程代码是由操作系统决定的。</p>
<h1 id="中断线程和守护线程以及线程优先级"><a href="#中断线程和守护线程以及线程优先级" class="headerlink" title="中断线程和守护线程以及线程优先级"></a>中断线程和守护线程以及线程优先级</h1><h2 id="什么是中断线程？"><a href="#什么是中断线程？" class="headerlink" title="什么是中断线程？"></a>什么是中断线程？</h2><p>我们先来看看中断线程是什么？(该解释来自java核心技术一书，我对其进行稍微简化)，当线程的run()方法执行方法体中的最后一条语句后，并经由执行return语句返回时，或者出现在方法中没有捕获的异常时线程将终止。在java早期版本中有一个stop方法，其他线程可以调用它终止线程，但是这个方法现在已经被弃用了，因为这个方法会造成一些线程不安全的问题。我们可以把中断理解为一个标识位的属性，它表示一个运行中的线程是否被其他线程进行了中断操作，而中断就好比其他线程对该线程打可个招呼，其他线程通过调用该线程的interrupt方法对其进行中断操作，当一个线程调用interrupt方法时，线程的中断状态（标识位）将被置位（改变），这是每个线程都具有的boolean标志，每个线程都应该不时的检查这个标志，来判断线程是否被中断。而要判断线程是否被中断，我们可以使用如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread.currentThread().isInterrupted()</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;  </div><div class="line">    <span class="keyword">do</span> something  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果此时线程处于阻塞状态（sleep或者wait），就无法检查中断状态，此时会抛出InterruptedException异常。如果每次迭代之后都调用sleep方法（或者其他可中断的方法），isInterrupted检测就没必要也没用处了，如果在中断状态被置位时调用sleep方法，它不会休眠反而会清除这一休眠状态并抛出InterruptedException。所以如果在循环中调用sleep,不要去检测中断状态，只需捕获InterruptedException。代码范例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">while</span>(more work to <span class="keyword">do</span> )&#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                Thread.sleep(<span class="number">5000</span>);  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                <span class="comment">//thread was interrupted during sleep  </span></div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;<span class="keyword">finally</span>&#123;  </div><div class="line">                <span class="comment">//clean up , if required  </span></div><div class="line">            &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不妥的处理方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myTask</span><span class="params">()</span></span>&#123;  </div><div class="line">    ...  </div><div class="line">   <span class="keyword">try</span>&#123;  </div><div class="line">       sleep(<span class="number">50</span>)  </div><div class="line">      &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </div><div class="line">   ...  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正确的处理方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myTask</span><span class="params">()</span>throw InterruptedException</span>&#123;  </div><div class="line">    sleep(<span class="number">50</span>)  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myTask</span><span class="params">()</span></span>&#123;  </div><div class="line">    ...  </div><div class="line">    <span class="keyword">try</span>&#123;  </div><div class="line">    sleep(<span class="number">50</span>)  </div><div class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </div><div class="line">     Thread.currentThread().interrupt();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后关于中断线程，我们这里给出中断线程的一些主要方法：<br>void interrupt()：向线程发送中断请求，线程的中断状态将会被设置为true，如果当前线程被一个sleep调用阻塞，那么将会抛出interrupedException异常。<br>static boolean interrupted()：测试当前线程（当前正在执行命令的这个线程）是否被中断。注意这是个静态方法，调用这个方法会产生一个副作用那就是它会将当前线程的中断状态重置为false。<br>boolean isInterrupted()：判断线程是否被中断，这个方法的调用不会产生副作用即不改变线程的当前中断状态。<br>static Thread currentThread() : 返回代表当前执行线程的Thread对象。</p>
<p><strong>这里要注意下，为啥上面的代码，在catch之后还要在中断一次，因为catch会把当前线程的中断标志重置为false，这里不重新中断一次，上层代码就不知道中断了，程序就不知道有中断的发生，下面代码可以说明这个</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ejunjsh on 8/10/2017.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterrupt</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        Thread t= <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">5000</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line">                    <span class="comment">//catch 异常之后，输出是false</span></div><div class="line">                    System.out.println(<span class="string">"1.current interrupted flag is "</span> +Thread.currentThread().isInterrupted());</div><div class="line">                    Thread.currentThread().interrupt();</div><div class="line">                    System.out.println(<span class="string">"2.current interrupted flag is "</span> +Thread.currentThread().isInterrupted());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">5000</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line">                    System.out.println(<span class="string">"3.current interrupted flag is "</span> +Thread.currentThread().isInterrupted());</div><div class="line">                    Thread.currentThread().interrupt();</div><div class="line">                    System.out.println(<span class="string">"4.current interrupted flag is "</span> +Thread.currentThread().isInterrupted());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        t.start();</div><div class="line">        <span class="comment">//开始中断</span></div><div class="line">        t.interrupt();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            t.join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"5.current state is "</span> +t.getState());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.current interrupted flag is false</div><div class="line">2.current interrupted flag is true</div><div class="line">3.current interrupted flag is false</div><div class="line">4.current interrupted flag is true</div><div class="line">5.current state is TERMINATED</div></pre></td></tr></table></figure></p>
<p>很明显，<code>开始中断</code>后，catch的标志位被重置了。</p>
<h2 id="什么是守护线程？"><a href="#什么是守护线程？" class="headerlink" title="什么是守护线程？"></a>什么是守护线程？</h2><p>首先我们可以通过t.setDaemon(true)的方法将线程转化为守护线程。而守护线程的唯一作用就是为其他线程提供服务。计时线程就是一个典型的例子，它定时地发送“计时器滴答”信号告诉其他线程去执行某项任务。当只剩下守护线程时，虚拟机就退出了，因为如果只剩下守护线程，程序就没有必要执行了。另外JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。最后还有一点需要特别注意的是在java虚拟机退出时Daemon线程中的finally代码块并不一定会执行哦，代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deamon</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread deamon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(),<span class="string">"DaemonRunner"</span>);</div><div class="line">        <span class="comment">//设置为守护线程</span></div><div class="line">        deamon.setDaemon(<span class="keyword">true</span>);</div><div class="line">        deamon.start();<span class="comment">//启动线程</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">500</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;<span class="keyword">finally</span>&#123;</div><div class="line">                System.out.println(<span class="string">"这里的代码在java虚拟机退出时并不一定会执行哦！"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此在构建Daemon线程时，不能依靠finally代码块中的内容来确保执行关闭或清理资源的逻辑。</p>
<h2 id="什么是线程优先级"><a href="#什么是线程优先级" class="headerlink" title="什么是线程优先级"></a>什么是线程优先级</h2><p>在现代操作系统中基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下一次分配。线程分配到的时间片多少也决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。在java线程中，通过一个整型的成员变量Priority来控制线程优先级，每一个线程有一个优先级，默认情况下，一个线程继承它父类的优先级。可以用setPriority方法提高或降低任何一个线程优先级。可以将优先级设置在MIN_PRIORITY（在Thread类定义为1）与MAX_PRIORITY（在Thread类定义为10）之间的任何值。线程的默认优先级为NORM_PRIORITY（在Thread类定义为5）。尽量不要依赖优先级，如果确实要用，应该避免初学者常犯的一个错误。如果有几个高优先级的线程没有进入非活动状态，低优先级线程可能永远也不能执行。每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择，尽管这样会使低优先级的线程可能永远不会被执行到。因此我们在设置优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高的优先级，而偏重计算（需要较多CPU时间或者运算）的线程则设置较低的优先级，这样才能确保处理器不会被长久独占。当然还有要注意就是在不同的JVM以及操作系统上线程的规划存在差异，有些操作系统甚至会忽略对线程优先级的设定，如mac os系统或者Ubuntu系统……..</p>
<h1 id="线程的状态转化关系"><a href="#线程的状态转化关系" class="headerlink" title="线程的状态转化关系"></a>线程的状态转化关系</h1><p>1.新建状态（New）：新创建了一个线程对象。<br>2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。<br>3.运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。<br>4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p>
<ul>
<li>等待阻塞（WAITING）：运行的线程执行wait()方法，JVM会把该线程放入等待池中。</li>
<li>同步阻塞（Blocked）：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li>
<li>超时阻塞（TIME_WAITING）：运行的线程执行sleep(long)或join(long)方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。</li>
</ul>
<p>5.死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。<br><a href="/images/java-thread-1-1.png"><img src="/images/java-thread-1-1.png" alt=""></a><br>图中的方法解析如下：<br>Thread.sleep()：在指定时间内让当前正在执行的线程暂停执行，但不会释放”锁标志”。不推荐使用。<br>Thread.sleep(long)：使当前线程进入阻塞状态，在指定时间内不会执行。<br>Object.wait()和Object.wait(long)：在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的”锁标志”，从而使别的线程有机会抢占该锁。 当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。 唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常，waite()和notify()必须在synchronized函数或synchronized中进行调用。如果在non-synchronized函数或non-synchronized中进行调用,虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。<br>Object.notifyAll()：则从对象等待池中唤醒所有等待等待线程<br>Object.notify()：则从对象等待池中唤醒其中一个线程。<br>Thread.yield()方法 暂停当前正在执行的线程对象，yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，yield()只能使同优先级或更高优先级的线程有执行的机会。<br>Thread.Join()：把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。<br>好了。本篇线程基础知识介绍到此结束。</p>
<p>参考 <a href="http://blog.csdn.net/javazejian/article/details/50878598" target="_blank" rel="external">http://blog.csdn.net/javazejian/article/details/50878598</a><br>所有代码在 <a href="https://github.com/ejunjsh/java-code/tree/master/com/sky/code/thread" target="_blank" rel="external">https://github.com/ejunjsh/java-code/tree/master/com/sky/code/thread</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对多线程复习下，汇总一下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>通过反编译深入理解Java String及intern</title>
    <link href="http://idiotsky.me/2016/07/29/java-string-intern/"/>
    <id>http://idiotsky.me/2016/07/29/java-string-intern/</id>
    <published>2016-07-29T12:11:55.000Z</published>
    <updated>2017-07-30T14:31:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串问题"><a href="#字符串问题" class="headerlink" title="字符串问题"></a>字符串问题</h1><p>字符串在我们平时的编码工作中其实用的非常多，并且用起来也比较简单，所以很少有人对其做特别深入的研究。倒是面试或者笔试的时候，往往会涉及比较深入和难度大一点的问题。我在招聘的时候也偶尔会问应聘者相关的问题，倒不是说一定要回答的特别正确和深入，通常问这些问题的目的有两个，第一是考察对 JAVA 基础知识的了解程度，第二是考察应聘者对技术的态度。<br><a id="more"></a><br>　　我们看看以下程序会输出什么结果？如果你能正确的回答每一道题，并且清楚其原因，那本文对你就没什么太大的意义。如果回答不正确或者不是很清楚其原理，那就仔细看看以下的分析，本文应该能帮助你清楚的理解每段程序的结果及输出该结果的深层次原因。</p>
<p>代码段一：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.string;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String str1 = <span class="string">"string"</span>;</div><div class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"string"</span>);</div><div class="line">        String str3 = str2.intern();</div><div class="line"> </div><div class="line">        System.out.println(str1==str2);<span class="comment">//#1</span></div><div class="line">        System.out.println(str1==str3);<span class="comment">//#2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段二：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> com.paddx.test.string;</div><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest01</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String baseStr = <span class="string">"baseStr"</span>;</div><div class="line">        <span class="keyword">final</span> String baseFinalStr = <span class="string">"baseStr"</span>;</div><div class="line"> </div><div class="line">        String str1 = <span class="string">"baseStr01"</span>;</div><div class="line">        String str2 = <span class="string">"baseStr"</span>+<span class="string">"01"</span>;</div><div class="line">        String str3 = baseStr + <span class="string">"01"</span>;</div><div class="line">        String str4 = baseFinalStr+<span class="string">"01"</span>;</div><div class="line">        String str5 = <span class="keyword">new</span> String(<span class="string">"baseStr01"</span>).intern();</div><div class="line"> </div><div class="line">        System.out.println(str1 == str2);<span class="comment">//#3</span></div><div class="line">        System.out.println(str1 == str3);<span class="comment">//#4</span></div><div class="line">        System.out.println(str1 == str4);<span class="comment">//#5</span></div><div class="line">        System.out.println(str1 == str5);<span class="comment">//#6</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段三（1）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.string;&lt;br&gt;　　</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"> </div><div class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</div><div class="line">        str2.intern();</div><div class="line">        String str1 = <span class="string">"str01"</span>;</div><div class="line">        System.out.println(str2==str1);<span class="comment">//#7</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段三（2）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">package</span> com.paddx.test.string;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternTest01</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String str1 = <span class="string">"str01"</span>;</div><div class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"str"</span>)+<span class="keyword">new</span> String(<span class="string">"01"</span>);</div><div class="line">        str2.intern();</div><div class="line">        System.out.println(str2 == str1);<span class="comment">//#8</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了方便描述，我对上述代码的输出结果由#1~#8进行了编码，下文中蓝色字体部分即为结果。</p>
<h1 id="字符串深入分析"><a href="#字符串深入分析" class="headerlink" title="字符串深入分析"></a>字符串深入分析</h1><h2 id="代码段一分析"><a href="#代码段一分析" class="headerlink" title="代码段一分析"></a>代码段一分析</h2><p>字符串不属于基本类型，但是可以像基本类型一样，直接通过字面量赋值，当然也可以通过new来生成一个字符串对象。不过通过字面量赋值的方式和new的方式生成字符串有本质的区别：<br><a href="/images/java-string-intern-1.jpg"><img src="/images/java-string-intern-1.jpg" alt=""></a> </p>
<p>通过字面量赋值创建字符串时，会优先在常量池中查找是否已经存在相同的字符串，倘若已经存在，栈中的引用直接指向该字符串；倘若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。而通过new的方式创建字符串时，就直接在堆中生成一个字符串的对象（备注，JDK 7 以后，HotSpot 已将常量池从永久代转移到了堆中。详细信息可参考《<a href="/2016/07/26/java8-permgen-metaspace/">JDK8内存模型-消失的PermGen</a>》一文），栈中的引用指向该对象。对于堆中的字符串对象，可以通过 intern() 方法来将字符串添加的常量池中，并返回指向该常量的引用。<br>现在我们应该能很清楚代码段一的结果了：</p>
<font color="blue">结果 #1：因为str1指向的是字符串中的常量，str2是在堆中生成的对象，所以str1==str2返回false。<br>结果 #2：str2调用intern方法，会将str2中值（“string”）复制到常量池中，但是常量池中已经存在该字符串（即str1指向的字符串），所以直接返回该字符串的引用，因此str1==str2返回true。</font>

<p>以下运行代码段一的代码的结果：<br><a href="/images/java-string-intern-2.jpg"><img src="/images/java-string-intern-2.jpg" alt=""></a> </p>
<h2 id="代码段二分析"><a href="#代码段二分析" class="headerlink" title="代码段二分析"></a>代码段二分析</h2><p>对于代码段二的结果，还是通过反编译StringTest01.class文件比较容易理解：<br>常量池内容（部分）：<br><a href="/images/java-string-intern-3.jpg"><img src="/images/java-string-intern-3.jpg" alt=""></a><br>执行指令（部分，第二列#+序数对应常量池中的项）：<br><a href="/images/java-string-intern-4.jpg"><img src="/images/java-string-intern-4.jpg" alt=""></a><br>在解释上述执行过程之前，先了解两条指令：</p>
<p>ldc：Push item from run-time constant pool，从常量池中加载指定项的引用到栈。</p>
<p>astore_<n>：Store reference into local variable，将引用赋值给第n个局部变量。</n></p>
<p>现在我们开始解释代码段二的执行过程：</p>
<p>0: ldc           #2：加载常量池中的第二项（”baseStr”）到栈中。</p>
<p>2: astore_1      ：将1中的引用赋值给第一个局部变量，即String baseStr = “baseStr”；</p>
<p>3: ldc           #2：加载常量池中的第二项（”baseStr”）到栈中。</p>
<p>5: astore_2      ：将3中的引用赋值给第二个局部变量，即 final String baseFinalStr=”baseStr”； </p>
<p>6: ldc           #3：加载常量池中的第三项（”baseStr01”）到栈中。</p>
<p>8: astore_3     ：将6中的引用赋值给第三个局部变量，即String str1=”baseStr01”;</p>
<p>9: ldc           #3：加载常量池中的第三项（”baseStr01”）到栈中。</p>
<p>11: astore        4：将9中的引用赋值给第四个局部变量：即String str2=”baseStr01”；</p>
<font color="blue"><br>结果#3：str1==str2 肯定会返回true，因为str1和str2都指向常量池中的同一引用地址。所以其实在JAVA 1.6之后，常量字符串的“+”操作，编译阶段直接会合成为一个字符串。</font><br>13: new           #4：生成StringBuilder的实例。<br><br>16: dup 　　　　   ：复制13生成对象的引用并压入栈中。<br><br>17: invokespecial #5：调用常量池中的第五项，即StringBuilder.<init>方法。<br><br>以上三条指令的作用是生成一个StringBuilder的对象。<br><br>20: aload_1　　：加载第一个参数的值，即”baseStr”<br><br>21: invokevirtual #6 ：调用StringBuilder对象的append方法。<br><br>24: ldc           #7：加载常量池中的第七项（”01”）到栈中。<br><br>26: invokevirtual #6：调用StringBuilder.append方法。<br><br>29: invokevirtual #8：调用StringBuilder.toString方法。<br><br>32: astore        5：将29中的结果引用赋值改第五个局部变量，即对变量str3的赋值。<br><font color="blue"><br>结果 #4：因为str3实际上是stringBuilder.append()生成的结果，所以与str1不相等，结果返回false。</font><br>34: ldc           #3：加载常量池中的第三项（”baseStr01”）到栈中。<br><br>36: astore        6：将34中的引用赋值给第六个局部变量，即str4=”baseStr01”;<br><font color="blue"><br>结果 #5 ：因为str1和str4指向的都是常量池中的第三项，所以str1==str4返回true。这里我们还能发现一个现象，对于final字段，编译期直接进行了常量替换，而对于非final字段则是在运行期进行赋值处理的。</font><br>38: new           #9：创建String对象<br><br>41: dup               ：复制引用并压如栈中。<br><br>42: ldc           #3：加载常量池中的第三项（”baseStr01”）到栈中。<br><br>44: invokespecial #10：调用String.”<init>“方法，并传42步骤中的引用作为参数传入该方法。<br><br>47: invokevirtual #11：调用String.intern方法。<br><br>从38到41的对应的源码就是new String(“baseStr01”).intern()。<br><br>50: astore        7：将47步返回的结果赋值给变量7，即str5指向baseStr01在常量池中的位置。<br><font color="blue"><br>结果 #6 ：因为str5和str1都指向的都是常量池中的同一个字符串，所以str1==str5返回true。</font><br>运行代码段二，输出结果如下：<br><a href="/images/java-string-intern-5.jpg"><img src="/images/java-string-intern-5.jpg" alt=""></a><br><br>## 代码段三解析：<br>对于代码段三，在 JDK 1.6 和 JDK 1.7中的运行结果不同。我们先看一下运行结果，然后再来解释其原因：<br><br>JDK 1.6 下的运行结果：<br><a href="/images/java-string-intern-6.jpg"><img src="/images/java-string-intern-6.jpg" alt=""></a><br>JDK 1.7 下的运行结果：<br><a href="/images/java-string-intern-7.jpg"><img src="/images/java-string-intern-7.jpg" alt=""></a><br><br>根据对代码段一的分析，应该可以很简单得出 JDK 1.6 的结果，因为 str2 和 str1本来就是指向不同的位置，理应返回false。<br><br>比较奇怪的问题在于JDK 1.7后，对于第一种情况返回true，但是调换了一下位置返回的结果就变成了false。这个原因主要是从JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7 后的intern方法在实现上发生了比较大的改变，JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。所以:<br><font color="blue"><br>结果 #7：在第一种情况下，因为常量池中没有“str01”这个字符串，所以会在常量池中生成一个对堆中的“str01”的引用，而在进行字面量赋值的时候，常量池中已经存在，所以直接返回该引用即可，因此str1和str2都指向堆中的字符串，返回true。<br><br>结果 #8：调换位置以后，因为在进行字面量赋值（String str1 = “str01”）的时候，常量池中不存在，所以str1指向的常量池中的位置，而str2指向的是堆中的对象，再进行intern方法时，对str1和str2已经没有影响了，所以返回false。</font>

<h1 id="常见面试题解答"><a href="#常见面试题解答" class="headerlink" title="常见面试题解答"></a>常见面试题解答</h1><p>有了对以上的知识的了解，我们现在再来看常见的面试或笔试题就很简单了：</p>
<p>Q：String s = new String(“xyz”)，创建了几个String Object? </p>
<p>A：两个，常量池中的”xyz”和堆中对象。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s1 = “abc”;<br>String s2 = “abc”;<br>System.out.println(s1 == s2);</p>
<p>A：true，均指向常量池中对象。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s1 = new String(“abc”);<br>String s2 = new String(“abc”);<br>System.out.println(s1 == s2);</p>
<p>A：false，两个引用指向堆中的不同对象。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s1 = “abc”;<br>String s2 = “a”;<br>String s3 = “bc”;<br>String s4 = s2 + s3;<br>System.out.println(s1 == s4);</p>
<p>A：false，因为s2+s3实际上是使用StringBuilder.append来完成，会生成不同的对象。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s1 = “abc”;<br>final String s2 = “a”;<br>final String s3 = “bc”;<br>String s4 = s2 + s3;<br>System.out.println(s1 == s4);</p>
<p>A：true，因为final变量在编译后会直接替换成对应的值，所以实际上等于s4=”a”+”bc”，而这种情况下，编译器会直接合并为s4=”abc”，所以最终s1==s4。</p>
<p>Q：下列程序的输出结果：</p>
<p>String s = new String(“abc”);<br>String s1 = “abc”;<br>String s2 = new String(“abc”);</p>
<p>System.out.println(s == s1.intern());<br>System.out.println(s == s2.intern());<br>System.out.println(s1 == s2.intern());</p>
<p>A：false，false，true，具体原因参考第二部分内容。</p>
<p>原文地址 <a href="http://www.cnblogs.com/paddix/p/5326863.html" target="_blank" rel="external">http://www.cnblogs.com/paddix/p/5326863.html</a></p>
</init></init>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;字符串问题&quot;&gt;&lt;a href=&quot;#字符串问题&quot; class=&quot;headerlink&quot; title=&quot;字符串问题&quot;&gt;&lt;/a&gt;字符串问题&lt;/h1&gt;&lt;p&gt;字符串在我们平时的编码工作中其实用的非常多，并且用起来也比较简单，所以很少有人对其做特别深入的研究。倒是面试或者笔试的时候，往往会涉及比较深入和难度大一点的问题。我在招聘的时候也偶尔会问应聘者相关的问题，倒不是说一定要回答的特别正确和深入，通常问这些问题的目的有两个，第一是考察对 JAVA 基础知识的了解程度，第二是考察应聘者对技术的态度。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="jvm" scheme="http://idiotsky.me/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java8内存模型—永久代(PermGen)和元空间(Metaspace)</title>
    <link href="http://idiotsky.me/2016/07/26/java8-permgen-metaspace/"/>
    <id>http://idiotsky.me/2016/07/26/java8-permgen-metaspace/</id>
    <published>2016-07-26T12:28:09.000Z</published>
    <updated>2017-07-29T12:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h1><p>根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。<br><a href="/images/java8-permgen-metaspace-1.png"><img src="/images/java8-permgen-metaspace-1.png" alt=""></a><br><a id="more"></a></p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误，不过这个深度范围不是一个恒定的值，我们通过下面这段程序可以测试一下这个结果：<br>栈溢出测试源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackErrorMock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">1</span>;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</div><div class="line">        index++;</div><div class="line">        call();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        StackErrorMock mock = <span class="keyword">new</span> StackErrorMock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mock.call();</div><div class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</div><div class="line">            System.out.println(<span class="string">"Stack deep : "</span>+index);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段1</p>
<p>运行三次，可以看出每次栈的深度都是不一样的，输出结果如下。<br><a href="/images/java8-permgen-metaspace-2.png"><img src="/images/java8-permgen-metaspace-2.png" alt=""></a><br>至于红色框里的值是怎么出来的，就需要深入到 JVM 的源码中才能探讨，这里不作详细阐述。</p>
<p>虚拟机栈除了上述错误外，还有另一种错误，那就是当申请不到空间时，会抛出 OutOfMemoryError。这里有一个小细节需要注意，catch 捕获的是 Throwable，而不是 Exception。因为 StackOverflowError 和 OutOfMemoryError 都不属于 Exception 的子类。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>这部分主要与虚拟机用到的 Native 方法相关，一般情况下， Java 应用程序员并不需要关心这部分的内容</p>
<h2 id="PC-寄存器"><a href="#PC-寄存器" class="headerlink" title="PC 寄存器"></a>PC 寄存器</h2><p>PC 寄存器，也叫程序计数器。JVM支持多个线程同时运行，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native 方法，则PC寄存器中为空。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。下面我们简单的模拟一个堆内存溢出的情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOomMock</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">while</span> (flag)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                i++;</div><div class="line">                list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);<span class="comment">//每次增加一个1M大小的数组对象</span></div><div class="line">            &#125;<span class="keyword">catch</span> (Throwable e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">                System.out.println(<span class="string">"count="</span>+i);<span class="comment">//记录运行的次数</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段2</p>
<p>运行上述代码，输出结果如下：　<br><a href="/images/java8-permgen-metaspace-3.png"><img src="/images/java8-permgen-metaspace-3.png" alt=""></a><br><em>注意，这里我指定了堆内存的大小为16M，所以这个地方显示的count=14（这个数字不是固定的），至于为什么会是14或其他数字，需要根据 GC 日志来判断</em></p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>　　方法区也是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。 关于方法区内存溢出的问题会在下文中详细探讨。</p>
<h1 id="PermGen（永久代）"><a href="#PermGen（永久代）" class="headerlink" title="PermGen（永久代）"></a>PermGen（永久代）</h1><p>绝大部分 Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space “这个异常。这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。我们现在通过动态生成类来模拟 “PermGen space”的内存溢出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"><span class="keyword">import</span> java.net.URLClassLoader;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermGenOomMock</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        URL url = <span class="keyword">null</span>;</div><div class="line">        List&lt;ClassLoader&gt; classLoaderList = <span class="keyword">new</span> ArrayList&lt;ClassLoader&gt;();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            url = <span class="keyword">new</span> File(<span class="string">"/tmp"</span>).toURI().toURL();</div><div class="line">            URL[] urls = &#123;url&#125;;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">                ClassLoader loader = <span class="keyword">new</span> URLClassLoader(urls);</div><div class="line">                classLoaderList.add(loader);</div><div class="line">                loader.loadClass(<span class="string">"com.paddx.test.memory.Test"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码段3</p>
<p>运行结果如下：<br><a href="/images/java8-permgen-metaspace-4.png"><img src="/images/java8-permgen-metaspace-4.png" alt=""></a><br>　　本例中使用的 JDK 版本是 1.7，指定的 PermGen 区的大小为 8M。通过每次生成不同URLClassLoader对象来加载Test类，从而生成不同的类对象，这样就能看到我们熟悉的 “java.lang.OutOfMemoryError: PermGen space “ 异常了。这里之所以采用 JDK 1.7，是因为在 JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。下面我们就来看看 Metaspace 与 PermGen space 的区别。</p>
<h1 id="Metaspace（元空间）"><a href="#Metaspace（元空间）" class="headerlink" title="Metaspace（元空间）"></a>Metaspace（元空间）</h1><p>其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。我们可以通过一段程序来比较 JDK 1.6 与 JDK 1.7及 JDK 1.8 的区别，以字符串常量为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.paddx.test.memory;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringOomMock</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> String  base = <span class="string">"string"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; Integer.MAX_VALUE;i++)&#123;</div><div class="line">            String str = base + base;</div><div class="line">            base = str;</div><div class="line">            list.add(str.intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码段4</p>
<p>这段程序以2的指数级不断的生成新的字符串，这样可以比较快速的消耗内存。我们通过 JDK 1.6、JDK 1.7 和 JDK 1.8 分别运行：<br>JDK 1.6 的运行结果：<br><a href="/images/java8-permgen-metaspace-5.png"><img src="/images/java8-permgen-metaspace-5.png" alt=""></a><br>JDK 1.7的运行结果：<br><a href="/images/java8-permgen-metaspace-6.png"><img src="/images/java8-permgen-metaspace-6.png" alt=""></a><br>JDK 1.8的运行结果：<br><a href="/images/java8-permgen-metaspace-7.png"><img src="/images/java8-permgen-metaspace-7.png" alt=""></a><br>从上述结果可以看出，JDK 1.6下，会出现“PermGen Space”的内存溢出，而在 JDK 1.7和 JDK 1.8 中，会出现堆内存溢出，并且 JDK 1.8中 PermSize 和 MaxPermGen 已经无效。因此，可以大致验证 JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论。现在我们看看元空间到底是一个什么东西？</p>
<p>　　元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<p>　　-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。<br>　　-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p>
<p>　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：<br>　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集<br>　　-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p>
<p>现在我们在 JDK 8下重新运行一下代码段3，不过这次不再指定 PermSize 和 MaxPermSize。而是指定 MetaSpaceSize 和 MaxMetaSpaceSize的大小。输出结果如下：<br><a href="/images/java8-permgen-metaspace-8.png"><img src="/images/java8-permgen-metaspace-8.png" alt=""></a><br>从输出结果，我们可以看出，这次不再出现永久代溢出，而是出现了元空间的溢出。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　通过上面分析，大家应该大致了解了 JVM 的内存划分，也清楚了 JDK 8 中永久代向元空间的转换。不过大家应该都有一个疑问，就是为什么要做这个转换？所以，最后给大家总结以下几点原因：</p>
<ul>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
<li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li>
</ul>
<p>原文地址 <a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="external">http://www.cnblogs.com/paddix/p/5309550.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-内存模型&quot;&gt;&lt;a href=&quot;#JVM-内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM 内存模型&quot;&gt;&lt;/a&gt;JVM 内存模型&lt;/h1&gt;&lt;p&gt;根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。&lt;br&gt;&lt;a href=&quot;/images/java8-permgen-metaspace-1.png&quot;&gt;&lt;img src=&quot;/images/java8-permgen-metaspace-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="jvm" scheme="http://idiotsky.me/tags/jvm/"/>
    
  </entry>
  
</feed>
