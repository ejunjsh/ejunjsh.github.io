<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IdiotSky</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://idiotsky.me/"/>
  <updated>2017-09-03T11:06:34.000Z</updated>
  <id>http://idiotsky.me/</id>
  
  <author>
    <name>ejunjsh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript是如何工作的(二)</title>
    <link href="http://idiotsky.me/2017/08/26/javascript-how-work-2/"/>
    <id>http://idiotsky.me/2017/08/26/javascript-how-work-2/</id>
    <published>2017-08-26T03:08:09.000Z</published>
    <updated>2017-09-03T11:06:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>几个星期前，我们开始了一个系列，目标是深入理解javascript和它怎么工作的：通过这些我们可以更容易的写出好代码和apps。</p>
</blockquote>
<p><a href="/2017/08/26/javascript-how-work">系列的第一篇</a>主要是提供一个关于引擎，运行时和调用栈的概括。这篇文章将深入到Google V8 javascript 引擎。同时，还提供一些快速的意见令你能够写出好的javascript代码。<br><a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>一个javascript引擎是一个解释器也是个程序，它执行javascript代码。它可以被实现为一个标准解释器，也可以是一个即时（just-in-time）的编译器（以不同形式编译javascript成字节码）<br>下面是一个流行的javascript引擎的列表：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/V8_%28JavaScript_engine%29" target="_blank" rel="external">V8</a> — 谷歌开源的, 用 C++写的。</li>
<li><a href="https://en.wikipedia.org/wiki/Rhino_%28JavaScript_engine%29" target="_blank" rel="external">Rhino</a> — 由Mozilla基金会管理,开源的, 完全用java写的。</li>
<li><a href="https://en.wikipedia.org/wiki/SpiderMonkey_%28JavaScript_engine%29" target="_blank" rel="external">SpiderMonkey</a> — 第一个javascript引擎 Netscape Navigator开发,现在Firefox维护。</li>
<li><a href="https://en.wikipedia.org/wiki/JavaScriptCore" target="_blank" rel="external">JavaScriptCore</a> — 开源，由Apple开发 ，Safari浏览器的引擎。</li>
<li><a href="https://en.wikipedia.org/wiki/KJS_%28KDE%29" target="_blank" rel="external">KJS</a> — KDE的引擎，由 Harri Porten开发，是Konqueror桌面系统的浏览器引擎。</li>
<li><a href="https://en.wikipedia.org/wiki/Chakra_%28JScript_engine%29" target="_blank" rel="external">Chakra (JScript9)</a> — IE的</li>
<li><a href="https://en.wikipedia.org/wiki/Chakra_%28JavaScript_engine%29" target="_blank" rel="external">Chakra (JavaScript)</a> — 微软Edge</li>
<li><a href="https://en.wikipedia.org/wiki/Nashorn_%28JavaScript_engine%29" target="_blank" rel="external">Nashorn</a> -  OpenJDK的开源一部分, 由Oracle Java 语言和工具组开发</li>
<li><a href="https://en.wikipedia.org/wiki/JerryScript" target="_blank" rel="external">JerryScript</a> — 一个轻量级引擎.</li>
</ul>
<h1 id="为什么要创造一个V8引擎？"><a href="#为什么要创造一个V8引擎？" class="headerlink" title="为什么要创造一个V8引擎？"></a>为什么要创造一个V8引擎？</h1><p>V8引擎由Google创建并开源，c++编写。用于Google的Chrome浏览器。不像其他引擎，V8还是流行的Node.js的运行时引擎。<br><a href="/images/js-how-work-2-1.png"><img src="/images/js-how-work-2-1.png" alt=""></a><br>V8是第一个为了性能提升的浏览器引擎。为了达到更好的性能，相比于使用解释器，V8更倾向于使用编译器编译javascript代码成更高效的机器码。它像其他现代化javascript引擎如SpiderMonkey或者Rhino (Mozilla)一样，使用<strong>JIT(Just-In-Time)</strong>编译器在执行阶段编译代码，唯一不同的是，V8不会生成字节码或任意中间代码。</p>
<h1 id="V8曾经有两个编译器"><a href="#V8曾经有两个编译器" class="headerlink" title="V8曾经有两个编译器"></a>V8曾经有两个编译器</h1><p>在5.9版本发布（今年早些时候）之前，V8曾经有两个编译器：</p>
<ul>
<li>full-codegen — 一个简单快速的编译器，用来生成简单，相对慢的机器码。</li>
<li>Crankshaft - 一个更复杂(Just-In-Time) 优化的编译，用来生成更优的机器码。</li>
</ul>
<p>V8引擎内部也用了一些线程：</p>
<ul>
<li>正如你想的，主线程就是拿到代码，编译代码和执行代码。</li>
<li>还有些线程用来编译和优化代码，协助主线程，让主线程继续执行代码。</li>
<li>一个剖析器线程用来汇报哪些方法需要Crankshaft编译器优化。</li>
<li>其他一些线程用来做垃圾回收</li>
</ul>
<p>当开始执行javascript代码，V8运用<strong>full-codegen</strong>来直接翻译解析过的javascript代码为机器码，这个过程没有任何中间转换，所以执行机器码<strong>非常快</strong>.由于没有用到任何中间的字节码，所以就没有需要解释器的必要了。</p>
<p>当你的代码运行一段时间后，剖析器线程就能收集到足够的数据来确定哪些方法应该被优化。</p>
<p>接下来，<strong>Crankshaft</strong> 优化编译器开始运行在其他线程。它翻译javascript抽象语法树到一个高级别的<a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="external">静态单赋值(SSA)</a> 形态,又叫<strong>Hydrogen(氢？)</strong>。然后优化这个Hydrogen图。大部分的优化都在这个层次上完成。</p>
<h1 id="内联（inlining）"><a href="#内联（inlining）" class="headerlink" title="内联（inlining）"></a>内联（inlining）</h1><p>首个优化方法就是内联，它会提前尽可能的内联更多的代码。内联是一个替换代码的一个过程，用方法体替换到调用的地方（其实就是方法展开）。这样一步简单的优化可以令接下来的优化更有意义。<br><a href="/images/js-how-work-2-2.png"><img src="/images/js-how-work-2-2.png" alt=""></a></p>
<h1 id="隐藏类-Hidden-class"><a href="#隐藏类-Hidden-class" class="headerlink" title="隐藏类(Hidden class)"></a>隐藏类(Hidden class)</h1><p>javascript是一种基于原型的语言：没有类和对象是通过克隆进程创建的(机翻😁)。javascript也是一种动态语言，他能够随意的添加和删除一个对象的属性，即使这个对象已经实例化了。<br>大部分javascript解释器使用类字典的结构(基于<a href="http://en.wikipedia.org/wiki/Hash_function" target="_blank" rel="external">哈希函数</a>)来存储对象属性值在内存的位置。相比非动态语言如java和c#，这种结构使得取值是种计算昂贵的操作。对java来说，在编译之前就已经确定对象的属性，运行时也不能随意添加和删除属性的（当然，c#支持<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic" target="_blank" rel="external">动态类型</a>,那就在其他话题里了）。所以，属性的值（或者属性的指针）可以存储在一个连续的缓存里面，属性之间的位移更是固定的，而且位移的长度可以容易的基于属性类型来确定。这些对于javascript来说是不可能的，因为javascript的类型可以在运行时改变。<br>由于这种字典的取地址方式是不高效的，所以V8用了一个不同的方法来取代：隐藏类(Hidden class)。隐藏类的运作方式跟java的固定对象布局类似，除了它们是在运行时创建的。下面举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>一旦<code>new Point(1, 2)</code>被调用，V8将创建一个<code>C0</code>的隐藏类。<br><a href="/images/js-how-work-2-3.png"><img src="/images/js-how-work-2-3.png" alt=""></a><br>由于<code>Point</code>没有属性定义,所以<code>C0</code>是空的。</p>
<p>一旦<code>this.x = x</code>(在<code>Point</code>函数)被执行，V8将创建一个基于<code>C0</code>的隐藏类<code>C1</code>。<code>C1</code>描述了x的内存的位置（相对于对象指针），在这个情况下，x的位置存在<a href="http://en.wikipedia.org/wiki/Offset_%28computer_science%29" target="_blank" rel="external">位移</a>0上，这代表了<code>point</code>对象是一个连续的内存，它的第一个位移对应的是属性x。同时V8也用“类转换”更新了<code>C0</code>，表明了如果一个属性x加到<code>point</code>对象，隐藏类就应该要从<code>C0</code>转换到<code>C1</code>。所以现在<code>point</code>对象的隐藏类为<code>C1</code>。<br><a href="/images/js-how-work-2-4.png"><img src="/images/js-how-work-2-4.png" alt=""></a><br><small><em>每一次一个新的属性加到一个对象，一条转换的路径更新到旧的隐藏类并指向新的隐藏类。隐藏类转换是很重要的，因为同样方式创建的对象都共享同一个隐藏类。如果两个对象共享一个隐藏类，同时相同的属性加到这个两个对象的话，那么转换将保证这两个对象还是共享同一个新的隐藏类，而且共享同一个隐藏类有益于优化代码。</em></small></p>
<p>当<code>this.y = y</code>被执行，一个新的隐藏类<code>C1</code>被创建，同时一个类转换加到<code>C1</code>上面，表明了如果一个属性y加到一个<code>point</code>对象（已经有x属性的），就要把隐藏类转换成<code>C2</code>。现在<code>point</code>对象的隐藏类就是<code>C2</code>了。<br><a href="/images/js-how-work-2-5.png"><img src="/images/js-how-work-2-5.png" alt=""></a></p>
<p>隐藏类的转换依赖于属性的加入顺序。看一下下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">p1.a = <span class="number">5</span>;</div><div class="line">p1.b = <span class="number">6</span>;</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</div><div class="line">p2.b = <span class="number">7</span>;</div><div class="line">p2.a = <span class="number">8</span>;</div></pre></td></tr></table></figure></p>
<p>现在你肯定会认为p1和p2都是共享同一个隐藏类和转换路径，其实不然。对于p1，第一个属性是a再到b，而p2的话是先b在到a，所以p1和p2是分别两个不同的隐藏类和不同的两条转换路径。<strong>所以，对于动态属性最好是用相同的顺序加入到对象里面，这样有利于隐藏类的重用。</strong></p>
<h1 id="内联缓存-Inline-caching"><a href="#内联缓存-Inline-caching" class="headerlink" title="内联缓存(Inline caching)"></a>内联缓存(Inline caching)</h1><p>V8利用内联缓存技术来优化动态类型语言。内联缓存依赖于观察哪些方法在哪些相同的对象类型被重复调用。更深的介绍可以看<a href="https://github.com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-caches" target="_blank" rel="external">这里</a><br>我们用更通用的概念来说说内联缓存（如果你没时间去看上面的介绍的链接的话。）<br>所以，内联缓存是怎么工作的呢？V8维护一个对象类型的缓存，当一个对象做为参数传递到一个函数调用中，那V8会缓存这个对象，并假设这个对象会在未来会再一次作为参数传递到一个函数调用中。如果V8的这个假设是正确的话，在下次传递对象到一个方法调用的时候，就会绕过查找类型对象的属性的过程，直接使用之前查找隐藏类所储存的信息。</p>
<p>所以隐藏类和内联缓存是怎么样关联起来的呢？无论一个指定对象方法什么时候被执行，V8引擎都会去查找那个对象的隐藏类去决定指定属性的访问位移。在两次成功调用相同隐藏类的相同方法后，V8就会忽略隐藏类的查找并简单的用属性位移和这个对象指针相加来确定地址。对于未来的那个方法的调用，V8都假设这个对象的隐藏类都没有改变，直接使用之前查找后对象内存的位移来访问属性，这样大大增加执行速度。</p>
<p>相同类型的对象共享相同隐藏类是很重要的，原因是内存缓存。如果你创建两个相同类型的对象，但它们的隐藏类不同（前面例子有提到），V8将没办法用到内联缓存，因为尽管类型相同，但是它们对应的隐藏类分配的属性位移是不同的。<br><a href="/images/js-how-work-2-6.png"><img src="/images/js-how-work-2-6.png" alt=""></a><br><small><em>这两个对象基本上是一样的，但是a和b属性是用不同的顺序创建的。</em></small></p>
<h1 id="编译机器码"><a href="#编译机器码" class="headerlink" title="编译机器码"></a>编译机器码</h1><p>一旦Hydrogen图被优化，Crankshaft降低它为一个低级别的表述，称为Lithium。大多数Lithium实现是架构指定的。注册器分配发生在这个级别。</p>
<p>最后，Lithium被编译为机器码。有一些编译发生在OSR:栈中替换。在我们编译和优化一个明显长时间运行的方法时，我们有可能已经运行了这个方法了。V8不会忘了这个方法重新运行一个优化的版本的方法，而是转换所有的上下文（栈，注册器），这样就可以在执行中切换到优化版本。这是一个复杂的任务，记得在其他优化里，V8已经一开始就内联代码了。V8不是唯一有这能力的引擎。</p>
<p>这里有个保障是，一旦引擎的假设不成立的话，会把优化过的代码回滚回之前未优化的代码。这个保障称之为去优化（deoptimization）</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>对于垃圾回收，V8使用传统的分代标记清理的方式来清除旧的对象。标记的阶段一般都会停止javascript的执行。为了控制GC的成本和令执行更加稳定，V8用了递增标记来取代全堆标记。递增标记只是在部分堆中递增标记可能的对象，之后回到正常的代码执行。到下次执行GC的时候，会从上次GC标记的堆中开始。这样的话，停止时间很少。之前提及过，清理过程是在不同的线程执行的。</p>
<h1 id="Ignition和TurboFan"><a href="#Ignition和TurboFan" class="headerlink" title="Ignition和TurboFan"></a>Ignition和TurboFan</h1><p>V8的5.9版本在2017年初发布，一个新的执行管道被引入。这个新的管道使得V8在现实的javascript应用程序中达到更高的性能和更少内存使用。</p>
<p>新的执行管道由V8解释器<a href="https://github.com/v8/v8/wiki/Interpreter" target="_blank" rel="external">Ignition</a>和V8最新优化编译器<a href="https://github.com/v8/v8/wiki/TurboFan" target="_blank" rel="external">TurboFan</a> 组成。</p>
<p>你可以在<a href="https://v8project.blogspot.bg/2017/05/launching-ignition-and-turbofan.html" target="_blank" rel="external">这里</a>查阅来自V8团队的博客文章.</p>
<p>自从5.9版本的V8发布，full-codegen和Crankshaft（这两个技术从2010就开始服务V8了）不再被V8用来执行javascript，当V8团队要跟上新的javascript语言特性的步伐和这些特性更需要优化的支持。</p>
<p>这就意味着V8总体来讲将是一个更简单和更容易维护的架构。<br><a href="/images/js-how-work-2-7.png"><img src="/images/js-how-work-2-7.png" alt=""></a><br><small><em>在网页和Node.js的性能改进</em></small></p>
<p>这些改进只是个开始。新的Ignition和TurboFan为更长远的优化铺平了道路，并在这几年提升javascript的性能和缩小Node.js和Chrome的差距。</p>
<h1 id="怎么写出最好的javascript代码"><a href="#怎么写出最好的javascript代码" class="headerlink" title="怎么写出最好的javascript代码"></a>怎么写出最好的javascript代码</h1><p>最后，这里有些建议帮助你们写出更优更好的javascript。我想，当你看到这里，你心里已经有所感悟了，但是，我还是总结下吧：</p>
<ol>
<li>对象属性的顺序:初始化对象属性最好要按相同顺序，这样，他们的隐藏类和后续的优化代码能够共享。</li>
<li>动态属性：加一个动态属性会令一个对象的隐藏类改变，和拖慢任何一个方法，因为这个方法已经针对前一个隐藏类优化的了。所以，尽可能分配在构造函数里面分配所有的对象属性。</li>
<li>方法：重复执行相同的方法比一次执行许多不同的方法快（因为内联缓存）</li>
<li>数组：避免稀疏数组，因为它们的key不是递增的。稀疏数组并不是每个索引都有元素，所以它更像个哈希表。还有访问这样的数组是昂贵的。还有就是不要一次分配个大数组，最好按需分配。最后，不要在数组中删除元素，这样就令key稀疏了。</li>
<li>标签值：V8用32位来代表对象和数字。它用一位来区分对象（flag=1）和整形（flag=0），这个整形也叫SMI（SMall Integer）,因为它只有31位。这样的话，如果一个数字值大于31位，V8将会将它转化为一个double并使用一个对象把它装箱。尽可能使用31位的有符号数字，这样能够避免昂贵的装箱操作。</li>
</ol>
<p>翻译 <a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="external">https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;几个星期前，我们开始了一个系列，目标是深入理解javascript和它怎么工作的：通过这些我们可以更容易的写出好代码和apps。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/2017/08/26/javascript-how-work&quot;&gt;系列的第一篇&lt;/a&gt;主要是提供一个关于引擎，运行时和调用栈的概括。这篇文章将深入到Google V8 javascript 引擎。同时，还提供一些快速的意见令你能够写出好的javascript代码。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://idiotsky.me/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://idiotsky.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript是如何工作的(一)</title>
    <link href="http://idiotsky.me/2017/08/26/javascript-how-work/"/>
    <id>http://idiotsky.me/2017/08/26/javascript-how-work/</id>
    <published>2017-08-25T17:17:54.000Z</published>
    <updated>2017-08-26T06:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>简评</strong>：JavaScript 是越来越受欢迎了，很多团队都在采用这些语言工作。前端、后端、嵌入式设备等等，都可以看见它的身影。虽然我们知其然，但又知其所以然吗？</p>
</blockquote>
<a id="more"></a>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>大家应该都知道 JavaScript 是单线程的，以及听过 V8 引擎的概念。<br>这篇文章将会介绍这些概念，并解释 JavaScript 是如何运行的。通过了解这些细节，开发者能更好地编写代码，正确利用其提供的 API。</p>
<h1 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h1><p>比较流行的一个 JavaScript 引擎示例就是 Google 的 V8 引擎。下图是 V8 引擎在 Chrome 和 Node.js 中使用的一个简化视图：<br><a href="/images/js-how-work.png"><img src="/images/js-how-work.png" alt=""></a></p>
<p>引擎主要由两个组件组成：</p>
<ul>
<li>内存堆（Memory Heap ）：这是内存分配的地方</li>
<li>调用堆栈（Call Stack）：这是程序运行时函数的调用过程</li>
</ul>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>在浏览器中，例如「setTimeout」这样的 API 已经有很多开发者在用了，然后引擎并没有提供这些 API，所以它们从哪里来的呢？<br>实际情况是这样的：<br><a href="/images/js-how-work-1.png"><img src="/images/js-how-work-1.png" alt=""></a><br>所以，除了引擎之外，还有浏览器提供的 Web API（像 DOM、AJAX、setTimeout 等等）。另外，还有事件循环（event loop）和回调队列（callback queue）。</p>
<h1 id="调用堆栈（Call-Stack）"><a href="#调用堆栈（Call-Stack）" class="headerlink" title="调用堆栈（Call Stack）"></a>调用堆栈（Call Stack）</h1><p>JavaScript 是单线程语言，这意味着它只有一个单一的调用堆栈。因此，它每次只能做一件事。</p>
<p>调用堆栈是一个数据结构，按调用顺序保存所有在运行期被调用的方法。既然是个栈，那么它就满足先入后出的特性。</p>
<p>我们来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * y;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> s = multiply(x, x);</div><div class="line">    <span class="built_in">console</span>.log(s);</div><div class="line">&#125;</div><div class="line">printSquare(<span class="number">5</span>);</div></pre></td></tr></table></figure></p>
<p>当引擎开始执行这段代码时，调用堆栈将为空。然后，就会有以下步骤：<br><a href="/images/js-how-work-2.png"><img src="/images/js-how-work-2.png" alt=""></a></p>
<p>调用堆栈中的每个条目称为堆栈帧（Stack Frame）。当异常发生时，它基本上是调用堆栈的状态。再看看下面这段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'SessionStack will help you resolve crashes :)'</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    foo();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    bar();</div><div class="line">&#125;</div><div class="line">start();</div></pre></td></tr></table></figure></p>
<p>如果这是在 Chrome 中执行（假设此代码位于一个名为 foo.js 的文件中），则会产生这种情况：<br><a href="/images/js-how-work-3.png"><img src="/images/js-how-work-3.png" alt=""></a></p>
<p>当你达到最大调用堆栈时，会容易发生这种情况，特别是在没有测试代码时随意使用递归。<br>看看这个示例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    foo();</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p>
<p>代码执行时，首先调用函数「foo」。然而，这是递归函数，调用自身的同时又没有设置终止条件，所以每一次执行，相同的函数都会被添加进堆栈中，看起来就是这样：<br><a href="/images/js-how-work-4.png"><img src="/images/js-how-work-4.png" alt=""></a><br>某些时候，调用堆栈中的函数调用次数超过了调用堆栈的实际大小，那么浏览器就会抛出一个错误，看起来像这样：<br><a href="/images/js-how-work-5.png"><img src="/images/js-how-work-5.png" alt=""></a><br>单线程上编写代码相对多线程来说会简单得多，你不必考虑死锁这样的复杂场景。但单线程也有许多限制，由于 JavaScript 有调用堆栈，当执行代码需要耗费大量时间时是怎样的呢？</p>
<h1 id="并发和事件循环"><a href="#并发和事件循环" class="headerlink" title="并发和事件循环"></a>并发和事件循环</h1><p>当你在调用堆栈中进行函数调用，有时候需要大量时间才能进行处理。例如在浏览器中使用JavaScript 进行一些复杂的图像转换。在这个过程中又发生了什么？<br>这个问题的产生是因为，虽然调用堆栈具有执行的功能，但浏览器本身是无法渲染也不能运行其他任何代码，它被卡住了。当你想执行一套流畅的 UI 时，就会产生这样的问题。大多数浏览器通过抛出异常处理错误，询问用户是否要终止网页：<br><a href="/images/js-how-work-6.jpg"><img src="/images/js-how-work-6.jpg" alt=""></a><br>这个用户体验很糟糕。那么如何解决呢？答案是异步回调（asynchronous callbacks）。这是后话，下次再讲。</p>
<p>翻译和参考 <a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="external">https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;简评&lt;/strong&gt;：JavaScript 是越来越受欢迎了，很多团队都在采用这些语言工作。前端、后端、嵌入式设备等等，都可以看见它的身影。虽然我们知其然，但又知其所以然吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://idiotsky.me/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://idiotsky.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>openstack安装准备(二)-环境的安装</title>
    <link href="http://idiotsky.me/2017/08/19/openstack-install-prepare-2/"/>
    <id>http://idiotsky.me/2017/08/19/openstack-install-prepare-2/</id>
    <published>2017-08-19T14:50:07.000Z</published>
    <updated>2017-09-02T14:10:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/openstack-install-prepare-2-1.png"><img src="/images/openstack-install-prepare-2-1.png" alt=""></a><br>上图是整个openstack的架构图，里面的椭圆方块都是openstack的服务，所以安装openstack就是要安装这些服务。</p>
<p>按照官方建议，这次openstack安装的服务为：</p>
<ul>
<li>Identity service (keystone)</li>
<li>Image service (glance)</li>
<li>Compute service (nova)</li>
<li>Networking service (neutron)</li>
<li>Dashboard (horizon)</li>
<li>Block Storage service (cinder)</li>
</ul>
<a id="more"></a>
<p>在安装上面服务前，先要弄好环境的😁</p>
<h1 id="安装openstack仓库"><a href="#安装openstack仓库" class="headerlink" title="安装openstack仓库"></a>安装openstack仓库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># change to root</span></div><div class="line">$ sudo -i</div><div class="line">$ apt install software-properties-common</div><div class="line">$ add-apt-repository cloud-archive:pike</div><div class="line">$ apt update &amp;&amp; apt dist-upgrade</div><div class="line">$ apt install python-openstackclient</div></pre></td></tr></table></figure>
<p>上面的步骤两个节点都要安装。<br><strong>以下步骤安装在controller</strong></p>
<h1 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h1><p>openstack所用到的数据都会存到数据库里，所以安装一个数据库是准备的一个重要步骤。mariadb是官方建议的数据库。</p>
<h2 id="安装和配置mariadb"><a href="#安装和配置mariadb" class="headerlink" title="安装和配置mariadb"></a>安装和配置mariadb</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ apt install mariadb-server python-pymysql</div><div class="line">$ vi /etc/mysql/mariadb.conf.d/99-openstack.cnf</div><div class="line"><span class="comment"># 加一个[mysqld]区，bind-address为管理网络ip</span></div><div class="line">[mysqld]</div><div class="line"><span class="built_in">bind</span>-address = controller <span class="comment"># 192.168.199.10 </span></div><div class="line"></div><div class="line">default-storage-engine = innodb</div><div class="line">innodb_file_per_table = on</div><div class="line">max_connections = 4096</div><div class="line">collation-server = utf8_general_ci</div><div class="line">character-set-server = utf8</div></pre></td></tr></table></figure>
<h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>重启服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service mysql restart</div></pre></td></tr></table></figure></p>
<p>设置下root用户的密码，这个密码后面要用到，务必谨记。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysql_secure_installation</div></pre></td></tr></table></figure></p>
<h1 id="安装消息队列"><a href="#安装消息队列" class="headerlink" title="安装消息队列"></a>安装消息队列</h1><p>openstack用消息队列来异步控制各种service，所以要装一个，rabbitmq是官方推荐，装之。</p>
<h2 id="安装和配置rabbitmq"><a href="#安装和配置rabbitmq" class="headerlink" title="安装和配置rabbitmq"></a>安装和配置rabbitmq</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt install rabbitmq-server</div></pre></td></tr></table></figure>
<p>加一个openstack用户。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rabbitmqctl add_user openstack RABBIT_PASS <span class="comment">#用你的密码替换下RABBIT_PASS，谨记这个密码，后面有用。</span></div></pre></td></tr></table></figure></p>
<p>赋予更多权限给openstack用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rabbitmqctl set_permissions openstack <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></div></pre></td></tr></table></figure></p>
<h1 id="安装缓存"><a href="#安装缓存" class="headerlink" title="安装缓存"></a>安装缓存</h1><p>openstack用到缓存，memcached是官方推荐，还是装之。</p>
<h2 id="安装和配置memcached"><a href="#安装和配置memcached" class="headerlink" title="安装和配置memcached"></a>安装和配置memcached</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ apt install memcached python-memcache</div><div class="line">$ vi /etc/memcached.conf</div><div class="line"><span class="comment">#监听管理网络ip</span></div><div class="line"><span class="comment">#-l 127.0.0.1 改成下面这样</span></div><div class="line">-l controller <span class="comment"># 192.168.199.10</span></div></pre></td></tr></table></figure>
<h2 id="收尾-1"><a href="#收尾-1" class="headerlink" title="收尾"></a>收尾</h2><p>重启服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service memcached restart</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基本上环境已经搭好了，接下来就要安装各种服务了。😈</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/openstack-install-prepare-2-1.png&quot;&gt;&lt;img src=&quot;/images/openstack-install-prepare-2-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;上图是整个openstack的架构图，里面的椭圆方块都是openstack的服务，所以安装openstack就是要安装这些服务。&lt;/p&gt;
&lt;p&gt;按照官方建议，这次openstack安装的服务为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Identity service (keystone)&lt;/li&gt;
&lt;li&gt;Image service (glance)&lt;/li&gt;
&lt;li&gt;Compute service (nova)&lt;/li&gt;
&lt;li&gt;Networking service (neutron)&lt;/li&gt;
&lt;li&gt;Dashboard (horizon)&lt;/li&gt;
&lt;li&gt;Block Storage service (cinder)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="openstack" scheme="http://idiotsky.me/categories/openstack/"/>
    
    
      <category term="openstack" scheme="http://idiotsky.me/tags/openstack/"/>
    
      <category term="ubuntu" scheme="http://idiotsky.me/tags/ubuntu/"/>
    
      <category term="kvm" scheme="http://idiotsky.me/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>openstack安装准备(一)</title>
    <link href="http://idiotsky.me/2017/08/18/openstack-install-prepare-1/"/>
    <id>http://idiotsky.me/2017/08/18/openstack-install-prepare-1/</id>
    <published>2017-08-18T14:50:07.000Z</published>
    <updated>2017-09-02T13:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备VMware"><a href="#准备VMware" class="headerlink" title="准备VMware"></a>准备VMware</h1><p>由于我是习惯了mac上做实验，所以用VMware fusion，随便下个破解版即可。</p>
<h1 id="准备Ubuntu"><a href="#准备Ubuntu" class="headerlink" title="准备Ubuntu"></a>准备Ubuntu</h1><p>Ubuntu去官网下载16.04的服务器版本的ISO即可。</p>
<a id="more"></a>
<h1 id="准备网络"><a href="#准备网络" class="headerlink" title="准备网络"></a>准备网络</h1><p>这次实验用到两台虚拟机： controller,compute</p>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/hostname</div><div class="line">controller</div><div class="line"></div><div class="line">$ cat /etc/hosts</div><div class="line">127.0.0.1	localhost</div><div class="line">192.168.199.11  compute</div><div class="line">192.168.199.10  controller</div><div class="line"></div><div class="line">$ cat /etc/network/interfaces</div><div class="line"><span class="comment"># The loopback network interface</span></div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"><span class="comment"># The primary network interface</span></div><div class="line">auto ens33</div><div class="line">iface ens33 inet static</div><div class="line">address 192.168.199.10</div><div class="line">netmask 255.255.255.0</div><div class="line">gateway 192.168.199.1</div><div class="line">dns-nameservers 192.168.199.1</div><div class="line"></div><div class="line">auto ens34</div><div class="line">iface ens34 inet static</div><div class="line">address 10.170.56.10</div><div class="line">netmask 255.255.255.0</div><div class="line"></div><div class="line">auto ens35</div><div class="line">iface ens35 inet manual</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>接口</th>
<th>ip</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>ens33</td>
<td>192.168.199.10</td>
<td>桥接</td>
</tr>
<tr>
<td>ens34</td>
<td>10.170.56.10</td>
<td>私有</td>
</tr>
<tr>
<td>ens35</td>
<td>网关192.168.112.2</td>
<td>nat</td>
</tr>
</tbody>
</table>
<h2 id="compute"><a href="#compute" class="headerlink" title="compute"></a>compute</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/hostname</div><div class="line">compute</div><div class="line"></div><div class="line">$ cat /etc/hosts</div><div class="line">127.0.0.1	localhost</div><div class="line">192.168.199.11  compute</div><div class="line">192.168.199.10  controller</div><div class="line"></div><div class="line">$ cat /etc/network/interfaces</div><div class="line"><span class="comment"># The loopback network interface</span></div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"><span class="comment"># The primary network interface</span></div><div class="line">auto ens33</div><div class="line">iface ens33 inet static</div><div class="line">address 192.168.199.11</div><div class="line">netmask 255.255.255.0</div><div class="line">gateway 192.168.199.1</div><div class="line">dns-nameservers 192.168.199.1</div><div class="line"></div><div class="line">auto ens34</div><div class="line">iface ens34 inet static</div><div class="line">address 10.170.56.11</div><div class="line">netmask 255.255.255.0</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>接口</th>
<th>ip</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>ens33</td>
<td>192.168.199.11</td>
<td>桥接</td>
</tr>
<tr>
<td>ens34</td>
<td>10.170.56.11</td>
<td>私有</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>PS:</p>
<ul>
<li>桥接模式是虚拟机可以更物理机所在网络共享一套网络，例如跟物理机同一个WiFi里面的设备都可以访问物理机里面的虚拟机。这里用来做管理节点的网络。</li>
<li>私有模式代表虚拟机只能跟物理机作为一个网络，其他设备访问不了，一般可以用来做内部网络</li>
<li>nat模式用来给虚拟机访问互联网用</li>
</ul>
<p>PSPS:<br>接下来会在上面的两台虚拟机安装openstack，安装完openstack后，两台虚拟机对于openstack来说，就是物理机，通过openstack，创建的就是云主机（或者叫租户）了。所以必须要谨记这点。</p>
<p>PSPSPS:</p>
<ul>
<li>桥接模式的ip必须是你电脑所在网络的任意不冲突的同子网的ip</li>
<li>私有模式的ip可以任意一个子网下的ip，这个网络是用来做租户网络的</li>
<li>nat网络不用配ip，这个给租户用来访问外网的，接下来实验会再提及，注意下他的网关即可，它是你的VMware的nat的一个网关。</li>
</ul>
<p>上面网络配置好后，可以开搞了，至于怎么安装虚拟机和配置网络，可以搜索相关文章😈。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备VMware&quot;&gt;&lt;a href=&quot;#准备VMware&quot; class=&quot;headerlink&quot; title=&quot;准备VMware&quot;&gt;&lt;/a&gt;准备VMware&lt;/h1&gt;&lt;p&gt;由于我是习惯了mac上做实验，所以用VMware fusion，随便下个破解版即可。&lt;/p&gt;
&lt;h1 id=&quot;准备Ubuntu&quot;&gt;&lt;a href=&quot;#准备Ubuntu&quot; class=&quot;headerlink&quot; title=&quot;准备Ubuntu&quot;&gt;&lt;/a&gt;准备Ubuntu&lt;/h1&gt;&lt;p&gt;Ubuntu去官网下载16.04的服务器版本的ISO即可。&lt;/p&gt;
    
    </summary>
    
      <category term="openstack" scheme="http://idiotsky.me/categories/openstack/"/>
    
    
      <category term="openstack" scheme="http://idiotsky.me/tags/openstack/"/>
    
      <category term="ubuntu" scheme="http://idiotsky.me/tags/ubuntu/"/>
    
      <category term="kvm" scheme="http://idiotsky.me/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>一张图了解三色标记法</title>
    <link href="http://idiotsky.me/2017/08/16/gc-three-color/"/>
    <id>http://idiotsky.me/2017/08/16/gc-three-color/</id>
    <published>2017-08-15T17:02:35.000Z</published>
    <updated>2017-08-20T03:32:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/gc-1.gif"><img src="/images/gc-1.gif" alt=""></a><br><a id="more"></a><br>三色标记法是传统 Mark-Sweep 的一个改进，它是一个并发的 GC 算法。<br>原理如下，</p>
<ol>
<li>首先创建三个集合：白、灰、黑。</li>
<li>将所有对象放入白色集合中。</li>
<li>然后从根节点开始遍历所有对象（注意这里并不<strong>递归遍历</strong>），把遍历到的对象从白色集合放入灰色集合。</li>
<li>之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</li>
<li>重复 4 直到灰色中无任何对象</li>
<li>通过write-barrier检测对象有变化，重复以上操作</li>
<li>收集所有白色对象（垃圾）</li>
</ol>
<p>这个算法可以实现 “on-the-fly”，也就是在程序执行的同时进行收集，并不需要暂停整个程序。<br>但是也会有一个缺陷，可能程序中的垃圾产生的速度会大于垃圾收集的速度，这样会导致程序中的垃圾越来越多无法被收集掉。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/gc-1.gif&quot;&gt;&lt;img src=&quot;/images/gc-1.gif&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="gc" scheme="http://idiotsky.me/tags/gc/"/>
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>一张图了解标记清除算法</title>
    <link href="http://idiotsky.me/2017/08/16/gc-mark-sweep/"/>
    <id>http://idiotsky.me/2017/08/16/gc-mark-sweep/</id>
    <published>2017-08-15T17:02:21.000Z</published>
    <updated>2017-08-15T17:06:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/gc.gif"><img src="/images/gc.gif" alt=""></a><br><a id="more"></a><br>这个算法分为两步，标记和清除。</p>
<ul>
<li>标记：从程序的根节点开始， 递归地 遍历所有对象，将能遍历到的对象打上标记。</li>
<li>清除：讲所有未标记的的对象当作垃圾销毁。</li>
</ul>
<p>但是这个算法也有一个缺陷，就是人们常常说的 STW 问题（Stop The World）。因为算法在标记时必须暂停整个程序，否则其他线程的代码可能会改变对象状态，从而可能把不应该回收的对象当做垃圾收集掉。<br>当程序中的对象逐渐增多时，递归遍历整个对象树会消耗很多的时间，在大型程序中这个时间可能会是毫秒级别的。让所有的用户等待几百毫秒的 GC 时间这是不能容忍的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/gc.gif&quot;&gt;&lt;img src=&quot;/images/gc.gif&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="gc" scheme="http://idiotsky.me/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>postman的几种body的使用介绍</title>
    <link href="http://idiotsky.me/2017/08/10/postman/"/>
    <id>http://idiotsky.me/2017/08/10/postman/</id>
    <published>2017-08-10T12:11:55.000Z</published>
    <updated>2017-08-15T16:51:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>postman,用来模拟发送http请求的工具，里面涉及的请求body有以下几个类型，所以记下，而且也能理解http body的几种格式，分享之。。</p>
</blockquote>
<a id="more"></a>
<h1 id="form-data"><a href="#form-data" class="headerlink" title="form-data"></a>form-data</h1><p>就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型；content-disposition，用来说明字段的一些信息；<br>由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。</p>
<p><a href="/images/postman-1.png"><img src="/images/postman-1.png" alt=""></a><br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">POST /login HTTP/1.1</div><div class="line">Host: 10.170.56.67</div><div class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Cache-Control: no-cache</div><div class="line">Postman-Token: 9843651a-5bf9-0544-03c1-fcc2a16f484b</div><div class="line"></div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;username&quot;</div><div class="line"></div><div class="line">admin</div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;password&quot;</div><div class="line"></div><div class="line">admin123</div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;abc&quot;; filename=&quot;&quot;</div><div class="line">Content-Type: </div><div class="line"></div><div class="line"></div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;tttt&quot;; filename=&quot;&quot;</div><div class="line">Content-Type: </div><div class="line"></div><div class="line"></div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</div></pre></td></tr></table></figure></p>
<h1 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h1><p>就是application/x-www-from-urlencoded,会将表单内的数据转换为键值对，并以urlencode为格式<br><a href="/images/postman-2.png"><img src="/images/postman-2.png" alt=""></a><br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST /login HTTP/1.1</div><div class="line">Host: 10.170.56.67</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Cache-Control: no-cache</div><div class="line">Postman-Token: e6887900-a46e-2ff4-8232-de878b75f5fd</div><div class="line"></div><div class="line">username=admin&amp;password=admin123</div></pre></td></tr></table></figure></p>
<h1 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h1><p>可以上传任意格式的文本，可以上传text、json、xml、html等<br><a href="/images/postman-3.png"><img src="/images/postman-3.png" alt=""></a><br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">POST /login HTTP/1.1</div><div class="line">Host: 10.170.56.67</div><div class="line">Content-Type: application/json</div><div class="line">Cache-Control: no-cache</div><div class="line">Postman-Token: 233df0e0-c6d9-98c7-4d7e-736329322683</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;abc&quot;:&quot;cba&quot;,</div><div class="line">  &quot;cba&quot;:&quot;abc&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从图片和内容对比，可以发现，基本，粘什么，就发什么，不会进行任何转意。</p>
<h1 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h1><p>相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。</p>
<h1 id="multipart-form-data与x-www-form-urlencoded区别"><a href="#multipart-form-data与x-www-form-urlencoded区别" class="headerlink" title="multipart/form-data与x-www-form-urlencoded区别"></a>multipart/form-data与x-www-form-urlencoded区别</h1><ul>
<li>multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息；</li>
<li>x-www-form-urlencoded：只能上传键值对，并且键值对都是间隔分开的</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;postman,用来模拟发送http请求的工具，里面涉及的请求body有以下几个类型，所以记下，而且也能理解http body的几种格式，分享之。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="http" scheme="http://idiotsky.me/categories/http/"/>
    
    
      <category term="postman" scheme="http://idiotsky.me/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>go的是否需要用goroutine pool？</title>
    <link href="http://idiotsky.me/2017/08/03/go-worker-pool-if-need/"/>
    <id>http://idiotsky.me/2017/08/03/go-worker-pool-if-need/</id>
    <published>2017-08-03T15:10:02.000Z</published>
    <updated>2017-08-05T14:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这几天无聊，想到java有自己的线程池，是否对应go也有它的goroutine pool呢，所以搜了下，标准库没有，github有，但都大同小异，所以自己实现了一个。</p>
</blockquote>
<a id="more"></a>
<h1 id="一个简单的goroutine-pool"><a href="#一个简单的goroutine-pool" class="headerlink" title="一个简单的goroutine pool"></a>一个简单的goroutine pool</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> workerpool</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> task <span class="function"><span class="keyword">func</span><span class="params">()</span></span></div><div class="line"></div><div class="line"><span class="title">type</span> <span class="title">worker</span> <span class="title">struct</span> &#123;</div><div class="line">	stopC <span class="keyword">chan</span> <span class="keyword">bool</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> WorkerPool <span class="keyword">struct</span> &#123;</div><div class="line">	num <span class="keyword">int</span></div><div class="line">	sync.Mutex</div><div class="line">	taskQ <span class="keyword">chan</span> task</div><div class="line">	workers []*worker</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorkerPool</span><span class="params">(workerNum <span class="keyword">int</span>,queueCap <span class="keyword">int</span>)</span> *<span class="title">WorkerPool</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> &amp;WorkerPool&#123;num:workerNum,taskQ:<span class="built_in">make</span>(<span class="keyword">chan</span> task,queueCap),workers:<span class="built_in">make</span>([]*worker,workerNum)&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span> <span class="title">Execute</span><span class="params">(t task)</span></span>&#123;</div><div class="line">	wp.taskQ&lt;-t</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span> <span class="title">Start</span><span class="params">()</span> *<span class="title">WorkerPool</span></span>&#123;</div><div class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;wp.num;i++&#123;</div><div class="line">		wp.workers[i]=&amp;worker&#123; <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)&#125;</div><div class="line">		w:=wp.workers[i]</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> &#123;</div><div class="line">				    stop:=<span class="literal">false</span></div><div class="line">					<span class="keyword">select</span> &#123;</div><div class="line">					    <span class="keyword">case</span> f:=&lt;-wp.taskQ:</div><div class="line">							f()</div><div class="line">					    <span class="keyword">case</span> stop=&lt;-w.stopC:</div><div class="line">						     <span class="keyword">break</span></div><div class="line"></div><div class="line">					&#125;</div><div class="line"></div><div class="line">				<span class="keyword">if</span> stop&#123;</div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			fmt.Println(<span class="string">"stop"</span>)</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> wp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">for</span> _,w:=<span class="keyword">range</span> wp.workers&#123;</div><div class="line">		w.stopC&lt;- <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很简单，就是<code>NewWorkerPool</code>一个池子的时候设置goroutine的数量和任务队列的大小。<code>Start</code>后就创建那么多goroutine去任务队列取任务执行，取不到任务就自循。<code>Execute</code>方法是把任务压进队列，如果队列满了就阻塞。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>要测试性能，肯定要有对比，以下是没有使用pool:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">nopool</span><span class="params">()</span></span> &#123;</div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">    <span class="comment">//执行1000000次，每次都启动一个goroutine</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">defer</span> wg.Done()</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	wg.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下是简单版的只是单纯限制goroutine数量和任务队列的代码，没有任何封装的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopool</span><span class="params">()</span></span> &#123;</div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">    <span class="comment">//队列100</span></div><div class="line">	data := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</div><div class="line"></div><div class="line">    <span class="comment">//goroutine 数量10个</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">defer</span> wg.Done()</div><div class="line">			<span class="keyword">for</span> _ = <span class="keyword">range</span> data &#123;</div><div class="line">				<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</div><div class="line">					<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</div><div class="line"></div><div class="line">					&#125;</div><div class="line">				&#125;()</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="comment">//执行1000000个任务</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</div><div class="line">		data &lt;- i</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">close</span>(data)</div><div class="line">	wg.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是主角:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">workerpool</span><span class="params">()</span></span> &#123;</div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">    <span class="comment">//十个goroutine，队列容量100</span></div><div class="line">	wp:=NewWorkerPool(<span class="number">10</span>,<span class="number">100</span>)</div><div class="line">	wp.Start()</div><div class="line">    <span class="comment">//提交1000000任务</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		wp.Execute(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			wg.Done()</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码基本都是做同样一件事，但是后两个只开10个goroutine，第一个就开了1000000个，结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BenchmarkNopool-8                      1        7966900091 ns/op</div><div class="line">BenchmarkGopool-8                      1        7949844269 ns/op</div><div class="line">BenchmarkWorkerPool-8                  1        7997732135 ns/op</div></pre></td></tr></table></figure></p>
<p>可以看出来，没有区别，重新run几次基本没有多大变化。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于go本身有对goroutine有调度，所以自己实现的池子来调度其实好像没有什么用。还有可能我自己能力实现不好，没发挥池子的作用😀。<br>但是用更少的goroutine能完成同样的事情，应该是一种优化，而且这里的goroutine执行都是简单的循环，没有复杂的业务，一旦业务复杂，更少goroutine能够减少内存和goroutine切换时的cpu资源，有可能上面性能的比较会拉开。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这几天无聊，想到java有自己的线程池，是否对应go也有它的goroutine pool呢，所以搜了下，标准库没有，github有，但都大同小异，所以自己实现了一个。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>利用树莓派搭建一个简易的NAS</title>
    <link href="http://idiotsky.me/2017/07/20/raspberry-nas/"/>
    <id>http://idiotsky.me/2017/07/20/raspberry-nas/</id>
    <published>2017-07-20T14:39:35.000Z</published>
    <updated>2017-08-31T13:48:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>raspberry pi 3</li>
<li>硬盘（格式化过ext4的）</li>
<li>连接raspberry用的终端</li>
</ul>
<a id="more"></a>
<h1 id="安装samba"><a href="#安装samba" class="headerlink" title="安装samba"></a>安装samba</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install samba samba-common-bin</div></pre></td></tr></table></figure>
<h1 id="配置samba"><a href="#配置samba" class="headerlink" title="配置samba"></a>配置samba</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.back</div><div class="line">sudo vim /etc/samba/smb.conf</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在末尾加入如下内容</span></div><div class="line"><span class="comment"># 分享名称</span></div><div class="line">[MyNAS]</div><div class="line"><span class="comment"># 说明信息</span></div><div class="line">comment = NAS Storage</div><div class="line"><span class="comment"># 可以访问的用户</span></div><div class="line">valid users = pi,root</div><div class="line"><span class="comment"># 共享文件的路径,raspberry pi 会自动将连接到其上的外接存储设备挂载到/media/pi/目录下。</span></div><div class="line">path = /media/pi/</div><div class="line"><span class="comment"># 可被其他人看到资源名称（非内容）</span></div><div class="line">browseable = yes</div><div class="line"><span class="comment"># 可写</span></div><div class="line">writable = yes</div><div class="line"><span class="comment"># 新建文件的权限为 664</span></div><div class="line">create mask = 0664</div><div class="line"><span class="comment"># 新建目录的权限为 775</span></div><div class="line">directory mask = 0775</div></pre></td></tr></table></figure>
<p>可以把配置文件中你不需要的分享名称删除，例如 [homes], [printers] 等。<br>测试配置文件是否有错误，根据提示做相应修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">testparm</div></pre></td></tr></table></figure></p>
<p>添加登陆账户并创建密码，必须是 linux 已存在的用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo smbpasswd -a pi</div></pre></td></tr></table></figure></p>
<p>重启 samba 服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/samba restart</div></pre></td></tr></table></figure></p>
<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>一般树莓派跟你的WiFi相连的话，你的网络就能看到跟上面配置一样的分享名称，如mac上面这样的显示：<br><a href="/images/nas-screenshot.png"><img src="/images/nas-screenshot.png" alt=""></a><br>如果显示没权限，可以断开连接，用你上面添加的账号登录。</p>
<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><ul>
<li>基本上不是ext4格式的硬盘都不用上传到NAS上了，因为树莓对其他格式的硬盘只有读权限。</li>
<li>如果是ext4格式，也不要高兴，那上传速度可以😭的</li>
<li><p>如果是其他格式的话，上面都说只能读，一般情况拷进硬盘的片片是可以用pi用户读的，如果遇到连pi用户都没有读权限的话，而且登上树莓派进到硬盘里面强制改权限都是改不了的。所以，老老实实加个root用户吧。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo smbpasswd -a root</div></pre></td></tr></table></figure>
</li>
<li><p>用root用户连上去基本没有不能读的。但是还是不能写。老老实实还是拔硬盘到电脑烤吧。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;raspberry pi 3&lt;/li&gt;
&lt;li&gt;硬盘（格式化过ext4的）&lt;/li&gt;
&lt;li&gt;连接raspberry用的终端&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="raspberrypi" scheme="http://idiotsky.me/categories/raspberrypi/"/>
    
    
      <category term="python" scheme="http://idiotsky.me/tags/python/"/>
    
      <category term="raspberrypi" scheme="http://idiotsky.me/tags/raspberrypi/"/>
    
      <category term="NAS" scheme="http://idiotsky.me/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>利用树莓派实现一个能播放天气的闹钟</title>
    <link href="http://idiotsky.me/2017/07/18/raspberry-weather-clock/"/>
    <id>http://idiotsky.me/2017/07/18/raspberry-weather-clock/</id>
    <published>2017-07-17T17:12:25.000Z</published>
    <updated>2017-08-10T12:26:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>你要有个pi😄<br><a id="more"></a></p>
<h1 id="获取天气接口"><a href="#获取天气接口" class="headerlink" title="获取天气接口"></a>获取天气接口</h1><p>这里我是用图灵机器人来获取天气的接口，你可以自己上去注册一个，下面代码URL的Key是我注册的机器人给的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getWeatherText</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        response = requests.get(</div><div class="line">            <span class="string">"http://www.tuling123.com/openapi/api?key=652ae4a714794fe6b01faa990d7a981f&amp;info=%s"</span> % <span class="string">"广州今日天气"</span>)</div><div class="line">        json = response.json()</div><div class="line">        <span class="keyword">if</span> json[<span class="string">"code"</span>] == <span class="number">100000</span>:</div><div class="line">            <span class="keyword">return</span> json[<span class="string">"text"</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span></div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span></div></pre></td></tr></table></figure></p>
<h1 id="播放文字"><a href="#播放文字" class="headerlink" title="播放文字"></a>播放文字</h1><p>利用百度的接口可以转换文本为语音。默认只有女声<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2voice</span><span class="params">(text)</span>:</span></div><div class="line">    url = <span class="string">'http://tts.baidu.com/text2audio?idx=1&amp;tex=&#123;0&#125;&amp;cuid=baidu_speech_'</span> \</div><div class="line">          <span class="string">'demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=4&amp;per=4&amp;vol=5&amp;pit=5'</span>.format(text)</div><div class="line">    <span class="comment"># 用mplayer播放语音</span></div><div class="line">    os.system(<span class="string">'mplayer "%s"'</span> % url)</div></pre></td></tr></table></figure></p>
<h1 id="安装播放媒体软件"><a href="#安装播放媒体软件" class="headerlink" title="安装播放媒体软件"></a>安装播放媒体软件</h1><p>上面代码你看到的<code>mplayer</code>,就是用来播放语音的，传个url作为参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mplayer</div><div class="line">usage: mplayer [url]</div></pre></td></tr></table></figure></p>
<h1 id="播放音乐"><a href="#播放音乐" class="headerlink" title="播放音乐"></a>播放音乐</h1><p>有了上面这个神器，你可以给播报语音前后加一首音乐😄<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">playMusic</span><span class="params">(path)</span>:</span></div><div class="line">    os.system(<span class="string">'mplayer %s'</span> % path)</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用上面的东东，可以组合些好玩的东西了，至于闹钟的唤醒，可以crob job 做，也可以代码里面实现，enjoy…😄<br>全部代码地址 <a href="https://github.com/ejunjsh/raspberrypi-code/blob/master/clock/weather.py" target="_blank" rel="external">https://github.com/ejunjsh/raspberrypi-code/blob/master/clock/weather.py</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h1&gt;&lt;p&gt;你要有个pi😄&lt;br&gt;
    
    </summary>
    
      <category term="raspberrypi" scheme="http://idiotsky.me/categories/raspberrypi/"/>
    
    
      <category term="python" scheme="http://idiotsky.me/tags/python/"/>
    
      <category term="raspberrypi" scheme="http://idiotsky.me/tags/raspberrypi/"/>
    
  </entry>
  
  <entry>
    <title>用go实现一个简单的restful接口</title>
    <link href="http://idiotsky.me/2017/07/18/go-first-rest/"/>
    <id>http://idiotsky.me/2017/07/18/go-first-rest/</id>
    <published>2017-07-17T17:01:18.000Z</published>
    <updated>2017-07-22T08:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>go的标准库<code>http</code>已经封装好很多接口，可以很简单实现一个web服务器。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义 handler</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</div><div class="line">    io.WriteString(w, <span class="string">"hello, world!\n"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">//绑定pattern和handler</span></div><div class="line">    http.HandleFunc(<span class="string">"/hello"</span>, HelloServer)</div><div class="line">    err := http.ListenAndServe(<span class="string">":12345"</span>, <span class="literal">nil</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基于上面例子可以封装一个restful接口，不是难事。<br><a id="more"></a></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>从上面例子可以看到，一个url pattern对应一个handler，即对应一个处理，就可以处理http请求了，所以下面的实现是基于对这两个东西的封装开始</p>
<h2 id="封装一个restful-app-结构"><a href="#封装一个restful-app-结构" class="headerlink" title="封装一个restful app 结构"></a>封装一个restful app 结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">//一个map，key是pattern，value是handler</span></div><div class="line">	handlers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(r *HttpRequest,w HttpResponse)</span><span class="title">error</span></span></div><div class="line">    //<span class="title">pattern</span>数组，用来保证加入<span class="title">pattern</span>的顺序，因为上面的<span class="title">map</span>是无顺序的</div><div class="line">	<span class="title">patterns</span> []<span class="title">string</span></div><div class="line">    //一个<span class="title">map</span>，<span class="title">key</span>是<span class="title">pattern</span>，<span class="title">value</span>是<span class="title">http</span> <span class="title">method</span></div><div class="line">	<span class="title">methods</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></div><div class="line">    //用来实现在<span class="title">url</span> <span class="title">path</span>取出参数的。</div><div class="line">	<span class="title">regexps</span> <span class="title">map</span>[<span class="title">string</span>]*<span class="title">regexp</span>.<span class="title">Regexp</span></div><div class="line">	<span class="title">pathparamanmes</span> <span class="title">map</span>[<span class="title">string</span>][]<span class="title">string</span></div><div class="line">    //用来处理异常的<span class="title">handler</span></div><div class="line">	<span class="title">errHandler</span> <span class="title">func</span><span class="params">( err error, r *HttpRequest,w HttpResponse)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApp</span><span class="params">()</span> *<span class="title">App</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;App&#123;</div><div class="line">		handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>),</span></div><div class="line">		<span class="title">patterns</span>:<span class="title">make</span><span class="params">([]<span class="keyword">string</span>,0)</span>,</div><div class="line">		<span class="title">methods</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span>,</div><div class="line">		<span class="title">regexps</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]*regexp.Regexp)</span>,</div><div class="line">		<span class="title">pathparamanmes</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span>,</div><div class="line">        //一个默认的异常处理，直接返回异常内容</div><div class="line">		<span class="title">errHandler</span>: <span class="title">func</span><span class="params">(err error, r *HttpRequest, w HttpResponse)</span> &#123;</div><div class="line">			w.Write( []<span class="keyword">byte</span>(err.Error()))</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="映射绑定"><a href="#映射绑定" class="headerlink" title="映射绑定"></a>映射绑定</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">handle</span><span class="params">(method <span class="keyword">string</span>,pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span> <span class="title">error</span>)</span>&#123;</div><div class="line">    <span class="comment">//绑定pattern和handler</span></div><div class="line">	a.handlers[pattern]=handler</div><div class="line">    <span class="comment">//绑定pattern和method</span></div><div class="line">	a.methods[pattern]=method</div><div class="line">    <span class="comment">//绑定pattern 正则，用来匹配url pattern,和获取url path 参数</span></div><div class="line">	a.regexps[pattern],a.pathparamanmes[pattern]=convertPatterntoRegex(pattern)</div><div class="line">	<span class="keyword">for</span> _,s:=<span class="keyword">range</span> a.patterns&#123;</div><div class="line">		<span class="keyword">if</span> s==pattern&#123;</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//加入数组，方便用此数组确定顺序</span></div><div class="line">	a.patterns=<span class="built_in">append</span>(a.patterns,pattern)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//绑定GET</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Get</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"GET"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定POST</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Post</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"POST"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定DELETE</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Delete</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"DELETE"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定PUT</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Put</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span> <span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"PUT"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Error</span><span class="params">(handler <span class="keyword">func</span>(err error,r *HttpRequest,w HttpResponse)</span>)</span>  &#123;</div><div class="line">	a.errHandler=handler</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了Restful接口的四个方法映射绑定，剩下的就要请求能进到来，所以接下来要写个入口才行。</p>
<h2 id="编写http入口"><a href="#编写http入口" class="headerlink" title="编写http入口"></a>编写http入口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//http 入口</span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">Run</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</div><div class="line">	fmt.Printf(<span class="string">"Server listens on %s"</span>,address)</div><div class="line">	err:=http.ListenAndServe(address,&amp;hodler&#123;app:a&#125;)</div><div class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//https 入口</span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">RunTls</span><span class="params">(address <span class="keyword">string</span>,cert <span class="keyword">string</span>,key <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</div><div class="line">	fmt.Printf(<span class="string">"Server listens on %s"</span>,address)</div><div class="line">	err:=http.ListenAndServeTLS(address,cert,key,&amp;hodler&#123;app:a&#125;)</div><div class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>入口函数主要调用<code>http</code>库来启动http服务，然后把请求处理函数作为<code>ListenAndServe</code>第二个参数传入。这里由<code>holder</code>来实现这个处理函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hodler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</div><div class="line">	<span class="comment">//封装一下，附加更多功能</span></div><div class="line">    request:= newHttpRequest(r)</div><div class="line">	response:=newHttpResponse(w)</div><div class="line">	<span class="comment">//捕获panic，并让errhandler处理返回。</span></div><div class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span>&#123;</div><div class="line">			<span class="keyword">if</span> e,ok:=err.(error);ok&#123;</div><div class="line">				h.app.errHandler(InternalError&#123;e,<span class="string">""</span>&#125;,request,response)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> e,ok:=err.(<span class="keyword">string</span>);ok&#123;</div><div class="line">				h.app.errHandler(InternalError&#123;<span class="literal">nil</span>,e&#125;,request,response)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">    <span class="comment">//根据pattern的添加顺序，循环判断</span></div><div class="line">   <span class="keyword">for</span> _,p:=<span class="keyword">range</span> h.app.patterns&#123;</div><div class="line">       <span class="keyword">if</span> reg,ok:= h.app.regexps[p];ok&#123;</div><div class="line">           <span class="comment">//匹配method</span></div><div class="line">		   <span class="keyword">if</span> method,ok:=h.app.methods[p];ok&amp;&amp;r.Method==method&#123;</div><div class="line">              <span class="comment">//匹配pattern</span></div><div class="line">			   <span class="keyword">if</span> reg.Match([]<span class="keyword">byte</span>(r.URL.Path)) &#123;</div><div class="line">                   <span class="comment">//抽取url path parameters</span></div><div class="line">				   matchers:=reg.FindSubmatch([]<span class="keyword">byte</span>(r.URL.Path))</div><div class="line">				   pathParamMap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</div><div class="line">				   <span class="keyword">if</span> <span class="built_in">len</span>(matchers)&gt;<span class="number">1</span>&#123;</div><div class="line">                       <span class="keyword">if</span> pathParamNames,ok:=h.app.pathparamanmes[p];ok&#123;</div><div class="line">						   <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(matchers);i++&#123;</div><div class="line">							   pathParamMap[pathParamNames[i]]=<span class="keyword">string</span>(matchers[i])</div><div class="line">						   &#125;</div><div class="line">					   &#125;</div><div class="line">				   &#125;</div><div class="line">                   <span class="comment">//PathParams是封装后的request独有的属性</span></div><div class="line">				   request.PathParams=pathParamMap</div><div class="line">				   <span class="keyword">if</span> handler,ok:=h.app.handlers[p];ok&#123;</div><div class="line">                       <span class="comment">//执行handler</span></div><div class="line">					   err:=handler(request,response)</div><div class="line">					   <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">                           <span class="comment">//执行errhandler</span></div><div class="line">						   h.app.errHandler(err,request,response)</div><div class="line">					   &#125;</div><div class="line">					   <span class="keyword">return</span></div><div class="line">				   &#125;</div><div class="line">			   &#125;</div><div class="line">		   &#125;</div><div class="line">	   &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//执行no found errhandler</span></div><div class="line">	h.app.errHandler(NoFoundError&#123;&#125;,request,response)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基本一个请求的流程如下：<br>requset-&gt;ServeHTTP()-&gt;匹配url pattern-&gt;匹配method-&gt;匹配到你的handler-&gt;执行你的handler-&gt;你的handler返回结果</p>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>由于返回结果可以有很多，所以封装了<code>http</code>库的<code>http.ResponseWriter</code>来实现<code>WriteString,WriteJson,WriteXml,WriteFile</code>等方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//封装request，附件一个PathParams来保存url path parameters.</span></div><div class="line"><span class="keyword">type</span> HttpRequest <span class="keyword">struct</span> &#123;</div><div class="line">	*http.Request</div><div class="line">	PathParams <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> HttpResponse <span class="keyword">struct</span> &#123;</div><div class="line">	http.ResponseWriter</div><div class="line">&#125;</div><div class="line"><span class="comment">//用来返回字符</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteString</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回JSON</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteJson</span><span class="params">(jsonObj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回XML</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteXml</span><span class="params">(xmlObj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回文件</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteFile</span><span class="params">(filepath <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回一个模板html</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteTemplates</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;,tplPath ...<span class="keyword">string</span>)</span> <span class="title">error</span></span>  &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//new 一个restful接口</span></div><div class="line">	app:=gorest.NewApp()</div><div class="line">    <span class="comment">//绑定</span></div><div class="line">	app.Get(<span class="string">"/json"</span>, <span class="function"><span class="keyword">func</span><span class="params">(r *gorest.HttpRequest, w gorest.HttpResponse)</span> <span class="title">error</span></span> &#123;</div><div class="line">		a:= <span class="keyword">struct</span> &#123;</div><div class="line">			Abc <span class="keyword">string</span> <span class="string">`json:"abc"`</span></div><div class="line">			Cba <span class="keyword">string</span> <span class="string">`json:"cba"`</span></div><div class="line">		&#125;&#123;<span class="string">"123"</span>,<span class="string">"321"</span>&#125;</div><div class="line">        <span class="comment">//返回json作为结果</span></div><div class="line">		<span class="keyword">return</span> w.WriteJson(a)</div><div class="line">	&#125;)</div><div class="line">	app.Error(<span class="function"><span class="keyword">func</span><span class="params">(err error, r *gorest.HttpRequest, w gorest.HttpResponse)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span> e,ok:=err.(gorest.NoFoundError);ok &#123;</div><div class="line">			w.Write([]<span class="keyword">byte</span>(e.Error()))</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> e,ok:=err.(gorest.InternalError);ok &#123;</div><div class="line">			w.Write([]<span class="keyword">byte</span>(e.Error()))</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">    <span class="comment">//启动</span></div><div class="line">	app.Run(<span class="string">":8081"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>收工😄</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>go的标准库封装了很多了，所以实现这个其实还是比较轻松的😄<br>详细代码见<a href="https://github.com/ejunjsh/gorest" target="_blank" rel="external">https://github.com/ejunjsh/gorest</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;go的标准库&lt;code&gt;http&lt;/code&gt;已经封装好很多接口，可以很简单实现一个web服务器。&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义 handler&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HelloServer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(w http.ResponseWriter, req *http.Request)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    io.WriteString(w, &lt;span class=&quot;string&quot;&gt;&quot;hello, world!\n&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//绑定pattern和handler&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    http.HandleFunc(&lt;span class=&quot;string&quot;&gt;&quot;/hello&quot;&lt;/span&gt;, HelloServer)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    err := http.ListenAndServe(&lt;span class=&quot;string&quot;&gt;&quot;:12345&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        log.Fatal(&lt;span class=&quot;string&quot;&gt;&quot;ListenAndServe: &quot;&lt;/span&gt;, err)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基于上面例子可以封装一个restful接口，不是难事。&lt;br&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
      <category term="restful" scheme="http://idiotsky.me/tags/restful/"/>
    
  </entry>
  
  <entry>
    <title>一张图了解一致性hash</title>
    <link href="http://idiotsky.me/2017/07/16/consistent-hash/"/>
    <id>http://idiotsky.me/2017/07/16/consistent-hash/</id>
    <published>2017-07-16T12:39:20.000Z</published>
    <updated>2017-07-19T12:39:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/consistent-hash.png"><img src="/images/consistent-hash.png" alt="one image describes how consistent-hash works"></a><br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/consistent-hash.png&quot;&gt;&lt;img src=&quot;/images/consistent-hash.png&quot; alt=&quot;one image describes how consistent-hash works&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>一张图了解hashmap</title>
    <link href="http://idiotsky.me/2017/07/15/hashmap/"/>
    <id>http://idiotsky.me/2017/07/15/hashmap/</id>
    <published>2017-07-15T10:03:15.000Z</published>
    <updated>2017-08-12T06:50:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/hashmap.png"><img src="/images/hashmap.png" alt="one image describes how hashmap works"></a><br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/hashmap.png&quot;&gt;&lt;img src=&quot;/images/hashmap.png&quot; alt=&quot;one image describes how hashmap works&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SELECT * ...... FOR UPDATE 锁机制</title>
    <link href="http://idiotsky.me/2016/12/19/mysql-select-for-update/"/>
    <id>http://idiotsky.me/2016/12/19/mysql-select-for-update/</id>
    <published>2016-12-19T12:35:56.000Z</published>
    <updated>2017-08-19T12:45:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>由于InnoDB预设是Row-Level Lock，InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ </p>
</blockquote>
<a id="more"></a>
<p>举个例子:<br>假设有个表单products ，里面有id跟name二个栏位，id是主键。<br>例1: (明确指定主键，并且有此笔资料，row lock)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'3'</span> <span class="keyword">and</span> <span class="keyword">type</span>=<span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure></p>
<p>例2: (明确指定主键，若查无此笔资料，无lock)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'-1'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure></p>
<p>例3: (无主键，table lock)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Mouse'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure></p>
<p>例4: (主键不明确，table lock)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>&lt;&gt;<span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure></p>
<p>例5: (主键不明确，table lock)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">LIKE</span> <span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</div></pre></td></tr></table></figure></p>
<p>注1: FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。<br>注2: 要测试锁定的状况，可以利用mysql的Command Mode ，开二个视窗来做测试。</p>
<p>在MySql 5.0中测试确实是这样的<br>另外：MyAsim 只支持表级锁，InnerDB支持行级锁<br>添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改（修改、删除）<br>是表级锁时，不管是否查询到记录，都会锁定表</p>
<p>此外，如果A与B都对表id进行查询但查询不到记录，则A与B在查询上不会进行row锁，但A与B都会获取排它锁，此时A再插入一条记录的话则会因为B已经有锁而处于等待中，此时B再插入一条同样的数据则会抛出Deadlock found when trying to get lock; try restarting transaction然后释放锁，此时A就获得了锁而插入成功</p>
<p>上面介绍过SELECT … FOR UPDATE 的用法，不过锁定(Lock)的数据是判别就得要注意一下了。由于InnoDB 预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。</p>
<p>转载 <a href="http://www.cnblogs.com/chenwenbiao/archive/2012/06/06/2537508.html" target="_blank" rel="external">http://www.cnblogs.com/chenwenbiao/archive/2012/06/06/2537508.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于InnoDB预设是Row-Level Lock，InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://idiotsky.me/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://idiotsky.me/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>简单理解Java GC与幽灵引用</title>
    <link href="http://idiotsky.me/2016/09/11/java-gc-reference/"/>
    <id>http://idiotsky.me/2016/09/11/java-gc-reference/</id>
    <published>2016-09-11T14:41:24.000Z</published>
    <updated>2017-08-11T15:03:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Java中一共有4种类型的引用:StrongReference、SoftReference、WeakReference以及PhantomReference (幽灵引用), 这 4 种类型的引用与Java GC有着密切的关系, 让我们逐一来看它们的定义和使用场景。</p>
</blockquote>
<a id="more"></a>
<h1 id="Strong-Reference"><a href="#Strong-Reference" class="headerlink" title="Strong Reference"></a>Strong Reference</h1><p>StrongReference 是 Java 的默认引用实现,它会尽可能长时间的存活于 JVM 内， 当没有任何对象指向它时Java GC 执行后将会被回收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strongReference</span><span class="params">()</span> </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 通过赋值创建 StrongReference   </div><div class="line"> */  </div><div class="line">Object strongReference = referent;   </div><div class="line">   </div><div class="line">assertSame(referent, strongReference);   </div><div class="line">   </div><div class="line">referent = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * StrongReference 在 GC 后不会被回收  </div><div class="line"> */  </div><div class="line">assertNotNull(strongReference);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="WeakReference-amp-WeakHashMap"><a href="#WeakReference-amp-WeakHashMap" class="headerlink" title="WeakReference &amp; WeakHashMap"></a>WeakReference &amp; WeakHashMap</h1><p>WeakReference， 顾名思义,是一个弱引用,当所引用的对象在 JVM 内不再有强引用时, Java GC 后 weak reference 将会被自动回收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakReference</span><span class="params">()</span> </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();   </div><div class="line">WeakReference&lt;Object&gt; weakRerference = <span class="keyword">new</span> WeakReference&lt;Object&gt;(referent);   </div><div class="line"> </div><div class="line">assertSame(referent, weakRerference.get());   </div><div class="line">   </div><div class="line">referent = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 一旦没有指向 referent 的强引用, weak reference 在 GC 后会被自动回收  </div><div class="line"> */  </div><div class="line">assertNull(weakRerference.get());   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WeakHashMap 使用 WeakReference 作为 key， 一旦没有指向 key 的强引用, WeakHashMap 在Java GC 后将自动删除相关的 entry<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakHashMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </div><div class="line">Map&lt;Object, Object&gt; weakHashMap = <span class="keyword">new</span> WeakHashMap&lt;Object, Object&gt;();   </div><div class="line">Object key = <span class="keyword">new</span> Object();   </div><div class="line">Object value = <span class="keyword">new</span> Object();   </div><div class="line">weakHashMap.put(key, value);   </div><div class="line"> </div><div class="line">assertTrue(weakHashMap.containsValue(value));   </div><div class="line">   </div><div class="line">key = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 等待无效 entries 进入 ReferenceQueue 以便下一次调用 getTable 时被清理  </div><div class="line"> */  </div><div class="line">Thread.sleep(<span class="number">1000</span>);   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * 一旦没有指向 key 的强引用, WeakHashMap 在 GC 后将自动删除相关的 entry  </div><div class="line"> */  </div><div class="line">assertFalse(weakHashMap.containsValue(value));   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="SoftReference"><a href="#SoftReference" class="headerlink" title="SoftReference"></a>SoftReference</h1><p>SoftReference 于 WeakReference 的特性基本一致， 最大的区别在于 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">softReference</span><span class="params">()</span> </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();   </div><div class="line">SoftReference&lt;Object&gt; softRerference = <span class="keyword">new</span> SoftReference&lt;Object&gt;(referent);   </div><div class="line"> </div><div class="line">assertNotNull(softRerference.get());   </div><div class="line">   </div><div class="line">referent = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> *soft references 只有在 jvm OutOfMemory 之前才会被回收, 所以它非常适合缓存应用  </div><div class="line"> */  </div><div class="line">assertNotNull(softRerference.get());   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Phantom-Reference"><a href="#Phantom-Reference" class="headerlink" title="Phantom Reference"></a>Phantom Reference</h1><p>作为本文主角， Phantom Reference(幽灵引用) 与 WeakReference 和 SoftReference 有很大的不同,因为它的 get() 方法永远返回 null, 这也正是它名字的由来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phantomReferenceAlwaysNull</span><span class="params">()</span> </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();   </div><div class="line">PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(referent, <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;());   </div><div class="line">   </div><div class="line"><span class="comment">/**  </span></div><div class="line"> * phantom reference 的 get 方法永远返回 null   </div><div class="line"> */  </div><div class="line">assertNull(phantomReference.get());   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>诸位可能要问, 一个永远返回 null 的 reference 要来何用,请注意构造 PhantomReference 时的第二个参数 ReferenceQueue(事实上 WeakReference &amp; SoftReference 也可以有这个参数)，<br>PhantomReference 唯一的用处就是跟踪 referent何时被 enqueue 到 ReferenceQueue 中.</p>
<h1 id="RererenceQueue"><a href="#RererenceQueue" class="headerlink" title="RererenceQueue"></a>RererenceQueue</h1><p>当一个 WeakReference 开始返回 null 时， 它所指向的对象已经准备被回收， 这时可以做一些合适的清理工作. 将一个 ReferenceQueue 传给一个 Reference 的构造函数， 当对象被回收时， 虚拟机会自动将这个对象插入到 ReferenceQueue 中， WeakHashMap 就是利用 ReferenceQueue 来清除 key 已经没有强引用的 entries.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">referenceQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;   </div><div class="line">Object referent = <span class="keyword">new</span> Object();  </div><div class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();   </div><div class="line">WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;Object&gt;(referent, referenceQueue);   </div><div class="line">   </div><div class="line">assertFalse(weakReference.isEnqueued());   </div><div class="line">Reference&lt;? extends Object&gt; polled = referenceQueue.poll();   </div><div class="line">assertNull(polled);   </div><div class="line">   </div><div class="line">referent = <span class="keyword">null</span>;   </div><div class="line">System.gc();   </div><div class="line"> </div><div class="line">assertTrue(weakReference.isEnqueued());   </div><div class="line">Reference&lt;? extends Object&gt; removed = referenceQueue.remove();   </div><div class="line">assertNotNull(removed);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Phantom-Reference-vs-Weak-Reference"><a href="#Phantom-Reference-vs-Weak-Reference" class="headerlink" title="Phantom Reference vs Weak Reference"></a>Phantom Reference vs Weak Reference</h1><p>PhantomReference有两个好处， 其一， 它可以让我们准确地知道对象何时被从内存中删除， 这个特性可以被用于一些特殊的需求中(例如 Distributed GC，XWork 和 google-guice 中也使用 PhantomReference 做了一些清理性工作).</p>
<p>其二， 它可以避免 finalization 带来的一些根本性问题, 上文提到 PhantomReference 的唯一作用就是跟踪 referent 何时被 enqueue 到 ReferenceQueue 中,但是 WeakReference 也有对应的功能, 两者的区别到底在哪呢 ?<br>这就要说到 Object 的 finalize 方法, 此方法将在 gc 执行前被调用, 如果某个对象重载了 finalize 方法并故意在方法内创建本身的强引用,这将导致这一轮的 GC 无法回收这个对象并有可能<br>引起任意次 GC， 最后的结果就是明明 JVM 内有很多 Garbage 却 OutOfMemory， 使用 PhantomReference 就可以避免这个问题， 因为 PhantomReference 是在 finalize 方法执行后回收的，也就意味着此时已经不可能拿到原来的引用,也就不会出现上述问题,当然这是一个很极端的例子, 一般不会出现.</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p><strong>Soft vs Weak vs Phantom References</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Purpose</th>
<th>Use</th>
<th>When GCed</th>
<th>Implementing Class</th>
</tr>
</thead>
<tbody>
<tr>
<td>Strong Reference</td>
<td>An ordinary reference. Keeps objects alive as long as they are referenced.</td>
<td>normal reference.</td>
<td>Any object not pointed to can be reclaimed.</td>
<td>default</td>
</tr>
<tr>
<td>Soft Reference</td>
<td>Keeps objects alive provided there’s enough memory.</td>
<td>to keep objects alive even after clients have removed their references (memory-sensitive caches), in case clients start asking for them again by key.</td>
<td>After a first gc pass, the JVM decides it still needs to reclaim more space.</td>
<td>java.lang.ref.SoftReference</td>
</tr>
<tr>
<td>Weak Reference</td>
<td>Keeps objects alive only while they’re in use (reachable) by clients.</td>
<td>Containers that automatically delete objects no longer in use.</td>
<td>After gc determines the object is only weakly reachable</td>
<td>java.lang.ref.WeakReference java.util.WeakHashMap</td>
</tr>
<tr>
<td>Phantom Reference</td>
<td>Lets you clean up after finalization but before the space is reclaimed (replaces or augments the use offinalize())</td>
<td>Special clean up processing</td>
<td>After finalization.</td>
<td>java.lang.ref.PhantomReference</td>
</tr>
</tbody>
</table>
<h1 id="Java-GC小结"><a href="#Java-GC小结" class="headerlink" title="Java GC小结"></a>Java GC小结</h1><p>一般的应用程序不会涉及到 Reference 编程， 但是了解这些知识会对理解Java GC 的工作原理以及性能调优有一定帮助, 在实现一些基础性设施比如缓存时也可能会用到， 希望本文能有所帮助.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Java中一共有4种类型的引用:StrongReference、SoftReference、WeakReference以及PhantomReference (幽灵引用), 这 4 种类型的引用与Java GC有着密切的关系, 让我们逐一来看它们的定义和使用场景。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="gc" scheme="http://idiotsky.me/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>redis的事务和watch</title>
    <link href="http://idiotsky.me/2016/09/03/redis-transaction-watch/"/>
    <id>http://idiotsky.me/2016/09/03/redis-transaction-watch/</id>
    <published>2016-09-03T14:43:12.000Z</published>
    <updated>2017-08-03T14:55:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis的事务"><a href="#redis的事务" class="headerlink" title="redis的事务"></a>redis的事务</h1><p>严格意义来讲,redis的事务和我们理解的传统数据库(如mysql)的事务是不一样的。<br><a id="more"></a></p>
<h2 id="redis中的事务定义"><a href="#redis中的事务定义" class="headerlink" title="redis中的事务定义"></a>redis中的事务定义</h2><p>Redis中的事务（transaction）是一组命令的集合。</p>
<p>事务同命令一样都是Redis的最小执行单位，一个事务中的命令要么都执行，要么都不执行。<br>事务的原理是先将属于一个事务的命令发送给Redis，然后再让Redis依次执行这些命令。</p>
<blockquote>
<p>Redis保证一个事务中的所有命令要么都执行，要么都不执行。如果在发送EXEC命令前客户端断线了，则Redis会清空事务队列，事务中的所有命令都不会执行。而一旦客户端发送了EXEC命令，所有的命令就都会被执行，即使此后客户端断线也没关系，因为Redis中已经记录了所有要执行的命令。</p>
<p>除此之外，Redis的事务还能保证一个事务内的命令依次执行而不被其他命令插入。试想客户端A需要执行几条命令，同时客户端B发送了一条命令，如果不使用事务，则客户端B的命令可能会插入到客户端A的几条命令中执行。如果不希望发生这种情况，也可以使用事务。</p>
</blockquote>
<h2 id="事务的应用"><a href="#事务的应用" class="headerlink" title="事务的应用"></a>事务的应用</h2><blockquote>
<p>事务的应用非常普遍，如银行转账过程中A给B汇款，首先系统从A的账户中将钱划走，然后向B的账户增加相应的金额。这两个步骤必须属于同一个事务，要么全执行，要么全不执行。否则只执行第一步，钱就凭空消失了，这显然让人无法接受。</p>
</blockquote>
<h2 id="和传统的事务不同"><a href="#和传统的事务不同" class="headerlink" title="和传统的事务不同"></a>和传统的事务不同</h2><blockquote>
<p>和传统的mysql事务不同的事，即使我们的加钱操作失败,我们也无法在这一组命令中让整个状态回滚到操作之前</p>
</blockquote>
<h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h2><p>如果一个事务中的某个命令执行出错，Redis会怎样处理呢？要回答这个问题，首先需要知道什么原因会导致命令执行出错。</p>
<h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p>语法错误指命令不存在或者命令参数的个数不对。比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">redis＞MULTI</div><div class="line">OK</div><div class="line">redis＞SET key value</div><div class="line">QUEUED</div><div class="line">redis＞SET key</div><div class="line">(error)ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'set'</span> <span class="built_in">command</span></div><div class="line">redis＞ errorCOMMAND key</div><div class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">'errorCOMMAND'</span></div><div class="line">redis＞ EXEC</div><div class="line">(error) EXECABORT Transaction discarded because of previous errors.</div></pre></td></tr></table></figure></p>
<p>跟在MULTI命令后执行了3个命令：一个是正确的命令，成功地加入事务队列；其余两个命令都有语法错误。而只要有一个命令有语法错误，执行EXEC命令后Redis就会直接返回错误，连语法正确的命令也不会执行。</p>
<h4 id="这里需要注意一点："><a href="#这里需要注意一点：" class="headerlink" title="这里需要注意一点："></a>这里需要注意一点：</h4><p>Redis 2.6.5之前的版本会忽略有语法错误的命令，然后执行事务中其他语法正确的命令。就此例而言，SET key value会被执行，EXEC命令会返回一个结果：1) OK。</p>
<h3 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h3><p>运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前Redis是无法发现的，所以在事务里这样的命令是会被Redis接受并执行的。如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续执行（包括出错命令之后的命令），示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">redis＞MULTI</div><div class="line">OK</div><div class="line">redis＞SET key 1</div><div class="line">QUEUED</div><div class="line">redis＞SADD key 2</div><div class="line">QUEUED</div><div class="line">redis＞SET key 3</div><div class="line">QUEUED</div><div class="line">redis＞EXEC</div><div class="line">1) OK</div><div class="line">2) (error) ERR Operation against a key holding the wrong kind of value</div><div class="line">3) OK</div><div class="line">redis＞GET key</div><div class="line"><span class="string">"3"</span></div></pre></td></tr></table></figure></p>
<p>可见虽然SADD key 2出现了错误，但是SET key 3依然执行了。</p>
<p>Redis的事务没有关系数据库事务提供的回滚（rollback）功能。为此开发者必须在事务执行出错后自己收拾剩下的摊子（将数据库复原回事务执行前的状态等,这里我们一般采取日志记录然后业务补偿的方式来处理，但是一般情况下，在redis做的操作不应该有这种强一致性要求的需求，我们认为这种需求为不合理的设计）。</p>
<h1 id="Watch命令"><a href="#Watch命令" class="headerlink" title="Watch命令"></a>Watch命令</h1><p>大家可能知道redis提供了基于incr命令来操作一个整数型数值的原子递增，那么我们假设如果redis没有这个incr命令，我们该怎么实现这个incr的操作呢？</p>
<p>那么我们下面的正主<code>watch</code>就要上场了。</p>
<h2 id="如何使用watch命令"><a href="#如何使用watch命令" class="headerlink" title="如何使用watch命令"></a>如何使用watch命令</h2><p>正常情况下我们想要对一个整形数值做修改是这么做的(伪代码实现)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val = GET mykey</div><div class="line">val = val + 1</div><div class="line">SET mykey <span class="variable">$val</span></div></pre></td></tr></table></figure></p>
<p>但是上述的代码会出现一个问题,因为上面吧正常的一个incr(原子递增操作)分为了两部分,那么在多线程(分布式)环境中，这个操作就有可能不再具有原子性了。</p>
<p>研究过java的juc包的人应该都知道cas，那么redis也提供了这样的一个机制，就是利用watch命令来实现的。</p>
<h2 id="watch命令描述"><a href="#watch命令描述" class="headerlink" title="watch命令描述"></a>watch命令描述</h2><blockquote>
<p>WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值）</p>
</blockquote>
<h2 id="利用watch实现incr"><a href="#利用watch实现incr" class="headerlink" title="利用watch实现incr"></a>利用watch实现incr</h2><p>具体做法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">WATCH mykey</div><div class="line">val = GET mykey</div><div class="line">val = val + 1</div><div class="line">MULTI</div><div class="line">SET mykey <span class="variable">$val</span></div><div class="line">EXEC</div></pre></td></tr></table></figure></p>
<p>和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前，如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>由于WATCH命令的作用只是当被监控的键值被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一键值，所以在一般的情况下我们需要在EXEC执行失败后重新执行整个函数。</p>
<p>执行EXEC命令后会取消对所有键的监控，如果不想执行事务中的命令也可以使用UNWATCH命令来取消监控。</p>
<h2 id="实现一个hsetNX函数"><a href="#实现一个hsetNX函数" class="headerlink" title="实现一个hsetNX函数"></a>实现一个hsetNX函数</h2><p>我们实现的hsetNX这个功能是：仅当字段存在时才赋值。</p>
<p>为了避免竞态条件我们使用watch和事务来完成这一功能（伪代码）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">WATCH key  </div><div class="line">isFieldExists = HEXISTS key, field  </div><div class="line"><span class="keyword">if</span> isFieldExists is 1  </div><div class="line">MULTI  </div><div class="line">HSET key, field, value  </div><div class="line">EXEC  </div><div class="line"><span class="keyword">else</span>  </div><div class="line">UNWATCH  </div><div class="line"><span class="built_in">return</span> isFieldExists</div></pre></td></tr></table></figure></p>
<p>在代码中会判断要赋值的字段是否存在，如果字段不存在的话就不执行事务中的命令，但需要使用UNWATCH命令来保证下一个事务的执行不会受到影响。</p>
<p>原文地址 <a href="http://www.jianshu.com/p/361cb9cd13d5" target="_blank" rel="external">http://www.jianshu.com/p/361cb9cd13d5</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redis的事务&quot;&gt;&lt;a href=&quot;#redis的事务&quot; class=&quot;headerlink&quot; title=&quot;redis的事务&quot;&gt;&lt;/a&gt;redis的事务&lt;/h1&gt;&lt;p&gt;严格意义来讲,redis的事务和我们理解的传统数据库(如mysql)的事务是不一样的。&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>全面解析-SQL事务+隔离级别+阻塞+死锁</title>
    <link href="http://idiotsky.me/2016/08/27/sql-trasaction-isolation-deadlock/"/>
    <id>http://idiotsky.me/2016/08/27/sql-trasaction-isolation-deadlock/</id>
    <published>2016-08-27T10:15:18.000Z</published>
    <updated>2017-08-28T12:51:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本篇主要是对SQL中事务和并发的详细讲解。</p>
</blockquote>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>为单个工作单元而执行的一系列操作。如查询、修改数据、修改数据定义。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="显示定义事务的开始、提交"><a href="#显示定义事务的开始、提交" class="headerlink" title="显示定义事务的开始、提交"></a>显示定义事务的开始、提交</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BEGIN</span> TRAN</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> b(t1) <span class="keyword">VALUES</span>(<span class="number">1</span>)</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> b(t1) <span class="keyword">VALUES</span>(<span class="number">2</span>)</div><div class="line"><span class="keyword">COMMIT</span> TRAN</div></pre></td></tr></table></figure>
<h3 id="隐式定义"><a href="#隐式定义" class="headerlink" title="隐式定义"></a>隐式定义</h3><p>如果不显示定义事务的边界，则SQL Server会默认把每个单独的语句作为一个事务，即在执行完每个语句之后就会自动提交事务。<br><a id="more"></a></p>
<h2 id="事务的四个属性ACID"><a href="#事务的四个属性ACID" class="headerlink" title="事务的四个属性ACID"></a>事务的四个属性ACID</h2><h3 id="原子性Atomicity"><a href="#原子性Atomicity" class="headerlink" title="原子性Atomicity"></a>原子性Atomicity</h3><p><a href="/images/sql-trasaction-isolation-deadlock-1.jpg"><img src="/images/sql-trasaction-isolation-deadlock-1.jpg" alt=""></a> </p>
<ol>
<li>事务必须是原子工作单元。事务中进行的修改，要么全部执行，要么全都不执行；</li>
<li>在事务完成之前（提交指令被记录到事务日志之前），系统出现故障或重新启动，SQL Server将会撤销在事务中进行的所有修改；</li>
<li>事务在处理中遇到错误，SQL Server通常会自动回滚事务；</li>
<li>少数不太严重的错误不会引发事务的自动回滚，如主键冲突、锁超时等；</li>
<li>可以使用错误处理来捕获第4点提到的错误，并采取某种操作，如把错误记录在日志中，再回滚事务；</li>
<li>SELECT @@TRANCOUNT可用在代码的任何位置来判断当前使用SELECT @@TRANCOUNT的地方是否位于一个打开的事务当中，如果不在任何打开的事务范围内，则该函数返回0；如果在某个打开的事务返回范围内，则返回一个大于0的值。打开一个事务，@@TRANCOUNT=@@TRANCOUNT+1；提交一个事务，@@TRANCOUNT-1。</li>
</ol>
<h3 id="一致性Consiitency"><a href="#一致性Consiitency" class="headerlink" title="一致性Consiitency"></a>一致性Consiitency</h3><p><a href="/images/sql-trasaction-isolation-deadlock-2.jpg"><img src="/images/sql-trasaction-isolation-deadlock-2.jpg" alt=""></a> </p>
<ol>
<li>同时发生的事务在修改和查询数据时不发生冲突；</li>
<li>一致性取决于应用程序的需要。后面会讲到一致性级别，以及如何对一致性进行控制。</li>
</ol>
<h3 id="隔离性Isolation"><a href="#隔离性Isolation" class="headerlink" title="隔离性Isolation"></a>隔离性Isolation</h3><p><a href="/images/sql-trasaction-isolation-deadlock-3.jpg"><img src="/images/sql-trasaction-isolation-deadlock-3.jpg" alt=""></a> </p>
<ol>
<li>用于控制数据访问，确保事务只访问处于期望的一致性级别下的数据；</li>
<li>使用锁对各个事务之间正在修改和查询的数据进行隔离。</li>
</ol>
<h3 id="持久性Durability"><a href="#持久性Durability" class="headerlink" title="持久性Durability"></a>持久性Durability</h3><p><a href="/images/sql-trasaction-isolation-deadlock-4.jpg"><img src="/images/sql-trasaction-isolation-deadlock-4.jpg" alt=""></a> </p>
<ol>
<li>在将数据修改写入到磁盘上数据库的数据分区之前会把这些修改写入到磁盘上数据库的事务日志中，把提交指令记录到磁盘的事务日志中以后，及时数据修改还没有应用到磁盘的数据分区，也可以认为事务时持久化的。</li>
<li>系统重新启动（正常启动或在发生系统故障之后启动），SQL Server会每个数据库的事务日志，进行回复处理。</li>
<li>恢复处理包含两个阶段：重做阶段和撤销阶段。</li>
<li>前滚：在重做阶段，对于提交指令已经写入到日志的事务，但数据修改还没有应用到数据分区的事务，数据库引擎会重做这些食物所做的所有修改。</li>
<li>回滚：在撤销阶段，对于提交指令没有写入到日志中的事务，数据库引擎会撤销这些事务所做的修改。（这句话需要research,可能是不正确的。因为提交指令没有写入到数据分区，撤销修改是指撤销哪些修改呢？？？）</li>
</ol>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="事务中的锁"><a href="#事务中的锁" class="headerlink" title="事务中的锁"></a>事务中的锁</h2><ol>
<li>SQL Server使用锁来实现事务的隔离。</li>
<li>事务获取锁这种控制资源，用于保护数据资源，防止其他事务对数据进行冲突的或不兼容的访问。</li>
</ol>
<h2 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h2><ol>
<li>排他锁<ul>
<li>当试图修改数据时，事务只能为所依赖的数据资源请求排他锁。</li>
<li>持有排他锁时间：一旦某个事务得到了排他锁，则这个事务将一直持有排他锁直到事务完成。</li>
<li>排他锁和其他任何类型的锁在多事务中不能在同一阶段作用于同一个资源。如：当前事务获得了某个资源的排他锁，则其他事务不能获得该资源的任何其他类型的锁。其他事务获得了某个资源的任何其他类型的锁，则当前事务不能获得该资源的排他锁。</li>
</ul>
</li>
<li>共享锁<ul>
<li>当试图读取数据时，事务默认会为所依赖的数据资源请求共享锁。</li>
<li>持有共享锁时间：从事务得到共享锁到读操作完成。</li>
<li>多个事务可以在同一阶段用共享锁作用于同一数据资源。</li>
<li>在读取数据时，可以对如何处理锁定进行控制。后面隔离级别会讲到如何对锁定进行控制。</li>
</ul>
</li>
</ol>
<h2 id="排他锁和共享锁的兼容性"><a href="#排他锁和共享锁的兼容性" class="headerlink" title="排他锁和共享锁的兼容性"></a>排他锁和共享锁的兼容性</h2><ol>
<li>如果数据正在由一个事务进行修改，则其他事务既不能修改该数据，也不能读取（至少默认不能）该数据，直到第一个事务完成。</li>
<li>如果数据正在由一个事务读取，则其他事务不能修改该数据（至少默认不能）。</li>
</ol>
<blockquote>
<p>to be continue..</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇主要是对SQL中事务和并发的详细讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;h2 id=&quot;什么是事务&quot;&gt;&lt;a href=&quot;#什么是事务&quot; class=&quot;headerlink&quot; title=&quot;什么是事务&quot;&gt;&lt;/a&gt;什么是事务&lt;/h2&gt;&lt;p&gt;为单个工作单元而执行的一系列操作。如查询、修改数据、修改数据定义。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;h3 id=&quot;显示定义事务的开始、提交&quot;&gt;&lt;a href=&quot;#显示定义事务的开始、提交&quot; class=&quot;headerlink&quot; title=&quot;显示定义事务的开始、提交&quot;&gt;&lt;/a&gt;显示定义事务的开始、提交&lt;/h3&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;BEGIN&lt;/span&gt; TRAN&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; b(t1) &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; b(t1) &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;COMMIT&lt;/span&gt; TRAN&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;隐式定义&quot;&gt;&lt;a href=&quot;#隐式定义&quot; class=&quot;headerlink&quot; title=&quot;隐式定义&quot;&gt;&lt;/a&gt;隐式定义&lt;/h3&gt;&lt;p&gt;如果不显示定义事务的边界，则SQL Server会默认把每个单独的语句作为一个事务，即在执行完每个语句之后就会自动提交事务。&lt;br&gt;
    
    </summary>
    
      <category term="sql" scheme="http://idiotsky.me/categories/sql/"/>
    
    
      <category term="sql" scheme="http://idiotsky.me/tags/sql/"/>
    
      <category term="死锁" scheme="http://idiotsky.me/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="事务" scheme="http://idiotsky.me/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="隔离级别" scheme="http://idiotsky.me/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出MappedByteBuffer</title>
    <link href="http://idiotsky.me/2016/08/23/java-mapped-byte-buffer/"/>
    <id>http://idiotsky.me/2016/08/23/java-mapped-byte-buffer/</id>
    <published>2016-08-22T16:36:51.000Z</published>
    <updated>2017-08-22T17:09:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java io操作中通常采用<code>BufferedReader</code>，<code>BufferedInputStream</code>等带缓冲的IO类处理大文件，不过java nio中引入了一种基于<code>MappedByteBuffer</code>操作大文件的方式，其读写性能极高，本文会介绍其性能如此高的内部实现原理。<br><a id="more"></a></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>在深入MappedByteBuffer之前，先看看计算机内存管理的几个术语：</p>
<ul>
<li><strong>MMC</strong>：CPU的内存管理单元。</li>
<li><strong>物理内存</strong>：即内存条的内存空间。</li>
<li><strong>虚拟内存</strong>：计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</li>
<li><strong>页面文件</strong>：操作系统反映构建并使用虚拟内存的硬盘空间大小而创建的文件，在windows下，即pagefile.sys文件，其存在意味着物理内存被占满后，将暂时不用的数据移动到硬盘上。</li>
<li><strong>缺页中断</strong>：当程序试图访问已映射在虚拟地址空间中但未被加载至物理内存的一个分页时，由MMC发出的中断。如果操作系统判断此次访问是有效的，则尝试将相关的页从虚拟内存文件中载入物理内存。</li>
</ul>
<p><strong>为什么会有虚拟内存和物理内存的区别？</strong><br>如果正在运行的一个进程，它所需的内存是有可能大于内存条容量之和的，如内存条是256M，程序却要创建一个2G的数据区，那么所有数据不可能都加载到内存（物理内存），必然有数据要放到其他介质中（比如硬盘），待进程需要访问那部分数据时，再调度进入物理内存。</p>
<p><strong>什么是虚拟内存地址和物理内存地址？</strong><br>假设你的计算机是32位，那么它的地址总线是32位的，也就是它可以寻址0~0xFFFFFFFF（4G）的地址空间，但如果你的计算机只有256M的物理内存0x~0x0FFFFFFF（256M），同时你的进程产生了一个不在这256M地址空间中的地址，那么计算机该如何处理呢？回答这个问题前，先说明计算机的内存分页机制。</p>
<p>计算机会对虚拟内存地址空间（32位为4G）进行分页产生页（page），对物理内存地址空间（假设256M）进行分页产生页帧（page frame），页和页帧的大小一样，所以虚拟内存页的个数势必要大于物理内存页帧的个数。在计算机上有一个页表（page table），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射，而且是一对一的映射。<br>问题来了，虚拟内存页的个数 &gt; 物理内存页帧的个数，岂不是有些虚拟内存页的地址永远没有对应的物理内存地址空间？不是的，操作系统是这样处理的。操作系统有个页面失效（page fault）功能。操作系统找到一个最少使用的页帧，使之失效，并把它写入磁盘，随后把需要访问的页放到页帧中，并修改页表中的映射，保证了所有的页都会被调度。</p>
<p>现在来看看什么是虚拟内存地址和物理内存地址：</p>
<ul>
<li>虚拟内存地址：由页号（与页表中的页号关联）和偏移量（页的小大，即这个页能存多少数据）组成。</li>
</ul>
<p>举个例子，有一个虚拟地址它的页号是4，偏移量是20，那么他的寻址过程是这样的：首先到页表中找到页号4对应的页帧号（比如为8），如果页不在内存中，则用失效机制调入页，接着把页帧号和偏移量传给MMC组成一个物理上真正存在的地址，最后就是访问物理内存的数据了。</p>
<h1 id="MappedByteBuffer是什么"><a href="#MappedByteBuffer是什么" class="headerlink" title="MappedByteBuffer是什么"></a>MappedByteBuffer是什么</h1><p>从继承结构上看，MappedByteBuffer继承自ByteBuffer，内部维护了一个逻辑地址address。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通过MappedByteBuffer读取文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D://data.txt"</span>);</div><div class="line">        <span class="keyword">long</span> len = file.length();</div><div class="line">        <span class="keyword">byte</span>[] ds = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) len];</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            MappedByteBuffer mappedByteBuffer = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>)</div><div class="line">                    .getChannel()</div><div class="line">                    .map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, len);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>; offset &lt; len; offset++) &#123;</div><div class="line">                <span class="keyword">byte</span> b = mappedByteBuffer.get();</div><div class="line">                ds[offset] = b;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Scanner scan = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> ByteArrayInputStream(ds)).useDelimiter(<span class="string">" "</span>);</div><div class="line">            <span class="keyword">while</span> (scan.hasNext()) &#123;</div><div class="line">                System.out.print(scan.next() + <span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="map过程"><a href="#map过程" class="headerlink" title="map过程"></a>map过程</h2><p>FileChannel提供了map方法把文件映射到虚拟内存，通常情况可以映射整个文件，如果文件比较大，可以进行分段映射。</p>
<ul>
<li><strong>FileChannel中的几个变量</strong>：<ul>
<li><strong>MapMode mode</strong>：内存映像文件访问的方式，共三种：<ol>
<li>MapMode.READ_ONLY：只读，试图修改得到的缓冲区将导致抛出异常。</li>
<li>MapMode.READ_WRITE：读/写，对得到的缓冲区的更改最终将写入文件；但该更改对映射到同一文件的其他程序不一定是可见的。</li>
<li>MapMode.PRIVATE：私用，可读可写,但是修改的内容不会写入文件，只是buffer自身的改变，这种能力称之为”copy on write”。</li>
</ol>
</li>
<li><strong>position</strong>：文件映射时的起始位置。</li>
<li><strong>allocationGranularity</strong>：Memory allocation size for mapping buffers，通过native函数initIDs初始化。</li>
</ul>
</li>
</ul>
<p>接下去通过分析源码，了解一下map过程的内部实现。</p>
<ol>
<li><p>通过RandomAccessFile获取FileChannel。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileChannel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</div><div class="line">        channel = FileChannelImpl.open(fd, path, <span class="keyword">true</span>, rw, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> channel;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 上述实现可以看出，由于synchronized ，只有一个线程能够初始化FileChannel。</p>
</li>
<li><p>通过FileChannel.map方法，把文件映射到虚拟内存，并返回逻辑地址address，实现如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">**只保留了核心代码**</div><div class="line"><span class="function"><span class="keyword">public</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode, <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span>  </span></div><div class="line"><span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="keyword">int</span> pagePosition = (<span class="keyword">int</span>)(position % allocationGranularity);</div><div class="line">    <span class="keyword">long</span> mapPosition = position - pagePosition;</div><div class="line">    <span class="keyword">long</span> mapSize = size + pagePosition;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        addr = map0(imode, mapPosition, mapSize);</div><div class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</div><div class="line">        System.gc();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">100</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException y) &#123;</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            addr = map0(imode, mapPosition, mapSize);</div><div class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError y) &#123;</div><div class="line">            <span class="comment">// After a second OOME, fail</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Map failed"</span>, y);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> isize = (<span class="keyword">int</span>)size;</div><div class="line">    Unmapper um = <span class="keyword">new</span> Unmapper(addr, mapSize, isize, mfd);</div><div class="line">    <span class="keyword">if</span> ((!writable) || (imode == MAP_RO)) &#123;</div><div class="line">        <span class="keyword">return</span> Util.newMappedByteBufferR(isize,</div><div class="line">                                        addr + pagePosition,</div><div class="line">                                        mfd,</div><div class="line">                                        um);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> Util.newMappedByteBuffer(isize,</div><div class="line">                                        addr + pagePosition,</div><div class="line">                                        mfd,</div><div class="line">                                        um);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 上述代码可以看出，最终map通过native函数map0完成文件的映射工作。</p>
<ol>
<li>如果第一次文件映射导致OOM，则手动触发垃圾回收，休眠100ms后再次尝试映射，如果失败，则抛出异常。</li>
<li><p>通过newMappedByteBuffer方法初始化MappedByteBuffer实例，不过其最终返回的是DirectByteBuffer的实例，实现如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> MappedByteBuffer <span class="title">newMappedByteBuffer</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">long</span> addr, FileDescriptor fd, Runnable unmapper)</span> </span>&#123;</div><div class="line">MappedByteBuffer dbb;</div><div class="line"><span class="keyword">if</span> (directByteBufferConstructor == <span class="keyword">null</span>)</div><div class="line">initDBBConstructor();</div><div class="line">dbb = (MappedByteBuffer)directByteBufferConstructor.newInstance(</div><div class="line"><span class="keyword">new</span> Object[] &#123; <span class="keyword">new</span> Integer(size),</div><div class="line">                <span class="keyword">new</span> Long(addr),</div><div class="line">                fd,</div><div class="line">                unmapper &#125;</div><div class="line"><span class="keyword">return</span> dbb;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 访问权限</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initDBBConstructor</span><span class="params">()</span> </span>&#123;</div><div class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</div><div class="line"><span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    Class&lt;?&gt; cl = Class.forName(<span class="string">"java.nio.DirectByteBuffer"</span>);</div><div class="line">        Constructor&lt;?&gt; ctor = cl.getDeclaredConstructor(</div><div class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123; <span class="keyword">int</span>.class,</div><div class="line">                            <span class="keyword">long</span>.class,</div><div class="line">                            FileDescriptor.class,</div><div class="line">                            Runnable.class &#125;);</div><div class="line">        ctor.setAccessible(<span class="keyword">true</span>);</div><div class="line">        directByteBufferConstructor = ctor;</div><div class="line">&#125;&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 由于FileChannelImpl和DirectByteBuffer不在同一个包中，所以有权限访问问题，通过AccessController类获取DirectByteBuffer的构造器进行实例化。<br> DirectByteBuffer是MappedByteBuffer的一个子类，其实现了对内存的直接操作。</p>
</li>
</ol>
</li>
</ol>
<h2 id="get过程"><a href="#get过程" class="headerlink" title="get过程"></a>get过程</h2><p>MappedByteBuffer的get方法最终通过DirectByteBuffer.get方法实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((unsafe.getByte(ix(nextGetIndex()))));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((unsafe.getByte(ix(checkIndex(i)))));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> address + (i &lt;&lt; <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>map0()函数返回一个地址address，这样就无需调用read或write方法对文件进行读写，通过address就能够操作文件。底层采用unsafe.getByte方法，通过（address + 偏移量）获取指定内存的数据。</p>
<ol>
<li>第一次访问address所指向的内存区域，导致缺页中断，中断响应函数会在交换区中查找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则从硬盘上将文件指定页读取到物理内存中（非jvm堆内存）。</li>
<li>如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘的虚拟内存中。</li>
</ol>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>从代码层面上看，从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，并且数据拷贝操作是由文件系统和硬件驱动实现的，理论上来说，拷贝数据的效率是一样的。<br>但是通过内存映射的方法访问硬盘上的文件，效率要比read和write系统调用高，这是为什么？</p>
<ul>
<li>read()是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝；</li>
<li>map()也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝。</li>
</ul>
<p>所以，采用内存映射的读写效率要比传统的read/write性能高。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>MappedByteBuffer使用虚拟内存，因此分配(map)的内存大小不受JVM的-Xmx参数限制，但是也是有大小限制的。</li>
<li>如果当文件超出1.5G限制时，可以通过position参数重新map文件后面的内容。</li>
<li>MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。<br>javadoc中也提到：<strong>A mapped byte buffer and the file mapping that it represents remain* valid until the buffer itself is garbage-collected</strong>.</li>
</ol>
<p>原文：<a href="http://www.jianshu.com/p/f90866dcbffc" target="_blank" rel="external">http://www.jianshu.com/p/f90866dcbffc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;java io操作中通常采用&lt;code&gt;BufferedReader&lt;/code&gt;，&lt;code&gt;BufferedInputStream&lt;/code&gt;等带缓冲的IO类处理大文件，不过java nio中引入了一种基于&lt;code&gt;MappedByteBuffer&lt;/code&gt;操作大文件的方式，其读写性能极高，本文会介绍其性能如此高的内部实现原理。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程(二) 同步和锁</title>
    <link href="http://idiotsky.me/2016/08/20/java-thread-2-md/"/>
    <id>http://idiotsky.me/2016/08/20/java-thread-2-md/</id>
    <published>2016-08-20T14:55:34.000Z</published>
    <updated>2017-08-20T08:06:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>记录，汇总</p>
</blockquote>
<a id="more"></a>
<h1 id="线程同步问题的产生"><a href="#线程同步问题的产生" class="headerlink" title="线程同步问题的产生"></a>线程同步问题的产生</h1><p>什么是线程同步问题，我们先来看一段卖票系统的代码，然后再分析这个问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSeller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> num = <span class="number">100</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    Thread.sleep(<span class="number">10</span>);</div><div class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)</div><div class="line">                &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//输出卖票信息</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">".....sale...."</span>+num--);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面是卖票线程类，下来再来看看执行类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TickeDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        TicketSeller t = <span class="keyword">new</span> TicketSeller();<span class="comment">//创建一个线程任务对象。</span></div><div class="line"></div><div class="line">        <span class="comment">//创建4个线程同时卖票</span></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(t);</div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(t);</div><div class="line">        Thread t3 = <span class="keyword">new</span> Thread(t);</div><div class="line">        Thread t4 = <span class="keyword">new</span> Thread(t);</div><div class="line">        <span class="comment">//启动线程</span></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        t4.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行程序结果如下（仅截取部分数据）：<br><a href="/images/java-thread-2-1.png"><img src="/images/java-thread-2-1.png" alt=""></a><br>从运行结果，我们就可以看出我们3个售票窗口同时卖出了96号票，这显然是不合逻辑的，其实这个问题就是我们前面所说的线程同步问题。不同的线程都对同一个数据进了操作这就容易导致数据错乱的问题，也就是线程不同步。那么这个问题该怎么解决呢？在给出解决思路之前我们先来分析一下这个问题是怎么产生的？我们声明一个线程类TicketSeller，在这个类中我们又声明了一个成员变量num也就是票的数量，然后我们通过run方法不断的去获取票数并输出，最后我们在外部类TicketDemo中创建了四个线程同时操作这个数据，运行后就出现我们刚才所说的线程同步问题，从这里我们可以看出产生线程同步(线程安全)问题的条件有两个：1.多个线程在操作共享的数据（num），2.操作共享数据的线程代码有多条（4条线程）；既然原因知道了，那该怎么解决？</p>
<blockquote>
<p>解决思路：将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程时不可以参与运算的。必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算。 好了，思路知道了，我们就用java代码的方式来解决这个问题。</p>
</blockquote>
<h1 id="解决线程同步的两种典型方案"><a href="#解决线程同步的两种典型方案" class="headerlink" title="解决线程同步的两种典型方案"></a>解决线程同步的两种典型方案</h1><p>在java中有两种机制可以防止线程安全的发生，Java语言提供了一个synchronized关键字来解决这问题，同时在Java SE5.0引入了Lock锁对象的相关类，接下来我们分别介绍这两种方法</p>
<h2 id="通过锁（Lock）对象的方式解决线程安全问题"><a href="#通过锁（Lock）对象的方式解决线程安全问题" class="headerlink" title="通过锁（Lock）对象的方式解决线程安全问题"></a>通过锁（Lock）对象的方式解决线程安全问题</h2><p>在给出解决代码前我们先来介绍一个知识点：Lock，锁对象。在java中锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但有的锁可以允许多个线程并发访问共享资源，比如读写锁，后面我们会分析）。在Lock接口出现之前，java程序是靠synchronized关键字（后面分析）实现锁功能的，而JAVA SE5.0之后并发包中新增了Lock接口用来实现锁的功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁，缺点就是缺少像synchronized那样隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。接下来我们就来介绍Lock接口的主要API方便我们学习</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>相关描述内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td>void lock()</td>
<td>获取锁，调用该方法当前线程会获取锁，当获取锁后。从该方法返回</td>
</tr>
<tr>
<td>void lockInterruptibly() throws InterruptedException</td>
<td>可中断获取锁和lock()方法不同的是该方法会响应中断，即在获取锁中可以中断当前线程。例如某个线程在等待一个锁的控制权的这段时间需要中断。</td>
</tr>
<tr>
<td>boolean tryLock()</td>
<td>尝试非阻塞获取锁，调用该方法后立即返回，如果能够获取锁则返回true，否则返回false。</td>
</tr>
<tr>
<td>boolean tryLock(long time,TimeUnit unit) throws  InterruptedException</td>
<td>超时获取锁，当前线程在以下3种情况返回：1.当前线程在超时时间内获取了锁2.当前线程在超时时间被中断3.当前线程超时时间结束，返回false</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
<tr>
<td>Condition newCondition()</td>
<td>条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将释放锁。</td>
</tr>
</tbody>
</table>
<p>这里先介绍一下API，接下来我们将结合Lock接口的实现子类ReentrantLock来讲解下他的几个方法。</p>
<h3 id="ReentrantLock（重入锁"><a href="#ReentrantLock（重入锁" class="headerlink" title="ReentrantLock（重入锁)"></a>ReentrantLock（重入锁)</h3><p>重入锁，顾名思义就是支持重新进入的锁，它表示该锁能够支持一个线程对资源的重复加锁，也就是说在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞，同时还支持获取锁的公平性和非公平性。这里的公平是在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平锁，反之，是不公平的(但是如果不是需要，建议不要用公平锁，因为会造成一些资源的没必要等待，浪费性能)。那么该如何使用呢？看范例代码：<br>1.同步执行的代码跟synchronized类似功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//参数默认false，不公平锁    </span></div><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">//公平锁    </span></div><div class="line">    </div><div class="line">lock.lock(); <span class="comment">//如果被其它资源锁定，会在此等待锁释放，达到暂停的效果    </span></div><div class="line"><span class="keyword">try</span> &#123;    </div><div class="line">    <span class="comment">//操作    </span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;    </div><div class="line">    lock.unlock();  <span class="comment">//释放锁  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.防止重复执行代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();    </div><div class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;  <span class="comment">//如果已经被lock，则立即返回false不会等待，达到忽略操作的效果     </span></div><div class="line">    <span class="keyword">try</span> &#123;    </div><div class="line">        <span class="comment">//操作    </span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;    </div><div class="line">        lock.unlock();    </div><div class="line">   &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.尝试等待执行的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">//公平锁    </span></div><div class="line"><span class="keyword">try</span> &#123;    </div><div class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;        </div><div class="line">        <span class="comment">//如果已经被lock，尝试等待5s，看是否可以获得锁，如果5s后仍然无法获得锁则返回false继续执行    </span></div><div class="line">       <span class="keyword">try</span> &#123;    </div><div class="line">            <span class="comment">//操作    </span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;    </div><div class="line">            lock.unlock();    </div><div class="line">        &#125;    </div><div class="line">    &#125;    </div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;    </div><div class="line">    e.printStackTrace(); <span class="comment">//当前线程被中断时(interrupt)，会抛InterruptedException                     </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里有点需要特别注意的，把解锁操作放在finally代码块内这个十分重要。如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。好了，ReentrantLock我们就简单介绍到这里，接下来我们通过ReentrantLock来解决前面卖票线程的线程同步（安全）问题，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketSellerWithLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//创建锁对象</span></div><div class="line">    <span class="keyword">private</span> Lock ticketLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="comment">//创建锁对象(公平锁)</span></div><div class="line">    <span class="comment">//private Lock ticketLock = new ReentrantLock(true);</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> num = <span class="number">100</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            ticketLock.lock();<span class="comment">//获取锁</span></div><div class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    Thread.sleep(<span class="number">10</span>);</div><div class="line">                    <span class="comment">//输出卖票信息</span></div><div class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">".....sale...."</span>+num--);</div><div class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)</div><div class="line">                &#123;</div><div class="line">                    Thread.currentThread().interrupt();<span class="comment">//继续中断异常</span></div><div class="line">                &#125;<span class="keyword">finally</span> &#123;</div><div class="line">                    ticketLock.unlock();<span class="comment">//释放锁</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                ticketLock.unlock();<span class="comment">//释放锁</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>TicketDemo类无需变化，线程安全问题就此解决。<br>但是还是要说一下公平锁的问题，上面例子，不开公平锁的结果如下：<br><a href="/images/java-thread-2-2.png"><img src="/images/java-thread-2-2.png" alt=""></a><br>开公平锁的结果如下：<br><a href="/images/java-thread-2-3.png"><img src="/images/java-thread-2-3.png" alt=""></a><br><em>你会发现不开公平锁，cpu钟爱用第一个线程做事情，而开了公平锁后，基本是各个线程交替执行。上面提到公平锁是会消耗性能的，如果CPU调度的时候选择的不是公平调度的那个线程，CPU会放弃本次调度，干别的事情，如果老是调度不到的话，是浪费CPU调度的。</em></p>
<h2 id="通过synchronied关键字的方式解决线程安全问题"><a href="#通过synchronied关键字的方式解决线程安全问题" class="headerlink" title="通过synchronied关键字的方式解决线程安全问题"></a>通过synchronied关键字的方式解决线程安全问题</h2><p>在Java中内置了语言级的同步原语－synchronized，这个可以大大简化了Java中多线程同步的使用。从JAVA SE1.0开始，java中的每一个对象都有一个内部锁，如果一个方法使用synchronized关键字进行声明，那么这个对象将保护整个方法，也就是说调用该方法线程必须获得内部的对象锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> method&#123;  </div><div class="line">  <span class="comment">//method body  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Lock ticketLock = <span class="keyword">new</span> ReentrantLock();  </div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> method&#123;  </div><div class="line"> ticketLock.lock();  </div><div class="line"> <span class="keyword">try</span>&#123;  </div><div class="line">  <span class="comment">//.......  </span></div><div class="line"> &#125;<span class="keyword">finally</span>&#123;  </div><div class="line">   ticketLock.unlock();  </div><div class="line"> &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这里可以看出使用synchronized关键字来编写代码要简洁得多了。当然，要理解这一代码，我们必须知道每个对象有一个内部锁，并且该锁有一个内部条件。由锁来管理那些试图进入synchronized方法的线程，由条件来管那些调用wait的线程(wait()/notifyAll/notify())。同时我们必须明白一旦有一个线程通过synchronied方法获取到内部锁，该类的所有synchronied方法或者代码块都无法被其他线程访问直到当前线程释放了内部锁。刚才上面说的是同步方法，synchronized还有一种同步代码块的实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Object obj = <span class="keyword">new</span> Object();  </div><div class="line"><span class="keyword">synchronized</span>(obj)&#123;  </div><div class="line">  <span class="comment">//需要同步的代码  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中obj是对象锁，可以是任意对象。那么我们就通过其中的一个方法来解决售票系统的线程同步问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> num = <span class="number">100</span>;  </div><div class="line">    Object obj = <span class="keyword">new</span> Object();  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">synchronized</span>(obj)  </div><div class="line">            &#123;  </div><div class="line">                <span class="keyword">if</span>(num&gt;<span class="number">0</span>)  </div><div class="line">                &#123;  </div><div class="line">                    <span class="keyword">try</span>&#123;Thread.sleep(<span class="number">10</span>);&#125;<span class="keyword">catch</span> (InterruptedException e)&#123;&#125;  </div><div class="line">                      </div><div class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">".....sale...."</span>+num--);  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>嗯，同步代码块解决，运行结果也正常。到此同步问题也就解决了，当然代码同步也是要牺牲效率为前提的：<br>同步的好处：解决了线程的安全问题。<br>同步的弊端：相对降低了效率，因为同步外的线程的都会判断同步锁。<br>同步的前提：同步中必须有多个线程并使用同一个锁。</p>
<h1 id="线程间的通信机制"><a href="#线程间的通信机制" class="headerlink" title="线程间的通信机制"></a>线程间的通信机制</h1><p>线程开始运行，拥有自己的栈空间，但是如果每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者是价值很小，如果多线程能够相互配合完成工作的话，这将带来巨大的价值，这也就是线程间的通信啦。在java中多线程间的通信使用的是等待/通知机制来实现的。</p>
<h2 id="synchronied关键字等待-通知机制"><a href="#synchronied关键字等待-通知机制" class="headerlink" title="synchronied关键字等待/通知机制"></a>synchronied关键字等待/通知机制</h2><p>是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述的两个线程通过对象O来完成交互，而对象上的wait()和notify()/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。<br>等待/通知机制主要是用到的函数方法是notify()/notifyAll(),wait()/wait(long),wait(long,int),这些方法在上一篇文章都有说明过，这里就不重复了。当然这是针对synchronied关键字修饰的函数或代码块，因为要使用notify()/notifyAll(),wait()/wait(long),wait(long,int)这些方法的前提是对调用对象加锁，也就是说只能在同步函数或者同步代码块中使用。</p>
<h2 id="条件对象的等待-通知机制"><a href="#条件对象的等待-通知机制" class="headerlink" title="条件对象的等待/通知机制"></a>条件对象的等待/通知机制</h2><p>所谓的条件对象也就是配合前面我们分析的Lock锁对象，通过锁对象的条件对象来实现等待/通知机制。那么条件对象是怎么创建的呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建条件对象  </span></div><div class="line">Condition conditionObj=ticketLock.newCondition();</div></pre></td></tr></table></figure></p>
<p>就这样我们创建了一个条件对象。注意这里返回的对象是与该锁（ticketLock）相关的条件对象。下面是条件对象的API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>函数方法对应的描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>void await()</td>
<td>将该线程放到条件等待池中（对应wait()方法）</td>
</tr>
<tr>
<td>void signalAll()</td>
<td>解除该条件等待池中所有线程的阻塞状态（对应notifyAll()方法）</td>
</tr>
<tr>
<td>void signal()</td>
<td>从该条件的等待池中随机地选择一个线程，解除其阻塞状态（对应notify()方法）</td>
</tr>
</tbody>
</table>
<p>上述方法的过程分析：一个线程A调用了条件对象的await()方法进入等待状态，而另一个线程B调用了条件对象的signal()或者signalAll()方法，线程A收到通知后从条件对象的await()方法返回，进而执行后续操作。上述的两个线程通过条件对象来完成交互，而对象上的await()和signal()/signalAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。当然这样的操作都是必须基于条件对象的锁的，当前线程只有获取了锁，才能调用该条件对象的await()方法，而调用后，当前线程将释放锁。</p>
<p>这里有点要特别注意的是，上述两种等待/通知机制中，无论是调用了signal()/signalAll()方法还是调用了notify()/notifyAll()方法并不会立即激活一个等待线程。它们仅仅都只是解除等待线程的阻塞状态，以便这些线程可以在当前线程解锁或者退出同步方法后，通过争夺CPU执行权实现对对象的访问。到此，线程通信机制的概念分析完，我们下面通过生产者消费者模式来实现等待/通知机制。</p>
<h1 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h1><h2 id="单生产者单消费者模式"><a href="#单生产者单消费者模式" class="headerlink" title="单生产者单消费者模式"></a>单生产者单消费者模式</h2><p>顾名思义，就是一个线程消费，一个线程生产。我们先来看看等待/通知机制下的生产者消费者模式：我们假设这样一个场景，我们是卖北京烤鸭店铺，我们现在只有一条生产线也只有一条消费线，也就是说只能生产线程生产完了，再通知消费线程才能去卖，如果消费线程没烤鸭了，就必须通知生产线程去生产，此时消费线程进入等待状态。在这样的场景下，我们不仅要保证共享数据（烤鸭数量）的线程安全，而且还要保证烤鸭数量在消费之前必须有烤鸭。下面我们通过java代码来实现：<br>北京烤鸭生产资源类KaoYaResource：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaoYaResource</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;<span class="comment">//烤鸭的初始数量  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//判断是否有需要线程等待的标志  </span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 生产烤鸭 </div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(flag)&#123;</div><div class="line">            <span class="comment">//此时有烤鸭，等待  </span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace()</div><div class="line">                ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.name=name+count;<span class="comment">//设置烤鸭的名称  </span></div><div class="line">        count++;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者..."</span>+<span class="keyword">this</span>.name);</div><div class="line">        flag=<span class="keyword">true</span>;<span class="comment">//有烤鸭后改变标志  </span></div><div class="line">        notifyAll();<span class="comment">//通知消费线程可以消费了  </span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 消费烤鸭 </div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(!flag)&#123;<span class="comment">//如果没有烤鸭就等待  </span></div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者........"</span>+<span class="keyword">this</span>.name);<span class="comment">//消费烤鸭1  </span></div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">        notifyAll();<span class="comment">//通知生产者生产烤鸭  </span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个类中我们有两个synchronized的同步方法，一个是生产烤鸭的，一个是消费烤鸭的，之所以需要同步是因为我们操作了共享数据count，同时为了保证生产烤鸭后才能消费也就是生产一只烤鸭后才能消费一只烤鸭，我们使用了等待/通知机制，wait()和notify()。当第一次运行生产现场时调用生产的方法，此时有一只烤鸭，即flag=false，无需等待，因此我们设置可消费的烤鸭名称然后改变flag=true，同时通知消费线程可以消费烤鸭了，即使此时生产线程再次抢到执行权，因为flag=true，所以生产线程会进入等待阻塞状态，消费线程被唤醒后就进入消费方法，消费完成后，又改变标志flag=false，通知生产线程可以生产烤鸭了………以此循环。<br>生产消费执行类Single_Producer_Consumer.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single_Producer_Consumer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        KaoYaResource r = <span class="keyword">new</span> KaoYaResource();</div><div class="line">        Producer pro = <span class="keyword">new</span> Producer(r);</div><div class="line">        Consumer con = <span class="keyword">new</span> Consumer(r);</div><div class="line">        <span class="comment">//生产者线程</span></div><div class="line">        Thread t0 = <span class="keyword">new</span> Thread(pro);</div><div class="line">        <span class="comment">//消费者线程</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(con);</div><div class="line">        <span class="comment">//启动线程</span></div><div class="line">        t0.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> KaoYaResource r;</div><div class="line">    Producer(KaoYaResource r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.r = r;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            r.product(<span class="string">"北京烤鸭"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> KaoYaResource r;</div><div class="line">    Consumer(KaoYaResource r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.r = r;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            r.consume();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个类中我们创建两个线程，一个是消费者线程，一个是生产者线程，我们分别开启这两个线程用于不断的生产消费，运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">hread-0...生产者...北京烤鸭1</div><div class="line">Thread-1...消费者........北京烤鸭1</div><div class="line">Thread-0...生产者...北京烤鸭2</div><div class="line">Thread-1...消费者........北京烤鸭2</div><div class="line">Thread-0...生产者...北京烤鸭3</div><div class="line">Thread-1...消费者........北京烤鸭3</div><div class="line">Thread-0...生产者...北京烤鸭4</div><div class="line">Thread-1...消费者........北京烤鸭4</div><div class="line">Thread-0...生产者...北京烤鸭5</div><div class="line">Thread-1...消费者........北京烤鸭5</div><div class="line">Thread-0...生产者...北京烤鸭6</div><div class="line">Thread-1...消费者........北京烤鸭6</div><div class="line">Thread-0...生产者...北京烤鸭7</div><div class="line">Thread-1...消费者........北京烤鸭7</div><div class="line">Thread-0...生产者...北京烤鸭8</div><div class="line">Thread-1...消费者........北京烤鸭8</div><div class="line">Thread-0...生产者...北京烤鸭9</div><div class="line">Thread-1...消费者........北京烤鸭9</div><div class="line">.....</div></pre></td></tr></table></figure></p>
<p>很显然的情况就是生产一只烤鸭然后就消费一只烤鸭。运行情况完全正常，嗯，这就是单生产者单消费者模式。上面使用的是synchronized关键字的方式实现的，那么接下来我们使用对象锁的方式实现：KaoYaResourceByLock.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaoYaResourceByLock</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;<span class="comment">//烤鸭的初始数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//判断是否有需要线程等待的标志</span></div><div class="line">    <span class="comment">//创建一个锁对象</span></div><div class="line">    <span class="keyword">private</span> Lock resourceLock=<span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="comment">//创建条件对象</span></div><div class="line">    <span class="keyword">private</span> Condition condition= resourceLock.newCondition();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 生产烤鸭</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">product</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        resourceLock.lock();<span class="comment">//先获取锁</span></div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">if</span>(flag)&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    condition.await();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.name=name+count;<span class="comment">//设置烤鸭的名称</span></div><div class="line">            count++;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者..."</span>+<span class="keyword">this</span>.name);</div><div class="line">            flag=<span class="keyword">true</span>;<span class="comment">//有烤鸭后改变标志</span></div><div class="line">            condition.signalAll();<span class="comment">//通知消费线程可以消费了</span></div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            resourceLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 消费烤鸭</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</div><div class="line">        resourceLock.lock();</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">if</span>(!flag)&#123;<span class="comment">//如果没有烤鸭就等待</span></div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                    condition.await();</div><div class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者........"</span>+<span class="keyword">this</span>.name);<span class="comment">//消费烤鸭1</span></div><div class="line">            flag = <span class="keyword">false</span>;</div><div class="line">            condition.signalAll();<span class="comment">//通知生产者生产烤鸭</span></div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            resourceLock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码变化不大，我们通过对象锁的方式去实现，首先要创建一个对象锁，我们这里使用的重入锁ReestrantLock类，然后通过手动设置lock()和unlock()的方式去获取锁以及释放锁。为了实现等待/通知机制，我们还必须通过锁对象去创建一个条件对象Condition，然后通过锁对象的await()和signalAll()方法去实现等待以及通知操作。Single_Producer_Consumer.java代码替换一下资源类即可,运行结果一样。</p>
<h2 id="多生产者多消费者模式"><a href="#多生产者多消费者模式" class="headerlink" title="多生产者多消费者模式"></a>多生产者多消费者模式</h2><p>分析完了单生产者单消费者模式，我们再来聊聊多生产者多消费者模式，也就是多条生产线程配合多条消费线程。既然这样的话我们先把上面的代码Single_Producer_Consumer.java类修改成新类，大部分代码不变，仅新增2条线程去跑，一条t1的生产  共享资源类KaoYaResource不作更改，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutil_Producer_Consumer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        KaoYaResource r = <span class="keyword">new</span> KaoYaResource();</div><div class="line">        Mutil_Producer pro = <span class="keyword">new</span> Mutil_Producer(r);</div><div class="line">        Mutil_Consumer con = <span class="keyword">new</span> Mutil_Consumer(r);</div><div class="line">        <span class="comment">//生产者线程</span></div><div class="line">        Thread t0 = <span class="keyword">new</span> Thread(pro);</div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(pro);</div><div class="line">        <span class="comment">//消费者线程</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(con);</div><div class="line">        Thread t3 = <span class="keyword">new</span> Thread(con);</div><div class="line">        <span class="comment">//启动线程</span></div><div class="line">        t0.start();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutil_Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> KaoYaResource r;</div><div class="line">    Mutil_Producer(KaoYaResource r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.r = r;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            r.product(<span class="string">"北京烤鸭"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutil_Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> KaoYaResource r;</div><div class="line">    Mutil_Consumer(KaoYaResource r)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">this</span>.r = r;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">        &#123;</div><div class="line">            r.consume();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>就多了两条线程，我们运行代码看看，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Thread-0...生产者...北京烤鸭63</div><div class="line">Thread-2...消费者........北京烤鸭63</div><div class="line">Thread-3...消费者........北京烤鸭63  <span class="comment">#消费两次了</span></div><div class="line">......</div><div class="line">......</div><div class="line">Thread-0...生产者...北京烤鸭67     <span class="comment">#没有被消费</span></div><div class="line">Thread-1...生产者...北京烤鸭68     </div><div class="line">Thread-2...消费者........北京烤鸭68</div><div class="line">Thread-0...生产者...北京烤鸭69</div></pre></td></tr></table></figure></p>
<p>不对呀，我们才生产一只烤鸭，怎么就被消费了2次啊，有的烤鸭生产了也没有被消费啊？难道共享数据源没有进行线程同步？回顾下KaoYaResource.java<br>共享数据count的获取方法都进行synchronized关键字同步了呀！那怎么还会出现数据混乱的现象啊？<br>分析：确实，我们对共享数据也采用了同步措施，而且也应用了等待/通知机制，但是这样的措施只在单生产者单消费者的情况下才能正确应用，但从运行结果来看，我们之前的单生产者单消费者安全处理措施就不太适合多生产者多消费者的情况了。那么问题出在哪里？可以明确的告诉大家，肯定是在资源共享类，下面我们就来分析问题是如何出现，又该如何解决？直接上图<br><a href="/images/java-thread-2-4.png"><img src="/images/java-thread-2-4.png" alt=""></a></p>
<p>解决后的资源代码如下只将if改为了while：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaoYaResourceByMulti</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;<span class="comment">//烤鸭的初始数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//判断是否有需要线程等待的标志</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 生产烤鸭</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">product</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">while</span> (flag)&#123;</div><div class="line">            <span class="comment">//此时有烤鸭，等待</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace()</div><div class="line">                ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.name=name+count;<span class="comment">//设置烤鸭的名称</span></div><div class="line">        count++;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者..."</span>+<span class="keyword">this</span>.name);</div><div class="line">        flag=<span class="keyword">true</span>;<span class="comment">//有烤鸭后改变标志</span></div><div class="line">        notifyAll();<span class="comment">//通知消费线程可以消费了</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 消费烤鸭</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span> (!flag)&#123;<span class="comment">//如果没有烤鸭就等待</span></div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                <span class="keyword">this</span>.wait();</div><div class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者........"</span>+<span class="keyword">this</span>.name);<span class="comment">//消费烤鸭1</span></div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">        notifyAll();<span class="comment">//通知生产者生产烤鸭</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果跟单线程那个一致，就不贴了。<br>到此，多消费者多生产者模式也完成，不过上面用的是synchronied关键字实现的，而锁对象的解决方法也一样将之前单消费者单生产者的资源类中的if判断改为while判断即可代码就不贴了哈。不过下面我们将介绍一种更有效的锁对象解决方法，我们准备使用两组条件对象（Condition也称为监视器）来实现等待/通知机制，也就是说通过已有的锁获取两组监视器，一组监视生产者，一组监视消费者。有了前面的分析这里我们直接上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBy2Condition</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">//创建一个锁对象。  </span></div><div class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="comment">//通过已有的锁获取两组监视器，一组监视生产者，一组监视消费者。  </span></div><div class="line">    Condition producer_con = lock.newCondition();</div><div class="line">    Condition consumer_con = lock.newCondition();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 生产 </div><div class="line">     * <span class="doctag">@param</span> name</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">product</span><span class="params">(String name)</span></span></div><div class="line">    &#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(flag)&#123;</div><div class="line">                <span class="keyword">try</span>&#123;producer_con.await();&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.name = name + count;</div><div class="line">            count++;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...生产者5.0..."</span>+<span class="keyword">this</span>.name);</div><div class="line">            flag = <span class="keyword">true</span>;</div><div class="line"><span class="comment">//          notifyAll();  </span></div><div class="line"><span class="comment">//          con.signalAll();  </span></div><div class="line">            consumer_con.signal();<span class="comment">//直接唤醒消费线程  </span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">finally</span></div><div class="line">        &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 消费 </div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(!flag)&#123;</div><div class="line">                <span class="keyword">try</span>&#123;consumer_con.await();&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"...消费者.5.0......."</span>+<span class="keyword">this</span>.name);<span class="comment">//消费烤鸭1  </span></div><div class="line">            flag = <span class="keyword">false</span>;</div><div class="line"><span class="comment">//          notifyAll();  </span></div><div class="line"><span class="comment">//          con.signalAll();  </span></div><div class="line">            producer_con.signal();<span class="comment">//直接唤醒生产线程  </span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">finally</span></div><div class="line">        &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码中可以看到，我们创建了producer_con 和consumer_con两个条件对象，分别用于监听生产者线程和消费者线程，在product()方法中，我们获取到锁后，<br>如果此时flag为true的话，也就是此时还有烤鸭未被消费，因此生产线程需要等待，所以我们调用生产线程的监控器producer_con的<br>await()的方法进入阻塞等待池；但如果此时的flag为false的话，就说明烤鸭已经消费完，需要生产线程去生产烤鸭，那么生产线程将进行烤<br>鸭生产并通过消费线程的监控器consumer_con的signal()方法去通知消费线程对烤鸭进行消费。consume()方法也是同样的道理，这里就不<br>过多分析了。我们可以发现这种方法比我们之前的synchronized同步方法或者是单监视器的锁对象都来得高效和方便些，之前都是使用<br>notifyAll()和signalAll()方法去唤醒池中的线程，然后让池中的线程又进入 竞争队列去抢占CPU资源，这样不仅唤醒了无关的线程而且又让全<br>部线程进入了竞争队列中，而我们最后使用两种监听器分别监听生产者线程和消费者线程，这样的方式恰好解决前面两种方式的问题所在，<br>我们每次唤醒都只是生产者线程或者是消费者线程而不会让两者同时唤醒，这样不就能更高效得去执行程序了吗？好了，到此多生产者多消<br>费者模式也分析完毕。</p>
<h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><p>现在我们再来讨论一下线程死锁问题，从上面的分析，我们知道锁是个非常有用的工具，运用的场景非常多，因为它使用起来非常简单，而<br>且易于理解。但同时它也会带来一些不必要的麻烦，那就是可能会引起死锁，一旦产生死锁，就会造成系统功能不可用。我们先通过一个例<br>子来分析，这个例子会引起死锁，使得线程t1和线程t2互相等待对方释放锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String A=<span class="string">"A"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String B=<span class="string">"B"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        DeadLockDemo deadLock=<span class="keyword">new</span> DeadLockDemo();</div><div class="line"></div><div class="line">        deadLock.deadLock();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span></span>&#123;</div><div class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"static-access"</span>)</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (A) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.currentThread().sleep(<span class="number">2000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">synchronized</span> (B) &#123;</div><div class="line">                        System.out.println(<span class="string">"1"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        Thread t2 =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (B) &#123;</div><div class="line">                    <span class="keyword">synchronized</span> (A) &#123;</div><div class="line">                        System.out.println(<span class="string">"2"</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="comment">//启动线程</span></div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码运行基本没有输出，一直卡着。<br>同步嵌套是产生死锁的常见情景，从上面的代码中我们可以看出，当t1线程拿到锁A后，睡眠2秒，此时线程t2刚好拿到了B锁，接着要获取A锁，但是此时A锁正好被t1线程持有，因此只能等待t1线程释放锁A，但遗憾的是在t1线程内又要求获取到B锁，而B锁此时又被t2线程持有，到此结果就是t1线程拿到了锁A同时在等待t2线程释放锁B，而t2线程获取到了锁B也同时在等待t1线程释放锁A，彼此等待也就造成了线程死锁问题。虽然我们现实中一般不会向上面那么写出那样的代码，但是有些更为复杂的场景中，我们可能会遇到这样的问题，比如t1拿了锁之后，因为一些异常情况没有释放锁（死循环），也可能t1拿到一个数据库锁，释放锁的时候抛出了异常，没有释放等等，所以我们应该在写代码的时候多考虑死锁的情况，这样才能有效预防死锁程序的出现。下面我们介绍一下避免死锁的几个常见方法：</p>
<ol>
<li>避免一个线程同时获取多个锁。</li>
<li>避免在一个资源内占用多个 资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用tryLock(timeout)来代替使用内部锁机制。</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
<li>避免同步嵌套的发生</li>
</ol>
<h1 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h1><p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才能从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。这两个超时的方法表示，如果线程在给定的超时时间里没有终止，那么将会从该超时方法中返回。下面给出一个例子，创建10个线程，编号0~9，每个线程调用前一个线程的join()方法，也就是线程0结束了，线程1才能从join()方法中返回，而0需要等待main线程结束。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread previous = Thread.currentThread();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="comment">//每个线程拥有前一个线程的引用。需要等待前一个线程终止，才能从等待中返回</span></div><div class="line">            Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Domino(previous),String.valueOf(i));</div><div class="line">            thread.start();</div><div class="line">            previous=thread;</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 线程结束"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Domino</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Thread thread;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Domino</span><span class="params">(Thread thread)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.thread=thread;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            thread.join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" 线程结束"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">main 线程结束</div><div class="line">0 线程结束</div><div class="line">1 线程结束</div><div class="line">2 线程结束</div><div class="line">3 线程结束</div><div class="line">4 线程结束</div><div class="line">5 线程结束</div><div class="line">6 线程结束</div><div class="line">7 线程结束</div><div class="line">8 线程结束</div><div class="line">9 线程结束</div></pre></td></tr></table></figure></p>
<blockquote>
<p>结束</p>
</blockquote>
<p>参考 <a href="http://blog.csdn.net/javazejian/article/details/50878665" target="_blank" rel="external">http://blog.csdn.net/javazejian/article/details/50878665</a><br>所有代码在 <a href="https://github.com/ejunjsh/java-code/tree/master/com/sky/code/thread" target="_blank" rel="external">https://github.com/ejunjsh/java-code/tree/master/com/sky/code/thread</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录，汇总&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程(一)基础</title>
    <link href="http://idiotsky.me/2016/08/08/java-thread-1-md/"/>
    <id>http://idiotsky.me/2016/08/08/java-thread-1-md/</id>
    <published>2016-08-08T14:06:08.000Z</published>
    <updated>2017-08-20T08:07:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>对多线程复习下，汇总一下</p>
</blockquote>
<a id="more"></a>
<h1 id="什么是线程以及多线程与进程的区别"><a href="#什么是线程以及多线程与进程的区别" class="headerlink" title="什么是线程以及多线程与进程的区别"></a>什么是线程以及多线程与进程的区别</h1><p>在现代操作在运行一个程序时，会为其创建一个进程。例如启动一个QQ程序，操作系统就会为其创建一个进程。而操作系统中调度的最小单位元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器，堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。因此我们可以这样理解：<br>进程：正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。<br>线程：是进程中的单个顺序控制流，是一条执行路径一个进程如果只有一条执行路径，则称为单线程程序。一个进程如果有多条执行路径，则称为多线程程序。</p>
<h1 id="多线程的创建与启动"><a href="#多线程的创建与启动" class="headerlink" title="多线程的创建与启动"></a>多线程的创建与启动</h1><p>创建多线程有两种方法，一种是继承Thread类重写run方法，另一种是实现Runnable接口重写run方法。<br>下面我们分别给出代码示例，继承Thread类重写run方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"I'm a thread that extends Thread!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现Runnable接口重写run方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"I'm a thread that implements Runnable !"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>怎么启动线程？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartThread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        </div><div class="line">        NewThread t1=<span class="keyword">new</span> NewThread();</div><div class="line">        t1.start();</div><div class="line"></div><div class="line">        NewRunnable r=<span class="keyword">new</span> NewRunnable();</div><div class="line">        Thread t2=<span class="keyword">new</span> Thread(r);</div><div class="line">        t2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I&apos;m a thread that extends Thread!</div><div class="line">I&apos;m a thread that implements Runnable !</div></pre></td></tr></table></figure></p>
<p>代码相当简单，不过多解释。这里有点需要注意的是调用start()方法后并不是是立即的执行多线程的代码，而是使该线程变为可运行态，什么时候运行多线程代码是由操作系统决定的。</p>
<h1 id="中断线程和守护线程以及线程优先级"><a href="#中断线程和守护线程以及线程优先级" class="headerlink" title="中断线程和守护线程以及线程优先级"></a>中断线程和守护线程以及线程优先级</h1><h2 id="什么是中断线程？"><a href="#什么是中断线程？" class="headerlink" title="什么是中断线程？"></a>什么是中断线程？</h2><p>我们先来看看中断线程是什么？(该解释来自java核心技术一书，我对其进行稍微简化)，当线程的run()方法执行方法体中的最后一条语句后，并经由执行return语句返回时，或者出现在方法中没有捕获的异常时线程将终止。在java早期版本中有一个stop方法，其他线程可以调用它终止线程，但是这个方法现在已经被弃用了，因为这个方法会造成一些线程不安全的问题。我们可以把中断理解为一个标识位的属性，它表示一个运行中的线程是否被其他线程进行了中断操作，而中断就好比其他线程对该线程打可个招呼，其他线程通过调用该线程的interrupt方法对其进行中断操作，当一个线程调用interrupt方法时，线程的中断状态（标识位）将被置位（改变），这是每个线程都具有的boolean标志，每个线程都应该不时的检查这个标志，来判断线程是否被中断。而要判断线程是否被中断，我们可以使用如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread.currentThread().isInterrupted()</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;  </div><div class="line">    <span class="keyword">do</span> something  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是如果此时线程处于阻塞状态（sleep或者wait），就无法检查中断状态，此时会抛出InterruptedException异常。如果每次迭代之后都调用sleep方法（或者其他可中断的方法），isInterrupted检测就没必要也没用处了，如果在中断状态被置位时调用sleep方法，它不会休眠反而会清除这一休眠状态并抛出InterruptedException。所以如果在循环中调用sleep,不要去检测中断状态，只需捕获InterruptedException。代码范例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">while</span>(more work to <span class="keyword">do</span> )&#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                Thread.sleep(<span class="number">5000</span>);  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                <span class="comment">//thread was interrupted during sleep  </span></div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;<span class="keyword">finally</span>&#123;  </div><div class="line">                <span class="comment">//clean up , if required  </span></div><div class="line">            &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不妥的处理方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myTask</span><span class="params">()</span></span>&#123;  </div><div class="line">    ...  </div><div class="line">   <span class="keyword">try</span>&#123;  </div><div class="line">       sleep(<span class="number">50</span>)  </div><div class="line">      &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </div><div class="line">   ...  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正确的处理方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myTask</span><span class="params">()</span>throw InterruptedException</span>&#123;  </div><div class="line">    sleep(<span class="number">50</span>)  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myTask</span><span class="params">()</span></span>&#123;  </div><div class="line">    ...  </div><div class="line">    <span class="keyword">try</span>&#123;  </div><div class="line">    sleep(<span class="number">50</span>)  </div><div class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </div><div class="line">     Thread.currentThread().interrupt();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后关于中断线程，我们这里给出中断线程的一些主要方法：<br>void interrupt()：向线程发送中断请求，线程的中断状态将会被设置为true，如果当前线程被一个sleep调用阻塞，那么将会抛出interrupedException异常。<br>static boolean interrupted()：测试当前线程（当前正在执行命令的这个线程）是否被中断。注意这是个静态方法，调用这个方法会产生一个副作用那就是它会将当前线程的中断状态重置为false。<br>boolean isInterrupted()：判断线程是否被中断，这个方法的调用不会产生副作用即不改变线程的当前中断状态。<br>static Thread currentThread() : 返回代表当前执行线程的Thread对象。</p>
<p><strong>这里要注意下，为啥上面的代码，在catch之后还要在中断一次，因为catch会把当前线程的中断标志重置为false，这里不重新中断一次，上层代码就不知道中断了，程序就不知道有中断的发生，下面代码可以说明这个</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ejunjsh on 8/10/2017.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterrupt</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        Thread t= <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">5000</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line">                    <span class="comment">//catch 异常之后，输出是false</span></div><div class="line">                    System.out.println(<span class="string">"1.current interrupted flag is "</span> +Thread.currentThread().isInterrupted());</div><div class="line">                    Thread.currentThread().interrupt();</div><div class="line">                    System.out.println(<span class="string">"2.current interrupted flag is "</span> +Thread.currentThread().isInterrupted());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">5000</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">catch</span> (InterruptedException e)&#123;</div><div class="line">                    System.out.println(<span class="string">"3.current interrupted flag is "</span> +Thread.currentThread().isInterrupted());</div><div class="line">                    Thread.currentThread().interrupt();</div><div class="line">                    System.out.println(<span class="string">"4.current interrupted flag is "</span> +Thread.currentThread().isInterrupted());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        t.start();</div><div class="line">        <span class="comment">//开始中断</span></div><div class="line">        t.interrupt();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            t.join();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"5.current state is "</span> +t.getState());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.current interrupted flag is false</div><div class="line">2.current interrupted flag is true</div><div class="line">3.current interrupted flag is false</div><div class="line">4.current interrupted flag is true</div><div class="line">5.current state is TERMINATED</div></pre></td></tr></table></figure></p>
<p>很明显，<code>开始中断</code>后，catch的标志位被重置了。</p>
<h2 id="什么是守护线程？"><a href="#什么是守护线程？" class="headerlink" title="什么是守护线程？"></a>什么是守护线程？</h2><p>首先我们可以通过t.setDaemon(true)的方法将线程转化为守护线程。而守护线程的唯一作用就是为其他线程提供服务。计时线程就是一个典型的例子，它定时地发送“计时器滴答”信号告诉其他线程去执行某项任务。当只剩下守护线程时，虚拟机就退出了，因为如果只剩下守护线程，程序就没有必要执行了。另外JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。最后还有一点需要特别注意的是在java虚拟机退出时Daemon线程中的finally代码块并不一定会执行哦，代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.sky.code.thread;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deamon</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread deamon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(),<span class="string">"DaemonRunner"</span>);</div><div class="line">        <span class="comment">//设置为守护线程</span></div><div class="line">        deamon.setDaemon(<span class="keyword">true</span>);</div><div class="line">        deamon.start();<span class="comment">//启动线程</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">500</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;<span class="keyword">finally</span>&#123;</div><div class="line">                System.out.println(<span class="string">"这里的代码在java虚拟机退出时并不一定会执行哦！"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此在构建Daemon线程时，不能依靠finally代码块中的内容来确保执行关闭或清理资源的逻辑。</p>
<h2 id="什么是线程优先级"><a href="#什么是线程优先级" class="headerlink" title="什么是线程优先级"></a>什么是线程优先级</h2><p>在现代操作系统中基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下一次分配。线程分配到的时间片多少也决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。在java线程中，通过一个整型的成员变量Priority来控制线程优先级，每一个线程有一个优先级，默认情况下，一个线程继承它父类的优先级。可以用setPriority方法提高或降低任何一个线程优先级。可以将优先级设置在MIN_PRIORITY（在Thread类定义为1）与MAX_PRIORITY（在Thread类定义为10）之间的任何值。线程的默认优先级为NORM_PRIORITY（在Thread类定义为5）。尽量不要依赖优先级，如果确实要用，应该避免初学者常犯的一个错误。如果有几个高优先级的线程没有进入非活动状态，低优先级线程可能永远也不能执行。每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中进行选择，尽管这样会使低优先级的线程可能永远不会被执行到。因此我们在设置优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高的优先级，而偏重计算（需要较多CPU时间或者运算）的线程则设置较低的优先级，这样才能确保处理器不会被长久独占。当然还有要注意就是在不同的JVM以及操作系统上线程的规划存在差异，有些操作系统甚至会忽略对线程优先级的设定，如mac os系统或者Ubuntu系统……..</p>
<h1 id="线程的状态转化关系"><a href="#线程的状态转化关系" class="headerlink" title="线程的状态转化关系"></a>线程的状态转化关系</h1><p>1.新建状态（New）：新创建了一个线程对象。<br>2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。<br>3.运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。<br>4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p>
<ul>
<li>等待阻塞（WAITING）：运行的线程执行wait()方法，JVM会把该线程放入等待池中。</li>
<li>同步阻塞（Blocked）：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li>
<li>超时阻塞（TIME_WAITING）：运行的线程执行sleep(long)或join(long)方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。</li>
</ul>
<p>5.死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。<br><a href="/images/java-thread-1-1.png"><img src="/images/java-thread-1-1.png" alt=""></a><br>图中的方法解析如下：<br>Thread.sleep()：在指定时间内让当前正在执行的线程暂停执行，但不会释放”锁标志”。不推荐使用。<br>Thread.sleep(long)：使当前线程进入阻塞状态，在指定时间内不会执行。<br>Object.wait()和Object.wait(long)：在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的”锁标志”，从而使别的线程有机会抢占该锁。 当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。 唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常，waite()和notify()必须在synchronized函数或synchronized中进行调用。如果在non-synchronized函数或non-synchronized中进行调用,虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。<br>Object.notifyAll()：则从对象等待池中唤醒所有等待等待线程<br>Object.notify()：则从对象等待池中唤醒其中一个线程。<br>Thread.yield()方法 暂停当前正在执行的线程对象，yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，yield()只能使同优先级或更高优先级的线程有执行的机会。<br>Thread.Join()：把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。<br>好了。本篇线程基础知识介绍到此结束。</p>
<p>参考 <a href="http://blog.csdn.net/javazejian/article/details/50878598" target="_blank" rel="external">http://blog.csdn.net/javazejian/article/details/50878598</a><br>所有代码在 <a href="https://github.com/ejunjsh/java-code/tree/master/com/sky/code/thread" target="_blank" rel="external">https://github.com/ejunjsh/java-code/tree/master/com/sky/code/thread</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对多线程复习下，汇总一下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
  </entry>
  
</feed>
