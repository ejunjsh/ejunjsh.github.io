<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IdiotSky</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://idiotsky.me/"/>
  <updated>2017-10-05T12:53:16.270Z</updated>
  <id>http://idiotsky.me/</id>
  
  <author>
    <name>ejunjsh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript是如何工作的(三)</title>
    <link href="http://idiotsky.me/2017/10/05/javascript-how-work-3/"/>
    <id>http://idiotsky.me/2017/10/05/javascript-how-work-3/</id>
    <published>2017-10-05T12:01:15.000Z</published>
    <updated>2017-10-05T12:53:16.270Z</updated>
    
    <content type="html"><![CDATA[<p>几个礼拜之前我们开始一系列对于JavaScript以及其本质工作原理的深入挖掘：我们认为通过了解JavaScript的构建方式以及它们是如何共同合作的，你就能够写出更好的代码以及应用。</p>
<p>这个系列的第一篇博客专注于介绍<a href="http://idiotsky.me/2017/08/26/javascript-how-work/">对于引擎，运行时以及调用栈的概述</a>。<a href="http://idiotsky.me/2017/08/26/javascript-how-work-2/">第二篇博客近距离地检测了Google V8 引擎的内部</a>并且提供了一些如何写出更好的JavaScript代码的建议。</p>
<p>在第三篇博客中，我们将会讨论另外一个关键的话题。这个话题由于随着编程语言的逐渐成熟和复杂化，越来越被开发者所忽视，这个话题就是在日常工作中使用到的——内存管理。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>语言，比如C，具有低层次的内存管理方法，比如<code>malloc()</code>以及<code>free()</code>。开发者利用这些方法精确地为操作系统分配以及释放内存。</p>
<p>同时，JavaScript会在创建一些变量（对象，字符串等等）的时候分配内存，并且会在这些不被使用之后“自动地”释放这些内存，这个过程被称为<em>垃圾收集</em>。这个看起来“自动化的”特性其实就是产生误解的原因，并且给JavaScript（以及其他高层次语言）开发者一个假象，他们不需要关心内存管理。<strong>大错特错。</strong></p>
<p>即使是使用高层次语言，开发者应该对于内存管理有一定的理解（或者最基本的理解）。有时候自动的内存管理会存在一些问题（比如一些bug或者垃圾收集器的一些限制等等），对于这些开发者必须能够理解从而能够合适地处理（或者使用最小的代价以及代码债务去绕过这个问题）。<br><a id="more"></a></p>
<h1 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h1><p>不管你在使用什么编程语言，内存的生命周期基本上都是一样的：</p>
<p><a href="http://idiotsky.me/images1/javascript-how-work-3-1.png"><img src="http://idiotsky.me/images1/javascript-how-work-3-1.png" alt=""></a></p>
<p>下面是对于周期中每一步所发生的情况的概述：</p>
<ul>
<li><strong>分配内存</strong>——操作系统为你的程序分配内存并且允许其使用。在低层次语言中（比如C），这正是开发者应该处理的操作。在高层次的语言，然而，就由语言帮你实现了。</li>
<li><strong>使用内存</strong>——当你的程序确实在使用之前分配的内存的阶段。当你在使用你代码里面分配的变量的时候会发生<strong>读</strong>以及<strong>写</strong>操作。</li>
<li><strong>释放内存</strong>——这个阶段就是释放你不再需要的内存，从而这些内存被释放并且能够再次被使用。和<strong>分配内存</strong>操作一样，这在低层次的语言也是开发者需要明确的操作。</li>
</ul>
<p>对于调用栈以及内存堆有一个快速的概念认识，你可以阅读我们<a href="http://idiotsky.me/2017/08/26/javascript-how-work/">关于这个话题的第一篇博客</a>。</p>
<h1 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a>什么是内存？</h1><p>在我们讲述JavaScript内存之前，我们将简要地讨论一下内存是什么以及它们是如何在 nutshell 中工作的。</p>
<p>在硬件层次上，计算机内存由大量的 <a href="https://en.wikipedia.org/wiki/Flip-flop_%28electronics%29" target="_blank" rel="external">寄存器</a> 组成。每一个寄存器都包含一些晶体管并且能够存储一比特。单独的寄存器可以通过<strong>独特的标识符</strong>去访问，因此我们能够读取以及重写它们。因此，从概念上来说，我们可以认为我们的整个计算机内存就是一个我们能够读写的大型比特数组。</p>
<p>因为作为人类，我们不擅长直接基于比特进行思考以及算术，我们将它们组织成大规模群组，它们在一起可以代表一个数字。8个比特称为一个字节。除了字节，还有词（有时候是16比特，有时候是32比特）。</p>
<p>内存中存储了很多东西：</p>
<ol>
<li>所有程序使用的变量和其他数据</li>
<li>程序的代码，包括操作系统的代码。</li>
</ol>
<p>编译器和操作系统共同合作为你处理大部分的内存管理，但是我们建议你应该了解其内部的运行原理。</p>
<p>当你编译你的代码的时候，编译器将会检查原始数据类型并且提前计算好它们需要多少内存。需要的内存被分配给程序，这被称为<strong>栈空间</strong>。这些被分配给变量的空间被称为栈空间，因为一旦函数被调用，它们的内存就会增加到现有内存的上面。当它们终止的时候，它们就会以后进先出(LIFO)的顺序移除。比如，考虑下面的声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n; <span class="comment">// 4 bytes</span></div><div class="line"><span class="keyword">int</span> x[<span class="number">4</span>]; <span class="comment">// array of 4 elements, each 4 bytes</span></div><div class="line"><span class="keyword">double</span> m; <span class="comment">// 8 bytes</span></div></pre></td></tr></table></figure>
<p>编译器能够立即计算出代码需要</p>
<p>4 + 4 × 4 + 8 = 28 字节</p>
<blockquote>
<p>那就是它如何对于现有的整形以及双浮点型工作。大约20年前，整形典型都是2个字节，双浮点型是4个字节。你的代码不应该取决于当下基本数据类型的大小。</p>
</blockquote>
<p>编译器将会插入能够与操作系统交互的代码，从而在栈上获取你需要存储变量需要的字节数。</p>
<p>在上述的例子中，编译器知道每一个变量的准确的内存地址。事实上，无论我们何时写变量 n ，这都会在内部转化为类似于“内存地址 4127963”的东西。</p>
<p>注意如果我们希望在这访问 x[4] 我们将会需要访问和 m 相关联的数据。这是因为我们在访问数组里面并不存在的元素——它比数组实际分配的最后一个元素 x[3] 要多4个字节，并且最后可能是阅读（或者重写）一些 m 的比特。这将很可能给程序的其他部分带来一些不良的后果。<br><a href="http://idiotsky.me/images1/javascript-how-work-3-2.png"><img src="http://idiotsky.me/images1/javascript-how-work-3-2.png" alt=""></a></p>
<p>当函数调用其它函数的时候，当它被调用的时候都会获取它自己的堆栈块。它在那保存了它所有的局部变量，但是还会有一个程序计数器记录它执行的位置。当这个函数执行完毕，它的内存块就可以再次用于其他目的。</p>
<h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><p>不幸的是，当我们在编译的时候不知道变量需要多少内存的话事情可能就不那么简单。假设我们想做下面的事情：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span> n = readInput(); <span class="comment">// reads input from the user</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// create an array with "n" elements</span></div></pre></td></tr></table></figure></p>
<p>在此，在编译阶段中，编译器就没有办法知道数组需要多少内存，因为它取决于用户的输入。</p>
<p>因此，它就不能够为栈上的变量分配空间。相反，我们的程序需要明确地询问操作运行时需要的空间数量。这个内存是从<strong>堆空间</strong>中分配出来的。动态内存和静态内存分配的区别总结如下表格：<br><a href="http://idiotsky.me/images1/javascript-how-work-3-3.png"><img src="http://idiotsky.me/images1/javascript-how-work-3-3.png" alt=""></a></p>
<p>为了深入地理解动态内存分配是如何工作的，我们需要花费更多的时间在<strong>指针</strong>，这个可能有点偏离这篇博客的话题。如果你感兴趣了解更多，在评论里面告诉我，我将会在后续的博客中挖掘更多的细节。</p>
<h3 id="JavaScript中的分配"><a href="#JavaScript中的分配" class="headerlink" title="JavaScript中的分配"></a>JavaScript中的分配</h3><p>现在我们将解释JavaScript中的第一步（分配内存）。</p>
<p>JavaScript 将开发者从内存分配的处理中解放出来——JavaScript自身可以利用声明变量来完成这些任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n = <span class="number">374</span>; <span class="comment">// allocates memory for a number</span></div><div class="line"><span class="keyword">var</span> s = <span class="string">'sessionstack'</span>; <span class="comment">// allocates memory for a string </span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">b</span>: <span class="literal">null</span></div><div class="line">&#125;; <span class="comment">// allocates memory for an object and its contained values</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">'str'</span>];  <span class="comment">// (like object) allocates memory for the</span></div><div class="line">                           <span class="comment">// array and its contained values</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> a + <span class="number">3</span>;</div><div class="line">&#125; <span class="comment">// allocates a function (which is a callable object)</span></div><div class="line"></div><div class="line"><span class="comment">// function expressions also allocate an object</span></div><div class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>一些函数调用也会导致一些对象的分配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// allocates a Date object</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">// allocates a DOM element</span></div></pre></td></tr></table></figure>
<p>能够分配新的值或者对象的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">'sessionstack'</span>;</div><div class="line"><span class="keyword">var</span> s2 = s1.substr(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 is a new string</span></div><div class="line"><span class="comment">// Since strings are immutable, </span></div><div class="line"><span class="comment">// JavaScript may decide to not allocate memory, </span></div><div class="line"><span class="comment">// but just store the [0, 3] range.</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a1 = [<span class="string">'str1'</span>, <span class="string">'str2'</span>];</div><div class="line"><span class="keyword">var</span> a2 = [<span class="string">'str3'</span>, <span class="string">'str4'</span>];</div><div class="line"><span class="keyword">var</span> a3 = a1.concat(a2); </div><div class="line"><span class="comment">// new array with 4 elements being</span></div><div class="line"><span class="comment">// the concatenation of a1 and a2 elements</span></div></pre></td></tr></table></figure>
<h3 id="在JavaScript中使用内存"><a href="#在JavaScript中使用内存" class="headerlink" title="在JavaScript中使用内存"></a>在JavaScript中使用内存</h3><p>基本上在JavaScript中分配内存，就意味着在其中读写。</p>
<p>这可以通过对一个变量或者一个对象的属性甚至是向函数传递一个参数来完成。</p>
<h3 id="当内存不再需要的时候释放它"><a href="#当内存不再需要的时候释放它" class="headerlink" title="当内存不再需要的时候释放它"></a>当内存不再需要的时候释放它</h3><p>大多数的内存管理的问题就来自于这个阶段。</p>
<p>最困难的任务就是如何知道何时被分配的不再需要了。它经常需要开发者决定在程序的什么地方某段内存不再需要了并且对其进行释放。</p>
<p>高层次语言内嵌了一个称为<strong>垃圾收集器</strong>的软件，他的任务就是跟踪内存分配并且用于需找不再需要的分配过的内存，并且自动地对其进行释放。</p>
<p>不幸的是，这个过程是一个近似，因为知道是否某块内存是需要的问题是<a href="http://en.wikipedia.org/wiki/Decidability_%28logic%29" target="_blank" rel="external">不可决定的</a>（无法通过算法解决）</p>
<p>大多数的垃圾收集器通过收集再也无法访问的内存工作，比如：指向它的所有变量都超出了作用域。然而，这依然是对于可以收集的内存空间的预估，因为在任何位置仍可能一些变量在作用域内指向这个内存，然而它再也不能被访问了。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>由于找到一些是“不再需要的”是不可决定的事实，垃圾收集实现了对一般问题的解决方案的限制。这一节将会解释理解主要的垃圾收集算法以及它们的限制的需要注意的事项。</p>
<h3 id="内存引用"><a href="#内存引用" class="headerlink" title="内存引用"></a>内存引用</h3><p>垃圾收集算法依赖的主要概念之一就是<strong>引用</strong>。</p>
<p>在内存管理的上下文中，一个对象被称为是对于另外一个对象的引用，如果前者可以访问后者（隐含或明确的）。例如，一个JavaScript对象都有一个指向其<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain" target="_blank" rel="external">原型</a>的引用（<strong>隐含的引用</strong>）</p>
<p>在这个上下文中，“对象”的概念扩展到比普通的JavaScript对象要广并且包括函数作用域（或者全局<strong>词法作用域</strong>）。</p>
<blockquote>
<p> 词法作用域定义了变量名称是如何在嵌套函数中解析的：内部函数包含了父函数的作用域即使父函数已经返回了。</p>
<h3 id="基于引用计数的垃圾收集器"><a href="#基于引用计数的垃圾收集器" class="headerlink" title="基于引用计数的垃圾收集器"></a>基于引用计数的垃圾收集器</h3></blockquote>
<p>这是最简单的垃圾收集器算法。如果没有引用指向这个对象的时候，这个对象就被认为是“可以作为垃圾收集”。</p>
<p>请看如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = &#123;</div><div class="line">  <span class="attr">o2</span>: &#123;</div><div class="line">    <span class="attr">x</span>: <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 2 objects are created. </span></div><div class="line"><span class="comment">// 'o2' is referenced by 'o1' object as one of its properties.</span></div><div class="line"><span class="comment">// None can be garbage-collected</span></div><div class="line"><span class="keyword">var</span> o3 = o1; <span class="comment">// the 'o3' variable is the second thing that </span></div><div class="line">            <span class="comment">// has a reference to the object pointed by 'o1'. </span></div><div class="line">o1 = <span class="number">1</span>;      <span class="comment">// now, the object that was originally in 'o1' has a         </span></div><div class="line">            <span class="comment">// single reference, embodied by the 'o3' variable</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o4 = o3.o2; <span class="comment">// reference to 'o2' property of the object.</span></div><div class="line">                <span class="comment">// This object has now 2 references: one as</span></div><div class="line">                <span class="comment">// a property. </span></div><div class="line">                <span class="comment">// The other as the 'o4' variable</span></div><div class="line"></div><div class="line">o3 = <span class="string">'374'</span>; <span class="comment">// The object that was originally in 'o1' has now zero</span></div><div class="line">            <span class="comment">// references to it. </span></div><div class="line">            <span class="comment">// It can be garbage-collected.</span></div><div class="line">            <span class="comment">// However, what was its 'o2' property is still</span></div><div class="line">            <span class="comment">// referenced by the 'o4' variable, so it cannot be</span></div><div class="line">            <span class="comment">// freed.</span></div><div class="line"></div><div class="line">o4 = <span class="literal">null</span>; <span class="comment">// what was the 'o2' property of the object originally in</span></div><div class="line">           <span class="comment">// 'o1' has zero references to it. </span></div><div class="line">           <span class="comment">// It can be garbage collected.</span></div></pre></td></tr></table></figure>
<h3 id="循环在产生问题"><a href="#循环在产生问题" class="headerlink" title="循环在产生问题"></a>循环在产生问题</h3><p>当遇到循环的时候就会有一个限制。在下面的实例之中，创建两个对象，并且互相引用，因此就会产生一个循环。当函数调用结束之后它们会走出作用域之外，因此它们就没什么用并且可以被释放。但是，基于引用计数的算法认为这两个对象都会被至少引用一次，所以它俩都不会被垃圾收集器收集。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> o1 = &#123;&#125;;</div><div class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</div><div class="line">  o1.p = o2; <span class="comment">// o1 references o2</span></div><div class="line">  o2.p = o1; <span class="comment">// o2 references o1. This creates a cycle.</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<p><a href="http://idiotsky.me/images1/javascript-how-work-3-4.png"><img src="http://idiotsky.me/images1/javascript-how-work-3-4.png" alt=""></a></p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>为了决定哪个对象是需要的，算法会决定是否这个对象是可访问的。</p>
<p>这个算法由以下步骤组成：</p>
<ol>
<li>这个垃圾收集器构建一个“roots”列表。Root是全局变量，被代码中的引用所保存。在 JavaScript中，“window”就是这样的作为root的全局变量的例子。</li>
<li>所有的root都会被监测并且被标志成活跃的（比如不是垃圾）。所有的子代也会递归地被监测。所有能够由root访问的一切都不会被认为是垃圾。</li>
<li>所有不再被标志成活跃的内存块都被认为是垃圾。这个收集器现在就可以释放这些内存并将它们返还给操作系统。</li>
</ol>
<p><a href="http://idiotsky.me/images1/javascript-how-work-3-5.gif"><img src="http://idiotsky.me/images1/javascript-how-work-3-5.gif" alt=""></a></p>
<p>这个算法要优于之前的因为“一个具有0引用的对象”可以让一个对象不能够再被访问。但是相反的却不一定成立，比如我们遇到循环的时候。</p>
<p>在2012年，所有的现代浏览器都使用标记-清除垃圾收集器。过去几年，JavaScript垃圾收集（代数/增量/并行/并行垃圾收集）领域的所有改进都是对该算法（标记和扫描）的实现进行了改进，但并没有对垃圾收集算法本身的改进， 其目标是确定一个对象是否可达。</p>
<p><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" target="_blank" rel="external">在这篇文章中</a>，你可以得到更多关于垃圾收集追踪并且也覆盖到了关于标记-清除算法的优化。</p>
<h3 id="循环不再是一个问题"><a href="#循环不再是一个问题" class="headerlink" title="循环不再是一个问题"></a>循环不再是一个问题</h3><p>在上述的第一个例子中，在函数调用返回之后，这两个对象不能够被全局对象所访问。因此，垃圾收集器就会发现它们不能够被访问了。</p>
<p><a href="http://idiotsky.me/images1/javascript-how-work-3-6.png"><img src="http://idiotsky.me/images1/javascript-how-work-3-6.png" alt=""></a></p>
<p>即使在这两个对象之间存在着引用，它们再也不能从root访问了。</p>
<h3 id="列举垃圾收集器的直观行为"><a href="#列举垃圾收集器的直观行为" class="headerlink" title="列举垃圾收集器的直观行为"></a>列举垃圾收集器的直观行为</h3><p>虽然垃圾收集器很方便，但它们自己也有自己的代价。 其中一个是非确定论。 换句话说，GC是不可预测的。 你不能真正地告诉你什么时候会收集。 这意味着在某些情况下，程序会使用实际需要的更多内存。 在其他情况下，特别敏感的应用程序可能会引起短暂暂停。 虽然非确定性意味着在执行集合时无法确定，但大多数GC实现共享在分配期间执行收集遍历的常见模式。 如果没有执行分配，大多数GC保持空闲状态。 考虑以下情况：</p>
<ol>
<li>执行相当大的一组分配。</li>
<li>这些元素中的大多数（或全部）被标记为不可访问（假设我们将指向我们不再需要的缓存的引用置空）。</li>
<li>不再执行分配。</li>
</ol>
<p>在这种情况下，大多数GC不会再运行收集处理。换句话说，即使存在对于收集器来说不可访问的引用，它们也不会被收集器所认领。严格意义来说这并不是泄露，但是依然会导致比平常更多的内存使用。</p>
<h3 id="什么是内存泄露？"><a href="#什么是内存泄露？" class="headerlink" title="什么是内存泄露？"></a>什么是内存泄露？</h3><p>实质上，内存泄漏可以被定义为应用程序不再需要的内存，但是由于某些原因不会返回到操作系统或可用内存池。</p>
<p><a href="http://idiotsky.me/images1/javascript-how-work-3-7.jpg"><img src="http://idiotsky.me/images1/javascript-how-work-3-7.jpg" alt=""></a></p>
<p>编程语言有支持管理内存的不同方法。 然而，某块内存是否被使用实际上是一个<a href="ttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Release_when_the_memory_is_not_needed_anymore" target="_blank" rel="external">不可判定的问题</a>。 换句话说，只有开发人员可以清楚一个内存是否可以返回到操作系统。</p>
<p>某些编程语言提供了帮助开发者执行此操作的功能。其他的则期望开发人员能够完全明确何时使用一块内存。 维基百科有关于<a href="https://en.wikipedia.org/wiki/Manual_memory_management" target="_blank" rel="external">手动</a>和<a href="https://en.wikipedia.org/wiki/Manual_memory_management" target="_blank" rel="external">自动</a>内存管理的好文章。</p>
<h3 id="四种常见的JavaScript泄露"><a href="#四种常见的JavaScript泄露" class="headerlink" title="四种常见的JavaScript泄露"></a>四种常见的JavaScript泄露</h3><h3 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1: 全局变量"></a>1: 全局变量</h3><p>JavaScript 使用一种有趣的方式处理未声明的变量：一个未声明变量的引用会在<em>全局</em>对象内部产生一个新的变量。在浏览器的情况，这个全局变量就会是window。换句话说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">    bar = <span class="string">"some text"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">    <span class="built_in">window</span>.bar = <span class="string">"some text"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果bar被期望仅仅在foo函数作用域内保持对变量的引用，并且你忘记使用var去声明它，一个意想不到的全局变量就产生了。</p>
<p>在这个例子中，泄露就仅仅是一个字符串并不会带来太多危害，但是它可能会变得更糟。</p>
<p>另外一种可能产生意外的全局变量的方式是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.var1 = <span class="string">"potential accidental global"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Foo called on its own, this points to the global object (window)</span></div><div class="line"><span class="comment">// rather than being undefined.</span></div><div class="line">foo();</div></pre></td></tr></table></figure>
<blockquote>
<p> 为了阻止这些错误的发生，可以在js文件头部添加’use strict’。这将会使用严格模式来解析 JavaScript 从而阻止意外的全局变量。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="external">了解更多</a>关于JavaScript执行的模式。</p>
</blockquote>
<p>即使我们讨论了未预期的全局变量，但仍然有很多代码用显式的全局变量填充。 这些定义是不可收集的（除非分配为null或重新分配）。 特别是，用于临时存储和处理大量信息的全局变量值得关注。 如果你必须使用全局变量来存储大量数据，请确保在完成之后<strong>将其分配为null或重新分配</strong>。</p>
<h3 id="2-被遗忘的计时器和回调"><a href="#2-被遗忘的计时器和回调" class="headerlink" title="2: 被遗忘的计时器和回调"></a>2: 被遗忘的计时器和回调</h3><p><code>setInterval</code> 在 JavaScript 中是经常被使用的。</p>
<p>大多数提供观察者和其他模式的回调函数库都会在调用自己的实例变得无法访问之后对其任何引用也设置为不可访问。 但是在<code>setInterval</code>的情况下，这样的代码很常见：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> serverData = loadData();</div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> renderer = <span class="built_in">document</span>.getElementById(<span class="string">'renderer'</span>);</div><div class="line">    <span class="keyword">if</span>(renderer) &#123;</div><div class="line">        renderer.innerHTML = <span class="built_in">JSON</span>.stringify(serverData);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">5000</span>); <span class="comment">//This will be executed every ~5 seconds.</span></div></pre></td></tr></table></figure>
<p>这个例子说明了计时器可能发生的情况：计时器可能会产生再也不被需要的节点或者数据的引用。</p>
<p><code>renderer</code>所代表的对象在未来可能被移除，让部分interval 处理器中代码变得不再被需要。然而，这个处理器不能够被收集因为interval依然活跃的（这个interval需要被停止从而表面这种情况）。如果这个interval处理器不能够被收集，那么它的依赖也不能够被收集。这意味这存储大量数据的<code>severData</code>也不能够被收集。</p>
<p>在这种观察者的情况下，做出准确的调用从而在不需要它们的时候立即将其移除是非常重要的（或者相关的对象被置为不可访问的）。</p>
<p>过去，以前特别重要的是某些浏览器（好的老IE 6）无法管理好循环引用（有关更多信息，请参见下文）。 如今，大多数浏览器一旦观察到的对象变得无法访问，就能收集观察者处理器，即使侦听器没有被明确删除。 但是，在处理对象之前，明确删除这些观察者仍然是一个很好的做法。 例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'launch-button'</span>);</div><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">   counter++;</div><div class="line">   element.innerHtml = <span class="string">'text '</span> + counter;</div><div class="line">&#125;</div><div class="line"></div><div class="line">element.addEventListener(<span class="string">'click'</span>, onClick);</div><div class="line"></div><div class="line"><span class="comment">// Do stuff</span></div><div class="line"></div><div class="line">element.removeEventListener(<span class="string">'click'</span>, onClick);</div><div class="line">element.parentNode.removeChild(element);</div><div class="line"></div><div class="line"><span class="comment">// Now when element goes out of scope,</span></div><div class="line"><span class="comment">// both element and onClick will be collected even in old browsers // that don't handle cycles well.</span></div></pre></td></tr></table></figure>
<p>当今，现在浏览器（报错IE和Edge）都使用了现代的垃圾收集算法，其能够检测到这些循环并且进行适宜的处理。换句话说，再也不是严格需要在将节点置为不可访问之前调用removeEventListener 。</p>
<p>框架和库（如jQuery）在处理节点之前（在为其使用特定的API时）会删除侦听器。 这是由库内部处理的，这也确保没有泄漏，即使在有问题的浏览器下运行，如…是的，IE 6。</p>
<h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3: 闭包"></a>3: 闭包</h3><p>JavaScript 开发的一个关键方面是闭包：一个可以访问外部（封闭）函数变量的内部函数。 由于JavaScript运行时的实现细节，可以通过以下方式泄漏内存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> theThing = <span class="literal">null</span>;</div><div class="line"> <span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> 	<span class="keyword">var</span> originalThing = theThing;</div><div class="line"> 	<span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    	<span class="keyword">if</span> (originalThing) <span class="comment">// a reference to 'originalThing'</span></div><div class="line">      		<span class="built_in">console</span>.log(<span class="string">"hi"</span>);</div><div class="line">  	&#125;;</div><div class="line"></div><div class="line">  	theThing = &#123;</div><div class="line">    	<span class="attr">longStr</span>: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</div><div class="line">    	<span class="attr">someMethod</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      		<span class="built_in">console</span>.log(<span class="string">"message"</span>);</div><div class="line">    	&#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">setInterval(replaceThing, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>这个代码段会做一件事情：每次 <code>replaceThing</code> 被调用时，<code>theThing</code> 都会获取一个一个包含一个大数组的以及一个新的闭包（<code>someMethod</code>）。同时，<code>unused</code> 会保持一个指向<code>originalThing</code>引用的闭包（从上一个调用的<code>theThing</code>到<code>replaceThing</code>）。可能已经很迷惑了，是不是？重要的事情是<strong>一旦在相同的父级作用域为闭包产生作用域，这个作用域就会被共享</strong>。</p>
<p>在这种情况下，为<code>someMethod</code>闭包产生的作用域就会被<code>unused</code> 所共享。<code>unused</code> 具有对于<code>originaThing</code>的引用。即使 <code>unused</code>  不再被使用，<code>someMethod</code>依然可以通过<code>replaceThing</code>作用域之外的<code>theThing</code>来使用。并且由于<code>somethod</code>和<code>unused</code> 共享闭包作用域，unused指向originalThing的引用强迫其保持活跃（两个闭包之间的整个共享作用域）。这将会阻止垃圾手机。</p>
<p>当这个代码段重复运行时，可以观察到内存使用量的稳定增长。 当GC运行时，这不会变小。 实质上，创建了一个关闭的链接列表（其root以TheThing变量的形式），并且这些闭包的范围中的每一个都对大数组进行间接引用，导致相当大的泄漏。</p>
<p>这个问题由Meteor团队发现，他们有<a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" target="_blank" rel="external">一篇很好的文章</a>，详细描述了这个问题。</p>
<h3 id="4-DOM-之外的引用"><a href="#4-DOM-之外的引用" class="headerlink" title="4: DOM 之外的引用"></a>4: DOM 之外的引用</h3><p>有时将DOM节点存储在数据结构中可能是有用的。 假设要快速更新表中的几行内容。 存储对字典或数组中每个DOM行的引用可能是有意义的。 当发生这种情况时，会保留对同一DOM元素的两个引用：一个在DOM树中，另一个在字典中。 如果将来某个时候您决定删除这些行，则需要使两个引用置为不可访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> elements = &#123;</div><div class="line">    <span class="attr">button</span>: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</div><div class="line">    <span class="attr">image</span>: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    image.src = <span class="string">'http://example.com/image_name.png'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeImage</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// The image is a direct child of the body element.</span></div><div class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'image'</span>));</div><div class="line"></div><div class="line">    <span class="comment">// At this point, we still have a reference to #button in the</span></div><div class="line">    <span class="comment">//global elements object. In other words, the button element is</span></div><div class="line">    <span class="comment">//still in memory and cannot be collected by the GC.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一个额外的考虑，当涉及对DOM树内部的内部或叶节点的引用时，必须考虑这一点。 假设你在JavaScript代码中保留对表格特定单元格（<td>标记）的引用。 有一天，你决定从DOM中删除该表，但保留对该单元格的引用。 直观地，可以假设GC将收集除了该单元格之外的所有内容。 实际上，这不会发生：该单元格是该表的子节点，并且孩子们保持对父代的引用。 也就是说，从JavaScript代码引用表格单元会导致整个表保留在内存中。 保持对DOM元素的引用时需要仔细考虑。</td></p>
<p>参考<br><a href="https://segmentfault.com/a/1190000011229300" target="_blank" rel="external">https://segmentfault.com/a/1190000011229300</a><br><a href="https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec" target="_blank" rel="external">https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个礼拜之前我们开始一系列对于JavaScript以及其本质工作原理的深入挖掘：我们认为通过了解JavaScript的构建方式以及它们是如何共同合作的，你就能够写出更好的代码以及应用。&lt;/p&gt;
&lt;p&gt;这个系列的第一篇博客专注于介绍&lt;a href=&quot;http://idiotsky.me/2017/08/26/javascript-how-work/&quot;&gt;对于引擎，运行时以及调用栈的概述&lt;/a&gt;。&lt;a href=&quot;http://idiotsky.me/2017/08/26/javascript-how-work-2/&quot;&gt;第二篇博客近距离地检测了Google V8 引擎的内部&lt;/a&gt;并且提供了一些如何写出更好的JavaScript代码的建议。&lt;/p&gt;
&lt;p&gt;在第三篇博客中，我们将会讨论另外一个关键的话题。这个话题由于随着编程语言的逐渐成熟和复杂化，越来越被开发者所忽视，这个话题就是在日常工作中使用到的——内存管理。&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;语言，比如C，具有低层次的内存管理方法，比如&lt;code&gt;malloc()&lt;/code&gt;以及&lt;code&gt;free()&lt;/code&gt;。开发者利用这些方法精确地为操作系统分配以及释放内存。&lt;/p&gt;
&lt;p&gt;同时，JavaScript会在创建一些变量（对象，字符串等等）的时候分配内存，并且会在这些不被使用之后“自动地”释放这些内存，这个过程被称为&lt;em&gt;垃圾收集&lt;/em&gt;。这个看起来“自动化的”特性其实就是产生误解的原因，并且给JavaScript（以及其他高层次语言）开发者一个假象，他们不需要关心内存管理。&lt;strong&gt;大错特错。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即使是使用高层次语言，开发者应该对于内存管理有一定的理解（或者最基本的理解）。有时候自动的内存管理会存在一些问题（比如一些bug或者垃圾收集器的一些限制等等），对于这些开发者必须能够理解从而能够合适地处理（或者使用最小的代价以及代码债务去绕过这个问题）。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://idiotsky.me/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://idiotsky.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化原理</title>
    <link href="http://idiotsky.me/2017/09/29/mysql-optimization-mechanism/"/>
    <id>http://idiotsky.me/2017/09/29/mysql-optimization-mechanism/</id>
    <published>2017-09-29T15:20:35.000Z</published>
    <updated>2017-10-02T08:03:13.579Z</updated>
    
    <content type="html"><![CDATA[<p>说起MySQL的查询优化，相信大家收藏了一堆奇技淫巧：不能使用SELECT *、不使用NULL字段、合理创建索引、为字段选择合适的数据类型….. 你是否真的理解这些优化技巧？是否理解其背后的工作原理？在实际场景下性能真有提升吗？我想未必。因而理解这些优化建议背后的原理就尤为重要，希望本文能让你重新审视这些优化建议，并在实际业务场景下合理的运用。</p>
<h1 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h1><p>如果能在头脑中构建一幅MySQL各组件之间如何协同工作的架构图，有助于深入理解MySQL服务器。下图展示了MySQL的逻辑架构图。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-1.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-1.jpg" alt=""></a><br><a id="more"></a><br>MySQL逻辑架构整体分为三层，最上层为客户端层，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。</p>
<p>MySQL大多数核心服务均在中间这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。</p>
<p>最下层为存储引擎，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。</p>
<h1 id="MySQL查询过程"><a href="#MySQL查询过程" class="headerlink" title="MySQL查询过程"></a>MySQL查询过程</h1><p>我们总是希望MySQL能够获得更高的查询性能，最好的办法是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，就会发现：很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。</p>
<p>当向MySQL发送一个请求的时候，MySQL到底做了些什么呢？<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-2.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-2.jpg" alt=""></a></p>
<h2 id="客户端-服务端通信协议"><a href="#客户端-服务端通信协议" class="headerlink" title="客户端/服务端通信协议"></a>客户端/服务端通信协议</h2><p>MySQL客户端/服务端通信协议是“半双工”的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。</p>
<p>客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置max_allowed_packet参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p>
<p>与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用SELECT *以及加上LIMIT限制的原因之一。</p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>在解析一个查询语句前，如果查询缓存是打开的，那么MySQL会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p>
<p>MySQL将缓存存放在一个引用表（不要理解成table，可以认为是类似于HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</p>
<p>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果都不会被缓存。比如函数NOW()或者CURRENT_DATE()会因为不同的查询时间，返回不同的查询结果，再比如包含CURRENT_USER或者CONNECION_ID()的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。</p>
<p>既然是缓存，就会失效，那查询缓存何时失效呢？MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿。而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外：</p>
<ol>
<li>任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存</li>
<li>如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗</li>
</ol>
<p>基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。但要如何评估打开缓存是否能够带来性能提升是一件非常困难的事情，也不在本文讨论的范畴内。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如：</p>
<ol>
<li>用多个小表代替一个大表，注意不要过度设计</li>
<li>批量插入代替循环单条插入</li>
<li>合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适</li>
<li>可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存</li>
</ol>
<p>最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。</p>
<p>当然查询缓存系统本身是非常复杂的，这里讨论的也只是很小的一部分，其他更深入的话题，比如：缓存是如何使用内存的？如何控制内存的碎片化？事务对查询缓存有何影响等等，读者可以自行阅读相关资料，这里权当抛砖引玉吧。</p>
<h2 id="语法解析和预处理"><a href="#语法解析和预处理" class="headerlink" title="语法解析和预处理"></a>语法解析和预处理</h2><p>MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等。</p>
<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><p>经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。优化器的作用就是找到这其中最好的执行计划。</p>
<p>MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在MySQL可以通过查询当前会话的last_query_cost的值来得到其计算当前查询的成本。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; select * from t_message limit 10;</div><div class="line">...省略结果集</div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show status like 'last_query_cost';</div><div class="line">+-----------------+-------------+</div><div class="line">| Variable_name   | Value       |</div><div class="line">+-----------------+-------------+</div><div class="line">| Last_query_cost | 6391.799000 |</div><div class="line">+-----------------+-------------+</div></pre></td></tr></table></figure>
<p>示例中的结果表示优化器认为大概需要做6391个数据页的随机查找才能完成上面的查询。这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。</p>
<p>有非常多的原因会导致MySQL选择错误的执行计划，比如统计信息不准确、不会考虑不受其控制的操作成本（用户自定义函数、存储过程）、MySQL认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但MySQL值选择它认为成本小的，但成本小并不意味着执行时间短）等等。</p>
<p>MySQL的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：</p>
<ul>
<li>重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）</li>
<li>优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值，具体原理见下文）</li>
<li>提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询）</li>
<li>优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多）</li>
</ul>
<p>随着MySQL的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略，其他的优化策略，大家自行查阅吧。</p>
<h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>在完成解析和优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为handler API。查询过程中的每一张表由一个handler实例表示。实际上，MySQL在查询优化阶段就为每一张表创建了一个handler实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。</p>
<h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等。</p>
<p>如果查询缓存被打开且这个查询可以被缓存，MySQL也会将结果存放到缓存中。</p>
<p>结果集返回客户端是一个增量且逐步返回的过程。有可能MySQL在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。需要注意的是，结果集中的每一行都会以一个满足①中所描述的通信协议的数据包发送，再通过TCP协议进行传输，在传输过程中，可能对MySQL的数据包进行缓存然后批量发送。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回头总结一下MySQL整个查询执行过程，总的来说分为6个步骤：</p>
<ul>
<li>客户端向MySQL服务器发送一条查询请求</li>
<li>服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li>
<li>服务器进行SQL解析、预处理、再由优化器生成对应的执行计划</li>
<li>MySQL根据执行计划，调用存储引擎的API来执行查询</li>
<li>将结果返回给客户端，同时缓存查询结果</li>
</ul>
<h1 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h1><p>看了这么多，你可能会期待给出一些优化手段，是的，下面会从3个不同方面给出一些优化建议。但请等等，还有一句忠告要先送给你：不要听信你看到的关于优化的“绝对真理”，包括本文所讨论的内容，而应该是在实际的业务场景下通过测试来验证你关于执行计划以及响应时间的假设。</p>
<h2 id="Scheme设计与数据类型优化"><a href="#Scheme设计与数据类型优化" class="headerlink" title="Scheme设计与数据类型优化"></a>Scheme设计与数据类型优化</h2><p>选择数据类型只要遵循小而简单的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的CPU周期也更少。越简单的数据类型在计算时需要更少的CPU周期，比如，整型就比字符操作代价低，因而会使用整型来存储ip地址，使用DATETIME来存储时间，而不是使用字符串。</p>
<p>这里总结几个可能容易理解错误的技巧：</p>
<ol>
<li>通常来说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为NOT NULL。</li>
<li>对整数类型指定宽度，比如INT(11)，没有任何卵用。INT使用32位（4个字节）存储空间，那么它的表示范围已经确定，所以INT(1)和INT(20)对于存储和计算是相同的。</li>
<li>UNSIGNED表示不允许负值，大致可以使正数的上限提高一倍。比如TINYINT存储范围是-128 ~ 127，而UNSIGNED TINYINT存储的范围却是0 - 255。</li>
<li>通常来讲，没有太大的必要使用DECIMAL数据类型。即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用BIGINT存储。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题。</li>
<li>TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节存储空间。因而，TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。</li>
<li>大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用ALTER TABLE（如果只只是在列表末尾追加元素，不需要重建表）。</li>
<li>schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。如果列太多而实际使用的列又很少的话，有可能会导致CPU占用过高。</li>
<li>大表ALTER TABLE非常耗时，MySQL执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表。尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。当然有一些奇技淫巧可以解决这个问题，有兴趣可自行查阅。</li>
</ol>
<h2 id="创建高性能索引"><a href="#创建高性能索引" class="headerlink" title="创建高性能索引"></a>创建高性能索引</h2><p>索引是提高MySQL查询性能的一个重要途径，但过多的索引可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的SQL才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。</p>
<p>接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。</p>
<h3 id="索引相关的数据结构和算法"><a href="#索引相关的数据结构和算法" class="headerlink" title="索引相关的数据结构和算法"></a>索引相关的数据结构和算法</h3><p>通常我们所说的索引是指B-Tree索引，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用B-Tree这个术语，是因为MySQL在CREATE TABLE或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如InnoDB就是使用的B+Tree。</p>
<p>B+Tree中的B是指balance，意为平衡。需要注意的是，B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行所在的页，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p>
<p>在介绍B+Tree前，先了解一下二叉查找树，它是一种经典的数据结构，其左子树的值总是小于根的值，右子树的值总是大于根的值，如下图①。如果要在这课树中查找值为5的记录，其大致流程：先找到根，其值为6，大于5，所以查找左子树，找到3，而5大于3，接着找3的右子树，总共找了3次。同样的方法，如果查找值为8的记录，也需要查找3次。所以二叉查找树的平均查找次数为(3 + 3 + 3 + 2 + 2 + 1) / 6 = 2.3次，而顺序查找的话，查找值为2的记录，仅需要1次，但查找值为8的记录则需要6次，所以顺序查找的平均查找次数为：(1 + 2 + 3 + 4 + 5 + 6) / 6 = 3.3次，因此大多数情况下二叉查找树的平均查找速度比顺序查找要快。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-3.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-3.jpg" alt=""></a></p>
<p>由于二叉查找树可以任意构造，同样的值，可以构造出如图②的二叉查找树，显然这棵二叉树的查询效率和顺序查找差不多。若想二叉查找数的查询性能最高，需要这棵二叉查找树是平衡的，也即平衡二叉树（AVL树）。</p>
<p>平衡二叉树首先需要符合二叉查找树的定义，其次必须满足任何节点的两个子树的高度差不能大于1。显然图②不满足平衡二叉树的定义，而图①是一课平衡二叉树。平衡二叉树的查找性能是比较高的（性能最好的是最优二叉树），查询性能越好，维护的成本就越大。比如图①的平衡二叉树，当用户需要插入一个新的值9的节点时，就需要做出如下变动。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-4.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-4.jpg" alt=""></a></p>
<p>通过一次左旋操作就将插入后的树重新变为平衡二叉树是最简单的情况了，实际应用场景中可能需要旋转多次。至此我们可以考虑一个问题，平衡二叉树的查找效率还不错，实现也非常简单，相应的维护成本还能接受，为什么MySQL索引不直接使用平衡二叉树？</p>
<p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级。可以想象一下一棵几百万节点的二叉树的深度是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的I/O读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的I/O存取次数？</p>
<p>一种行之有效的解决方法是减少树的深度，将二叉树变为m叉树（多路搜索树），而B+Tree就是一种多路搜索树。理解B+Tree时，只需要理解其最重要的两个特征即可：第一，所有的关键字（可以理解为数据）都存储在叶子节点（Leaf Page），非叶子节点（Index Page）并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。其次，所有的叶子节点由指针连接。如下图为高度为2的简化了的B+Tree。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-5.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-5.jpg" alt=""></a></p>
<p>怎么理解这两个特征？MySQL将每个节点的大小设置为一个页的整数倍（原因下文会介绍），也就是在节点空间大小一定的情况下，每个节点可以存储更多的内结点，这样每个结点能索引的范围更大更精确。所有的叶子节点使用指针链接的好处是可以进行区间访问，比如上图中，如果查找大于20而小于30的记录，只需要找到节点20，就可以遍历指针依次找到25、30。如果没有链接指针的话，就无法进行区间查找。这也是MySQL使用B+Tree作为索引存储结构的重要原因。</p>
<p>MySQL为何将节点大小设置为页的整数倍，这就需要理解磁盘的存储原理。磁盘本身存取就比主存慢很多，在加上机械运动损耗（特别是普通的机械硬盘），磁盘的存取速度往往是主存的几百万分之一，为了尽量减少磁盘I/O，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存，预读的长度一般为页的整数倍。</p>
<p>“页是计算机管理存储器的逻辑块，硬件及OS往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（许多OS中，页的大小通常为4K）。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后一起返回，程序继续运行。”</p>
<p>MySQL巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了读取一个节点只需一次I/O。假设B+Tree的高度为h，一次检索最多需要h-1I/O（根节点常驻内存），复杂度$O(h) = O(log_{M}N)$。实际应用场景中，M通常较大，常常超过100，因此树的高度一般都比较小，通常不超过3。</p>
<p>最后简单了解下B+Tree节点的操作，在整体上对索引的维护有一个大概的了解，虽然索引可以大大提高查询效率，但维护索引仍要花费很大的代价，因此合理的创建索引也就尤为重要。</p>
<p>仍以上面的树为例，我们假设每个节点只能存储4个内节点。首先要插入第一个节点28，如下图所示。</p>
<p><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-6.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-6.jpg" alt=""></a><br>接着插入下一个节点70，在Index Page中查询后得知应该插入到50 - 70之间的叶子节点，但叶子节点已满，这时候就需要进行也分裂的操作，当前的叶子节点起点为50，所以根据中间值来拆分叶子节点，如下图所示。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-7.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-7.jpg" alt=""></a><br>最后插入一个节点95，这时候Index Page和Leaf Page都满了，就需要做两次拆分，如下图所示。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-8.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-8.jpg" alt=""></a><br>拆分后最终形成了这样一颗树。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-9.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-9.jpg" alt=""></a><br>B+Tree为了保持平衡，对于新插入的值需要做大量的拆分页操作，而页的拆分需要I/O操作，为了尽可能的减少页的拆分操作，B+Tree也提供了类似于平衡二叉树的旋转功能。当Leaf Page已满但其左右兄弟节点没有满的情况下，B+Tree并不急于去做拆分操作，而是将记录移到当前所在页的兄弟节点上。通常情况下，左兄弟会被先检查用来做旋转操作。就比如上面第二个示例，当插入70的时候，并不会去做页拆分，而是左旋操作。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-10.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-10.jpg" alt=""></a></p>
<p>通过旋转操作可以最大限度的减少页分裂，从而减少索引维护过程中的磁盘的I/O操作，也提高索引维护效率。需要注意的是，删除节点跟插入节点类似，仍然需要旋转和拆分操作，这里就不再说明。</p>
<h3 id="高性能策略"><a href="#高性能策略" class="headerlink" title="高性能策略"></a>高性能策略</h3><p>通过上文，相信你对B+Tree的数据结构已经有了大致的了解，但MySQL中索引是如何组织数据的存储呢？以一个简单的示例来说明，假如有如下数据表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People(</div><div class="line">last_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">first_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">dob <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line">gender enum(<span class="string">`m`</span>,<span class="string">`f`</span>) <span class="keyword">not</span> <span class="literal">null</span>,</div><div class="line"><span class="keyword">key</span>(last_name,first_name,dob)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>对于表中每一行数据，索引中包含了last_name、first_name、dob列的值，下图展示了索引是如何组织数据存储的。<br><a href="http://idiotsky.me/images1/mysql-optimization-mechanism-11.jpg"><img src="http://idiotsky.me/images1/mysql-optimization-mechanism-11.jpg" alt=""></a></p>
<p>可以看到，索引首先根据第一个字段来排列顺序，当名字相同时，则根据第三个字段，即出生日期来排序，正是因为这个原因，才有了索引的“最左原则”。</p>
<h4 id="MySQL不会使用索引的情况：非独立的列"><a href="#MySQL不会使用索引的情况：非独立的列" class="headerlink" title="MySQL不会使用索引的情况：非独立的列"></a>MySQL不会使用索引的情况：非独立的列</h4><p>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。比如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">where</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">5</span></div></pre></td></tr></table></figure></p>
<p>我们很容易看出其等价于 id = 4，但是MySQL无法自动解析这个表达式，使用函数是同样的道理。</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>如果列很长，通常可以索引开始的部分字符，这样可以有效节约索引空间，从而提高索引效率。</p>
<h4 id="多列索引和索引顺序"><a href="#多列索引和索引顺序" class="headerlink" title="多列索引和索引顺序"></a>多列索引和索引顺序</h4><p>在多数情况下，在多个列上建立独立的索引并不能提高查询性能。理由非常简单，MySQL不知道选择哪个索引的查询效率更好，所以在老版本，比如MySQL5.0之前就会随便选择一个列的索引，而新的版本会采用合并索引的策略。举个简单的例子，在一张电影演员表中，在actor_id和film_id两个列上都建立了独立的索引，然后有如下查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> film_id,actor_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span> <span class="keyword">or</span> film_id = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>老版本的MySQL会随机选择一个索引，但新版本做如下的优化：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> film_id,actor_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span></div><div class="line"><span class="keyword">union</span> all</div><div class="line"><span class="keyword">select</span> film_id,actor_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> film_id = <span class="number">1</span> <span class="keyword">and</span> actor_id &lt;&gt; <span class="number">1</span></div></pre></td></tr></table></figure></p>
<ul>
<li>当出现多个索引做相交操作时（多个AND条件），通常来说一个包含所有相关列的索引要优于多个独立索引。</li>
<li>当出现多个索引做联合操作时（多个OR条件），对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描。</li>
</ul>
<p>因此explain时如果发现有索引合并（Extra字段出现Using union），应该好好检查一下查询和表结构是不是已经是最优的，如果查询和表都没有问题，那只能说明索引建的非常糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的多列索引更适合。</p>
<p>前面我们提到过索引如何组织数据存储的，从图中可以看到多列索引时，索引的顺序对于查询是至关重要的，很明显应该把选择性更高的字段放到索引的前面，这样通过第一个字段就可以过滤掉大多数不符合条件的数据。</p>
<p>索引选择性是指不重复的索引值和数据表的总记录数的比值，选择性越高查询效率越高，因为选择性越高的索引可以让MySQL在查询时过滤掉更多的行。唯一索引的选择性是1，这时最好的索引选择性，性能也是最好的。</p>
<p>理解索引选择性的概念后，就不难确定哪个字段的选择性较高了，查一下就知道了，比如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> payment <span class="keyword">where</span> staff_id = <span class="number">2</span> <span class="keyword">and</span> customer_id = <span class="number">584</span></div></pre></td></tr></table></figure></p>
<p>是应该创建(staff_id,customer_id)的索引还是应该颠倒一下顺序？执行下面的查询，哪个字段的选择性更接近1就把哪个字段索引前面就好。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> staff_id)/<span class="keyword">count</span>(*) <span class="keyword">as</span> staff_id_selectivity,</div><div class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> customer_id)/<span class="keyword">count</span>(*) <span class="keyword">as</span> customer_id_selectivity,</div><div class="line"><span class="keyword">count</span>(*) <span class="keyword">from</span> payment</div></pre></td></tr></table></figure></p>
<p>多数情况下使用这个原则没有任何问题，但仍然注意你的数据中是否存在一些特殊情况。举个简单的例子，比如要查询某个用户组下有过交易的用户信息：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> user_id <span class="keyword">from</span> trade <span class="keyword">where</span> user_group_id = <span class="number">1</span> <span class="keyword">and</span> trade_amount &gt; <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>MySQL为这个查询选择了索引(user_group_id,trade_amount)，如果不考虑特殊情况，这看起来没有任何问题，但实际情况是这张表的大多数数据都是从老系统中迁移过来的，由于新老系统的数据不兼容，所以就给老系统迁移过来的数据赋予了一个默认的用户组。这种情况下，通过索引扫描的行数跟全表扫描基本没什么区别，索引也就起不到任何作用。</p>
<p>推广开来说，经验法则和推论在多数情况下是有用的，可以指导我们开发和设计，但实际情况往往会更复杂，实际业务场景下的某些特殊情况可能会摧毁你的整个设计。</p>
<h4 id="避免多个范围条件"><a href="#避免多个范围条件" class="headerlink" title="避免多个范围条件"></a>避免多个范围条件</h4><p>实际开发中，我们会经常使用多个范围条件，比如想查询某个时间段内登录过的用户：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> user.* <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> login_time &gt; <span class="string">'2017-04-01'</span> <span class="keyword">and</span> age <span class="keyword">between</span> <span class="number">18</span> <span class="keyword">and</span> <span class="number">30</span>;</div></pre></td></tr></table></figure></p>
<p>这个查询有一个问题：它有两个范围条件，login_time列和age列，MySQL可以使用login_time列的索引或者age列的索引，但无法同时使用它们。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含或者说覆盖所有需要查询的字段的值，那么就没有必要再回表查询，这就称为覆盖索引。覆盖索引是非常有用的工具，可以极大的提高性能，因为查询只需要扫描索引会带来许多好处：</p>
<ul>
<li>索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量</li>
<li>索引是有按照列值顺序存储的，对于I/O密集型的范围查询要比随机从磁盘读取每一行数据的IO要少的多</li>
</ul>
<h4 id="使用索引扫描来排序"><a href="#使用索引扫描来排序" class="headerlink" title="使用索引扫描来排序"></a>使用索引扫描来排序</h4><p>MySQL有两种方式可以生产有序的结果集，其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的。如果explain的结果中type列的值为index表示使用了索引扫描来做排序。</p>
<p>扫描索引本身很快，因为只需要从一条索引记录移动到相邻的下一条记录。但如果索引本身不能覆盖所有需要查询的列，那么就不得不每扫描一条索引记录就回表查询一次对应的行。这个读取操作基本上是随机I/O，因此按照索引顺序读取数据的速度通常要比顺序地全表扫描要慢。</p>
<p>在设计索引时，如果一个索引既能够满足排序，又满足查询，是最好的。</p>
<p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向也一样时，才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有ORDER BY子句引用的字段全部为第一张表时，才能使用索引做排序。ORDER BY子句和查询的限制是一样的，都要满足最左前缀的要求（有一种情况例外，就是最左的列被指定为常数，下面是一个简单的示例），其它情况下都需要执行排序操作，而无法利用索引排序。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 最左列为常数，索引：(date,staff_id,customer_id)</span></div><div class="line"><span class="keyword">select</span> staff_id,customer_id <span class="keyword">from</span> demo <span class="keyword">where</span> <span class="built_in">date</span> = <span class="string">'2015-06-01'</span> <span class="keyword">order</span> <span class="keyword">by</span> staff_id,customer_id</div></pre></td></tr></table></figure></p>
<h4 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h4><p>冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引(A,B)，再创建索引(A)就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引(A,B)，但这个索引不是扩展已有的索引(A)。</p>
<p>大多数情况下都应该尽量扩展已有的索引而不是创建新索引。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。</p>
<h4 id="删除长期未使用的索引"><a href="#删除长期未使用的索引" class="headerlink" title="删除长期未使用的索引"></a>删除长期未使用的索引</h4><p>定期删除一些长时间未使用过的索引是一个非常好的习惯。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>关于索引这个话题打算就此打住，最后要说一句，索引并不总是最好的工具，只有当索引帮助提高查询速度带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，简单的全表扫描更高效。对于中到大型的表，索引就非常有效。对于超大型的表，建立和维护索引的代价随之增长，这时候其他技术也许更有效，比如分区表。最后的最后，explain后再提测是一种美德。</p>
<h2 id="特定类型查询优化"><a href="#特定类型查询优化" class="headerlink" title="特定类型查询优化"></a>特定类型查询优化</h2><h3 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT()查询"></a>优化COUNT()查询</h3><p>COUNT()可能是被大家误解最多的函数了，它有两种不同的作用，其一是统计某个列值的数量，其二是统计行数。统计列值时，要求列值是非空的，它不会统计NULL。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用COUNT(*)时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计所有的行数。</p>
<p>我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用COUNT(*)，意义清晰，且性能更好。</p>
<p>有时候某些业务场景并不需要完全精确的COUNT值，可以用近似值来代替，EXPLAIN出来的行数就是一个不错的近似值，而且执行EXPLAIN并不需要真正地去执行查询，所以成本非常低。通常来说，执行COUNT()都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用redis这样的外部缓存系统。</p>
<h3 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h3><p>在大数据场景下，表与表之间通过一个冗余字段来关联，要比直接使用JOIN有更好的性能。如果确实需要使用关联查询的情况下，需要特别注意的是：</p>
<ol>
<li>确保ON和USING字句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表A和表B用列c关联的时候，如果优化器关联的顺序是A、B，那么就不需要在A表的对应列上创建索引。没有用到的索引会带来额外的负担，一般来说，除非有其他理由，只需要在关联顺序中的第二张表的相应列上创建索引（具体原因下文分析）。</li>
<li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化。</li>
</ol>
<p>要理解优化关联查询的第一个技巧，就需要理解MySQL是如何执行关联查询的。当前MySQL关联执行的策略非常简单，它对任何的关联都执行嵌套循环关联操作，即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列。</p>
<p>太抽象了？以上面的示例来说明，比如有这样的一个查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> A.xx,B.yy</div><div class="line"><span class="keyword">FROM</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B <span class="keyword">USING</span>(c)</div><div class="line"><span class="keyword">WHERE</span> A.xx <span class="keyword">IN</span> (<span class="number">5</span>,<span class="number">6</span>)</div></pre></td></tr></table></figure></p>
<p>假设MySQL按照查询中的关联顺序A、B来进行关联操作，那么可以用下面的伪代码表示MySQL如何完成这个查询：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">outer_iterator = SELECT A.xx,A.c FROM A WHERE A.xx IN (5,6);</div><div class="line">outer_row = outer_iterator.next;</div><div class="line">while(outer_row) &#123;</div><div class="line">    inner_iterator = SELECT B.yy FROM B WHERE B.c = outer_row.c;</div><div class="line">    inner_row = inner_iterator.next;</div><div class="line">    while(inner_row) &#123;</div><div class="line">        output[inner_row.yy,outer_row.xx];</div><div class="line">        inner_row = inner_iterator.next;</div><div class="line">    &#125;</div><div class="line">    outer_row = outer_iterator.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，最外层的查询是根据A.xx列来查询的，A.c上如果有索引的话，整个关联查询也不会使用。再看内层的查询，很明显B.c上如果有索引的话，能够加速查询，因此只需要在关联顺序中的第二张表的相应列上创建索引即可。</p>
<h3 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h3><p>当需要分页操作时，通常会使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY字句。如果有对应的索引，通常效率会不错，否则，MySQL需要做大量的文件排序操作。</p>
<p>一个常见的问题是当偏移量非常大的时候，比如：LIMIT 10000 20这样的查询，MySQL需要查询10020条记录然后只返回20条记录，前面的10000条都将被抛弃，这样的代价非常高。</p>
<p>优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> film_id,description <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span>;</div></pre></td></tr></table></figure></p>
<p>如果这张表非常大，那么这个查询最好改成下面的样子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> film.film_id,film.description</div><div class="line"><span class="keyword">FROM</span> film <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</div><div class="line"><span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span></div><div class="line">) <span class="keyword">AS</span> tmp <span class="keyword">USING</span>(film_id);</div></pre></td></tr></table></figure></p>
<p>这里的延迟关联将大大提升查询效率，让MySQL扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。</p>
<p>有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET，比如下面的查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t <span class="keyword">LIMIT</span> <span class="number">10000</span>, <span class="number">10</span>;</div></pre></td></tr></table></figure></p>
<p>改为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">10000</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</div></pre></td></tr></table></figure></p>
<p>其它优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。</p>
<h3 id="优化UNION"><a href="#优化UNION" class="headerlink" title="优化UNION"></a>优化UNION</h3><p>MySQL处理UNION的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在UNION查询中都没有办法很好的时候。经常需要手动将WHERE、LIMIT、ORDER BY等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。</p>
<p>除非确实需要服务器去重，否则就一定要使用UNION ALL，如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用ALL关键字，MySQL总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把每个子查询的结果返回给客户端。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>理解查询是如何执行以及时间都消耗在哪些地方，再加上一些优化过程的知识，可以帮助大家更好的理解MySQL，理解常见优化技巧背后的原理。希望本文中的原理、示例能够帮助大家更好的将理论和实践联系起来，更多的将理论知识运用到实践中。</p>
<p>其他也没啥说的了，给大家留两个思考题吧，可以在脑袋里想想答案，这也是大家经常挂在嘴边的，但很少有人会思考为什么？</p>
<ol>
<li>有非常多的程序员在分享时都会抛出这样一个观点：尽可能不要使用存储过程，存储过程非常不容易维护，也会增加使用成本，应该把业务逻辑放到客户端。既然客户端都能干这些事，那为什么还要存储过程？</li>
<li>JOIN本身也挺方便的，直接查询就好了，为什么还需要视图呢？</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起MySQL的查询优化，相信大家收藏了一堆奇技淫巧：不能使用SELECT *、不使用NULL字段、合理创建索引、为字段选择合适的数据类型….. 你是否真的理解这些优化技巧？是否理解其背后的工作原理？在实际场景下性能真有提升吗？我想未必。因而理解这些优化建议背后的原理就尤为重要，希望本文能让你重新审视这些优化建议，并在实际业务场景下合理的运用。&lt;/p&gt;
&lt;h1 id=&quot;MySQL逻辑架构&quot;&gt;&lt;a href=&quot;#MySQL逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL逻辑架构&quot;&gt;&lt;/a&gt;MySQL逻辑架构&lt;/h1&gt;&lt;p&gt;如果能在头脑中构建一幅MySQL各组件之间如何协同工作的架构图，有助于深入理解MySQL服务器。下图展示了MySQL的逻辑架构图。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images1/mysql-optimization-mechanism-1.jpg&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images1/mysql-optimization-mechanism-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://idiotsky.me/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://idiotsky.me/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>从一个 NullPointerException 探究 Java 的自动装箱拆箱机制</title>
    <link href="http://idiotsky.me/2017/09/28/java-box-unbox/"/>
    <id>http://idiotsky.me/2017/09/28/java-box-unbox/</id>
    <published>2017-09-28T12:35:44.000Z</published>
    <updated>2017-09-28T15:54:46.025Z</updated>
    
    <content type="html"><![CDATA[<p>前天遇到了一个 NullPointerException，触发的代码类似下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Long value = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        test(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>main 方法里的代码实际上相当于调用 <code>test(null);</code>，为什么不直接这样写呢？因为编译不过，会报 <code>错误: 不兼容的类型: &lt;空值&gt;无法转换为long</code>。</p>
<h1 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h1><p>运行时提示 <code>test(value);</code> 这一行抛出 NullPointerException，但是看着以上代码会有些许困惑：以上代码里一个对象方法都没有调用啊，NullPointerException 从何而来？<br><a id="more"></a></p>
<h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>这时，如果留意到 test 方法接受的参数是 long 类型，而我们传入的是 Long 类型（虽然其实是 null），就会想到这会经历一次从类型 Long 到基本数据类型 long 的自动拆箱过程，那会不会是这个过程中抛出的 NullPointerException 呢？因为以前只知道 Java 为一些基础数据类型与对应的包装器类型之间提供了自动装箱拆箱机制，而并不知这机制的具体实现方法是怎么样的，正好学习一下。</p>
<p>用命令 <code>javap -c Test</code> 将以上代码编译出的 Test.class 文件进行反汇编，可以看到如下输出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Compiled from "Test.java"</div><div class="line">public class Test &#123;</div><div class="line">  public Test();</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</div><div class="line">       4: return</div><div class="line"></div><div class="line">  public static long test(long);</div><div class="line">    Code:</div><div class="line">       0: lload_0</div><div class="line">       1: lreturn</div><div class="line"></div><div class="line">  public static void main(java.lang.String[]);</div><div class="line">    Code:</div><div class="line">       0: aconst_null</div><div class="line">       1: astore_1</div><div class="line">       2: aload_1</div><div class="line">       3: invokevirtual #2                  // Method java/lang/Long.longValue:()J</div><div class="line">       6: invokestatic  #3                  // Method test:(J)J</div><div class="line">       9: pop2</div><div class="line">      10: return</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从以上字节码及对应的注释可以看出，<code>test(value);</code> 这一行被编译后等同于如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> primitive = value.longValue();</div><div class="line">test(promitive);</div></pre></td></tr></table></figure></p>
<p>相比实际代码，多出的 <code>long primitive = value.longValue();</code> 这一行看起来就是自动拆箱的过程了，而我们传入的 <code>value</code> 为 null，<code>value.longValue()</code> 会抛出 NullPointerException，一切就解释得通了。用更简洁的代码表达出了更丰富的含义，这就是所谓的语法糖了。</p>
<h1 id="证实猜想"><a href="#证实猜想" class="headerlink" title="证实猜想"></a>证实猜想</h1><p>那么我们上面得出的自动拆箱机制的结论是否正确呢？选择一种其它基本数据类型，比如 int，来佐证一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Integer value = <span class="number">10</span>;</div><div class="line">        <span class="keyword">int</span> primitive = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>反汇编后对应的字节码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Compiled from "Test.java"</div><div class="line">public class Test &#123;</div><div class="line">  public Test();</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</div><div class="line">       4: return</div><div class="line"></div><div class="line">  public static void main(java.lang.String[]);</div><div class="line">    Code:</div><div class="line">       0: bipush        10</div><div class="line">       2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</div><div class="line">       5: astore_1</div><div class="line">       6: aload_1</div><div class="line">       7: invokevirtual #3                  // Method java/lang/Integer.intValue:()I</div><div class="line">      10: istore_2</div><div class="line">      11: return</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由以上字节码我们可以印证下文里的知识点了。</p>
<h1 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h1><p>自动装箱与拆箱是 Java 1.5 引入的新特性，是一种语法糖。</p>
<p>在此之前，我们要创建一个值为 10 的 Integer 对象，只能写作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer value = <span class="keyword">new</span> Integer(<span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<p>而现在，我们可以更方便地写为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer value = <span class="number">10</span>;</div></pre></td></tr></table></figure></p>
<h1 id="定义与实现机制"><a href="#定义与实现机制" class="headerlink" title="定义与实现机制"></a>定义与实现机制</h1><p>自动装箱，是指从基本数据类型值到其对应的包装类对象的自动转换。比如 <code>Integer value = 10;</code>，是通过调用 Integer.valueOf 方法实现转换的。</p>
<p>自动拆箱，是指从包装类对象到其对应的基本数据类型值的自动转换。比如 <code>int primitive = value;</code>，是通过调用 Integer.intValue 方法实现转换的。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
<th>装箱方法</th>
<th>拆箱方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>Boolean</td>
<td>Boolean.valueOf(boolean)</td>
<td>Boolean.booleanValue()</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
<td>Byte.valueOf(byte)</td>
<td>Byte.byteValue()</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td>Character.valueOf(char)</td>
<td>Character.charValue()</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>Short.valueOf(short)</td>
<td>Short.shortValue()</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>Integer.valueOf(int)</td>
<td>Integer.intValue()</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>Long.valueOf(long)</td>
<td>Long.longValue()</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>Float.valueOf(float)</td>
<td>Float.floatValue()</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>Double.valueOf(double)</td>
<td>Double.doubleValue()</td>
</tr>
</tbody>
</table>
<h1 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h1><p>自动装箱与拆箱主要发生在以下四种时机：</p>
<ol>
<li><p>赋值时；</p>
</li>
<li><p>比较时；</p>
</li>
<li><p>算术运算时；</p>
</li>
<li><p>方法调用时。</p>
</li>
</ol>
<h1 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h1><h2 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer value = <span class="number">10</span>; <span class="comment">// 自动装箱（赋值时）</span></div><div class="line"><span class="keyword">int</span> primitive = value; <span class="comment">// 自动拆箱（方法调用时）</span></div></pre></td></tr></table></figure>
<h2 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Integer value = <span class="number">1000</span>;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">if</span> (value &lt;= <span class="number">1000</span>) &#123; <span class="comment">// 自动拆箱（比较时）</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Case-3"><a href="#Case-3" class="headerlink" title="Case 3"></a>Case 3</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">list.add(<span class="number">10</span>); <span class="comment">// 自动装箱（方法调用时）</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> i = list.get(<span class="number">0</span>); <span class="comment">// 自动拆箱（赋值时）</span></div></pre></td></tr></table></figure>
<p><strong>注：集合（Collections）里不能直接放入原始类型，集合只接收对象。</strong></p>
<h2 id="Case-4"><a href="#Case-4" class="headerlink" title="Case 4"></a>Case 4</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ThreadLocal&lt;Integer&gt; local = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</div><div class="line">local.set(<span class="number">10</span>); <span class="comment">// 自动装箱（方法调用时）</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> i = local.get(); <span class="comment">// 自动拆箱（赋值时）</span></div></pre></td></tr></table></figure>
<p><strong>注：ThreadLocal 不能存储基本数据类型，只接收引用类型。</strong></p>
<h2 id="Case-5"><a href="#Case-5" class="headerlink" title="Case 5"></a>Case 5</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(Integer value)</span> </span>&#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">    fun1(<span class="number">10</span>); <span class="comment">// 自动装箱（方法调用时）</span></div><div class="line"></div><div class="line">    Integer value = <span class="number">10</span>;</div><div class="line">    fun2(value); <span class="comment">// 自动拆箱（方法调用时）</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Case-6"><a href="#Case-6" class="headerlink" title="Case 6"></a>Case 6</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Integer v1 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</div><div class="line">Integer v2 = <span class="keyword">new</span> Integer(<span class="number">20</span>);</div><div class="line"><span class="keyword">int</span> v3 = <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> sum = v1 + v2; <span class="comment">// 自动拆箱（算术运算时）</span></div><div class="line">sum = v1 + <span class="number">30</span>; <span class="comment">// 自动拆箱（算术运算时）</span></div></pre></td></tr></table></figure>
<h1 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h1><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>除 <code>==</code> 以外，包装类对象与基本数据类型值的比较，包装类对象与包装类对象之间的比较，都是自动拆箱后对基本数据类型值进行比较，所以，<strong>要注意这些类型间进行比较时自动拆箱可能引发的 NullPointerException</strong>。</p>
<p><code>==</code> 比较特殊，因为可以用于判断左右是否为同一对象，所以两个包装类对象之间 <code>==</code>，会用于判断是否为同一对象，而不会进行自动拆箱操作；包装类对象与基本数据类型值之间 <code>==</code>，会自动拆箱。</p>
<p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Integer v1 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</div><div class="line">Integer v2 = <span class="keyword">new</span> Integer(<span class="number">20</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (v1 &lt; v2) &#123; <span class="comment">// 自动拆箱</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (v1 == v2) &#123; <span class="comment">// 不拆箱</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (v1 == <span class="number">10</span>) &#123; <span class="comment">// 自动拆箱</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Java 为整型值包装类 Byte、Character、Short、Integer、Long 设置了缓存，用于存储一定范围内的值，详细如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>缓存值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>Byte</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>Character</td>
<td>0 ~ 127</td>
</tr>
<tr>
<td>Short</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>Integer</td>
<td>-128 ~ 127（可配置）</td>
</tr>
<tr>
<td>Long</td>
<td>-128 ~ 127</td>
</tr>
</tbody>
</table>
<p>在一些情况下，比如自动装箱时，如果值在缓存值范围内，将不创建新对象，直接从缓存里取出对象返回，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Integer v1 = <span class="number">10</span>;</div><div class="line">Integer v2 = <span class="number">10</span>;</div><div class="line">Integer v3 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</div><div class="line">Integer v4 = <span class="number">128</span>;</div><div class="line">Integer v5 = <span class="number">128</span>;</div><div class="line">Integer v6 = Integer.valueOf(<span class="number">10</span>);</div><div class="line"></div><div class="line">System.out.println(v1 == v2); <span class="comment">// true</span></div><div class="line">System.out.println(v1 == v3); <span class="comment">// false</span></div><div class="line">System.out.println(v4 == v5); <span class="comment">// false</span></div><div class="line">System.out.println(v1 == v6); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h3 id="缓存实现机制"><a href="#缓存实现机制" class="headerlink" title="缓存实现机制"></a>缓存实现机制</h3><p>这里使用了设计模式享元模式。</p>
<p>以 Short 类实现源码为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Short</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Short</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCache</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ShortCache</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Short cache[] = <span class="keyword">new</span> Short[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</div><div class="line">                cache[i] = <span class="keyword">new</span> Short((<span class="keyword">short</span>)(i - <span class="number">128</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</div><div class="line">        <span class="keyword">int</span> sAsInt = s;</div><div class="line">        <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></div><div class="line">            <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在第一次调用到 <code>Short.valueOf(short)</code> 方法时，将创建 -128 ~ 127 对应的 256 个对象缓存到堆内存里。</p>
<p>这种设计，在频繁用到这个范围内的值的时候效率较高，可以避免重复创建和回收对象，否则有可能闲置较多对象在内存中。</p>
<h3 id="使用不当的情况"><a href="#使用不当的情况" class="headerlink" title="使用不当的情况"></a>使用不当的情况</h3><p>自动装箱和拆箱这种语法糖为我们写代码带来了简洁和便利，但如果使用不当，也有可能带来负面影响。</p>
<ol>
<li>性能的损耗<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Integer sum = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1000</span>; i &lt; <span class="number">5000</span>; i++) &#123;</div><div class="line">       <span class="comment">// 1. 先对 sum 进行自动拆箱</span></div><div class="line">       <span class="comment">// 2. 加法</span></div><div class="line">       <span class="comment">// 3. 自动装箱赋值给 sum，无法命中缓存，会 new Integer(int)</span></div><div class="line">       sum = sum + i;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在循环过程中会分别调用 4000 次 Integer.intValue() 和 Integer.valueOf(int)，并 new 4000 个 Integer 对象，而这些操作将 sum 的类型改为 int 即可避免，节约运行时间和空间，提升性能。</p>
<ol>
<li>java.lang.NullPointerException<br>尝试对一个值为 null 的包装类对象进行自动拆箱，就有可能造成 NullPointerException。<br>比如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Integer v1 = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">int</span> v2 = v1; <span class="comment">// NullPointerException</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (v1 &gt; <span class="number">10</span>) &#123; <span class="comment">// NullPointerException</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> v3 = v1 + <span class="number">10</span>; <span class="comment">// NullPointerException</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>还有一种更隐蔽的情形<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> value = <span class="keyword">true</span> ? <span class="keyword">null</span> : <span class="number">1</span>; <span class="comment">// NullPointerException</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这实际上还是对一个值为 null 的 Long 类型进行自动拆箱，反汇编代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Compiled from "Test.java"</div><div class="line">public class Test &#123;</div><div class="line">  public Test();</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</div><div class="line">       4: return</div><div class="line"></div><div class="line">  public static void main(java.lang.String[]);</div><div class="line">    Code:</div><div class="line">       0: aconst_null</div><div class="line">       1: checkcast     #2                  // class java/lang/Long</div><div class="line">       4: invokevirtual #3                  // Method java/lang/Long.longValue:()J</div><div class="line">       7: lstore_1</div><div class="line">       8: return</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>转载 <a href="http://mazhuang.org/2017/08/20/java-auto-boxing-unboxing/" target="_blank" rel="external">http://mazhuang.org/2017/08/20/java-auto-boxing-unboxing/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前天遇到了一个 NullPointerException，触发的代码类似下面这样：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Long value = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        test(value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;main 方法里的代码实际上相当于调用 &lt;code&gt;test(null);&lt;/code&gt;，为什么不直接这样写呢？因为编译不过，会报 &lt;code&gt;错误: 不兼容的类型: &amp;lt;空值&amp;gt;无法转换为long&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;抛出问题&quot;&gt;&lt;a href=&quot;#抛出问题&quot; class=&quot;headerlink&quot; title=&quot;抛出问题&quot;&gt;&lt;/a&gt;抛出问题&lt;/h1&gt;&lt;p&gt;运行时提示 &lt;code&gt;test(value);&lt;/code&gt; 这一行抛出 NullPointerException，但是看着以上代码会有些许困惑：以上代码里一个对象方法都没有调用啊，NullPointerException 从何而来？&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="装箱" scheme="http://idiotsky.me/tags/%E8%A3%85%E7%AE%B1/"/>
    
      <category term="拆箱" scheme="http://idiotsky.me/tags/%E6%8B%86%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>go基础-iota</title>
    <link href="http://idiotsky.me/2017/09/18/go-basic-iota/"/>
    <id>http://idiotsky.me/2017/09/18/go-basic-iota/</id>
    <published>2017-09-18T07:44:21.000Z</published>
    <updated>2017-09-19T13:18:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>iota这个关键字，用来实现枚举的功能，但是用起来很奇怪，其实最后表示的还是常量。</p>
</blockquote>
<h1 id="先上代码"><a href="#先上代码" class="headerlink" title="先上代码"></a>先上代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span>(</div><div class="line">    a= <span class="number">10</span>+<span class="literal">iota</span></div><div class="line">    b</div><div class="line">    c</div><div class="line">    d</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(a)</div><div class="line">	fmt.Println(b)</div><div class="line">	fmt.Println(c)</div><div class="line">	fmt.Println(d)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td></tr></table></figure></p>
<p>其实上面代码等价于<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span>(</div><div class="line">    a= <span class="number">10</span>+<span class="number">0</span></div><div class="line">    b= <span class="number">10</span>+<span class="number">1</span></div><div class="line">    c= <span class="number">10</span>+<span class="number">2</span></div><div class="line">    d= <span class="number">10</span>+<span class="number">3</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>看出规律了吧，只要iota出现一次，就累加一次，而且一旦出现一次，就算后面不使用这个iota关键字，接下来的变量都会套用前面的表达式来计算，所以b,c,d用的就是a的表达式<br><a id="more"></a></p>
<h1 id="再上代码"><a href="#再上代码" class="headerlink" title="再上代码"></a>再上代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span>(</div><div class="line">    a= <span class="number">10</span>+<span class="literal">iota</span></div><div class="line">    b</div><div class="line">    c</div><div class="line">    d</div><div class="line">	  e=<span class="number">1</span>+<span class="literal">iota</span></div><div class="line">	  f</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(a)</div><div class="line">	fmt.Println(b)</div><div class="line">	fmt.Println(c)</div><div class="line">	fmt.Println(d)</div><div class="line">	fmt.Println(e)</div><div class="line">	fmt.Println(f)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个的输出，应该能猜出来了吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">5</div><div class="line">6</div></pre></td></tr></table></figure></p>
<p>f很明显是由于e的表达式变了，所以是套用了e的表达式，而不用a的表达式</p>
<h1 id="最后的代码"><a href="#最后的代码" class="headerlink" title="最后的代码"></a>最后的代码</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span>(</div><div class="line">    a= <span class="number">10</span>+<span class="literal">iota</span></div><div class="line">    b</div><div class="line">    c</div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span>(</div><div class="line">	d=<span class="number">1</span>+<span class="literal">iota</span></div><div class="line">	e</div><div class="line">	f</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(a)</div><div class="line">	fmt.Println(b)</div><div class="line">	fmt.Println(c)</div><div class="line">	fmt.Println(d)</div><div class="line">	fmt.Println(e)</div><div class="line">	fmt.Println(f)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>很明显，iota只能在一个代码块累加，在另外的代码块就又重置了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实iota在go就是一个常量，定义在builtin.go这个源文件<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// iota is a predeclared identifier representing the untyped integer ordinal</span></div><div class="line"><span class="comment">// number of the current const specification in a (usually parenthesized)</span></div><div class="line"><span class="comment">// const declaration. It is zero-indexed.</span></div><div class="line"><span class="keyword">const</span> <span class="literal">iota</span> = <span class="number">0</span> <span class="comment">// Untyped int.</span></div></pre></td></tr></table></figure></p>
<p>本文代码在 <a href="https://github.com/ejunjsh/go-code/tree/master/iota" target="_blank" rel="external">https://github.com/ejunjsh/go-code/tree/master/iota</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iota这个关键字，用来实现枚举的功能，但是用起来很奇怪，其实最后表示的还是常量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;先上代码&quot;&gt;&lt;a href=&quot;#先上代码&quot; class=&quot;headerlink&quot; title=&quot;先上代码&quot;&gt;&lt;/a&gt;先上代码&lt;/h1&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    a= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;+&lt;span class=&quot;literal&quot;&gt;iota&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    b&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    c&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    d&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	fmt.Println(a)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	fmt.Println(b)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	fmt.Println(c)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	fmt.Println(d)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结果：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其实上面代码等价于&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt;(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    a= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    b= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    c= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    d= &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看出规律了吧，只要iota出现一次，就累加一次，而且一旦出现一次，就算后面不使用这个iota关键字，接下来的变量都会套用前面的表达式来计算，所以b,c,d用的就是a的表达式&lt;br&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-对象</title>
    <link href="http://idiotsky.me/2017/09/18/redis-object/"/>
    <id>http://idiotsky.me/2017/09/18/redis-object/</id>
    <published>2017-09-17T17:29:58.000Z</published>
    <updated>2017-10-02T14:01:45.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面的数个章节里， 我们陆续介绍了 Redis 用到的所有主要数据结构， 比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合， 等等。</p>
<p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p>
<p>通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 使用对象的另一个好处是， 我们可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</p>
<p>除此之外， Redis 的对象系统还实现了基于引用计数技术的内存回收机制： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放； 另外， Redis 还通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。</p>
<p>最后， Redis 的对象带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。</p>
<p>本章接下来将逐一介绍以上提到的 Redis 对象系统的各个特性。<br><a id="more"></a></p>
<h1 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h1><p>Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p>
<p>举个例子， 以下 SET 命令在数据库中创建了一个新的键值对， 其中键值对的键是一个包含了字符串值 “msg” 的对象， 而键值对的值则是一个包含了字符串值 “hello world” 的对象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello world"</span></span></div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 类型</span></div><div class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 编码</span></div><div class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">&#125; robj;</div></pre></td></tr></table></figure></p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>对象的 type 属性记录了对象的类型， 这个属性的值可以是表 8-1 列出的常量的其中一个。</p>
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象的名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>字符串对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>列表对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>哈希对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>有序集合对象</td>
</tr>
</tbody>
</table>
<p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：</p>
<ul>
<li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；</li>
<li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”，</li>
</ul>
<p>诸如此类。</p>
<p>TYPE 命令的实现方式也与此类似， 当我们对一个数据库键执行 TYPE 命令时， 命令返回的结果为数据库键对应的值对象的类型， 而不是键对象的类型：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 键为字符串对象，值为字符串对象</span></div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> SET msg <span class="string">"hello world"</span></span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> TYPE msg</span></div><div class="line">string</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 键为字符串对象，值为列表对象</span></div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> RPUSH numbers 1 3 5</span></div><div class="line">(integer) 6</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> TYPE numbers</span></div><div class="line">list</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 键为字符串对象，值为哈希对象</span></div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> HMSET profile name Tome age 25 career Programmer</span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> TYPE profile</span></div><div class="line">hash</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 键为字符串对象，值为集合对象</span></div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> SADD fruits apple banana cherry</span></div><div class="line">(integer) 3</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> TYPE fruits</span></div><div class="line">set</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 键为字符串对象，值为有序集合对象</span></div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> ZADD price 8.5 apple 5.0 banana 6.0 cherry</span></div><div class="line">(integer) 3</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> TYPE price</span></div><div class="line">zset</div></pre></td></tr></table></figure></p>
<p>表 8-2 列出了 TYPE 命令在面对不同类型的值对象时所产生的输出。</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>对象 type 属性的值</th>
<th>TYPE 命令的输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串对象</td>
<td>REDIS_STRING</td>
<td>“string”</td>
</tr>
<tr>
<td>列表对象</td>
<td>REDIS_LIST</td>
<td>“list”</td>
</tr>
<tr>
<td>哈希对象</td>
<td>REDIS_HASH</td>
<td>“hash”</td>
</tr>
<tr>
<td>集合对象</td>
<td>REDIS_SET</td>
<td>“set”</td>
</tr>
<tr>
<td>有序集合对象</td>
<td>REDIS_ZSET</td>
<td>“zset”</td>
</tr>
</tbody>
</table>
<h2 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h2><p>对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。</p>
<p>encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现， 这个属性的值可以是表 8-3 列出的常量的其中一个。</p>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>long 类型的整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
</tr>
</tbody>
</table>
<p>每种类型的对象都至少使用了两种不同的编码， 表 8-4 列出了每种类型的对象可以使用的编码。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET</td>
<td>使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
<p>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">"hello wrold"</span></span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING msg</span></div><div class="line">"embstr"</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> SET story <span class="string">"long long long long long long ago ..."</span></span></div><div class="line">OK</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING story</span></div><div class="line">"raw"</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> SADD numbers 1 3 5</span></div><div class="line">(integer) 3</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING numbers</span></div><div class="line">"intset"</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> SADD numbers <span class="string">"seven"</span></span></div><div class="line">(integer) 1</div><div class="line"><span class="meta"></span></div><div class="line">redis&gt;<span class="bash"> OBJECT ENCODING numbers</span></div><div class="line">"hashtable"</div></pre></td></tr></table></figure></p>
<p>表 8-5 列出了不同编码的对象所对应的 OBJECT ENCODING 命令输出。</p>
<table>
<thead>
<tr>
<th>对象所使用的底层数据结构</th>
<th>编码常量</th>
<th>OBJECT ENCODING 命令输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数</td>
<td>REDIS_ENCODING_INT</td>
<td>“int”</td>
</tr>
<tr>
<td>embstr 编码的简单动态字符串（SDS）</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>“embstr”</td>
</tr>
<tr>
<td>简单动态字符串</td>
<td>REDIS_ENCODING_RAW</td>
<td>“raw”</td>
</tr>
<tr>
<td>字典</td>
<td>REDIS_ENCODING_HT</td>
<td>“hashtable”</td>
</tr>
<tr>
<td>双端链表</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>“linkedlist”</td>
</tr>
<tr>
<td>压缩列表</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>“ziplist”</td>
</tr>
<tr>
<td>整数集合</td>
<td>REDIS_ENCODING_INTSET</td>
<td>“intset”</td>
</tr>
<tr>
<td>跳跃表和字典</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>“skiplist”</td>
</tr>
</tbody>
</table>
<p>通过 encoding 属性来设定对象所使用的编码， 而不是为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的灵活性和效率， 因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。</p>
<p>举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：</p>
<ul>
<li>因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li>
<li>随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li>
</ul>
<p>其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p>
<p>在接下来的内容中， 我们将分别介绍 Redis 中的五种不同类型的对象， 说明这些对象底层所使用的编码方式， 列出对象从一种编码转换成另一种编码所需的条件， 以及同一个命令在多种不同编码上的实现方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在前面的数个章节里， 我们陆续介绍了 Redis 用到的所有主要数据结构， 比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合， 等等。&lt;/p&gt;
&lt;p&gt;Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。&lt;/p&gt;
&lt;p&gt;通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 使用对象的另一个好处是， 我们可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。&lt;/p&gt;
&lt;p&gt;除此之外， Redis 的对象系统还实现了基于引用计数技术的内存回收机制： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放； 另外， Redis 还通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。&lt;/p&gt;
&lt;p&gt;最后， Redis 的对象带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。&lt;/p&gt;
&lt;p&gt;本章接下来将逐一介绍以上提到的 Redis 对象系统的各个特性。&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-压缩列表</title>
    <link href="http://idiotsky.me/2017/09/17/redis-ziplist/"/>
    <id>http://idiotsky.me/2017/09/17/redis-ziplist/</id>
    <published>2017-09-17T14:07:30.000Z</published>
    <updated>2017-09-29T15:15:01.029Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。<br>当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。</p>
</blockquote>
<h1 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h1><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。<br>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。<br>图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。<br><a href="http://idiotsky.me/images1/redis-ziplist-1.png"><img src="http://idiotsky.me/images1/redis-ziplist-1.png" alt=""></a></p>
<p>表 7-1 压缩列表各个组成部分的详细说明</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4 字节</td>
<td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2 字节</td>
<td>记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td>entryX</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1 字节</td>
<td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>图 7-2 展示了一个压缩列表示例：</p>
<ul>
<li>列表 zlbytes 属性的值为 0x50 （十进制 80）， 表示压缩列表的总长为 80 字节。</li>
<li>列表 zltail 属性的值为 0x3c （十进制 60）， 这表示如果我们有一个指向压缩列表起始地址的指针 p ， 那么只要用指针 p 加上偏移量 60 ， 就可以计算出表尾节点 entry3 的地址。</li>
<li>列表 zllen 属性的值为 0x3 （十进制 3）， 表示压缩列表包含三个节点。</li>
</ul>
<p><a href="http://idiotsky.me/images1/redis-ziplist-2.png"><img src="http://idiotsky.me/images1/redis-ziplist-2.png" alt=""></a><br>图 7-3 展示了另一个压缩列表示例：</p>
<ul>
<li>列表 zlbytes 属性的值为 0xd2 （十进制 210）， 表示压缩列表的总长为 210 字节。</li>
<li>列表 zltail 属性的值为 0xb3 （十进制 179）， 这表示如果我们有一个指向压缩列表起始地址的指针 p ， 那么只要用指针 p 加上偏移量 179 ， 就可以计算出表尾节点 entry5 的地址。</li>
<li>列表 zllen 属性的值为 0x5 （十进制 5）， 表示压缩列表包含五个节点。</li>
</ul>
<p><a href="http://idiotsky.me/images1/redis-ziplist-3.png"><img src="http://idiotsky.me/images1/redis-ziplist-3.png" alt=""></a></p>
<h1 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h1><p>每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种：</p>
<ol>
<li>长度小于等于 63 （2^{6}-1）字节的字节数组；</li>
<li>长度小于等于 16383 （2^{14}-1） 字节的字节数组；</li>
<li>长度小于等于 4294967295 （2^{32}-1）字节的字节数组；</li>
</ol>
<p>而整数值则可以是以下六种长度的其中一种：</p>
<ol>
<li>4 位长，介于 0 至 12 之间的无符号整数；</li>
<li>1 字节长的有符号整数；</li>
<li>3 字节长的有符号整数；</li>
<li>int16_t 类型整数；</li>
<li>int32_t 类型整数；</li>
<li>int64_t 类型整数。</li>
</ol>
<p>每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成， 如图 7-4 所示。<br><a href="http://idiotsky.me/images1/redis-ziplist-4.png"><img src="http://idiotsky.me/images1/redis-ziplist-4.png" alt=""></a><br>接下来的内容将分别介绍这三个组成部分。</p>
<h2 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h2><p>节点的 previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。</p>
<p>previous_entry_length 属性的长度可以是 1 字节或者 5 字节：</p>
<ul>
<li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</li>
</ul>
<p>图 7-5 展示了一个包含一字节长 previous_entry_length 属性的压缩列表节点， 属性的值为 0x05 ， 表示前一节点的长度为 5 字节。<br><a href="http://idiotsky.me/images1/redis-ziplist-5.png"><img src="http://idiotsky.me/images1/redis-ziplist-5.png" alt=""></a><br>图 7-6 展示了一个包含五字节长 previous_entry_length 属性的压缩节点， 属性的值为 0xFE00002766 ， 其中值的最高位字节 0xFE 表示这是一个五字节长的 previous_entry_length 属性， 而之后的四字节 0x00002766 （十进制值 10086 ）才是前一节点的实际长度。<br><a href="http://idiotsky.me/images1/redis-ziplist-6.png"><img src="http://idiotsky.me/images1/redis-ziplist-6.png" alt=""></a></p>
<p>因为节点的 previous_entry_length 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。</p>
<p>举个例子， 如果我们有一个指向当前节点起始地址的指针 c ， 那么我们只要用指针 c 减去当前节点 previous_entry_length 属性的值， 就可以得出一个指向前一个节点起始地址的指针 p ， 如图 7-7 所示。<br><a href="http://idiotsky.me/images1/redis-ziplist-7.png"><img src="http://idiotsky.me/images1/redis-ziplist-7.png" alt=""></a></p>
<p>压缩列表的从表尾向表头遍历操作就是使用这一原理实现的： 只要我们拥有了一个指向某个节点起始地址的指针， 那么通过这个指针以及这个节点的 previous_entry_length 属性， 程序就可以一直向前一个节点回溯， 最终到达压缩列表的表头节点。</p>
<p>图 7-8 展示了一个从表尾节点向表头节点进行遍历的完整过程：</p>
<ul>
<li>首先，我们拥有指向压缩列表表尾节点 entry4 起始地址的指针 p1 （指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上 zltail 属性的值得出）；</li>
<li>通过用 p1 减去 entry4 节点 previous_entry_length 属性的值， 我们得到一个指向 entry4 前一节点 entry3 起始地址的指针 p2 ；</li>
<li>通过用 p2 减去 entry3 节点 previous_entry_length 属性的值， 我们得到一个指向 entry3 前一节点 entry2 起始地址的指针 p3 ；</li>
<li>通过用 p3 减去 entry2 节点 previous_entry_length 属性的值， 我们得到一个指向 entry2 前一节点 entry1 起始地址的指针 p4 ， entry1 为压缩列表的表头节点；</li>
<li>最终， 我们从表尾节点向表头节点遍历了整个列表。</li>
</ul>
<p><a href="http://idiotsky.me/images1/redis-ziplist-8.png"><img src="http://idiotsky.me/images1/redis-ziplist-8.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-9.png"><img src="http://idiotsky.me/images1/redis-ziplist-9.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-10.png"><img src="http://idiotsky.me/images1/redis-ziplist-10.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-11.png"><img src="http://idiotsky.me/images1/redis-ziplist-11.png" alt=""></a></p>
<h2 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h2><p>节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度：</p>
<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</li>
<li>一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</li>
</ul>
<p>表 7-2 记录了所有可用的字节数组编码， 而表 7-3 则记录了所有可用的整数编码。 表格中的下划线 _ 表示留空， 而 b 、 x 等变量则代表实际的二进制数据， 为了方便阅读， 多个字节之间用空格隔开。</p>
<p>表 7-2 字节数组编码</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content 属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>00bbbbbb</td>
<td>1 字节</td>
<td>长度小于等于 63 字节的字节数组。</td>
</tr>
<tr>
<td>01bbbbbb xxxxxxxx</td>
<td>2 字节</td>
<td>长度小于等于 16383 字节的字节数组。</td>
</tr>
<tr>
<td>10<strong>__</strong> aaaaaaaa bbbbbbbb cccccccc dddddddd</td>
<td>5 字节</td>
<td>长度小于等于 4294967295 的字节数组。</td>
</tr>
</tbody>
</table>
<p>表 7-3 整数编码</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content 属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>11000000</td>
<td>1 字节</td>
<td>int16_t 类型的整数。</td>
</tr>
<tr>
<td>11010000</td>
<td>1 字节</td>
<td>int32_t 类型的整数。</td>
</tr>
<tr>
<td>11100000</td>
<td>1 字节</td>
<td>int64_t 类型的整数。</td>
</tr>
<tr>
<td>11110000</td>
<td>1 字节</td>
<td>24 位有符号整数。</td>
</tr>
<tr>
<td>11111110</td>
<td>1 字节</td>
<td>8 位有符号整数。</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1 字节</td>
<td>使用这一编码的节点没有相应的 content 属性， 因为编码本身的 xxxx 四个位已经保存了一个介于 0 和 12 之间的值， 所以它无须 content 属性。</td>
</tr>
</tbody>
</table>
<h2 id="content"><a href="#content" class="headerlink" title="content"></a>content</h2><p>节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定。</p>
<p>图 7-9 展示了一个保存字节数组的节点示例：</p>
<ul>
<li>编码的最高两位 00 表示节点保存的是一个字节数组；</li>
<li>编码的后六位 001011 记录了字节数组的长度 11 ；</li>
<li>content 属性保存着节点的值 “hello world” 。</li>
</ul>
<p><a href="http://idiotsky.me/images1/redis-ziplist-12.png"><img src="http://idiotsky.me/images1/redis-ziplist-12.png" alt=""></a></p>
<p>图 7-10 展示了一个保存整数值的节点示例：</p>
<ul>
<li>编码 11000000 表示节点保存的是一个 int16_t 类型的整数值；</li>
<li>content 属性保存着节点的值 10086 。</li>
</ul>
<p><a href="http://idiotsky.me/images1/redis-ziplist-13.png"><img src="http://idiotsky.me/images1/redis-ziplist-13.png" alt=""></a></p>
<h1 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h1><p>前面说过， 每个节点的 previous_entry_length 属性都记录了前一个节点的长度：</p>
<ul>
<li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性需要用 1 字节长的空间来保存这个长度值。</li>
<li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性需要用 5 字节长的空间来保存这个长度值。</li>
</ul>
<p>现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 250 字节到 253 字节之间的节点 e1 至 eN ， 如图 7-11 所示。<br><a href="http://idiotsky.me/images1/redis-ziplist-14.png"><img src="http://idiotsky.me/images1/redis-ziplist-14.png" alt=""></a><br>因为 e1 至 eN 的所有节点的长度都小于 254 字节， 所以记录这些节点的长度只需要 1 字节长的 previous_entry_length 属性， 换句话说， e1 至 eN 的所有节点的 previous_entry_length 属性都是 1 字节长的。</p>
<p>这时， 如果我们将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的表头节点， 那么 new 将成为 e1 的前置节点， 如图 7-12 所示。<br><a href="http://idiotsky.me/images1/redis-ziplist-15.png"><img src="http://idiotsky.me/images1/redis-ziplist-15.png" alt=""></a></p>
<p>因为 e1 的 previous_entry_length 属性仅长 1 字节， 它没办法保存新节点 new 的长度， 所以程序将对压缩列表执行空间重分配操作， 并将 e1 节点的 previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长。</p>
<p>现在， 麻烦的事情来了 —— e1 原本的长度介于 250 字节至 253 字节之间， 在为 previous_entry_length 属性新增四个字节的空间之后， e1 的长度就变成了介于 254 字节至 257 字节之间， 而这种长度使用 1 字节长的 previous_entry_length 属性是没办法保存的。</p>
<p>因此， 为了让 e2 的 previous_entry_length 属性可以记录下 e1 的长度， 程序需要再次对压缩列表执行空间重分配操作， 并将 e2 节点的 previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长。</p>
<p>正如扩展 e1 引发了对 e2 的扩展一样， 扩展 e2 也会引发对 e3 的扩展， 而扩展 e3 又会引发对 e4 的扩展……为了让每个节点的 previous_entry_length 属性都符合压缩列表对节点的要求， 程序需要不断地对压缩列表执行空间重分配操作， 直到 eN 为止。</p>
<p>Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）， 图 7-13 展示了这一过程。<br><a href="http://idiotsky.me/images1/redis-ziplist-16.png"><img src="http://idiotsky.me/images1/redis-ziplist-16.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-17.png"><img src="http://idiotsky.me/images1/redis-ziplist-17.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-18.png"><img src="http://idiotsky.me/images1/redis-ziplist-18.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-19.png"><img src="http://idiotsky.me/images1/redis-ziplist-19.png" alt=""></a><br><a href="http://idiotsky.me/images1/redis-ziplist-20.png"><img src="http://idiotsky.me/images1/redis-ziplist-20.png" alt=""></a></p>
<p>除了添加新节点可能会引发连锁更新之外， 删除节点也可能会引发连锁更新。</p>
<p>考虑图 7-14 所示的压缩列表， 如果 e1 至 eN 都是大小介于 250 字节至 253 字节的节点， big 节点的长度大于等于 254 字节（需要 5 字节的 previous_entry_length 来保存）， 而 small 节点的长度小于 254 字节（只需要 1 字节的 previous_entry_length 来保存）， 那么当我们将 small 节点从压缩列表中删除之后， 为了让 e1 的 previous_entry_length 属性可以记录 big 节点的长度， 程序将扩展 e1 的空间， 并由此引发之后的连锁更新。<br><a href="http://idiotsky.me/images1/redis-ziplist-21.png"><img src="http://idiotsky.me/images1/redis-ziplist-21.png" alt=""></a><br>因为连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2) 。</p>
<p>要注意的是， 尽管连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的：</p>
<ul>
<li>首先， 压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；</li>
<li>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；</li>
</ul>
<p>因为以上原因， ziplistPush 等命令的平均复杂度仅为 O(N) ， 在实际中， 我们可以放心地使用这些函数， 而不必担心连锁更新会影响压缩列表的性能。</p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li>
<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>
<li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li>
<li>添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。</li>
</ul>
<p>参考 <a href="http://redisbook.com" target="_blank" rel="external">http://redisbook.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;压缩列表（ziplist）是列表键和哈希键的底层实现之一。&lt;br&gt;当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;压缩列表的构成&quot;&gt;&lt;a href=&quot;#压缩列表的构成&quot; class=&quot;headerlink&quot; title=&quot;压缩列表的构成&quot;&gt;&lt;/a&gt;压缩列表的构成&lt;/h1&gt;&lt;p&gt;压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。&lt;br&gt;一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。&lt;br&gt;图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images1/redis-ziplist-1.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images1/redis-ziplist-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表 7-1 压缩列表各个组成部分的详细说明&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;长度&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;zlbytes&lt;/td&gt;
&lt;td&gt;uint32_t&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zltail&lt;/td&gt;
&lt;td&gt;uint32_t&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zllen&lt;/td&gt;
&lt;td&gt;uint16_t&lt;/td&gt;
&lt;td&gt;2 字节&lt;/td&gt;
&lt;td&gt;记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;entryX&lt;/td&gt;
&lt;td&gt;列表节点&lt;/td&gt;
&lt;td&gt;不定&lt;/td&gt;
&lt;td&gt;压缩列表包含的各个节点，节点的长度由节点保存的内容决定。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zlend&lt;/td&gt;
&lt;td&gt;uint8_t&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
      <category term="压缩列表" scheme="http://idiotsky.me/tags/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-整数集合</title>
    <link href="http://idiotsky.me/2017/09/17/redis-intset/"/>
    <id>http://idiotsky.me/2017/09/17/redis-intset/</id>
    <published>2017-09-17T04:07:30.000Z</published>
    <updated>2017-09-24T06:34:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
</blockquote>
<h1 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h1><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。</p>
<p>每个 intset.h/intset 结构表示一个整数集合：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 编码方式</span></div><div class="line">    <span class="keyword">uint32_t</span> encoding;</div><div class="line"></div><div class="line">    <span class="comment">// 集合包含的元素数量</span></div><div class="line">    <span class="keyword">uint32_t</span> length;</div><div class="line"></div><div class="line">    <span class="comment">// 保存元素的数组</span></div><div class="line">    <span class="keyword">int8_t</span> contents[];</div><div class="line"></div><div class="line">&#125; intset;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
<p>length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。</p>
<p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：</p>
<ul>
<li>如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。</li>
<li>如果 encoding 属性的值为 INTSET_ENC_INT32 ， 那么 contents 就是一个 int32_t 类型的数组， 数组里的每个项都是一个 int32_t 类型的整数值 （最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。</li>
<li>如果 encoding 属性的值为 INTSET_ENC_INT64 ， 那么 contents 就是一个 int64_t 类型的数组， 数组里的每个项都是一个 int64_t 类型的整数值 （最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）。</li>
</ul>
<p>图 6-1 展示了一个整数集合示例：<br>encoding 属性的值为 INTSET_ENC_INT16 ， 表示整数集合的底层实现为 int16_t 类型的数组， 而集合保存的都是 int16_t 类型的整数值。<br>length 属性的值为 5 ， 表示整数集合包含五个元素。<br>contents 数组按从小到大的顺序保存着集合中的五个元素。<br>因为每个集合元素都是 int16_t 类型的整数值， 所以 contents 数组的大小等于 sizeof(int16_t) <em> 5 = 16 </em> 5 = 80 位。<br><a href="http://idiotsky.me/images/redis-intset-1.png"><img src="http://idiotsky.me/images/redis-intset-1.png" alt=""></a><br>图 6-2 展示了另一个整数集合示例：<br>encoding 属性的值为 INTSET_ENC_INT64 ， 表示整数集合的底层实现为 int64_t 类型的数组， 而数组中保存的都是 int64_t 类型的整数值。<br>length 属性的值为 4 ， 表示整数集合包含四个元素。<br>contents 数组按从小到大的顺序保存着集合中的四个元素。<br>因为每个集合元素都是 int64_t 类型的整数值， 所以 contents 数组的大小为 sizeof(int64_t) <em> 4 = 64 </em> 4 = 256 位。<br><a href="http://idiotsky.me/images/redis-intset-2.png"><img src="http://idiotsky.me/images/redis-intset-2.png" alt=""></a><br>虽然 contents 数组保存的四个整数值中， 只有 -2675256175807981027 是真正需要用 int64_t 类型来保存的， 而其他的 1 、 3 、 5 三个值都可以用 int16_t 类型来保存， 不过根据整数集合的升级规则， 当向一个底层为 int16_t 数组的整数集合添加一个 int64_t 类型的整数值时， 整数集合已有的所有元素都会被转换成 int64_t 类型， 所以 contents 数组保存的四个整数值都是 int64_t 类型的， 不仅仅是 -2675256175807981027 。</p>
<h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ol>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<p>举个例子， 假设现在有一个 INTSET_ENC_INT16 编码的整数集合， 集合中包含三个 int16_t 类型的元素， 如图 6-3 所示。<br><a href="http://idiotsky.me/images/redis-intset-3.png"><img src="http://idiotsky.me/images/redis-intset-3.png" alt=""></a><br>因为每个元素都占用 16 位空间， 所以整数集合底层数组的大小为 3 * 16 = 48 位， 图 6-4 展示了整数集合的三个元素在这 48 位里的位置。<br><a href="http://idiotsky.me/images/redis-intset-4.png"><img src="http://idiotsky.me/images/redis-intset-4.png" alt=""></a><br>现在， 假设我们要将类型为 int32_t 的整数值 65535 添加到整数集合里面， 因为 65535 的类型 int32_t 比整数集合当前所有元素的类型都要长， 所以在将 65535 添加到整数集合之前， 程序需要先对整数集合进行升级。</p>
<p>升级首先要做的是， 根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配。</p>
<p>整数集合目前有三个元素， 再加上新元素 65535 ， 整数集合需要分配四个元素的空间， 因为每个 int32_t 整数值需要占用 32 位空间， 所以在空间重分配之后， 底层数组的大小将是 32 * 4 = 128 位， 如图 6-5 所示。<br><a href="http://idiotsky.me/images/redis-intset-5.png"><img src="http://idiotsky.me/images/redis-intset-5.png" alt=""></a><br>虽然程序对底层数组进行了空间重分配， 但数组原有的三个元素 1 、 2 、 3 仍然是 int16_t 类型， 这些元素还保存在数组的前 48 位里面， 所以程序接下来要做的就是将这三个元素转换成 int32_t 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。</p>
<p>首先， 因为元素 3 在 1 、 2 、 3 、 65535 四个元素中排名第三， 所以它将被移动到 contents 数组的索引 2 位置上， 也即是数组 64 位至 95 位的空间内， 如图 6-6 所示。<br><a href="http://idiotsky.me/images/redis-intset-6.png"><img src="http://idiotsky.me/images/redis-intset-6.png" alt=""></a><br>接着， 因为元素 2 在 1 、 2 、 3 、 65535 四个元素中排名第二， 所以它将被移动到 contents 数组的索引 1 位置上， 也即是数组的 32 位至 63 位的空间内， 如图 6-7 所示。<br><a href="http://idiotsky.me/images/redis-intset-7.png"><img src="http://idiotsky.me/images/redis-intset-7.png" alt=""></a><br>之后， 因为元素 1 在 1 、 2 、 3 、 65535 四个元素中排名第一， 所以它将被移动到 contents 数组的索引 0 位置上， 也即是数组的 0 位至 31 位的空间内， 如图 6-8 所示。<br><a href="http://idiotsky.me/images/redis-intset-8.png"><img src="http://idiotsky.me/images/redis-intset-8.png" alt=""></a><br>然后， 因为元素 65535 在 1 、 2 、 3 、 65535 四个元素中排名第四， 所以它将被添加到 contents 数组的索引 3 位置上， 也即是数组的 96 位至 127 位的空间内， 如图 6-9 所示。<br><a href="http://idiotsky.me/images/redis-intset-9.png"><img src="http://idiotsky.me/images/redis-intset-9.png" alt=""></a><br>最后， 程序将整数集合 encoding 属性的值从 INTSET_ENC_INT16 改为 INTSET_ENC_INT32 ， 并将 length 属性的值从 3 改为 4 ， 设置完成之后的整数集合如图 6-10 所示。<br><a href="http://idiotsky.me/images/redis-intset-10.png"><img src="http://idiotsky.me/images/redis-intset-10.png" alt=""></a><br>因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。</p>
<p>其他类型的升级操作， 比如从 INTSET_ENC_INT16 编码升级为 INTSET_ENC_INT64 编码， 或者从 INTSET_ENC_INT32 编码升级为 INTSET_ENC_INT64 编码， 升级的过程都和上面展示的升级过程类似。</p>
<blockquote>
<p>升级之后新元素的摆放位置<br>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：</p>
<ul>
<li>在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 0 ）；</li>
<li>在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 length-1 ）。</li>
</ul>
</blockquote>
<h1 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h1><p>整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。</p>
<h2 id="提升灵活性"><a href="#提升灵活性" class="headerlink" title="提升灵活性"></a>提升灵活性</h2><p>因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。</p>
<p>比如说， 我们一般只使用 int16_t 类型的数组来保存 int16_t 类型的值， 只使用 int32_t 类型的数组来保存 int32_t 类型的值， 诸如此类。</p>
<p>但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 int16_t 、 int32_t 或者 int64_t 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</p>
<h2 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h2><p>当然， 要让一个数组可以同时保存 int16_t 、 int32_t 、 int64_t 三种类型的值， 最简单的做法就是直接使用 int64_t 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 int16_t 类型或者 int32_t 类型的值， 数组都需要使用 int64_t 类型的空间去保存它们， 从而出现浪费内存的情况。</p>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<p>比如说， 如果我们一直只向整数集合添加 int16_t 类型的值， 那么整数集合的底层实现就会一直是 int16_t 类型的数组， 只有在我们要将 int32_t 类型或者 int64_t 类型的值添加到集合时， 程序才会对数组进行升级。</p>
<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<p>举个例子， 对于图 6-11 所示的整数集合来说， 即使我们将集合里唯一一个真正需要使用 int64_t 类型来保存的元素 4294967295 删除了， 整数集合的编码仍然会维持 INTSET_ENC_INT64 ， 底层数组也仍然会是 int64_t 类型的， 如图 6-12 所示。<br><a href="http://idiotsky.me/images/redis-intset-11.png"><img src="http://idiotsky.me/images/redis-intset-11.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-intset-12.png"><img src="http://idiotsky.me/images/redis-intset-12.png" alt=""></a></p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>整数集合是集合键的底层实现之一。</li>
<li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作， 不支持降级操作。</li>
</ul>
<p>参考 <a href="http://redisbook.com" target="_blank" rel="external">http://redisbook.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;整数集合的实现&quot;&gt;&lt;a href=&quot;#整数集合的实现&quot; class=&quot;headerlink&quot; title=&quot;整数集合的实现&quot;&gt;&lt;/a&gt;整数集合的实现&lt;/h1&gt;&lt;p&gt;整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。&lt;/p&gt;
&lt;p&gt;每个 intset.h/intset 结构表示一个整数集合：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;intset&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 编码方式&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; encoding;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 集合包含的元素数量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保存元素的数组&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int8_t&lt;/span&gt; contents[];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; intset;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
      <category term="整数集合" scheme="http://idiotsky.me/tags/%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-跳跃表</title>
    <link href="http://idiotsky.me/2017/09/16/redis-skiplist/"/>
    <id>http://idiotsky.me/2017/09/16/redis-skiplist/</id>
    <published>2017-09-16T04:07:30.000Z</published>
    <updated>2017-09-24T06:26:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下， 跳跃表的效率可以和平衡树相媲美， 并且因为跳跃表的实现比平衡树要来得更为简单， 所以有不少程序都使用跳跃表来代替平衡树。<br>Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多， 又或者有序集合中元素的成员（member）是比较长的字符串时， Redis 就会使用跳跃表来作为有序集合键的底层实现。</p>
</blockquote>
<h1 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h1><p>Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。<br><a href="http://idiotsky.me/images/redis-skiplist.png"><img src="http://idiotsky.me/images/redis-skiplist.png" alt=""></a><br>图 5-1 展示了一个跳跃表示例， 位于图片最左边的是 zskiplist 结构， 该结构包含以下属性：</p>
<ul>
<li>header ：指向跳跃表的表头节点。</li>
<li>tail ：指向跳跃表的表尾节点。</li>
<li>level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li>length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li>
</ul>
<p>位于 zskiplist 结构右方的是四个 zskiplistNode 结构， 该结构包含以下属性：</p>
<ul>
<li>层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。</li>
</ul>
<p>注意表头节点和其他节点的构造是一样的： 表头节点也有后退指针、分值和成员对象， 不过表头节点的这些属性都不会被用到， 所以图中省略了这些部分， 只显示了表头节点的各个层。</p>
<p>本节接下来的内容将对 zskiplistNode 和 zskiplist 两个结构进行更详细的介绍。<br><a id="more"></a></p>
<h1 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h1><p>跳跃表节点的实现由 redis.h/zskiplistNode 结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 后退指针</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 分值</span></div><div class="line">    <span class="keyword">double</span> score;</div><div class="line"></div><div class="line">    <span class="comment">// 成员对象</span></div><div class="line">    robj *obj;</div><div class="line"></div><div class="line">    <span class="comment">// 层</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></div><div class="line"></div><div class="line">        <span class="comment">// 前进指针</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></div><div class="line"></div><div class="line">        <span class="comment">// 跨度</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</div><div class="line"></div><div class="line">    &#125; level[];</div><div class="line"></div><div class="line">&#125; zskiplistNode;</div></pre></td></tr></table></figure></p>
<h2 id="层"><a href="#层" class="headerlink" title="层"></a>层</h2><p>跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。</p>
<p>图 5-2 分别展示了三个高度为 1 层、 3 层和 5 层的节点， 因为 C 语言的数组索引总是从 0 开始的， 所以节点的第一层是 level[0] ， 而第二层是 level[1] ， 以此类推。<br><a href="http://idiotsky.me/images/redis-skiplist-1.png"><img src="http://idiotsky.me/images/redis-skiplist-1.png" alt=""></a></p>
<h2 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h2><p>每个层都有一个指向表尾方向的前进指针（level[i].forward 属性）， 用于从表头向表尾方向访问节点。</p>
<p>图 5-3 用虚线表示出了程序从表头向表尾方向， 遍历跳跃表中所有节点的路径：</p>
<ol>
<li>迭代程序首先访问跳跃表的第一个节点（表头）， 然后从第四层的前进指针移动到表中的第二个节点。</li>
<li>在第二个节点时， 程序沿着第二层的前进指针移动到表中的第三个节点。</li>
<li>在第三个节点时， 程序同样沿着第二层的前进指针移动到表中的第四个节点。</li>
<li>当程序再次沿着第四个节点的前进指针移动时， 它碰到一个 NULL ， 程序知道这时已经到达了跳跃表的表尾， 于是结束这次遍历。</li>
</ol>
<p><a href="http://idiotsky.me/images/redis-skiplist-2.png"><img src="http://idiotsky.me/images/redis-skiplist-2.png" alt=""></a></p>
<h2 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h2><p>层的跨度（level[i].span 属性）用于记录两个节点之间的距离：</p>
<ul>
<li>两个节点之间的跨度越大， 它们相距得就越远。</li>
<li>指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。</li>
</ul>
<p>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p>
<p>举个例子， 图 5-4 用虚线标记了在跳跃表中查找分值为 3.0 、 成员对象为 o3 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 3 ， 所以目标节点在跳跃表中的排位为 3 。<br><a href="http://idiotsky.me/images/redis-skiplist-3.png"><img src="http://idiotsky.me/images/redis-skiplist-3.png" alt=""></a><br>再举个例子， 图 5-5 用虚线标记了在跳跃表中查找分值为 2.0 、 成员对象为 o2 的节点时， 沿途经历的层： 在查找节点的过程中， 程序经过了两个跨度为 1 的节点， 因此可以计算出， 目标节点在跳跃表中的排位为 2 。<br><a href="http://idiotsky.me/images/redis-skiplist-4.png"><img src="http://idiotsky.me/images/redis-skiplist-4.png" alt=""></a></p>
<h2 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h2><p>节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p>
<p>图 5-6 用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点： 程序首先通过跳跃表的 tail 指针访问表尾节点， 然后通过后退指针访问倒数第二个节点， 之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 NULL 的后退指针， 于是访问结束。<br><a href="http://idiotsky.me/images/redis-skiplist-5.png"><img src="http://idiotsky.me/images/redis-skiplist-5.png" alt=""></a></p>
<h2 id="分值和成员"><a href="#分值和成员" class="headerlink" title="分值和成员"></a>分值和成员</h2><p>节点的分值（score 属性）是一个 double 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p>
<p>节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p>
<p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p>
<p>举个例子， 在图 5-7 所示的跳跃表中， 三个跳跃表节点都保存了相同的分值 10086.0 ， 但保存成员对象 o1 的节点却排在保存成员对象 o2 和 o3 的节点之前， 而保存成员对象 o2 的节点又排在保存成员对象 o3 的节点之前， 由此可见， o1 、 o2 、 o3 三个成员对象在字典中的排序为 o1 &lt;= o2 &lt;= o3 。<br><a href="http://idiotsky.me/images/redis-skiplist-6.png"><img src="http://idiotsky.me/images/redis-skiplist-6.png" alt=""></a></p>
<h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表， 如图 5-8 所示。<br><a href="http://idiotsky.me/images/redis-skiplist-7.png"><img src="http://idiotsky.me/images/redis-skiplist-7.png" alt=""></a><br>但通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息， 如图 5-9 所示。<br><a href="http://idiotsky.me/images/redis-skiplist-8.png"><img src="http://idiotsky.me/images/redis-skiplist-8.png" alt=""></a><br>zskiplist 结构的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 表头节点和表尾节点</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 表中节点的数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</div><div class="line"></div><div class="line">    <span class="comment">// 表中层数最大的节点的层数</span></div><div class="line">    <span class="keyword">int</span> level;</div><div class="line"></div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure></p>
<p>header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</p>
<p>通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。</p>
<p>level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。</p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。</li>
<li>Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成， 其中 zskiplist 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 zskiplistNode 则用于表示跳跃表节点。</li>
<li>每个跳跃表节点的层高都是 1 至 32 之间的随机数。</li>
<li>在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。</li>
<li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li>
</ul>
<p>参考 <a href="http://redisbook.com" target="_blank" rel="external">http://redisbook.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。&lt;/p&gt;
&lt;p&gt;跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。&lt;/p&gt;
&lt;p&gt;在大部分情况下， 跳跃表的效率可以和平衡树相媲美， 并且因为跳跃表的实现比平衡树要来得更为简单， 所以有不少程序都使用跳跃表来代替平衡树。&lt;br&gt;Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多， 又或者有序集合中元素的成员（member）是比较长的字符串时， Redis 就会使用跳跃表来作为有序集合键的底层实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;概括&quot;&gt;&lt;a href=&quot;#概括&quot; class=&quot;headerlink&quot; title=&quot;概括&quot;&gt;&lt;/a&gt;概括&lt;/h1&gt;&lt;p&gt;Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images/redis-skiplist.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images/redis-skiplist.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;图 5-1 展示了一个跳跃表示例， 位于图片最左边的是 zskiplist 结构， 该结构包含以下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;header ：指向跳跃表的表头节点。&lt;/li&gt;
&lt;li&gt;tail ：指向跳跃表的表尾节点。&lt;/li&gt;
&lt;li&gt;level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。&lt;/li&gt;
&lt;li&gt;length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;位于 zskiplist 结构右方的是四个 zskiplistNode 结构， 该结构包含以下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。&lt;/li&gt;
&lt;li&gt;后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。&lt;/li&gt;
&lt;li&gt;分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。&lt;/li&gt;
&lt;li&gt;成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意表头节点和其他节点的构造是一样的： 表头节点也有后退指针、分值和成员对象， 不过表头节点的这些属性都不会被用到， 所以图中省略了这些部分， 只显示了表头节点的各个层。&lt;/p&gt;
&lt;p&gt;本节接下来的内容将对 zskiplistNode 和 zskiplist 两个结构进行更详细的介绍。&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
      <category term="跳跃表" scheme="http://idiotsky.me/tags/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-字典</title>
    <link href="http://idiotsky.me/2017/09/15/redis-dict/"/>
    <id>http://idiotsky.me/2017/09/15/redis-dict/</id>
    <published>2017-09-14T16:59:31.000Z</published>
    <updated>2017-09-24T06:27:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Redis 的数据库就是使用字典来作为底层实现的, 字典还是哈希键的底层实现之一<br>Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。</p>
</blockquote>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 哈希表数组</span></div><div class="line">    dictEntry **table;</div><div class="line"></div><div class="line">    <span class="comment">// 哈希表大小</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</div><div class="line"></div><div class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></div><div class="line">    <span class="comment">// 总是等于 size - 1</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</div><div class="line"></div><div class="line">    <span class="comment">// 该哈希表已有节点的数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</div><div class="line"></div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure></p>
<p>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。<br>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。<br>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。<br>图 4-1 展示了一个大小为 4 的空哈希表 （没有包含任何键值对）。<br><a href="http://idiotsky.me/images/redis-dict-1.png"><img src="http://idiotsky.me/images/redis-dict-1.png" alt=""></a><br><a id="more"></a></p>
<h1 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h1><p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 键</span></div><div class="line">    <span class="keyword">void</span> *key;</div><div class="line"></div><div class="line">    <span class="comment">// 值</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">    &#125; v;</div><div class="line"></div><div class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></div><div class="line"></div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure></p>
<p>key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。<br>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。<br>举个例子， 图 4-2 就展示了如何通过 next 指针， 将两个索引值相同的键 k1 和 k0 连接在一起。<br><a href="http://idiotsky.me/images/redis-dict-2.png"><img src="http://idiotsky.me/images/redis-dict-2.png" alt=""></a></p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 类型特定函数</span></div><div class="line">    dictType *type;</div><div class="line"></div><div class="line">    <span class="comment">// 私有数据</span></div><div class="line">    <span class="keyword">void</span> *privdata;</div><div class="line"></div><div class="line">    <span class="comment">// 哈希表</span></div><div class="line">    dictht ht[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="comment">// rehash 索引</span></div><div class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></div><div class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></div><div class="line"></div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<ul>
<li>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>
<li>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 计算哈希值的函数</span></div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 复制键的函数</span></div><div class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</div><div class="line"></div><div class="line">    <span class="comment">// 复制值的函数</span></div><div class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</div><div class="line"></div><div class="line">    <span class="comment">// 对比键的函数</span></div><div class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</div><div class="line"></div><div class="line">    <span class="comment">// 销毁键的函数</span></div><div class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</div><div class="line"></div><div class="line">    <span class="comment">// 销毁值的函数</span></div><div class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</div><div class="line"></div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure>
<p>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。</p>
<p>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</p>
<p>图 4-3 展示了一个普通状态下（没有进行 rehash）的字典：<br><a href="http://idiotsky.me/images/redis-dict-3.png"><img src="http://idiotsky.me/images/redis-dict-3.png" alt=""></a></p>
<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis 计算哈希值和索引值的方法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用字典设置的哈希函数，计算键 key 的哈希值</span></div><div class="line">hash = dict-&gt;type-&gt;hashFunction(key);</div><div class="line"></div><div class="line"><span class="comment">//使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></div><div class="line"><span class="comment">//根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span></div><div class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</div></pre></td></tr></table></figure></p>
<p><a href="http://idiotsky.me/images/redis-dict-4.png"><img src="http://idiotsky.me/images/redis-dict-4.png" alt=""></a><br>举个例子， 对于图 4-4 所示的字典来说， 如果我们要将一个键值对 k0 和 v0 添加到字典里面， 那么程序会先使用语句：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hash = dict-&gt;type-&gt;hashFunction(k0);</div></pre></td></tr></table></figure></p>
<p>计算键 k0 的哈希值。<br>假设计算得出的哈希值为 8 ， 那么程序会继续使用语句：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">index = hash &amp; dict-&gt;ht[<span class="number">0</span>].sizemask = <span class="number">8</span> &amp; <span class="number">3</span> = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>计算出键 k0 的索引值 0 ， 这表示包含键值对 k0 和 v0 的节点应该被放置到哈希表数组的索引 0 位置上， 如图 4-5 所示。<br><a href="http://idiotsky.me/images/redis-dict-5.png"><img src="http://idiotsky.me/images/redis-dict-5.png" alt=""></a><br>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</p>
<p>MurmurHash 算法最初由 Austin Appleby 于 2008 年发明， 这种算法的优点在于， 即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。</p>
<p>MurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <a href="http://code.google.com/p/smhasher/" target="_blank" rel="external">http://code.google.com/p/smhasher/</a> 。</p>
<h1 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h1><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p>举个例子， 假设程序要将键值对 k2 和 v2 添加到图 4-6 所示的哈希表里面， 并且计算得出 k2 的索引值为 2 ， 那么键 k1 和 k2 将产生冲突， 而解决冲突的办法就是使用 next 指针将键 k2 和 k1 所在的节点连接起来， 如图 4-7 所示。<br><a href="http://idiotsky.me/images/redis-dict-6.png"><img src="http://idiotsky.me/images/redis-dict-6.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-7.png"><img src="http://idiotsky.me/images/redis-dict-7.png" alt=""></a><br>因为 dictEntry 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面。</p>
<h1 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h1><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。<br>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li><p>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）：</p>
<ul>
<li>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；</li>
<li>如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</li>
</ul>
</li>
<li><p>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</p>
</li>
<li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<p>举个例子， 假设程序要对图 4-8 所示字典的 ht[0] 进行扩展操作， 那么程序将执行以下步骤：</p>
<ol>
<li>ht[0].used 当前的值为 4 ， 4 * 2 = 8 ， 而 8 （2^3）恰好是第一个大于等于 4 的 2 的 n 次方， 所以程序会将 ht[1] 哈希表的大小设置为 8 。 图 4-9 展示了 ht[1] 在分配空间之后， 字典的样子。</li>
<li>将 ht[0] 包含的四个键值对都 rehash 到 ht[1] ， 如图 4-10 所示。</li>
<li>释放 ht[0] ，并将 ht[1] 设置为 ht[0] ，然后为 ht[1] 分配一个空白哈希表，如图 4-11 所示。</li>
</ol>
<p>至此， 对哈希表的扩展操作执行完毕， 程序成功将哈希表的大小从原来的 4 改为了现在的 8 。<br><a href="http://idiotsky.me/images/redis-dict-8.png"><img src="http://idiotsky.me/images/redis-dict-8.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-9.png"><img src="http://idiotsky.me/images/redis-dict-9.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-10.png"><img src="http://idiotsky.me/images/redis-dict-10.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-11.png"><img src="http://idiotsky.me/images/redis-dict-11.png" alt=""></a></p>
<h1 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h1><p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<ol>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；</li>
</ol>
<p>其中哈希表的负载因子可以通过公式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span></div><div class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</div></pre></td></tr></table></figure></p>
<p>计算得出。</p>
<p>比如说， 对于一个大小为 4 ， 包含 4 个键值对的哈希表来说， 这个哈希表的负载因子为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">load_factor = <span class="number">4</span> / <span class="number">4</span> = <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>又比如说， 对于一个大小为 512 ， 包含 256 个键值对的哈希表来说， 这个哈希表的负载因子为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">load_factor = <span class="number">256</span> / <span class="number">512</span> = <span class="number">0.5</span></div></pre></td></tr></table></figure></p>
<p>根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE 命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制（<a href="http://en.wikipedia.org/wiki/Copy-on-write" target="_blank" rel="external">copy-on-write</a>）技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p>
<p>另一方面， 当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作。</p>
<h1 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h1><p>上一节说过， 扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。</p>
<p>这样做的原因在于， 如果 ht[0] 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1] ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。<br>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</li>
</ol>
<p>图 4-12 至图 4-17 展示了一次完整的渐进式 rehash 过程， 注意观察在整个 rehash 过程中， 字典的 rehashidx 属性是如何变化的。<br><a href="http://idiotsky.me/images/redis-dict-12.png"><img src="http://idiotsky.me/images/redis-dict-12.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-13.png"><img src="http://idiotsky.me/images/redis-dict-13.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-14.png"><img src="http://idiotsky.me/images/redis-dict-14.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-15.png"><img src="http://idiotsky.me/images/redis-dict-15.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-16.png"><img src="http://idiotsky.me/images/redis-dict-16.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-dict-17.png"><img src="http://idiotsky.me/images/redis-dict-17.png" alt=""></a></p>
<h1 id="渐进式-rehash-执行期间的哈希表操作"><a href="#渐进式-rehash-执行期间的哈希表操作" class="headerlink" title="渐进式 rehash 执行期间的哈希表操作"></a>渐进式 rehash 执行期间的哈希表操作</h1><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。</li>
<li>Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用。</li>
<li>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</li>
<li>哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。</li>
<li>在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。</li>
</ul>
<p>参考 <a href="http://redisbook.com" target="_blank" rel="external">http://redisbook.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Redis 的数据库就是使用字典来作为底层实现的, 字典还是哈希键的底层实现之一&lt;br&gt;Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h1&gt;&lt;p&gt;Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dictht&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 哈希表数组&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dictEntry **table;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 哈希表大小&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; size;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 哈希表大小掩码，用于计算索引值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 总是等于 size - 1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; sizemask;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 该哈希表已有节点的数量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; used;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; dictht;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。&lt;br&gt;size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。&lt;br&gt;sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。&lt;br&gt;图 4-1 展示了一个大小为 4 的空哈希表 （没有包含任何键值对）。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images/redis-dict-1.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images/redis-dict-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
      <category term="hashtable" scheme="http://idiotsky.me/tags/hashtable/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-链表</title>
    <link href="http://idiotsky.me/2017/09/14/redis-linkedlist/"/>
    <id>http://idiotsky.me/2017/09/14/redis-linkedlist/</id>
    <published>2017-09-14T15:59:31.000Z</published>
    <updated>2017-09-24T06:30:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>列表键的底层就是一个链表</p>
</blockquote>
<h1 id="链表节点"><a href="#链表节点" class="headerlink" title="链表节点"></a>链表节点</h1><p>每个链表节点使用一个 adlist.h/listNode 结构来表示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 前置节点</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 后置节点</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></div><div class="line"></div><div class="line">    <span class="comment">// 节点的值</span></div><div class="line">    <span class="keyword">void</span> *value;</div><div class="line"></div><div class="line">&#125; listNode;</div></pre></td></tr></table></figure></p>
<p>多个 listNode 可以通过 prev 和 next 指针组成双端链表， 如图 3-1 所示。<br><a href="http://idiotsky.me/images/redis-linkedlist-1.png"><img src="http://idiotsky.me/images/redis-linkedlist-1.png" alt=""></a><br><a id="more"></a></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>虽然仅仅使用多个 listNode 结构就可以组成链表， 但使用 adlist.h/list 来持有链表的话， 操作起来会更方便：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 表头节点</span></div><div class="line">    listNode *head;</div><div class="line"></div><div class="line">    <span class="comment">// 表尾节点</span></div><div class="line">    listNode *tail;</div><div class="line"></div><div class="line">    <span class="comment">// 链表所包含的节点数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</div><div class="line"></div><div class="line">    <span class="comment">// 节点值复制函数</span></div><div class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</div><div class="line"></div><div class="line">    <span class="comment">// 节点值释放函数</span></div><div class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</div><div class="line"></div><div class="line">    <span class="comment">// 节点值对比函数</span></div><div class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</div><div class="line"></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure></p>
<p>list 结构为链表提供了表头指针 head 、表尾指针 tail ， 以及链表长度计数器 len ， 而 dup 、 free 和 match 成员则是用于实现多态链表所需的类型特定函数：</p>
<ul>
<li>dup 函数用于复制链表节点所保存的值；</li>
<li>free 函数用于释放链表节点所保存的值；</li>
<li>match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li>
</ul>
<p>图 3-2 是由一个 list 结构和三个 listNode 结构组成的链表：<br><a href="http://idiotsky.me/images/redis-linkedlist-2.png"><img src="http://idiotsky.me/images/redis-linkedlist-2.png" alt=""></a></p>
<p>Redis 的链表实现的特性可以总结如下：</p>
<ul>
<li>双端： 链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。</li>
<li>无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点。</li>
<li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</li>
<li>带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。</li>
<li>多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。</li>
</ul>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。</li>
<li>每个链表节点由一个 listNode 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。</li>
<li>每个链表使用一个 list 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。</li>
<li>因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL ， 所以 Redis 的链表实现是无环链表。</li>
<li>通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。</li>
</ul>
<p>参考 <a href="http://redisbook.com" target="_blank" rel="external">http://redisbook.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;列表键的底层就是一个链表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;链表节点&quot;&gt;&lt;a href=&quot;#链表节点&quot; class=&quot;headerlink&quot; title=&quot;链表节点&quot;&gt;&lt;/a&gt;链表节点&lt;/h1&gt;&lt;p&gt;每个链表节点使用一个 adlist.h/listNode 结构来表示：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;listNode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 前置节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;listNode&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;prev&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 后置节点&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;listNode&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;next&lt;/span&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 节点的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; listNode;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;多个 listNode 可以通过 prev 和 next 指针组成双端链表， 如图 3-1 所示。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images/redis-linkedlist-1.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images/redis-linkedlist-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
      <category term="链表" scheme="http://idiotsky.me/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM杂谈之JIT</title>
    <link href="http://idiotsky.me/2017/09/14/java-jit/"/>
    <id>http://idiotsky.me/2017/09/14/java-jit/</id>
    <published>2017-09-14T14:41:24.000Z</published>
    <updated>2017-09-19T17:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Just-In-Time"><a href="#Just-In-Time" class="headerlink" title="Just In Time"></a>Just In Time</h1><p>Just in time编译，也叫做运行时编译，不同于 C / C++ 语言直接被翻译成机器指令，javac把java的源文件翻译成了class文件，而class文件中全都是Java字节码。那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。</p>
<p>还有一种，就是把这些Java字节码重新编译优化，生成机器码，让CPU直接执行。这样编出来的代码效率会更高。通常，我们不必把所有的Java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。这种调用最频繁的Java方法就是我们常说的热点方法（Hotspot，说不定这个虚拟机的名字就是从这里来的）。</p>
<p>这种在运行时按需编译的方式就是Just In Time。<br><a id="more"></a></p>
<h1 id="主要技术点"><a href="#主要技术点" class="headerlink" title="主要技术点"></a>主要技术点</h1><p>其实JIT的主要技术点，从大的框架上来说，非常简单，就是申请一块既有写权限又有执行权限的内存，然后把你要编译的Java方法，翻译成机器码，写入到这块内存里。当再需要调用原来的Java方法时，就转向调用这块内存。</p>
<p>我们看一个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, inc(<span class="number">3</span>));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个例子很简单，就是把3加1，然后打印出来，我们通过以下命令，查看一下它的机器码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># gcc -o inc inc.c</div><div class="line"># objdump -d inc</div></pre></td></tr></table></figure></p>
<p>然后在这一堆输出中，可以找到 inc 方法最终被翻译成了这样的机器码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">40052d:	55                   	push   %rbp</div><div class="line">40052e:	48 89 e5             	mov    %rsp,%rbp</div><div class="line">400531:	89 7d fc             	mov    %edi,-0x4(%rbp)</div><div class="line">400534:	8b 45 fc             	mov    -0x4(%rbp),%eax</div><div class="line">400537:	83 c0 01             	add    $0x1,%eax</div><div class="line">40053a:	5d                   	pop    %rbp</div><div class="line">40053b:	c3                   	retq</div></pre></td></tr></table></figure></p>
<p>我来解释一下（读者需要一定的x86汇编语言的知识）。</p>
<p>第一句，保存上一个栈帧的基址，并把当前的栈指针赋给栈基址寄存器，这是进入一个函数的常规操作。我们不去管它。</p>
<p>第三句，把edi存到栈上。在x64处理器上，前6个参数都是使用寄存器传参的。第一个参数会使用rdi，第二个参数使用 rsi，等等。所以 edi 里存的其实就是第一个参数，也就是整数 3，为什么使用rdi的低32位，也就是 edi 呢？因为我们的入参 a 是 int 型啊。大家可以换成 long 型看看效果。</p>
<p>第四句，把上一步存到栈上的那个整数再存进 eax 中。</p>
<p>第五句往后，把 eax 加上 1， 然后就退栈，返回。按照x64的规定（ABI），返回值通过eax传递。</p>
<p>我们看到了，其实第三句，第四句好像根本没有存在的必要，gcc 默认情况下，生成的机器码有点傻，它总要把入参放到栈上，但其实，我们是可以直接把参数从 rdi 中放入到 rax 中的。不满意。那我们可以自己改一下，让它更精简一点。怎么做呢？答案就是运行时修改 inc 的逻辑。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* inc_func)</span><span class="params">(<span class="keyword">int</span> a)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> code[] = &#123; </div><div class="line">        <span class="number">0x55</span>,             <span class="comment">// push rbp</span></div><div class="line">        <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe5</span>, <span class="comment">// mov rsp, rbp</span></div><div class="line">        <span class="number">0x89</span>, <span class="number">0xf8</span>,       <span class="comment">// mov edi, eax</span></div><div class="line">        <span class="number">0x83</span>, <span class="number">0xc0</span>, <span class="number">0x01</span>, <span class="comment">// add $1, eax</span></div><div class="line">        <span class="number">0x5d</span>,             <span class="comment">// pop rbp</span></div><div class="line">        <span class="number">0xc3</span>              <span class="comment">// ret</span></div><div class="line">    &#125;;  </div><div class="line"></div><div class="line">    <span class="keyword">void</span> * temp = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(code), PROT_WRITE | PROT_EXEC,</div><div class="line">            MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>); </div><div class="line"></div><div class="line">    <span class="built_in">memcpy</span>(temp, code, <span class="keyword">sizeof</span>(code));</div><div class="line">    inc_func p_inc = (inc_func)temp;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p_inc(<span class="number">7</span>));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，我们使用了 mmap 来申请了一块有写权限和执行权限的内存，然后把我们手写的机器码拷进去，然后使用一个函数指针指向这块内存，并且调用它。通过这种方式我们就可以执行这一段手写的机器码了。</p>
<p>运行一下看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># gcc -o inc_a inc_a.c </div><div class="line"># ./inc_a</div><div class="line">8</div></pre></td></tr></table></figure></p>
<p>再回想一下这个过程。我们通过手写机器码把原来的 inc 函数代替掉了。在新的例子中，我们是使用程序中定义的数据来重新造了一个 inc 函数。这种在运行的过程创建新的函数的方式，就是JIT的核心操作。</p>
<h1 id="解释器，C1和C2"><a href="#解释器，C1和C2" class="headerlink" title="解释器，C1和C2"></a>解释器，C1和C2</h1><p>在Hotspot中，解释器是为每一个字节码生成一小段机器码，在执行Java方法的过程中，每次取一条指令，然后就去执行这一个指令所对应的那一段机器码。256条指令，就组成了一个表，在这个表里，每一条指令都对应一段机器码，当执行到某一条指令时，就从这个表里去查这段机器码，并且通过 jmp 指令去执行这段机器码就行了。</p>
<p>这种方式被称为模板解释器。</p>
<p>模板解释器生成的代码有很多冗余，就像我们上面的第一个例子那样。为了生成更精简的机器码，我们可以引入编译器优化手段，例如全局值编码，死代码消除，标量展开，公共子表达式消除，常量传播等等。这样生成出来的机器码会更加优化。</p>
<p>但是，生成机器码的质量越高，所需要的时间也就越长。JIT线程也是要挤占Java 应用线程的资源的。所以C1是一个折衷，编译时间既不会太长，生成的机器码的指令也不是最优化的，但肯定比解释器的效率要高很多。</p>
<p>如果一个Java方法调用得足够频繁，那就更值得花大力气去为它生成更优质的机器码，这时就会触发C2编译，c2是一个运行得更慢，但却能生成更高效代码的编译器。</p>
<p>由此，我们看到，其实Java的运行，几乎全部都依赖运行时生成的机器码上。所以，对于文章开头的那个问题“Java是运行在C++上的吗？”，大家应该都有自己的答案了。这个问题无法简单地回答是或者不是，正确答案就是Java的运行依赖模板解释器和JIT编译器。</p>
<h1 id="多说一点优化"><a href="#多说一点优化" class="headerlink" title="多说一点优化"></a>多说一点优化</h1><p>我们这节课所举的例子中，可以做更多的优化，例如，既然我进到inc函数以后，完全没有使用栈，那其实，我就不要再为它开辟栈帧了。所以可以把push rbp, pop rbp的逻辑都去掉。</p>
<p>进一步优化成这样：<br>inc_b.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> code[] = &#123; </div><div class="line">    <span class="number">0x89</span>, <span class="number">0xf8</span>,       <span class="comment">// mov edi, eax</span></div><div class="line">    <span class="number">0x83</span>, <span class="number">0xc0</span>, <span class="number">0x01</span>, <span class="comment">// add $1, eax</span></div><div class="line">    <span class="number">0xc3</span>              <span class="comment">// ret</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以看到，指令更加精简了。我们重新编译运行，还是能成功打印出8。</p>
<p>根据这个问题：<a href="https://www.zhihu.com/question/61724266" target="_blank" rel="external">为什么 lea 会被用来计算？</a></p>
<p>我们还可以写出更优化的代码来：<br>inc_c.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> code[] = &#123; </div><div class="line">    <span class="number">0x8d</span>, <span class="number">0x47</span>, <span class="number">0x01</span>,    <span class="comment">// lea 0x1(rdi), rax</span></div><div class="line">    <span class="number">0xc3</span>                 <span class="comment">// ret</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果开启 gcc 的优化编译，我们也可以得到这样的代码，例如，还是针对这个方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 -O2 优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># gcc -o inc inc.c -O2</div><div class="line"># objdump -d inc</div></pre></td></tr></table></figure></p>
<p>就可以看到，inc 的机器码变成这样了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">00000000004005f0 &lt;inc&gt;:</div><div class="line">  4005f0:	8d 47 01             	lea    0x1(%rdi),%eax</div><div class="line">  4005f3:	c3                   	retq</div></pre></td></tr></table></figure></p>
<p>这和我们手写的优化的机器码是完全一样的了。</p>
<p>实际上，C1和C2所要做的和gcc的优化编译是一样的，就是使用特定的方法生成更高效的机器码。但是从原理上来说，运行时生成机器码这个技术，大家都是相通的。</p>
<p>代码<a href="https://github.com/ejunjsh/c-code/tree/master/inc" target="_blank" rel="external">https://github.com/ejunjsh/c-code/tree/master/inc</a><br>参考<a href="https://zhuanlan.zhihu.com/p/28476709" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/28476709</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Just-In-Time&quot;&gt;&lt;a href=&quot;#Just-In-Time&quot; class=&quot;headerlink&quot; title=&quot;Just In Time&quot;&gt;&lt;/a&gt;Just In Time&lt;/h1&gt;&lt;p&gt;Just in time编译，也叫做运行时编译，不同于 C / C++ 语言直接被翻译成机器指令，javac把java的源文件翻译成了class文件，而class文件中全都是Java字节码。那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。&lt;/p&gt;
&lt;p&gt;还有一种，就是把这些Java字节码重新编译优化，生成机器码，让CPU直接执行。这样编出来的代码效率会更高。通常，我们不必把所有的Java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。这种调用最频繁的Java方法就是我们常说的热点方法（Hotspot，说不定这个虚拟机的名字就是从这里来的）。&lt;/p&gt;
&lt;p&gt;这种在运行时按需编译的方式就是Just In Time。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="jvm" scheme="http://idiotsky.me/tags/jvm/"/>
    
      <category term="jit" scheme="http://idiotsky.me/tags/jit/"/>
    
  </entry>
  
  <entry>
    <title>kafka学习（一）</title>
    <link href="http://idiotsky.me/2017/09/13/kafka-design/"/>
    <id>http://idiotsky.me/2017/09/13/kafka-design/</id>
    <published>2017-09-13T13:38:51.000Z</published>
    <updated>2017-09-14T13:22:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>to be continue</p>
</blockquote>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;to be continue&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="kafka" scheme="http://idiotsky.me/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构-简单动态字符串</title>
    <link href="http://idiotsky.me/2017/09/13/redis-string/"/>
    <id>http://idiotsky.me/2017/09/13/redis-string/</id>
    <published>2017-09-13T04:07:30.000Z</published>
    <updated>2017-10-02T13:29:25.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。例如键（key）底层就是SDS，而值如果是字符串对象，那这个对象的底层也是个SDS</p>
</blockquote>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>每个 sds.h/sdshdr 结构表示一个 SDS 值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></div><div class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></div><div class="line">    <span class="keyword">int</span> len;</div><div class="line"></div><div class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></div><div class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 字节数组，用于保存字符串</span></div><div class="line">    <span class="keyword">char</span> buf[];</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>图 2-1 展示了一个 SDS 示例：</p>
<ul>
<li>free 属性的值为 0 ， 表示这个 SDS 没有分配任何未使用空间。</li>
<li>len 属性的值为 5 ， 表示这个 SDS 保存了一个五字节长的字符串。</li>
<li>buf 属性是一个 char 类型的数组， 数组的前五个字节分别保存了 ‘R’ 、 ‘e’ 、 ‘d’ 、 ‘i’ 、 ‘s’ 五个字符， 而最后一个字节则保存了空字符 ‘\0’ 。<br><a href="http://idiotsky.me/images/redis-string-1.png"><img src="http://idiotsky.me/images/redis-string-1.png" alt=""></a><br>SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。</li>
</ul>
<p>遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数。</p>
<p>举个例子， 如果我们有一个指向图 2-1 所示 SDS 的指针 s ， 那么我们可以直接使用 stdio.h/printf 函数， 通过执行以下语句：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, s-&gt;buf);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>来打印出 SDS 保存的字符串值 “Redis” ， 而无须为 SDS 编写专门的打印函数。</p>
<p>图 2-2 展示了另一个 SDS 示例:</p>
<ul>
<li>这个 SDS 和之前展示的 SDS 一样， 都保存了字符串值 “Redis” 。</li>
<li>这个 SDS 和之前展示的 SDS 的区别在于， 这个 SDS 为 buf 数组分配了五字节未使用空间， 所以它的 free 属性的值为 5 （图中使用五个空格来表示五字节的未使用空间）。<br><a href="http://idiotsky.me/images/redis-string-2.png"><img src="http://idiotsky.me/images/redis-string-2.png" alt=""></a></li>
</ul>
<h1 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h1><p>根据传统， C 语言使用长度为 N+1 的字符数组来表示长度为 N 的字符串， 并且字符数组的最后一个元素总是空字符 ‘\0’ 。</p>
<p>比如说， 图 2-3 就展示了一个值为 “Redis” 的 C 字符串：<br><a href="http://idiotsky.me/images/redis-string-3.png"><img src="http://idiotsky.me/images/redis-string-3.png" alt=""></a><br>C 语言使用的这种简单的字符串表示方式， 并不能满足 Redis 对字符串在安全性、效率、以及功能方面的要求， 本节接下来的内容将详细对比 C 字符串和 SDS 之间的区别， 并说明 SDS 比 C 字符串更适用于 Redis 的原因。</p>
<h2 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h2><p>因为 C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N) 。</p>
<p>举个例子， 图 2-4 展示了程序计算一个 C 字符串长度的过程。<br><a href="http://idiotsky.me/images/redis-string-4.png"><img src="http://idiotsky.me/images/redis-string-4.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-string-5.png"><img src="http://idiotsky.me/images/redis-string-5.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-string-6.png"><img src="http://idiotsky.me/images/redis-string-6.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-string-7.png"><img src="http://idiotsky.me/images/redis-string-7.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-string-8.png"><img src="http://idiotsky.me/images/redis-string-8.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-string-9.png"><img src="http://idiotsky.me/images/redis-string-9.png" alt=""></a><br>和 C 字符串不同， 因为 SDS 在 len 属性中记录了 SDS 本身的长度， 所以获取一个 SDS 长度的复杂度仅为 O(1) 。</p>
<p>举个例子， 对于图 2-5 所示的 SDS 来说， 程序只要访问 SDS 的 len 属性， 就可以立即知道 SDS 的长度为 5 字节：<br><a href="http://idiotsky.me/images/redis-string-10.png"><img src="http://idiotsky.me/images/redis-string-10.png" alt=""></a><br>又比如说， 对于图 2-6 展示的 SDS 来说， 程序只要访问 SDS 的 len 属性， 就可以立即知道 SDS 的长度为 11 字节。<br><a href="http://idiotsky.me/images/redis-string-11.png"><img src="http://idiotsky.me/images/redis-string-11.png" alt=""></a><br>设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的， 使用 SDS 无须进行任何手动修改长度的工作。</p>
<p>通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1) ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。</p>
<p>比如说， 因为字符串键在底层使用 SDS 来实现， 所以即使我们对一个非常长的字符串键反复执行 STRLEN 命令， 也不会对系统性能造成任何影响， 因为 STRLEN 命令的复杂度仅为 O(1) 。</p>
<h2 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h2><p>除了获取字符串长度的复杂度高之外， C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。</p>
<p>举个例子， <code>&lt;string.h&gt;/strcat</code> 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</div></pre></td></tr></table></figure></p>
<p>因为 C 字符串不记录自身的长度， 所以 strcat 假定用户在执行这个函数时， 已经为 dest 分配了足够多的内存， 可以容纳 src 字符串中的所有内容， 而一旦这个假定不成立时， 就会产生缓冲区溢出。</p>
<p>举个例子， 假设程序里有两个在内存中紧邻着的 C 字符串 s1 和 s2 ， 其中 s1 保存了字符串 “Redis” ， 而 s2 则保存了字符串 “MongoDB” ， 如图 2-7 所示。<br><a href="http://idiotsky.me/images/redis-string-12.png"><img src="http://idiotsky.me/images/redis-string-12.png" alt=""></a><br>如果一个程序员决定通过执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">strcat</span>(s1, <span class="string">" Cluster"</span>);</div></pre></td></tr></table></figure></p>
<p>将 s1 的内容修改为 “Redis Cluster” ， 但粗心的他却忘了在执行 strcat 之前为 s1 分配足够的空间， 那么在 strcat 函数执行之后， s1 的数据将溢出到 s2 所在的空间中， 导致 s2 保存的内容被意外地修改， 如图 2-8 所示。<br><a href="http://idiotsky.me/images/redis-string-13.png"><img src="http://idiotsky.me/images/redis-string-13.png" alt=""></a><br>与 C 字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。</p>
<p>举个例子， SDS 的 API 里面也有一个用于执行拼接操作的 sdscat 函数， 它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面， 但是在执行拼接操作之前， sdscat 会先检查给定 SDS 的空间是否足够， 如果不够的话， sdscat 就会先扩展 SDS 的空间， 然后才执行拼接操作。</p>
<p>比如说， 如果我们执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sdscat(s, <span class="string">" Cluster"</span>);</div></pre></td></tr></table></figure></p>
<p>其中 SDS 值 s 如图 2-9 所示， 那么 sdscat 将在执行拼接操作之前检查 s 的长度是否足够， 在发现 s 目前的空间不足以拼接 “ Cluster” 之后， sdscat 就会先扩展 s 的空间， 然后才执行拼接 “ Cluster” 的操作， 拼接操作完成之后的 SDS 如图 2-10 所示。<br><a href="http://idiotsky.me/images/redis-string-14.png"><img src="http://idiotsky.me/images/redis-string-14.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-string-15.png"><img src="http://idiotsky.me/images/redis-string-15.png" alt=""></a><br>注意图 2-10 所示的 SDS ： sdscat 不仅对这个 SDS 进行了拼接操作， 它还为 SDS 分配了 13 字节的未使用空间， 并且拼接之后的字符串也正好是 13 字节长， 这种现象既不是 bug 也不是巧合， 它和 SDS 的空间分配策略有关， 接下来的小节将对这一策略进行说明</p>
<h2 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h2><p>正如前两个小节所说， 因为 C 字符串并不记录自身的长度， 所以对于一个包含了 N 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 N+1 个字符长的数组（额外的一个字符空间用于保存空字符）。</p>
<p>因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：</p>
<ul>
<li>如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。</li>
<li>如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。</li>
</ul>
<p>举个例子， 如果我们持有一个值为 “Redis” 的 C 字符串 s ， 那么为了将 s 的值改为 “Redis Cluster” ， 在执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">strcat</span>(s, <span class="string">" Cluster"</span>);</div></pre></td></tr></table></figure></p>
<p>之前， 我们需要先使用内存重分配操作， 扩展 s 的空间。</p>
<p>之后， 如果我们又打算将 s 的值从 “Redis Cluster” 改为 “Redis Cluster Tutorial” ， 那么在执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">strcat</span>(s, <span class="string">" Tutorial"</span>);</div></pre></td></tr></table></figure></p>
<p>之前， 我们需要再次使用内存重分配扩展 s 的空间， 诸如此类。</p>
<p>因为内存重分配涉及复杂的算法， 并且可能需要执行系统调用， 所以它通常是一个比较耗时的操作：</p>
<ul>
<li>在一般程序中， 如果修改字符串长度的情况不太常出现， 那么每次修改都执行一次内存重分配是可以接受的。</li>
<li>但是 Redis 作为数据库， 经常被用于速度要求严苛、数据被频繁修改的场合， 如果每次修改字符串的长度都需要执行一次内存重分配的话， 那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分， 如果这种修改频繁地发生的话， 可能还会对性能造成影响。</li>
</ul>
<p>为了避免 C 字符串的这种缺陷， SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联： 在 SDS 中， buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节， 而这些字节的数量就由 SDS 的 free 属性记录。</p>
<p>通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。</p>
<h3 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h3><p>空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。</p>
<p>其中， 额外分配的未使用空间数量由以下公式决定：</p>
<ul>
<li>如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 len 将变成 13 字节， 那么程序也会分配 13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 13 + 13 + 1 = 27 字节（额外的一字节用于保存空字符）。</li>
<li>如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 len 将变成 30 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1 MB + 1 byte 。</li>
</ul>
<p>通过空间预分配策略， Redis 可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
<p>举个例子， 对于图 2-11 所示的 SDS 值 s 来说， 如果我们执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sdscat(s, <span class="string">" Cluster"</span>);</div></pre></td></tr></table></figure></p>
<p>那么 sdscat 将执行一次内存重分配操作， 将 SDS 的长度修改为 13 字节， 并将 SDS 的未使用空间同样修改为 13 字节， 如图 2-12 所示。<br><a href="http://idiotsky.me/images/redis-string-16.png"><img src="http://idiotsky.me/images/redis-string-16.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-string-17.png"><img src="http://idiotsky.me/images/redis-string-17.png" alt=""></a><br>如果这时， 我们再次对 s 执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sdscat(s, <span class="string">" Tutorial"</span>);</div></pre></td></tr></table></figure></p>
<p>那么这次 sdscat 将不需要执行内存重分配： 因为未使用空间里面的 13 字节足以保存 9 字节的 “ Tutorial” ， 执行 sdscat 之后的 SDS 如图 2-13 所示。<br><a href="http://idiotsky.me/images/redis-string-18.png"><img src="http://idiotsky.me/images/redis-string-18.png" alt=""></a><br>在扩展 SDS 空间之前， SDS API 会先检查未使用空间是否足够， 如果足够的话， API 就会直接使用未使用空间， 而无须执行内存重分配。</p>
<p>通过这种预分配策略， SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次。</p>
<h3 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h3><p>惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用。</p>
<p>举个例子， sdstrim 函数接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。</p>
<p>比如对于图 2-14 所示的 SDS 值 s 来说， 执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sdstrim(s, <span class="string">"XY"</span>);   <span class="comment">// 移除 SDS 字符串中的所有 'X' 和 'Y'</span></div></pre></td></tr></table></figure></p>
<p>会将 SDS 修改成图 2-15 所示的样子。<br><a href="http://idiotsky.me/images/redis-string-19.png"><img src="http://idiotsky.me/images/redis-string-19.png" alt=""></a><br><a href="http://idiotsky.me/images/redis-string-20.png"><img src="http://idiotsky.me/images/redis-string-20.png" alt=""></a><br>注意执行 sdstrim 之后的 SDS 并没有释放多出来的 8 字节空间， 而是将这 8 字节空间作为未使用空间保留在了 SDS 里面， 如果将来要对 SDS 进行增长操作的话， 这些未使用空间就可能会派上用场。</p>
<p>举个例子， 如果现在对 s 执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sdscat(s, <span class="string">" Redis"</span>);</div></pre></td></tr></table></figure></p>
<p>那么完成这次 sdscat 操作将不需要执行内存重分配： 因为 SDS 里面预留的 8 字节空间已经足以拼接 6 个字节长的 “ Redis” ， 如图 2-16 所示。<br><a href="http://idiotsky.me/images/redis-string-21.png"><img src="http://idiotsky.me/images/redis-string-21.png" alt=""></a><br>通过惰性空间释放策略， SDS 避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了优化。</p>
<p>与此同时， SDS 也提供了相应的 API ， 让我们可以在有需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费。</p>
<h1 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h1><p>C 字符串中的字符必须符合某种编码（比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。</p>
<p>举个例子， 如果有一种使用空字符来分割多个单词的特殊数据格式， 如图 2-17 所示， 那么这种格式就不能使用 C 字符串来保存， 因为 C 字符串所用的函数只会识别出其中的 “Redis” ， 而忽略之后的 “Cluster” 。<br><a href="http://idiotsky.me/images/redis-string-22.png"><img src="http://idiotsky.me/images/redis-string-22.png" alt=""></a><br>虽然数据库一般用于保存文本数据， 但使用数据库来保存二进制数据的场景也不少见， 因此， 为了确保 Redis 可以适用于各种不同的使用场景， SDS 的 API 都是二进制安全的（binary-safe）： 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。</p>
<p>这也是我们将 SDS 的 buf 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据。</p>
<p>比如说， 使用 SDS 来保存之前提到的特殊数据格式就没有任何问题， 因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束， 如图 2-18 所示。<br><a href="http://idiotsky.me/images/redis-string-23.png"><img src="http://idiotsky.me/images/redis-string-23.png" alt=""></a><br>通过使用二进制安全的 SDS ， 而不是 C 字符串， 使得 Redis 不仅可以保存文本数据， 还可以保存任意格式的二进制数据。</p>
<h1 id="兼容部分-C-字符串函数"><a href="#兼容部分-C-字符串函数" class="headerlink" title="兼容部分 C 字符串函数"></a>兼容部分 C 字符串函数</h1><p>虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 <code>&lt;string.h&gt;</code> 库定义的函数。<br><a href="http://idiotsky.me/images/redis-string-24.png"><img src="http://idiotsky.me/images/redis-string-24.png" alt=""></a><br>举个例子， 如图 2-19 所示， 如果我们有一个保存文本数据的 SDS 值 sds ， 那么我们就可以重用 <code>&lt;string.h&gt;/strcasecmp</code> 函数， 使用它来对比 SDS 保存的字符串和另一个 C 字符串：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strcasecmp(sds-&gt;buf, <span class="string">"hello world"</span>);</div></pre></td></tr></table></figure></p>
<p>这样 Redis 就不用自己专门去写一个函数来对比 SDS 值和 C 字符串值了。</p>
<p>与此类似， 我们还可以将一个保存文本数据的 SDS 作为 strcat 函数的第二个参数， 将 SDS 保存的字符串追加到一个 C 字符串的后面：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">strcat</span>(c_string, sds-&gt;buf);</div></pre></td></tr></table></figure></p>
<p>这样 Redis 就不用专门编写一个将 SDS 字符串追加到 C 字符串之后的函数了。</p>
<p>通过遵循 C 字符串以空字符结尾的惯例， SDS 可以在有需要时重用 <code>&lt;string.h&gt;</code> 函数库， 从而避免了不必要的代码重复。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th>C 字符串</th>
<th>SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取字符串长度的复杂度为 O(N) 。</td>
<td>获取字符串长度的复杂度为 O(1) 。</td>
</tr>
<tr>
<td>API 是不安全的，可能会造成缓冲区溢出。</td>
<td>API 是安全的，不会造成缓冲区溢出。</td>
</tr>
<tr>
<td>修改字符串长度 N 次必然需要执行 N 次内存重分配。</td>
<td>修改字符串长度 N 次最多需要执行 N 次内存重分配。</td>
</tr>
<tr>
<td>只能保存文本数据。</td>
<td>可以保存文本或者二进制数据。</td>
</tr>
<tr>
<td>可以使用所有 <code>&lt;string.h&gt;</code>库中的函数。</td>
<td>可以使用一部分 <code>&lt;string.h&gt;</code>库中的函数。</td>
</tr>
</tbody>
</table>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>Redis 只会使用 C 字符串作为字面量， 在大多数情况下， Redis 使用 SDS （Simple Dynamic String，简单动态字符串）作为字符串表示。</li>
<li>比起 C 字符串， SDS 具有以下优点：<ol>
<li>常数复杂度获取字符串长度。</li>
<li>杜绝缓冲区溢出。</li>
<li>减少修改字符串长度时所需的内存重分配次数。</li>
<li>二进制安全。</li>
<li>兼容部分 C 字符串函数。</li>
</ol>
</li>
</ul>
<p>参考 <a href="http://redisbook.com" target="_blank" rel="external">http://redisbook.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。例如键（key）底层就是SDS，而值如果是字符串对象，那这个对象的底层也是个SDS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;每个 sds.h/sdshdr 结构表示一个 SDS 值：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sdshdr&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 记录 buf 数组中已使用字节的数量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 等于 SDS 所保存字符串的长度&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 记录 buf 数组中未使用字节的数量&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 字节数组，用于保存字符串&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; buf[];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;图 2-1 展示了一个 SDS 示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;free 属性的值为 0 ， 表示这个 SDS 没有分配任何未使用空间。&lt;/li&gt;
&lt;li&gt;len 属性的值为 5 ， 表示这个 SDS 保存了一个五字节长的字符串。&lt;/li&gt;
&lt;li&gt;buf 属性是一个 char 类型的数组， 数组的前五个字节分别保存了 ‘R’ 、 ‘e’ 、 ‘d’ 、 ‘i’ 、 ‘s’ 五个字符， 而最后一个字节则保存了空字符 ‘\0’ 。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images/redis-string-1.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images/redis-string-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;SDS 遵循 C 字符串以空字符结尾的惯例， 保存空字符的 1 字节空间不计算在 SDS 的 len 属性里面， 并且为空字符分配额外的 1 字节空间， 以及添加空字符到字符串末尾等操作都是由 SDS 函数自动完成的， 所以这个空字符对于 SDS 的使用者来说是完全透明的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数。&lt;/p&gt;
&lt;p&gt;举个例子， 如果我们有一个指向图 2-1 所示 SDS 的指针 s ， 那么我们可以直接使用 stdio.h/printf 函数， 通过执行以下语句：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s&quot;&lt;/span&gt;, s-&amp;gt;buf);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="数据结构" scheme="http://idiotsky.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
      <category term="字符串" scheme="http://idiotsky.me/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>linux epoll原理</title>
    <link href="http://idiotsky.me/2017/09/11/epoll-mechanism/"/>
    <id>http://idiotsky.me/2017/09/11/epoll-mechanism/</id>
    <published>2017-09-10T17:35:15.000Z</published>
    <updated>2017-09-19T17:05:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>epoll是Linux下的一种IO多路复用技术，可以非常高效的处理数以百万计的socket句柄。 </p>
</blockquote>
<p>先看看使用c封装的3个epoll系统调用：</p>
<ul>
<li><strong>int epoll_create(int size)</strong><br>  epoll_create建立一个epoll对象。参数size是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。</li>
<li><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</strong><br>  epoll_ctl可以操作epoll_create创建的epoll，如将socket句柄加入到epoll中让其监控，或把epoll正在监控的某个socket句柄移出epoll。</li>
<li><strong>int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout)</strong><br>  epoll_wait在调用时，在给定的timeout时间内，所监控的句柄中有事件发生时，就返回用户态的进程。</li>
</ul>
<a id="more"></a>
<p>大概看看epoll内部是怎么实现的：</p>
<ol>
<li>epoll初始化时，会向内核注册一个文件系统，用于存储被监控的句柄文件，调用epoll_create时，会在这个文件系统中创建一个file节点。同时epoll会开辟自己的内核高速缓存区，以红黑树的结构保存句柄，以支持快速的查找、插入、删除。还会再建立一个list链表，用于存储准备就绪的事件。</li>
<li>当执行epoll_ctl时，除了把socket句柄放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后，就把socket插入到就绪链表里。</li>
<li>当epoll_wait调用时，仅仅观察就绪链表里有没有数据，如果有数据就返回，否则就sleep，超时时立刻返回。</li>
</ol>
<p>epoll的两种工作模式：</p>
<ul>
<li><strong>LT</strong>：level-trigger，水平触发模式，只要某个socket处于readable/writable状态，无论什么时候进行epoll_wait都会返回该socket。</li>
<li><strong>ET</strong>：edge-trigger，边缘触发模式，只有某个socket从unreadable变为readable或从unwritable变为writable时，epoll_wait才会返回该socket。</li>
</ul>
<p>socket读数据<br><a href="http://idiotsky.me/images/epoll-mechanism-1.png"><img src="http://idiotsky.me/images/epoll-mechanism-1.png" alt=""></a></p>
<p>socket写数据<br><a href="http://idiotsky.me/images/epoll-mechanism-2.png"><img src="http://idiotsky.me/images/epoll-mechanism-2.png" alt=""></a></p>
<p>参考 <a href="http://www.jianshu.com/p/0d497fe5484a" target="_blank" rel="external">http://www.jianshu.com/p/0d497fe5484a</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;epoll是Linux下的一种IO多路复用技术，可以非常高效的处理数以百万计的socket句柄。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看看使用c封装的3个epoll系统调用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;int epoll_create(int size)&lt;/strong&gt;&lt;br&gt;  epoll_create建立一个epoll对象。参数size是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)&lt;/strong&gt;&lt;br&gt;  epoll_ctl可以操作epoll_create创建的epoll，如将socket句柄加入到epoll中让其监控，或把epoll正在监控的某个socket句柄移出epoll。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout)&lt;/strong&gt;&lt;br&gt;  epoll_wait在调用时，在给定的timeout时间内，所监控的句柄中有事件发生时，就返回用户态的进程。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux" scheme="http://idiotsky.me/categories/linux/"/>
    
    
      <category term="linux" scheme="http://idiotsky.me/tags/linux/"/>
    
      <category term="nio" scheme="http://idiotsky.me/tags/nio/"/>
    
      <category term="epoll" scheme="http://idiotsky.me/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>openstack安装-keystone</title>
    <link href="http://idiotsky.me/2017/09/09/openstack-install-keystone/"/>
    <id>http://idiotsky.me/2017/09/09/openstack-install-keystone/</id>
    <published>2017-09-09T07:46:36.000Z</published>
    <updated>2017-09-14T12:59:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>keystone 是openstack中所有service的权限管理和接口入口，所以先安装它<br>这一章都是在<code>controller</code>节点操作。。。</p>
</blockquote>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><ol>
<li><p>切换到<code>root</code>用户，执行下面命令</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysql</div></pre></td></tr></table></figure>
</li>
<li><p>创建<code>keystone</code>数据库:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MariaDB [(none)]&gt; CREATE DATABASE keystone;</div></pre></td></tr></table></figure>
</li>
<li><p>赋予合适权限给<code>keystone</code>数据库：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON keystone.* TO <span class="string">'keystone'</span>@<span class="string">'localhost'</span> \</div><div class="line">IDENTIFIED BY <span class="string">'KEYSTONE_DBPASS'</span>;</div><div class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON keystone.* TO <span class="string">'keystone'</span>@<span class="string">'%'</span> \</div><div class="line">IDENTIFIED BY <span class="string">'KEYSTONE_DBPASS'</span>;</div></pre></td></tr></table></figure>
<p> <strong>用一个合适的密码覆盖<code>KEYSTONE_DBPASS</code></strong></p>
</li>
<li>退出数据库</li>
</ol>
<a id="more"></a>
<h1 id="安装和配置组件"><a href="#安装和配置组件" class="headerlink" title="安装和配置组件"></a>安装和配置组件</h1><ol>
<li><p>运行下面命令安装包：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt install keystone  apache2 libapache2-mod-wsgi</div></pre></td></tr></table></figure>
</li>
<li><p>编辑<code>/etc/keystone/keystone.conf</code></p>
<ul>
<li><p>在<code>[database]</code> 区域，配置数据库访问连接：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[database]</div><div class="line"># ...</div><div class="line">connection = mysql+pymysql://keystone:KEYSTONE_DBPASS@controller/keystone</div></pre></td></tr></table></figure>
<p>  <strong>替换掉<code>KEYSTONE_DBPASS</code>,密码是上面配置的数据库密码</strong><br>  <strong>去掉这个区域里面其他关于<code>connection</code>的属性</strong></p>
</li>
<li>在<code>[token]</code> 区域，配置Fernet：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[token]</div><div class="line"># ...</div><div class="line">provider = fernet</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>部署身份服务（Identity service）数据库：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ su -s /bin/sh -c <span class="string">"keystone-manage db_sync"</span> keystone</div></pre></td></tr></table></figure>
</li>
<li><p>初始化Fernet</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ keystone-manage fernet_setup --keystone-user keystone --keystone-group keystone</div><div class="line">$ keystone-manage credential_setup --keystone-user keystone --keystone-group keystone</div></pre></td></tr></table></figure>
</li>
<li><p>启动身份服务（Identity service）</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ keystone-manage bootstrap --bootstrap-password ADMIN_PASS \</div><div class="line">--bootstrap-admin-url http://controller:35357/v3/ \</div><div class="line">--bootstrap-internal-url http://controller:5000/v3/ \</div><div class="line">--bootstrap-public-url http://controller:5000/v3/ \</div><div class="line">--bootstrap-region-id RegionOne</div></pre></td></tr></table></figure>
<p> <strong>替换<code>ADMIN_PASS</code></strong></p>
</li>
</ol>
<h1 id="配置Apache"><a href="#配置Apache" class="headerlink" title="配置Apache"></a>配置Apache</h1><p>因为这个服务是跑在Apache里面的，所以需要配置之。</p>
<ol>
<li><p>修改<code>/etc/apache2/apache2.conf</code>文件，配置<code>ServerName</code>选项：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ServerName controller</div></pre></td></tr></table></figure>
</li>
<li><p>重启</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service apache2 restart</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="编写admin环境变量脚本"><a href="#编写admin环境变量脚本" class="headerlink" title="编写admin环境变量脚本"></a>编写admin环境变量脚本</h1><p>创建一个<code>admin-openrc</code>文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">export OS_PROJECT_DOMAIN_NAME=Default</div><div class="line">export OS_USER_DOMAIN_NAME=Default</div><div class="line">export OS_PROJECT_NAME=admin</div><div class="line">export OS_USERNAME=admin</div><div class="line">export OS_PASSWORD=ADMIN_PASS</div><div class="line">export OS_AUTH_URL=http://controller:35357/v3</div><div class="line">export OS_IDENTITY_API_VERSION=3</div><div class="line">export OS_IMAGE_API_VERSION=2</div></pre></td></tr></table></figure></p>
<p><strong><code>ADMIN_PASS</code> 用上面的创建的密码替换掉这个</strong></p>
<h1 id="创建域-domain-项目-project-用户-users-和角色-roles"><a href="#创建域-domain-项目-project-用户-users-和角色-roles" class="headerlink" title="创建域(domain),项目(project),用户(users)和角色(roles)"></a>创建域(domain),项目(project),用户(users)和角色(roles)</h1><p>创建这些之前，先执行上面那个脚本，切换到admin用户。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. admin-openrc</div></pre></td></tr></table></figure></p>
<p>因为OpenStack默认创建了<code>default</code>的域，所以这次不用创建域了</p>
<ol>
<li><p>创建一个<code>service</code> project</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ openstack project create --domain default \</div><div class="line">--description <span class="string">"Service Project"</span> service</div><div class="line"></div><div class="line">+-------------+----------------------------------+</div><div class="line">| Field       | Value                            |</div><div class="line">+-------------+----------------------------------+</div><div class="line">| description | Service Project                  |</div><div class="line">| domain_id   | default                          |</div><div class="line">| enabled     | True                             |</div><div class="line">| id          | 24ac7f19cd944f4cba1d77469b2a73ed |</div><div class="line">| is_domain   | False                            |</div><div class="line">| name        | service                          |</div><div class="line">| parent_id   | default                          |</div><div class="line">+-------------+----------------------------------+</div></pre></td></tr></table></figure>
</li>
<li><p>创建<code>demo</code>project,user和role</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ openstack project create --domain default \</div><div class="line">--description <span class="string">"Demo Project"</span> demo</div><div class="line"></div><div class="line">+-------------+----------------------------------+</div><div class="line">| Field       | Value                            |</div><div class="line">+-------------+----------------------------------+</div><div class="line">| description | Demo Project                     |</div><div class="line">| domain_id   | default                          |</div><div class="line">| enabled     | True                             |</div><div class="line">| id          | 231ad6e7ebba47d6a1e57e1cc07ae446 |</div><div class="line">| is_domain   | False                            |</div><div class="line">| name        | demo                             |</div><div class="line">| parent_id   | default                          |</div><div class="line">+-------------+----------------------------------+</div></pre></td></tr></table></figure>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ openstack user create --domain default \</div><div class="line">--password-prompt demo</div><div class="line"></div><div class="line">User Password:</div><div class="line">Repeat User Password:</div><div class="line">+---------------------+----------------------------------+</div><div class="line">| Field               | Value                            |</div><div class="line">+---------------------+----------------------------------+</div><div class="line">| domain_id           | default                          |</div><div class="line">| enabled             | True                             |</div><div class="line">| id                  | aeda23aa78f44e859900e22c24817832 |</div><div class="line">| name                | demo                             |</div><div class="line">| options             | &#123;&#125;                               |</div><div class="line">| password_expires_at | None                             |</div><div class="line">+---------------------+----------------------------------+</div></pre></td></tr></table></figure>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ openstack role create user</div><div class="line"></div><div class="line">+-----------+----------------------------------+</div><div class="line">| Field     | Value                            |</div><div class="line">+-----------+----------------------------------+</div><div class="line">| domain_id | None                             |</div><div class="line">| id        | 997ce8d05fc143ac97d83fdfb5998552 |</div><div class="line">| name      | user                             |</div><div class="line">+-----------+----------------------------------+</div></pre></td></tr></table></figure>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openstack role add --project demo --user demo user</div></pre></td></tr></table></figure>
</li>
<li><p>创建demo用户的环境脚本<br> <code>demo-openrc</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">export OS_PROJECT_DOMAIN_NAME=Default</div><div class="line">export OS_USER_DOMAIN_NAME=Default</div><div class="line">export OS_PROJECT_NAME=demo</div><div class="line">export OS_USERNAME=demo</div><div class="line">export OS_PASSWORD=DEMO_PASS</div><div class="line">export OS_AUTH_URL=http://controller:5000/v3</div><div class="line">export OS_IDENTITY_API_VERSION=3</div><div class="line">export OS_IMAGE_API_VERSION=2</div></pre></td></tr></table></figure>
<p> <strong><code>DEMO_PASS</code></strong>替换成上一步创建demo用户时保存的密码<br> 好了现在执行一下这个脚本就切换到demo用户了</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. demo-openrc</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>切换到<code>admin</code>用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. admin-openrc</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ openstack token issue</div><div class="line"></div><div class="line">+------------+-----------------------------------------------------------------+</div><div class="line">| Field      | Value                                                           |</div><div class="line">+------------+-----------------------------------------------------------------+</div><div class="line">| expires    | 2016-02-12T20:44:35.659723Z                                     |</div><div class="line">| id         | gAAAAABWvjYj-Zjfg8WXFaQnUd1DMYTBVrKw4h3fIagi5NoEmh21U72SrRv2trl |</div><div class="line">|            | JWFYhLi2_uPR31Igf6A8mH2Rw9kv_bxNo1jbLNPLGzW_u5FC7InFqx0yYtTwa1e |</div><div class="line">|            | eq2b0f6-18KZyQhs7F3teAta143kJEWuNEYET-y7u29y0be1_64KYkM7E       |</div><div class="line">| project_id | 343d245e850143a096806dfaefa9afdc                                |</div><div class="line">| user_id    | ac3377633149401296f6c0d92d79dc16                                |</div><div class="line">+------------+-----------------------------------------------------------------+</div></pre></td></tr></table></figure>
<p>上面输出上面类似代表正常了。<code>demo</code>用户也是类似，这里就不演示了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里需要注意的是，用户的环境脚本，其实他只是方便切换用户的，就算不做，都可以通过把环境变量作为<code>openstack</code>命令参数来执行，例如上面验证可以用下面命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ openstack --os-auth-url http://controller:35357/v3 \</div><div class="line">  --os-project-domain-name Default --os-user-domain-name Default \</div><div class="line">  --os-project-name admin --os-username admin token issue</div><div class="line"></div><div class="line">Password: <span class="comment">#这里要输入admin密码</span></div><div class="line">+------------+-----------------------------------------------------------------+</div><div class="line">| Field      | Value                                                           |</div><div class="line">+------------+-----------------------------------------------------------------+</div><div class="line">| expires    | 2016-02-12T20:14:07.056119Z                                     |</div><div class="line">| id         | gAAAAABWvi7_B8kKQD9wdXac8MoZiQldmjEO643d-e_j-XXq9AmIegIbA7UHGPv |</div><div class="line">|            | atnN21qtOMjCFWX7BReJEQnVOAj3nclRQgAYRsfSU_MrsuWb4EDtnjU7HEpoBb4 |</div><div class="line">|            | o6ozsA_NmFWEpLeKy0uNn_WeKbAhYygrsmQGA49dclHVnz-OMVLiyM9ws       |</div><div class="line">| project_id | 343d245e850143a096806dfaefa9afdc                                |</div><div class="line">| user_id    | ac3377633149401296f6c0d92d79dc16                                |</div><div class="line">+------------+-----------------------------------------------------------------+</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;keystone 是openstack中所有service的权限管理和接口入口，所以先安装它&lt;br&gt;这一章都是在&lt;code&gt;controller&lt;/code&gt;节点操作。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;切换到&lt;code&gt;root&lt;/code&gt;用户，执行下面命令&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ mysql&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建&lt;code&gt;keystone&lt;/code&gt;数据库:&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;MariaDB [(none)]&amp;gt; CREATE DATABASE keystone;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;赋予合适权限给&lt;code&gt;keystone&lt;/code&gt;数据库：&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;MariaDB [(none)]&amp;gt; GRANT ALL PRIVILEGES ON keystone.* TO &lt;span class=&quot;string&quot;&gt;&#39;keystone&#39;&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&#39;localhost&#39;&lt;/span&gt; \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;IDENTIFIED BY &lt;span class=&quot;string&quot;&gt;&#39;KEYSTONE_DBPASS&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;MariaDB [(none)]&amp;gt; GRANT ALL PRIVILEGES ON keystone.* TO &lt;span class=&quot;string&quot;&gt;&#39;keystone&#39;&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&#39;%&#39;&lt;/span&gt; \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;IDENTIFIED BY &lt;span class=&quot;string&quot;&gt;&#39;KEYSTONE_DBPASS&#39;&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; &lt;strong&gt;用一个合适的密码覆盖&lt;code&gt;KEYSTONE_DBPASS&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;退出数据库&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="openstack" scheme="http://idiotsky.me/categories/openstack/"/>
    
    
      <category term="openstack" scheme="http://idiotsky.me/tags/openstack/"/>
    
      <category term="ubuntu" scheme="http://idiotsky.me/tags/ubuntu/"/>
    
      <category term="kvm" scheme="http://idiotsky.me/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>go的变量和字面值的类型</title>
    <link href="http://idiotsky.me/2017/09/09/go-type-literal/"/>
    <id>http://idiotsky.me/2017/09/09/go-type-literal/</id>
    <published>2017-09-09T07:44:21.000Z</published>
    <updated>2017-09-09T08:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前几天逛v2ex，无聊看到一个关于这个的话题 <a href="https://www.v2ex.com/t/389157" target="_blank" rel="external">golang 的字面值与类型转换，来猜猜结果</a>，所以现在总结下，免得以后进坑。</p>
</blockquote>
<h1 id="论述"><a href="#论述" class="headerlink" title="论述"></a>论述</h1><p>先上代码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"> a := <span class="number">1</span></div><div class="line"> b := <span class="number">3</span></div><div class="line"> </div><div class="line"> fmt.Printf(<span class="string">"%T\n"</span>, a / b)</div><div class="line"> fmt.Printf(<span class="string">"%T\n"</span>, a / <span class="number">3</span>)</div><div class="line"> fmt.Printf(<span class="string">"%T\n"</span>, a / <span class="number">3.0</span>)</div><div class="line"> fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">1</span> / <span class="number">3</span>)</div><div class="line"> fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">1</span> / <span class="number">3.0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">int</div><div class="line">int</div><div class="line">int</div><div class="line">float64</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>其实这里有奇怪的第三行和最后一行的输出结果，第三行里面a=1跟最后一行是一样的，为什么结果类型不一样呢，很明显这里有类型转换了，究竟谁类型转换了呢，继续上代码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"> a := <span class="number">1</span></div><div class="line"> </div><div class="line"> fmt.Println(a / <span class="number">3</span>)</div><div class="line"> fmt.Println(a / <span class="number">3.0</span>)</div><div class="line"> <span class="comment">//fmt.Println(a / 3.1) //类型错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">0</div><div class="line"># literal/test2/main.go:10: constant 3.1 truncated to integer</div></pre></td></tr></table></figure></p>
<p>很明显是字面值转换了类型，最后一行的3.1是转换不了整形的，所以就报错了，而3.0是没问题的，那为什么变量不会转换呢，继续上代码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	a := <span class="number">1</span></div><div class="line">	b := <span class="number">3.0</span></div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"%T\n"</span>, a)</div><div class="line">	fmt.Printf(<span class="string">"%T\n"</span>, b)</div><div class="line">    <span class="comment">//fmt.Printf("%T\n", a/b) //编译错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">float64</div><div class="line">#literal/test3/main.go:11: invalid operation: a / b (mismatched types int and float64)</div></pre></td></tr></table></figure></p>
<p>很明显变量类型在初始化赋值的时候就确定，在运算的时候变量不会去类型转换。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>go里面的变量运算是保证运算变量一定是相同类型才行，否则会编译错误，而且是初始赋值后就确定类型，不会在运算时自动帮你转换。但是字面值不同，在不同的场景会转换成不同的类型，当然前提是可以转换，否则就跟上面的例子3.1一样，没办法转换成整形而报错。<br>所有代码在 <a href="https://github.com/ejunjsh/go-code/tree/master/literal" target="_blank" rel="external">https://github.com/ejunjsh/go-code/tree/master/literal</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前几天逛v2ex，无聊看到一个关于这个的话题 &lt;a href=&quot;https://www.v2ex.com/t/389157&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;golang 的字面值与类型转换，来猜猜结果&lt;/a&gt;，所以现在总结下，免得以后进坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;论述&quot;&gt;&lt;a href=&quot;#论述&quot; class=&quot;headerlink&quot; title=&quot;论述&quot;&gt;&lt;/a&gt;论述&lt;/h1&gt;&lt;p&gt;先上代码&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; a := &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; b := &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%T\n&quot;&lt;/span&gt;, a / b)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%T\n&quot;&lt;/span&gt;, a / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%T\n&quot;&lt;/span&gt;, a / &lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%T\n&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%T\n&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;float64&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript是如何工作的(二)</title>
    <link href="http://idiotsky.me/2017/08/26/javascript-how-work-2/"/>
    <id>http://idiotsky.me/2017/08/26/javascript-how-work-2/</id>
    <published>2017-08-26T03:08:09.000Z</published>
    <updated>2017-09-19T17:05:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>几个星期前，我们开始了一个系列，目标是深入理解javascript和它怎么工作的：通过这些我们可以更容易的写出好代码和apps。</p>
</blockquote>
<p><a href="/2017/08/26/javascript-how-work">系列的第一篇</a>主要是提供一个关于引擎，运行时和调用栈的概括。这篇文章将深入到Google V8 javascript 引擎。同时，还提供一些快速的意见令你能够写出好的javascript代码。<br><a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>一个javascript引擎是一个解释器也是个程序，它执行javascript代码。它可以被实现为一个标准解释器，也可以是一个即时（just-in-time）的编译器（以不同形式编译javascript成字节码）<br>下面是一个流行的javascript引擎的列表：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/V8_%28JavaScript_engine%29" target="_blank" rel="external">V8</a> — 谷歌开源的, 用 C++写的。</li>
<li><a href="https://en.wikipedia.org/wiki/Rhino_%28JavaScript_engine%29" target="_blank" rel="external">Rhino</a> — 由Mozilla基金会管理,开源的, 完全用java写的。</li>
<li><a href="https://en.wikipedia.org/wiki/SpiderMonkey_%28JavaScript_engine%29" target="_blank" rel="external">SpiderMonkey</a> — 第一个javascript引擎 Netscape Navigator开发,现在Firefox维护。</li>
<li><a href="https://en.wikipedia.org/wiki/JavaScriptCore" target="_blank" rel="external">JavaScriptCore</a> — 开源，由Apple开发 ，Safari浏览器的引擎。</li>
<li><a href="https://en.wikipedia.org/wiki/KJS_%28KDE%29" target="_blank" rel="external">KJS</a> — KDE的引擎，由 Harri Porten开发，是Konqueror桌面系统的浏览器引擎。</li>
<li><a href="https://en.wikipedia.org/wiki/Chakra_%28JScript_engine%29" target="_blank" rel="external">Chakra (JScript9)</a> — IE的</li>
<li><a href="https://en.wikipedia.org/wiki/Chakra_%28JavaScript_engine%29" target="_blank" rel="external">Chakra (JavaScript)</a> — 微软Edge</li>
<li><a href="https://en.wikipedia.org/wiki/Nashorn_%28JavaScript_engine%29" target="_blank" rel="external">Nashorn</a> -  OpenJDK的开源一部分, 由Oracle Java 语言和工具组开发</li>
<li><a href="https://en.wikipedia.org/wiki/JerryScript" target="_blank" rel="external">JerryScript</a> — 一个轻量级引擎.</li>
</ul>
<h1 id="为什么要创造一个V8引擎？"><a href="#为什么要创造一个V8引擎？" class="headerlink" title="为什么要创造一个V8引擎？"></a>为什么要创造一个V8引擎？</h1><p>V8引擎由Google创建并开源，c++编写。用于Google的Chrome浏览器。不像其他引擎，V8还是流行的Node.js的运行时引擎。<br><a href="http://idiotsky.me/images/js-how-work-2-1.png"><img src="http://idiotsky.me/images/js-how-work-2-1.png" alt=""></a><br>V8是第一个为了性能提升的浏览器引擎。为了达到更好的性能，相比于使用解释器，V8更倾向于使用编译器编译javascript代码成更高效的机器码。它像其他现代化javascript引擎如SpiderMonkey或者Rhino (Mozilla)一样，使用<strong>JIT(Just-In-Time)</strong>编译器在执行阶段编译代码，唯一不同的是，V8不会生成字节码或任意中间代码。</p>
<h1 id="V8曾经有两个编译器"><a href="#V8曾经有两个编译器" class="headerlink" title="V8曾经有两个编译器"></a>V8曾经有两个编译器</h1><p>在5.9版本发布（今年早些时候）之前，V8曾经有两个编译器：</p>
<ul>
<li>full-codegen — 一个简单快速的编译器，用来生成简单，相对慢的机器码。</li>
<li>Crankshaft - 一个更复杂(Just-In-Time) 优化的编译，用来生成更优的机器码。</li>
</ul>
<p>V8引擎内部也用了一些线程：</p>
<ul>
<li>正如你想的，主线程就是拿到代码，编译代码和执行代码。</li>
<li>还有些线程用来编译和优化代码，协助主线程，让主线程继续执行代码。</li>
<li>一个剖析器线程用来汇报哪些方法需要Crankshaft编译器优化。</li>
<li>其他一些线程用来做垃圾回收</li>
</ul>
<p>当开始执行javascript代码，V8运用<strong>full-codegen</strong>来直接翻译解析过的javascript代码为机器码，这个过程没有任何中间转换，所以执行机器码<strong>非常快</strong>.由于没有用到任何中间的字节码，所以就没有需要解释器的必要了。</p>
<p>当你的代码运行一段时间后，剖析器线程就能收集到足够的数据来确定哪些方法应该被优化。</p>
<p>接下来，<strong>Crankshaft</strong> 优化编译器开始运行在其他线程。它翻译javascript抽象语法树到一个高级别的<a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="external">静态单赋值(SSA)</a> 形态,又叫<strong>Hydrogen(氢？)</strong>。然后优化这个Hydrogen图。大部分的优化都在这个层次上完成。</p>
<h1 id="内联（inlining）"><a href="#内联（inlining）" class="headerlink" title="内联（inlining）"></a>内联（inlining）</h1><p>首个优化方法就是内联，它会提前尽可能的内联更多的代码。内联是一个替换代码的一个过程，用方法体替换到调用的地方（其实就是方法展开）。这样一步简单的优化可以令接下来的优化更有意义。<br><a href="http://idiotsky.me/images/js-how-work-2-2.png"><img src="http://idiotsky.me/images/js-how-work-2-2.png" alt=""></a></p>
<h1 id="隐藏类-Hidden-class"><a href="#隐藏类-Hidden-class" class="headerlink" title="隐藏类(Hidden class)"></a>隐藏类(Hidden class)</h1><p>javascript是一种基于原型的语言：没有类和对象是通过克隆进程创建的(机翻😁)。javascript也是一种动态语言，他能够随意的添加和删除一个对象的属性，即使这个对象已经实例化了。<br>大部分javascript解释器使用类字典的结构(基于<a href="http://en.wikipedia.org/wiki/Hash_function" target="_blank" rel="external">哈希函数</a>)来存储对象属性值在内存的位置。相比非动态语言如java和c#，这种结构使得取值是种计算昂贵的操作。对java来说，在编译之前就已经确定对象的属性，运行时也不能随意添加和删除属性的（当然，c#支持<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic" target="_blank" rel="external">动态类型</a>,那就在其他话题里了）。所以，属性的值（或者属性的指针）可以存储在一个连续的缓存里面，属性之间的位移更是固定的，而且位移的长度可以容易的基于属性类型来确定。这些对于javascript来说是不可能的，因为javascript的类型可以在运行时改变。<br>由于这种字典的取地址方式是不高效的，所以V8用了一个不同的方法来取代：隐藏类(Hidden class)。隐藏类的运作方式跟java的固定对象布局类似，除了它们是在运行时创建的。下面举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>一旦<code>new Point(1, 2)</code>被调用，V8将创建一个<code>C0</code>的隐藏类。<br><a href="http://idiotsky.me/images/js-how-work-2-3.png"><img src="http://idiotsky.me/images/js-how-work-2-3.png" alt=""></a><br>由于<code>Point</code>没有属性定义,所以<code>C0</code>是空的。</p>
<p>一旦<code>this.x = x</code>(在<code>Point</code>函数)被执行，V8将创建一个基于<code>C0</code>的隐藏类<code>C1</code>。<code>C1</code>描述了x的内存的位置（相对于对象指针），在这个情况下，x的位置存在<a href="http://en.wikipedia.org/wiki/Offset_%28computer_science%29" target="_blank" rel="external">位移</a>0上，这代表了<code>point</code>对象是一个连续的内存，它的第一个位移对应的是属性x。同时V8也用“类转换”更新了<code>C0</code>，表明了如果一个属性x加到<code>point</code>对象，隐藏类就应该要从<code>C0</code>转换到<code>C1</code>。所以现在<code>point</code>对象的隐藏类为<code>C1</code>。<br><a href="http://idiotsky.me/images/js-how-work-2-4.png"><img src="http://idiotsky.me/images/js-how-work-2-4.png" alt=""></a><br><small><em>每一次一个新的属性加到一个对象，一条转换的路径更新到旧的隐藏类并指向新的隐藏类。隐藏类转换是很重要的，因为同样方式创建的对象都共享同一个隐藏类。如果两个对象共享一个隐藏类，同时相同的属性加到这个两个对象的话，那么转换将保证这两个对象还是共享同一个新的隐藏类，而且共享同一个隐藏类有益于优化代码。</em></small></p>
<p>当<code>this.y = y</code>被执行，一个新的隐藏类<code>C1</code>被创建，同时一个类转换加到<code>C1</code>上面，表明了如果一个属性y加到一个<code>point</code>对象（已经有x属性的），就要把隐藏类转换成<code>C2</code>。现在<code>point</code>对象的隐藏类就是<code>C2</code>了。<br><a href="http://idiotsky.me/images/js-how-work-2-5.png"><img src="http://idiotsky.me/images/js-how-work-2-5.png" alt=""></a></p>
<p>隐藏类的转换依赖于属性的加入顺序。看一下下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">p1.a = <span class="number">5</span>;</div><div class="line">p1.b = <span class="number">6</span>;</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</div><div class="line">p2.b = <span class="number">7</span>;</div><div class="line">p2.a = <span class="number">8</span>;</div></pre></td></tr></table></figure></p>
<p>现在你肯定会认为p1和p2都是共享同一个隐藏类和转换路径，其实不然。对于p1，第一个属性是a再到b，而p2的话是先b在到a，所以p1和p2是分别两个不同的隐藏类和不同的两条转换路径。<strong>所以，对于动态属性最好是用相同的顺序加入到对象里面，这样有利于隐藏类的重用。</strong></p>
<h1 id="内联缓存-Inline-caching"><a href="#内联缓存-Inline-caching" class="headerlink" title="内联缓存(Inline caching)"></a>内联缓存(Inline caching)</h1><p>V8利用内联缓存技术来优化动态类型语言。内联缓存依赖于观察哪些方法在哪些相同的对象类型被重复调用。更深的介绍可以看<a href="https://github.com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-caches" target="_blank" rel="external">这里</a><br>我们用更通用的概念来说说内联缓存（如果你没时间去看上面的介绍的链接的话。）<br>所以，内联缓存是怎么工作的呢？V8维护一个对象类型的缓存，当一个对象做为参数传递到一个函数调用中，那V8会缓存这个对象，并假设这个对象会在未来会再一次作为参数传递到一个函数调用中。如果V8的这个假设是正确的话，在下次传递对象到一个方法调用的时候，就会绕过查找类型对象的属性的过程，直接使用之前查找隐藏类所储存的信息。</p>
<p>所以隐藏类和内联缓存是怎么样关联起来的呢？无论一个指定对象方法什么时候被执行，V8引擎都会去查找那个对象的隐藏类去决定指定属性的访问位移。在两次成功调用相同隐藏类的相同方法后，V8就会忽略隐藏类的查找并简单的用属性位移和这个对象指针相加来确定地址。对于未来的那个方法的调用，V8都假设这个对象的隐藏类都没有改变，直接使用之前查找后对象内存的位移来访问属性，这样大大增加执行速度。</p>
<p>相同类型的对象共享相同隐藏类是很重要的，原因是内存缓存。如果你创建两个相同类型的对象，但它们的隐藏类不同（前面例子有提到），V8将没办法用到内联缓存，因为尽管类型相同，但是它们对应的隐藏类分配的属性位移是不同的。<br><a href="http://idiotsky.me/images/js-how-work-2-6.png"><img src="http://idiotsky.me/images/js-how-work-2-6.png" alt=""></a><br><small><em>这两个对象基本上是一样的，但是a和b属性是用不同的顺序创建的。</em></small></p>
<h1 id="编译机器码"><a href="#编译机器码" class="headerlink" title="编译机器码"></a>编译机器码</h1><p>一旦Hydrogen图被优化，Crankshaft降低它为一个低级别的表述，称为Lithium。大多数Lithium实现是架构指定的。注册器分配发生在这个级别。</p>
<p>最后，Lithium被编译为机器码。有一些编译发生在OSR:栈中替换。在我们编译和优化一个明显长时间运行的方法时，我们有可能已经运行了这个方法了。V8不会忘了这个方法重新运行一个优化的版本的方法，而是转换所有的上下文（栈，注册器），这样就可以在执行中切换到优化版本。这是一个复杂的任务，记得在其他优化里，V8已经一开始就内联代码了。V8不是唯一有这能力的引擎。</p>
<p>这里有个保障是，一旦引擎的假设不成立的话，会把优化过的代码回滚回之前未优化的代码。这个保障称之为去优化（deoptimization）</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>对于垃圾回收，V8使用传统的分代标记清理的方式来清除旧的对象。标记的阶段一般都会停止javascript的执行。为了控制GC的成本和令执行更加稳定，V8用了递增标记来取代全堆标记。递增标记只是在部分堆中递增标记可能的对象，之后回到正常的代码执行。到下次执行GC的时候，会从上次GC标记的堆中开始。这样的话，停止时间很少。之前提及过，清理过程是在不同的线程执行的。</p>
<h1 id="Ignition和TurboFan"><a href="#Ignition和TurboFan" class="headerlink" title="Ignition和TurboFan"></a>Ignition和TurboFan</h1><p>V8的5.9版本在2017年初发布，一个新的执行管道被引入。这个新的管道使得V8在现实的javascript应用程序中达到更高的性能和更少内存使用。</p>
<p>新的执行管道由V8解释器<a href="https://github.com/v8/v8/wiki/Interpreter" target="_blank" rel="external">Ignition</a>和V8最新优化编译器<a href="https://github.com/v8/v8/wiki/TurboFan" target="_blank" rel="external">TurboFan</a> 组成。</p>
<p>你可以在<a href="https://v8project.blogspot.bg/2017/05/launching-ignition-and-turbofan.html" target="_blank" rel="external">这里</a>查阅来自V8团队的博客文章.</p>
<p>自从5.9版本的V8发布，full-codegen和Crankshaft（这两个技术从2010就开始服务V8了）不再被V8用来执行javascript，当V8团队要跟上新的javascript语言特性的步伐和这些特性更需要优化的支持。</p>
<p>这就意味着V8总体来讲将是一个更简单和更容易维护的架构。<br><a href="http://idiotsky.me/images/js-how-work-2-7.png"><img src="http://idiotsky.me/images/js-how-work-2-7.png" alt=""></a><br><small><em>在网页和Node.js的性能改进</em></small></p>
<p>这些改进只是个开始。新的Ignition和TurboFan为更长远的优化铺平了道路，并在这几年提升javascript的性能和缩小Node.js和Chrome的差距。</p>
<h1 id="怎么写出最好的javascript代码"><a href="#怎么写出最好的javascript代码" class="headerlink" title="怎么写出最好的javascript代码"></a>怎么写出最好的javascript代码</h1><p>最后，这里有些建议帮助你们写出更优更好的javascript。我想，当你看到这里，你心里已经有所感悟了，但是，我还是总结下吧：</p>
<ol>
<li>对象属性的顺序:初始化对象属性最好要按相同顺序，这样，他们的隐藏类和后续的优化代码能够共享。</li>
<li>动态属性：加一个动态属性会令一个对象的隐藏类改变，和拖慢任何一个方法，因为这个方法已经针对前一个隐藏类优化的了。所以，尽可能分配在构造函数里面分配所有的对象属性。</li>
<li>方法：重复执行相同的方法比一次执行许多不同的方法快（因为内联缓存）</li>
<li>数组：避免稀疏数组，因为它们的key不是递增的。稀疏数组并不是每个索引都有元素，所以它更像个哈希表。还有访问这样的数组是昂贵的。还有就是不要一次分配个大数组，最好按需分配。最后，不要在数组中删除元素，这样就令key稀疏了。</li>
<li>标签值：V8用32位来代表对象和数字。它用一位来区分对象（flag=1）和整形（flag=0），这个整形也叫SMI（SMall Integer）,因为它只有31位。这样的话，如果一个数字值大于31位，V8将会将它转化为一个double并使用一个对象把它装箱。尽可能使用31位的有符号数字，这样能够避免昂贵的装箱操作。</li>
</ol>
<p>翻译 <a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="external">https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;几个星期前，我们开始了一个系列，目标是深入理解javascript和它怎么工作的：通过这些我们可以更容易的写出好代码和apps。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/2017/08/26/javascript-how-work&quot;&gt;系列的第一篇&lt;/a&gt;主要是提供一个关于引擎，运行时和调用栈的概括。这篇文章将深入到Google V8 javascript 引擎。同时，还提供一些快速的意见令你能够写出好的javascript代码。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://idiotsky.me/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://idiotsky.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript是如何工作的(一)</title>
    <link href="http://idiotsky.me/2017/08/26/javascript-how-work/"/>
    <id>http://idiotsky.me/2017/08/26/javascript-how-work/</id>
    <published>2017-08-25T17:17:54.000Z</published>
    <updated>2017-09-19T17:05:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>简评</strong>：JavaScript 是越来越受欢迎了，很多团队都在采用这些语言工作。前端、后端、嵌入式设备等等，都可以看见它的身影。虽然我们知其然，但又知其所以然吗？</p>
</blockquote>
<a id="more"></a>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>大家应该都知道 JavaScript 是单线程的，以及听过 V8 引擎的概念。<br>这篇文章将会介绍这些概念，并解释 JavaScript 是如何运行的。通过了解这些细节，开发者能更好地编写代码，正确利用其提供的 API。</p>
<h1 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h1><p>比较流行的一个 JavaScript 引擎示例就是 Google 的 V8 引擎。下图是 V8 引擎在 Chrome 和 Node.js 中使用的一个简化视图：<br><a href="http://idiotsky.me/images/js-how-work.png"><img src="http://idiotsky.me/images/js-how-work.png" alt=""></a></p>
<p>引擎主要由两个组件组成：</p>
<ul>
<li>内存堆（Memory Heap ）：这是内存分配的地方</li>
<li>调用堆栈（Call Stack）：这是程序运行时函数的调用过程</li>
</ul>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>在浏览器中，例如「setTimeout」这样的 API 已经有很多开发者在用了，然后引擎并没有提供这些 API，所以它们从哪里来的呢？<br>实际情况是这样的：<br><a href="http://idiotsky.me/images/js-how-work-1.png"><img src="http://idiotsky.me/images/js-how-work-1.png" alt=""></a><br>所以，除了引擎之外，还有浏览器提供的 Web API（像 DOM、AJAX、setTimeout 等等）。另外，还有事件循环（event loop）和回调队列（callback queue）。</p>
<h1 id="调用堆栈（Call-Stack）"><a href="#调用堆栈（Call-Stack）" class="headerlink" title="调用堆栈（Call Stack）"></a>调用堆栈（Call Stack）</h1><p>JavaScript 是单线程语言，这意味着它只有一个单一的调用堆栈。因此，它每次只能做一件事。</p>
<p>调用堆栈是一个数据结构，按调用顺序保存所有在运行期被调用的方法。既然是个栈，那么它就满足先入后出的特性。</p>
<p>我们来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * y;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> s = multiply(x, x);</div><div class="line">    <span class="built_in">console</span>.log(s);</div><div class="line">&#125;</div><div class="line">printSquare(<span class="number">5</span>);</div></pre></td></tr></table></figure></p>
<p>当引擎开始执行这段代码时，调用堆栈将为空。然后，就会有以下步骤：<br><a href="http://idiotsky.me/images/js-how-work-2.png"><img src="http://idiotsky.me/images/js-how-work-2.png" alt=""></a></p>
<p>调用堆栈中的每个条目称为堆栈帧（Stack Frame）。当异常发生时，它基本上是调用堆栈的状态。再看看下面这段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'SessionStack will help you resolve crashes :)'</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    foo();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    bar();</div><div class="line">&#125;</div><div class="line">start();</div></pre></td></tr></table></figure></p>
<p>如果这是在 Chrome 中执行（假设此代码位于一个名为 foo.js 的文件中），则会产生这种情况：<br><a href="http://idiotsky.me/images/js-how-work-3.png"><img src="http://idiotsky.me/images/js-how-work-3.png" alt=""></a></p>
<p>当你达到最大调用堆栈时，会容易发生这种情况，特别是在没有测试代码时随意使用递归。<br>看看这个示例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    foo();</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p>
<p>代码执行时，首先调用函数「foo」。然而，这是递归函数，调用自身的同时又没有设置终止条件，所以每一次执行，相同的函数都会被添加进堆栈中，看起来就是这样：<br><a href="http://idiotsky.me/images/js-how-work-4.png"><img src="http://idiotsky.me/images/js-how-work-4.png" alt=""></a><br>某些时候，调用堆栈中的函数调用次数超过了调用堆栈的实际大小，那么浏览器就会抛出一个错误，看起来像这样：<br><a href="http://idiotsky.me/images/js-how-work-5.png"><img src="http://idiotsky.me/images/js-how-work-5.png" alt=""></a><br>单线程上编写代码相对多线程来说会简单得多，你不必考虑死锁这样的复杂场景。但单线程也有许多限制，由于 JavaScript 有调用堆栈，当执行代码需要耗费大量时间时是怎样的呢？</p>
<h1 id="并发和事件循环"><a href="#并发和事件循环" class="headerlink" title="并发和事件循环"></a>并发和事件循环</h1><p>当你在调用堆栈中进行函数调用，有时候需要大量时间才能进行处理。例如在浏览器中使用JavaScript 进行一些复杂的图像转换。在这个过程中又发生了什么？<br>这个问题的产生是因为，虽然调用堆栈具有执行的功能，但浏览器本身是无法渲染也不能运行其他任何代码，它被卡住了。当你想执行一套流畅的 UI 时，就会产生这样的问题。大多数浏览器通过抛出异常处理错误，询问用户是否要终止网页：<br><a href="http://idiotsky.me/images/js-how-work-6.jpg"><img src="http://idiotsky.me/images/js-how-work-6.jpg" alt=""></a><br>这个用户体验很糟糕。那么如何解决呢？答案是异步回调（asynchronous callbacks）。这是后话，下次再讲。</p>
<p>翻译和参考 <a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="external">https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;简评&lt;/strong&gt;：JavaScript 是越来越受欢迎了，很多团队都在采用这些语言工作。前端、后端、嵌入式设备等等，都可以看见它的身影。虽然我们知其然，但又知其所以然吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://idiotsky.me/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://idiotsky.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>openstack安装准备(二)-环境的安装</title>
    <link href="http://idiotsky.me/2017/08/19/openstack-install-prepare-2/"/>
    <id>http://idiotsky.me/2017/08/19/openstack-install-prepare-2/</id>
    <published>2017-08-19T14:50:07.000Z</published>
    <updated>2017-09-19T17:05:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://idiotsky.me/images/openstack-install-prepare-2-1.png"><img src="http://idiotsky.me/images/openstack-install-prepare-2-1.png" alt=""></a><br>上图是整个openstack的架构图，里面的椭圆方块都是openstack的服务，所以安装openstack就是要安装这些服务。</p>
<p>按照官方建议，这次openstack安装的服务为：</p>
<ul>
<li>Identity service (keystone)</li>
<li>Image service (glance)</li>
<li>Compute service (nova)</li>
<li>Networking service (neutron)</li>
<li>Dashboard (horizon)</li>
<li>Block Storage service (cinder)</li>
</ul>
<a id="more"></a>
<p>在安装上面服务前，先要弄好环境的😁<br>这次安装的openstack为最新的release，<strong>pike</strong></p>
<h1 id="安装openstack仓库"><a href="#安装openstack仓库" class="headerlink" title="安装openstack仓库"></a>安装openstack仓库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># change to root</span></div><div class="line">$ sudo -i</div><div class="line">$ apt install software-properties-common</div><div class="line">$ add-apt-repository cloud-archive:pike</div><div class="line">$ apt update &amp;&amp; apt dist-upgrade</div><div class="line">$ apt install python-openstackclient</div></pre></td></tr></table></figure>
<p>上面的步骤两个节点都要安装。<br><strong>以下步骤安装在controller</strong></p>
<h1 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h1><p>openstack所用到的数据都会存到数据库里，所以安装一个数据库是准备的一个重要步骤。mariadb是官方建议的数据库。</p>
<h2 id="安装和配置mariadb"><a href="#安装和配置mariadb" class="headerlink" title="安装和配置mariadb"></a>安装和配置mariadb</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ apt install mariadb-server python-pymysql</div><div class="line">$ vi /etc/mysql/mariadb.conf.d/99-openstack.cnf</div><div class="line"><span class="comment"># 加一个[mysqld]区，bind-address为管理网络ip</span></div><div class="line">[mysqld]</div><div class="line"><span class="built_in">bind</span>-address = controller <span class="comment"># 192.168.199.10 </span></div><div class="line"></div><div class="line">default-storage-engine = innodb</div><div class="line">innodb_file_per_table = on</div><div class="line">max_connections = 4096</div><div class="line">collation-server = utf8_general_ci</div><div class="line">character-set-server = utf8</div></pre></td></tr></table></figure>
<h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>重启服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service mysql restart</div></pre></td></tr></table></figure></p>
<p>设置下root用户的密码，这个密码后面要用到，务必谨记。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysql_secure_installation</div></pre></td></tr></table></figure></p>
<h1 id="安装消息队列"><a href="#安装消息队列" class="headerlink" title="安装消息队列"></a>安装消息队列</h1><p>openstack用消息队列来异步控制各种service，所以要装一个，rabbitmq是官方推荐，装之。</p>
<h2 id="安装和配置rabbitmq"><a href="#安装和配置rabbitmq" class="headerlink" title="安装和配置rabbitmq"></a>安装和配置rabbitmq</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt install rabbitmq-server</div></pre></td></tr></table></figure>
<p>加一个openstack用户。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rabbitmqctl add_user openstack RABBIT_PASS <span class="comment">#用你的密码替换下RABBIT_PASS，谨记这个密码，后面有用。</span></div></pre></td></tr></table></figure></p>
<p>赋予更多权限给openstack用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rabbitmqctl set_permissions openstack <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></div></pre></td></tr></table></figure></p>
<h1 id="安装缓存"><a href="#安装缓存" class="headerlink" title="安装缓存"></a>安装缓存</h1><p>openstack用到缓存，memcached是官方推荐，还是装之。</p>
<h2 id="安装和配置memcached"><a href="#安装和配置memcached" class="headerlink" title="安装和配置memcached"></a>安装和配置memcached</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ apt install memcached python-memcache</div><div class="line">$ vi /etc/memcached.conf</div><div class="line"><span class="comment">#监听管理网络ip</span></div><div class="line"><span class="comment">#-l 127.0.0.1 改成下面这样</span></div><div class="line">-l controller <span class="comment"># 192.168.199.10</span></div></pre></td></tr></table></figure>
<h2 id="收尾-1"><a href="#收尾-1" class="headerlink" title="收尾"></a>收尾</h2><p>重启服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service memcached restart</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基本上环境已经搭好了，接下来就要安装各种服务了。😈</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://idiotsky.me/images/openstack-install-prepare-2-1.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images/openstack-install-prepare-2-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;上图是整个openstack的架构图，里面的椭圆方块都是openstack的服务，所以安装openstack就是要安装这些服务。&lt;/p&gt;
&lt;p&gt;按照官方建议，这次openstack安装的服务为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Identity service (keystone)&lt;/li&gt;
&lt;li&gt;Image service (glance)&lt;/li&gt;
&lt;li&gt;Compute service (nova)&lt;/li&gt;
&lt;li&gt;Networking service (neutron)&lt;/li&gt;
&lt;li&gt;Dashboard (horizon)&lt;/li&gt;
&lt;li&gt;Block Storage service (cinder)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="openstack" scheme="http://idiotsky.me/categories/openstack/"/>
    
    
      <category term="openstack" scheme="http://idiotsky.me/tags/openstack/"/>
    
      <category term="ubuntu" scheme="http://idiotsky.me/tags/ubuntu/"/>
    
      <category term="kvm" scheme="http://idiotsky.me/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>openstack安装准备(一)</title>
    <link href="http://idiotsky.me/2017/08/18/openstack-install-prepare-1/"/>
    <id>http://idiotsky.me/2017/08/18/openstack-install-prepare-1/</id>
    <published>2017-08-18T14:50:07.000Z</published>
    <updated>2017-09-02T13:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备VMware"><a href="#准备VMware" class="headerlink" title="准备VMware"></a>准备VMware</h1><p>由于我是习惯了mac上做实验，所以用VMware fusion，随便下个破解版即可。</p>
<h1 id="准备Ubuntu"><a href="#准备Ubuntu" class="headerlink" title="准备Ubuntu"></a>准备Ubuntu</h1><p>Ubuntu去官网下载16.04的服务器版本的ISO即可。</p>
<a id="more"></a>
<h1 id="准备网络"><a href="#准备网络" class="headerlink" title="准备网络"></a>准备网络</h1><p>这次实验用到两台虚拟机： controller,compute</p>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/hostname</div><div class="line">controller</div><div class="line"></div><div class="line">$ cat /etc/hosts</div><div class="line">127.0.0.1	localhost</div><div class="line">192.168.199.11  compute</div><div class="line">192.168.199.10  controller</div><div class="line"></div><div class="line">$ cat /etc/network/interfaces</div><div class="line"><span class="comment"># The loopback network interface</span></div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"><span class="comment"># The primary network interface</span></div><div class="line">auto ens33</div><div class="line">iface ens33 inet static</div><div class="line">address 192.168.199.10</div><div class="line">netmask 255.255.255.0</div><div class="line">gateway 192.168.199.1</div><div class="line">dns-nameservers 192.168.199.1</div><div class="line"></div><div class="line">auto ens34</div><div class="line">iface ens34 inet static</div><div class="line">address 10.170.56.10</div><div class="line">netmask 255.255.255.0</div><div class="line"></div><div class="line">auto ens35</div><div class="line">iface ens35 inet manual</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>接口</th>
<th>ip</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>ens33</td>
<td>192.168.199.10</td>
<td>桥接</td>
</tr>
<tr>
<td>ens34</td>
<td>10.170.56.10</td>
<td>私有</td>
</tr>
<tr>
<td>ens35</td>
<td>网关192.168.112.2</td>
<td>nat</td>
</tr>
</tbody>
</table>
<h2 id="compute"><a href="#compute" class="headerlink" title="compute"></a>compute</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/hostname</div><div class="line">compute</div><div class="line"></div><div class="line">$ cat /etc/hosts</div><div class="line">127.0.0.1	localhost</div><div class="line">192.168.199.11  compute</div><div class="line">192.168.199.10  controller</div><div class="line"></div><div class="line">$ cat /etc/network/interfaces</div><div class="line"><span class="comment"># The loopback network interface</span></div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"><span class="comment"># The primary network interface</span></div><div class="line">auto ens33</div><div class="line">iface ens33 inet static</div><div class="line">address 192.168.199.11</div><div class="line">netmask 255.255.255.0</div><div class="line">gateway 192.168.199.1</div><div class="line">dns-nameservers 192.168.199.1</div><div class="line"></div><div class="line">auto ens34</div><div class="line">iface ens34 inet static</div><div class="line">address 10.170.56.11</div><div class="line">netmask 255.255.255.0</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>接口</th>
<th>ip</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>ens33</td>
<td>192.168.199.11</td>
<td>桥接</td>
</tr>
<tr>
<td>ens34</td>
<td>10.170.56.11</td>
<td>私有</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>PS:</p>
<ul>
<li>桥接模式是虚拟机可以更物理机所在网络共享一套网络，例如跟物理机同一个WiFi里面的设备都可以访问物理机里面的虚拟机。这里用来做管理节点的网络。</li>
<li>私有模式代表虚拟机只能跟物理机作为一个网络，其他设备访问不了，一般可以用来做内部网络</li>
<li>nat模式用来给虚拟机访问互联网用</li>
</ul>
<p>PSPS:<br>接下来会在上面的两台虚拟机安装openstack，安装完openstack后，两台虚拟机对于openstack来说，就是物理机，通过openstack，创建的就是云主机（或者叫租户）了。所以必须要谨记这点。</p>
<p>PSPSPS:</p>
<ul>
<li>桥接模式的ip必须是你电脑所在网络的任意不冲突的同子网的ip</li>
<li>私有模式的ip可以任意一个子网下的ip，这个网络是用来做租户网络的</li>
<li>nat网络不用配ip，这个给租户用来访问外网的，接下来实验会再提及，注意下他的网关即可，它是你的VMware的nat的一个网关。</li>
</ul>
<p>上面网络配置好后，可以开搞了，至于怎么安装虚拟机和配置网络，可以搜索相关文章😈。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备VMware&quot;&gt;&lt;a href=&quot;#准备VMware&quot; class=&quot;headerlink&quot; title=&quot;准备VMware&quot;&gt;&lt;/a&gt;准备VMware&lt;/h1&gt;&lt;p&gt;由于我是习惯了mac上做实验，所以用VMware fusion，随便下个破解版即可。&lt;/p&gt;
&lt;h1 id=&quot;准备Ubuntu&quot;&gt;&lt;a href=&quot;#准备Ubuntu&quot; class=&quot;headerlink&quot; title=&quot;准备Ubuntu&quot;&gt;&lt;/a&gt;准备Ubuntu&lt;/h1&gt;&lt;p&gt;Ubuntu去官网下载16.04的服务器版本的ISO即可。&lt;/p&gt;
    
    </summary>
    
      <category term="openstack" scheme="http://idiotsky.me/categories/openstack/"/>
    
    
      <category term="openstack" scheme="http://idiotsky.me/tags/openstack/"/>
    
      <category term="ubuntu" scheme="http://idiotsky.me/tags/ubuntu/"/>
    
      <category term="kvm" scheme="http://idiotsky.me/tags/kvm/"/>
    
  </entry>
  
</feed>
