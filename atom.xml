<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IdiotSky</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://idiotsky.me/"/>
  <updated>2017-09-14T12:59:17.000Z</updated>
  <id>http://idiotsky.me/</id>
  
  <author>
    <name>ejunjsh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM杂谈之JIT</title>
    <link href="http://idiotsky.me/2017/09/14/java-jit/"/>
    <id>http://idiotsky.me/2017/09/14/java-jit/</id>
    <published>2017-09-14T14:41:24.000Z</published>
    <updated>2017-09-14T12:59:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Just-In-Time"><a href="#Just-In-Time" class="headerlink" title="Just In Time"></a>Just In Time</h1><p>Just in time编译，也叫做运行时编译，不同于 C / C++ 语言直接被翻译成机器指令，javac把java的源文件翻译成了class文件，而class文件中全都是Java字节码。那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。</p>
<p>还有一种，就是把这些Java字节码重新编译优化，生成机器码，让CPU直接执行。这样编出来的代码效率会更高。通常，我们不必把所有的Java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。这种调用最频繁的Java方法就是我们常说的热点方法（Hotspot，说不定这个虚拟机的名字就是从这里来的）。</p>
<p>这种在运行时按需编译的方式就是Just In Time。<br><a id="more"></a></p>
<h1 id="主要技术点"><a href="#主要技术点" class="headerlink" title="主要技术点"></a>主要技术点</h1><p>其实JIT的主要技术点，从大的框架上来说，非常简单，就是申请一块既有写权限又有执行权限的内存，然后把你要编译的Java方法，翻译成机器码，写入到这块内存里。当再需要调用原来的Java方法时，就转向调用这块内存。</p>
<p>我们看一个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, inc(<span class="number">3</span>));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个例子很简单，就是把3加1，然后打印出来，我们通过以下命令，查看一下它的机器码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># gcc -o inc inc.c</div><div class="line"># objdump -d inc</div></pre></td></tr></table></figure></p>
<p>然后在这一堆输出中，可以找到 inc 方法最终被翻译成了这样的机器码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">40052d:	55                   	push   %rbp</div><div class="line">40052e:	48 89 e5             	mov    %rsp,%rbp</div><div class="line">400531:	89 7d fc             	mov    %edi,-0x4(%rbp)</div><div class="line">400534:	8b 45 fc             	mov    -0x4(%rbp),%eax</div><div class="line">400537:	83 c0 01             	add    $0x1,%eax</div><div class="line">40053a:	5d                   	pop    %rbp</div><div class="line">40053b:	c3                   	retq</div></pre></td></tr></table></figure></p>
<p>我来解释一下（读者需要一定的x86汇编语言的知识）。</p>
<p>第一句，保存上一个栈帧的基址，并把当前的栈指针赋给栈基址寄存器，这是进入一个函数的常规操作。我们不去管它。</p>
<p>第三句，把edi存到栈上。在x64处理器上，前6个参数都是使用寄存器传参的。第一个参数会使用rdi，第二个参数使用 rsi，等等。所以 edi 里存的其实就是第一个参数，也就是整数 3，为什么使用rdi的低32位，也就是 edi 呢？因为我们的入参 a 是 int 型啊。大家可以换成 long 型看看效果。</p>
<p>第四句，把上一步存到栈上的那个整数再存进 eax 中。</p>
<p>第五句往后，把 eax 加上 1， 然后就退栈，返回。按照x64的规定（ABI），返回值通过eax传递。</p>
<p>我们看到了，其实第三句，第四句好像根本没有存在的必要，gcc 默认情况下，生成的机器码有点傻，它总要把入参放到栈上，但其实，我们是可以直接把参数从 rdi 中放入到 rax 中的。不满意。那我们可以自己改一下，让它更精简一点。怎么做呢？答案就是运行时修改 inc 的逻辑。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* inc_func)</span><span class="params">(<span class="keyword">int</span> a)</span></span>; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> code[] = &#123; </div><div class="line">        <span class="number">0x55</span>,             <span class="comment">// push rbp</span></div><div class="line">        <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe5</span>, <span class="comment">// mov rsp, rbp</span></div><div class="line">        <span class="number">0x89</span>, <span class="number">0xf8</span>,       <span class="comment">// mov edi, eax</span></div><div class="line">        <span class="number">0x83</span>, <span class="number">0xc0</span>, <span class="number">0x01</span>, <span class="comment">// add $1, eax</span></div><div class="line">        <span class="number">0x5d</span>,             <span class="comment">// pop rbp</span></div><div class="line">        <span class="number">0xc3</span>              <span class="comment">// ret</span></div><div class="line">    &#125;;  </div><div class="line"></div><div class="line">    <span class="keyword">void</span> * temp = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(code), PROT_WRITE | PROT_EXEC,</div><div class="line">            MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>); </div><div class="line"></div><div class="line">    <span class="built_in">memcpy</span>(temp, code, <span class="keyword">sizeof</span>(code));</div><div class="line">    inc_func p_inc = (inc_func)temp;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p_inc(<span class="number">7</span>));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，我们使用了 mmap 来申请了一块有写权限和执行权限的内存，然后把我们手写的机器码拷进去，然后使用一个函数指针指向这块内存，并且调用它。通过这种方式我们就可以执行这一段手写的机器码了。</p>
<p>运行一下看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># gcc -o inc_a inc_a.c </div><div class="line"># ./inc_a</div><div class="line">8</div></pre></td></tr></table></figure></p>
<p>再回想一下这个过程。我们通过手写机器码把原来的 inc 函数代替掉了。在新的例子中，我们是使用程序中定义的数据来重新造了一个 inc 函数。这种在运行的过程创建新的函数的方式，就是JIT的核心操作。</p>
<h1 id="解释器，C1和C2"><a href="#解释器，C1和C2" class="headerlink" title="解释器，C1和C2"></a>解释器，C1和C2</h1><p>在Hotspot中，解释器是为每一个字节码生成一小段机器码，在执行Java方法的过程中，每次取一条指令，然后就去执行这一个指令所对应的那一段机器码。256条指令，就组成了一个表，在这个表里，每一条指令都对应一段机器码，当执行到某一条指令时，就从这个表里去查这段机器码，并且通过 jmp 指令去执行这段机器码就行了。</p>
<p>这种方式被称为模板解释器。</p>
<p>模板解释器生成的代码有很多冗余，就像我们上面的第一个例子那样。为了生成更精简的机器码，我们可以引入编译器优化手段，例如全局值编码，死代码消除，标量展开，公共子表达式消除，常量传播等等。这样生成出来的机器码会更加优化。</p>
<p>但是，生成机器码的质量越高，所需要的时间也就越长。JIT线程也是要挤占Java 应用线程的资源的。所以C1是一个折衷，编译时间既不会太长，生成的机器码的指令也不是最优化的，但肯定比解释器的效率要高很多。</p>
<p>如果一个Java方法调用得足够频繁，那就更值得花大力气去为它生成更优质的机器码，这时就会触发C2编译，c2是一个运行得更慢，但却能生成更高效代码的编译器。</p>
<p>由此，我们看到，其实Java的运行，几乎全部都依赖运行时生成的机器码上。所以，对于文章开头的那个问题“Java是运行在C++上的吗？”，大家应该都有自己的答案了。这个问题无法简单地回答是或者不是，正确答案就是Java的运行依赖模板解释器和JIT编译器。</p>
<h1 id="多说一点优化"><a href="#多说一点优化" class="headerlink" title="多说一点优化"></a>多说一点优化</h1><p>我们这节课所举的例子中，可以做更多的优化，例如，既然我进到inc函数以后，完全没有使用栈，那其实，我就不要再为它开辟栈帧了。所以可以把push rbp, pop rbp的逻辑都去掉。</p>
<p>进一步优化成这样：<br>inc_b.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> code[] = &#123; </div><div class="line">    <span class="number">0x89</span>, <span class="number">0xf8</span>,       <span class="comment">// mov edi, eax</span></div><div class="line">    <span class="number">0x83</span>, <span class="number">0xc0</span>, <span class="number">0x01</span>, <span class="comment">// add $1, eax</span></div><div class="line">    <span class="number">0xc3</span>              <span class="comment">// ret</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以看到，指令更加精简了。我们重新编译运行，还是能成功打印出8。</p>
<p>根据这个问题：<a href="https://www.zhihu.com/question/61724266" target="_blank" rel="external">为什么 lea 会被用来计算？</a></p>
<p>我们还可以写出更优化的代码来：<br>inc_c.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> code[] = &#123; </div><div class="line">    <span class="number">0x8d</span>, <span class="number">0x47</span>, <span class="number">0x01</span>,    <span class="comment">// lea 0x1(rdi), rax</span></div><div class="line">    <span class="number">0xc3</span>                 <span class="comment">// ret</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果开启 gcc 的优化编译，我们也可以得到这样的代码，例如，还是针对这个方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 -O2 优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># gcc -o inc inc.c -O2</div><div class="line"># objdump -d inc</div></pre></td></tr></table></figure></p>
<p>就可以看到，inc 的机器码变成这样了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">00000000004005f0 &lt;inc&gt;:</div><div class="line">  4005f0:	8d 47 01             	lea    0x1(%rdi),%eax</div><div class="line">  4005f3:	c3                   	retq</div></pre></td></tr></table></figure></p>
<p>这和我们手写的优化的机器码是完全一样的了。</p>
<p>实际上，C1和C2所要做的和gcc的优化编译是一样的，就是使用特定的方法生成更高效的机器码。但是从原理上来说，运行时生成机器码这个技术，大家都是相通的。</p>
<p>代码<a href="https://github.com/ejunjsh/c-code/tree/master/inc" target="_blank" rel="external">https://github.com/ejunjsh/c-code/tree/master/inc</a><br>参考<a href="https://zhuanlan.zhihu.com/p/28476709" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/28476709</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Just-In-Time&quot;&gt;&lt;a href=&quot;#Just-In-Time&quot; class=&quot;headerlink&quot; title=&quot;Just In Time&quot;&gt;&lt;/a&gt;Just In Time&lt;/h1&gt;&lt;p&gt;Just in time编译，也叫做运行时编译，不同于 C / C++ 语言直接被翻译成机器指令，javac把java的源文件翻译成了class文件，而class文件中全都是Java字节码。那么，JVM在加载了这些class文件以后，针对这些字节码，逐条取出，逐条执行，这种方法就是解释执行。&lt;/p&gt;
&lt;p&gt;还有一种，就是把这些Java字节码重新编译优化，生成机器码，让CPU直接执行。这样编出来的代码效率会更高。通常，我们不必把所有的Java方法都编译成机器码，只需要把调用最频繁，占据CPU时间最长的方法找出来将其编译成机器码。这种调用最频繁的Java方法就是我们常说的热点方法（Hotspot，说不定这个虚拟机的名字就是从这里来的）。&lt;/p&gt;
&lt;p&gt;这种在运行时按需编译的方式就是Just In Time。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="jit" scheme="http://idiotsky.me/tags/jit/"/>
    
  </entry>
  
  <entry>
    <title>kafka学习（一）</title>
    <link href="http://idiotsky.me/2017/09/13/kafka-design/"/>
    <id>http://idiotsky.me/2017/09/13/kafka-design/</id>
    <published>2017-09-13T13:38:51.000Z</published>
    <updated>2017-09-14T13:18:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>to be continue</p>
</blockquote>
<a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;to be continue&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux epoll原理</title>
    <link href="http://idiotsky.me/2017/09/11/epoll-mechanism/"/>
    <id>http://idiotsky.me/2017/09/11/epoll-mechanism/</id>
    <published>2017-09-10T17:35:15.000Z</published>
    <updated>2017-09-13T12:54:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>epoll是Linux下的一种IO多路复用技术，可以非常高效的处理数以百万计的socket句柄。 </p>
</blockquote>
<p>先看看使用c封装的3个epoll系统调用：</p>
<ul>
<li><strong>int epoll_create(int size)</strong><br>  epoll_create建立一个epoll对象。参数size是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。</li>
<li><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</strong><br>  epoll_ctl可以操作epoll_create创建的epoll，如将socket句柄加入到epoll中让其监控，或把epoll正在监控的某个socket句柄移出epoll。</li>
<li><strong>int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout)</strong><br>  epoll_wait在调用时，在给定的timeout时间内，所监控的句柄中有事件发生时，就返回用户态的进程。</li>
</ul>
<a id="more"></a>
<p>大概看看epoll内部是怎么实现的：</p>
<ol>
<li>epoll初始化时，会向内核注册一个文件系统，用于存储被监控的句柄文件，调用epoll_create时，会在这个文件系统中创建一个file节点。同时epoll会开辟自己的内核高速缓存区，以红黑树的结构保存句柄，以支持快速的查找、插入、删除。还会再建立一个list链表，用于存储准备就绪的事件。</li>
<li>当执行epoll_ctl时，除了把socket句柄放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后，就把socket插入到就绪链表里。</li>
<li>当epoll_wait调用时，仅仅观察就绪链表里有没有数据，如果有数据就返回，否则就sleep，超时时立刻返回。</li>
</ol>
<p>epoll的两种工作模式：</p>
<ul>
<li><strong>LT</strong>：level-trigger，水平触发模式，只要某个socket处于readable/writable状态，无论什么时候进行epoll_wait都会返回该socket。</li>
<li><strong>ET</strong>：edge-trigger，边缘触发模式，只有某个socket从unreadable变为readable或从unwritable变为writable时，epoll_wait才会返回该socket。</li>
</ul>
<p>socket读数据<br><a href="/images/epoll-mechanism-1.png"><img src="/images/epoll-mechanism-1.png" alt=""></a></p>
<p>socket写数据<br><a href="/images/epoll-mechanism-2.png"><img src="/images/epoll-mechanism-2.png" alt=""></a></p>
<p>参考 <a href="http://www.jianshu.com/p/0d497fe5484a" target="_blank" rel="external">http://www.jianshu.com/p/0d497fe5484a</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;epoll是Linux下的一种IO多路复用技术，可以非常高效的处理数以百万计的socket句柄。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看看使用c封装的3个epoll系统调用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;int epoll_create(int size)&lt;/strong&gt;&lt;br&gt;  epoll_create建立一个epoll对象。参数size是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)&lt;/strong&gt;&lt;br&gt;  epoll_ctl可以操作epoll_create创建的epoll，如将socket句柄加入到epoll中让其监控，或把epoll正在监控的某个socket句柄移出epoll。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout)&lt;/strong&gt;&lt;br&gt;  epoll_wait在调用时，在给定的timeout时间内，所监控的句柄中有事件发生时，就返回用户态的进程。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux" scheme="http://idiotsky.me/categories/linux/"/>
    
    
      <category term="linux" scheme="http://idiotsky.me/tags/linux/"/>
    
      <category term="nio" scheme="http://idiotsky.me/tags/nio/"/>
    
      <category term="epoll" scheme="http://idiotsky.me/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>openstack安装-keystone</title>
    <link href="http://idiotsky.me/2017/09/09/openstack-install-keystone/"/>
    <id>http://idiotsky.me/2017/09/09/openstack-install-keystone/</id>
    <published>2017-09-09T07:46:36.000Z</published>
    <updated>2017-09-14T12:59:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>keystone 是openstack中所有service的权限管理和接口入口，所以先安装它<br>这一章都是在<code>controller</code>节点操作。。。</p>
</blockquote>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><ol>
<li><p>切换到<code>root</code>用户，执行下面命令</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysql</div></pre></td></tr></table></figure>
</li>
<li><p>创建<code>keystone</code>数据库:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MariaDB [(none)]&gt; CREATE DATABASE keystone;</div></pre></td></tr></table></figure>
</li>
<li><p>赋予合适权限给<code>keystone</code>数据库：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON keystone.* TO <span class="string">'keystone'</span>@<span class="string">'localhost'</span> \</div><div class="line">IDENTIFIED BY <span class="string">'KEYSTONE_DBPASS'</span>;</div><div class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON keystone.* TO <span class="string">'keystone'</span>@<span class="string">'%'</span> \</div><div class="line">IDENTIFIED BY <span class="string">'KEYSTONE_DBPASS'</span>;</div></pre></td></tr></table></figure>
<p> <strong>用一个合适的密码覆盖<code>KEYSTONE_DBPASS</code></strong></p>
</li>
<li>退出数据库</li>
</ol>
<a id="more"></a>
<h1 id="安装和配置组件"><a href="#安装和配置组件" class="headerlink" title="安装和配置组件"></a>安装和配置组件</h1><ol>
<li><p>运行下面命令安装包：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt install keystone  apache2 libapache2-mod-wsgi</div></pre></td></tr></table></figure>
</li>
<li><p>编辑<code>/etc/keystone/keystone.conf</code></p>
<ul>
<li><p>在<code>[database]</code> 区域，配置数据库访问连接：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[database]</div><div class="line"># ...</div><div class="line">connection = mysql+pymysql://keystone:KEYSTONE_DBPASS@controller/keystone</div></pre></td></tr></table></figure>
<p>  <strong>替换掉<code>KEYSTONE_DBPASS</code>,密码是上面配置的数据库密码</strong><br>  <strong>去掉这个区域里面其他关于<code>connection</code>的属性</strong></p>
</li>
<li>在<code>[token]</code> 区域，配置Fernet：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[token]</div><div class="line"># ...</div><div class="line">provider = fernet</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>部署身份服务（Identity service）数据库：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ su -s /bin/sh -c <span class="string">"keystone-manage db_sync"</span> keystone</div></pre></td></tr></table></figure>
</li>
<li><p>初始化Fernet</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ keystone-manage fernet_setup --keystone-user keystone --keystone-group keystone</div><div class="line">$ keystone-manage credential_setup --keystone-user keystone --keystone-group keystone</div></pre></td></tr></table></figure>
</li>
<li><p>启动身份服务（Identity service）</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ keystone-manage bootstrap --bootstrap-password ADMIN_PASS \</div><div class="line">--bootstrap-admin-url http://controller:35357/v3/ \</div><div class="line">--bootstrap-internal-url http://controller:5000/v3/ \</div><div class="line">--bootstrap-public-url http://controller:5000/v3/ \</div><div class="line">--bootstrap-region-id RegionOne</div></pre></td></tr></table></figure>
<p> <strong>替换<code>ADMIN_PASS</code></strong></p>
</li>
</ol>
<h1 id="配置Apache"><a href="#配置Apache" class="headerlink" title="配置Apache"></a>配置Apache</h1><p>因为这个服务是跑在Apache里面的，所以需要配置之。</p>
<ol>
<li><p>修改<code>/etc/apache2/apache2.conf</code>文件，配置<code>ServerName</code>选项：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ServerName controller</div></pre></td></tr></table></figure>
</li>
<li><p>重启</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service apache2 restart</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="编写admin环境变量脚本"><a href="#编写admin环境变量脚本" class="headerlink" title="编写admin环境变量脚本"></a>编写admin环境变量脚本</h1><p>创建一个<code>admin-openrc</code>文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">export OS_PROJECT_DOMAIN_NAME=Default</div><div class="line">export OS_USER_DOMAIN_NAME=Default</div><div class="line">export OS_PROJECT_NAME=admin</div><div class="line">export OS_USERNAME=admin</div><div class="line">export OS_PASSWORD=ADMIN_PASS</div><div class="line">export OS_AUTH_URL=http://controller:35357/v3</div><div class="line">export OS_IDENTITY_API_VERSION=3</div><div class="line">export OS_IMAGE_API_VERSION=2</div></pre></td></tr></table></figure></p>
<p><strong><code>ADMIN_PASS</code> 用上面的创建的密码替换掉这个</strong></p>
<h1 id="创建域-domain-项目-project-用户-users-和角色-roles"><a href="#创建域-domain-项目-project-用户-users-和角色-roles" class="headerlink" title="创建域(domain),项目(project),用户(users)和角色(roles)"></a>创建域(domain),项目(project),用户(users)和角色(roles)</h1><p>创建这些之前，先执行上面那个脚本，切换到admin用户。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. admin-openrc</div></pre></td></tr></table></figure></p>
<p>因为OpenStack默认创建了<code>default</code>的域，所以这次不用创建域了</p>
<ol>
<li><p>创建一个<code>service</code> project</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ openstack project create --domain default \</div><div class="line">--description <span class="string">"Service Project"</span> service</div><div class="line"></div><div class="line">+-------------+----------------------------------+</div><div class="line">| Field       | Value                            |</div><div class="line">+-------------+----------------------------------+</div><div class="line">| description | Service Project                  |</div><div class="line">| domain_id   | default                          |</div><div class="line">| enabled     | True                             |</div><div class="line">| id          | 24ac7f19cd944f4cba1d77469b2a73ed |</div><div class="line">| is_domain   | False                            |</div><div class="line">| name        | service                          |</div><div class="line">| parent_id   | default                          |</div><div class="line">+-------------+----------------------------------+</div></pre></td></tr></table></figure>
</li>
<li><p>创建<code>demo</code>project,user和role</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ openstack project create --domain default \</div><div class="line">--description <span class="string">"Demo Project"</span> demo</div><div class="line"></div><div class="line">+-------------+----------------------------------+</div><div class="line">| Field       | Value                            |</div><div class="line">+-------------+----------------------------------+</div><div class="line">| description | Demo Project                     |</div><div class="line">| domain_id   | default                          |</div><div class="line">| enabled     | True                             |</div><div class="line">| id          | 231ad6e7ebba47d6a1e57e1cc07ae446 |</div><div class="line">| is_domain   | False                            |</div><div class="line">| name        | demo                             |</div><div class="line">| parent_id   | default                          |</div><div class="line">+-------------+----------------------------------+</div></pre></td></tr></table></figure>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ openstack user create --domain default \</div><div class="line">--password-prompt demo</div><div class="line"></div><div class="line">User Password:</div><div class="line">Repeat User Password:</div><div class="line">+---------------------+----------------------------------+</div><div class="line">| Field               | Value                            |</div><div class="line">+---------------------+----------------------------------+</div><div class="line">| domain_id           | default                          |</div><div class="line">| enabled             | True                             |</div><div class="line">| id                  | aeda23aa78f44e859900e22c24817832 |</div><div class="line">| name                | demo                             |</div><div class="line">| options             | &#123;&#125;                               |</div><div class="line">| password_expires_at | None                             |</div><div class="line">+---------------------+----------------------------------+</div></pre></td></tr></table></figure>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ openstack role create user</div><div class="line"></div><div class="line">+-----------+----------------------------------+</div><div class="line">| Field     | Value                            |</div><div class="line">+-----------+----------------------------------+</div><div class="line">| domain_id | None                             |</div><div class="line">| id        | 997ce8d05fc143ac97d83fdfb5998552 |</div><div class="line">| name      | user                             |</div><div class="line">+-----------+----------------------------------+</div></pre></td></tr></table></figure>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openstack role add --project demo --user demo user</div></pre></td></tr></table></figure>
</li>
<li><p>创建demo用户的环境脚本<br> <code>demo-openrc</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">export OS_PROJECT_DOMAIN_NAME=Default</div><div class="line">export OS_USER_DOMAIN_NAME=Default</div><div class="line">export OS_PROJECT_NAME=demo</div><div class="line">export OS_USERNAME=demo</div><div class="line">export OS_PASSWORD=DEMO_PASS</div><div class="line">export OS_AUTH_URL=http://controller:5000/v3</div><div class="line">export OS_IDENTITY_API_VERSION=3</div><div class="line">export OS_IMAGE_API_VERSION=2</div></pre></td></tr></table></figure>
<p> <strong><code>DEMO_PASS</code></strong>替换成上一步创建demo用户时保存的密码<br> 好了现在执行一下这个脚本就切换到demo用户了</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. demo-openrc</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>切换到<code>admin</code>用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. admin-openrc</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ openstack token issue</div><div class="line"></div><div class="line">+------------+-----------------------------------------------------------------+</div><div class="line">| Field      | Value                                                           |</div><div class="line">+------------+-----------------------------------------------------------------+</div><div class="line">| expires    | 2016-02-12T20:44:35.659723Z                                     |</div><div class="line">| id         | gAAAAABWvjYj-Zjfg8WXFaQnUd1DMYTBVrKw4h3fIagi5NoEmh21U72SrRv2trl |</div><div class="line">|            | JWFYhLi2_uPR31Igf6A8mH2Rw9kv_bxNo1jbLNPLGzW_u5FC7InFqx0yYtTwa1e |</div><div class="line">|            | eq2b0f6-18KZyQhs7F3teAta143kJEWuNEYET-y7u29y0be1_64KYkM7E       |</div><div class="line">| project_id | 343d245e850143a096806dfaefa9afdc                                |</div><div class="line">| user_id    | ac3377633149401296f6c0d92d79dc16                                |</div><div class="line">+------------+-----------------------------------------------------------------+</div></pre></td></tr></table></figure>
<p>上面输出上面类似代表正常了。<code>demo</code>用户也是类似，这里就不演示了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里需要注意的是，用户的环境脚本，其实他只是方便切换用户的，就算不做，都可以通过把环境变量作为<code>openstack</code>命令参数来执行，例如上面验证可以用下面命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ openstack --os-auth-url http://controller:35357/v3 \</div><div class="line">  --os-project-domain-name Default --os-user-domain-name Default \</div><div class="line">  --os-project-name admin --os-username admin token issue</div><div class="line"></div><div class="line">Password: <span class="comment">#这里要输入admin密码</span></div><div class="line">+------------+-----------------------------------------------------------------+</div><div class="line">| Field      | Value                                                           |</div><div class="line">+------------+-----------------------------------------------------------------+</div><div class="line">| expires    | 2016-02-12T20:14:07.056119Z                                     |</div><div class="line">| id         | gAAAAABWvi7_B8kKQD9wdXac8MoZiQldmjEO643d-e_j-XXq9AmIegIbA7UHGPv |</div><div class="line">|            | atnN21qtOMjCFWX7BReJEQnVOAj3nclRQgAYRsfSU_MrsuWb4EDtnjU7HEpoBb4 |</div><div class="line">|            | o6ozsA_NmFWEpLeKy0uNn_WeKbAhYygrsmQGA49dclHVnz-OMVLiyM9ws       |</div><div class="line">| project_id | 343d245e850143a096806dfaefa9afdc                                |</div><div class="line">| user_id    | ac3377633149401296f6c0d92d79dc16                                |</div><div class="line">+------------+-----------------------------------------------------------------+</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;keystone 是openstack中所有service的权限管理和接口入口，所以先安装它&lt;br&gt;这一章都是在&lt;code&gt;controller&lt;/code&gt;节点操作。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;切换到&lt;code&gt;root&lt;/code&gt;用户，执行下面命令&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ mysql&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建&lt;code&gt;keystone&lt;/code&gt;数据库:&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;MariaDB [(none)]&amp;gt; CREATE DATABASE keystone;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;赋予合适权限给&lt;code&gt;keystone&lt;/code&gt;数据库：&lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;MariaDB [(none)]&amp;gt; GRANT ALL PRIVILEGES ON keystone.* TO &lt;span class=&quot;string&quot;&gt;&#39;keystone&#39;&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&#39;localhost&#39;&lt;/span&gt; \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;IDENTIFIED BY &lt;span class=&quot;string&quot;&gt;&#39;KEYSTONE_DBPASS&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;MariaDB [(none)]&amp;gt; GRANT ALL PRIVILEGES ON keystone.* TO &lt;span class=&quot;string&quot;&gt;&#39;keystone&#39;&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&#39;%&#39;&lt;/span&gt; \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;IDENTIFIED BY &lt;span class=&quot;string&quot;&gt;&#39;KEYSTONE_DBPASS&#39;&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; &lt;strong&gt;用一个合适的密码覆盖&lt;code&gt;KEYSTONE_DBPASS&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;退出数据库&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="openstack" scheme="http://idiotsky.me/categories/openstack/"/>
    
    
      <category term="openstack" scheme="http://idiotsky.me/tags/openstack/"/>
    
      <category term="ubuntu" scheme="http://idiotsky.me/tags/ubuntu/"/>
    
      <category term="kvm" scheme="http://idiotsky.me/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>go的变量和字面值的类型</title>
    <link href="http://idiotsky.me/2017/09/09/go-type-literal/"/>
    <id>http://idiotsky.me/2017/09/09/go-type-literal/</id>
    <published>2017-09-09T07:44:21.000Z</published>
    <updated>2017-09-09T08:40:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前几天逛v2ex，无聊看到一个关于这个的话题 <a href="https://www.v2ex.com/t/389157" target="_blank" rel="external">golang 的字面值与类型转换，来猜猜结果</a>，所以现在总结下，免得以后进坑。</p>
</blockquote>
<h1 id="论述"><a href="#论述" class="headerlink" title="论述"></a>论述</h1><p>先上代码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"> a := <span class="number">1</span></div><div class="line"> b := <span class="number">3</span></div><div class="line"> </div><div class="line"> fmt.Printf(<span class="string">"%T\n"</span>, a / b)</div><div class="line"> fmt.Printf(<span class="string">"%T\n"</span>, a / <span class="number">3</span>)</div><div class="line"> fmt.Printf(<span class="string">"%T\n"</span>, a / <span class="number">3.0</span>)</div><div class="line"> fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">1</span> / <span class="number">3</span>)</div><div class="line"> fmt.Printf(<span class="string">"%T\n"</span>, <span class="number">1</span> / <span class="number">3.0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">int</div><div class="line">int</div><div class="line">int</div><div class="line">float64</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>其实这里有奇怪的第三行和最后一行的输出结果，第三行里面a=1跟最后一行是一样的，为什么结果类型不一样呢，很明显这里有类型转换了，究竟谁类型转换了呢，继续上代码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"> a := <span class="number">1</span></div><div class="line"> </div><div class="line"> fmt.Println(a / <span class="number">3</span>)</div><div class="line"> fmt.Println(a / <span class="number">3.0</span>)</div><div class="line"> <span class="comment">//fmt.Println(a / 3.1) //类型错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0</div><div class="line">0</div><div class="line"># literal/test2/main.go:10: constant 3.1 truncated to integer</div></pre></td></tr></table></figure></p>
<p>很明显是字面值转换了类型，最后一行的3.1是转换不了整形的，所以就报错了，而3.0是没问题的，那为什么变量不会转换呢，继续上代码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	a := <span class="number">1</span></div><div class="line">	b := <span class="number">3.0</span></div><div class="line"></div><div class="line">	fmt.Printf(<span class="string">"%T\n"</span>, a)</div><div class="line">	fmt.Printf(<span class="string">"%T\n"</span>, b)</div><div class="line">    <span class="comment">//fmt.Printf("%T\n", a/b) //编译错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">float64</div><div class="line">#literal/test3/main.go:11: invalid operation: a / b (mismatched types int and float64)</div></pre></td></tr></table></figure></p>
<p>很明显变量类型在初始化赋值的时候就确定，在运算的时候变量不会去类型转换。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>go里面的变量运算是保证运算变量一定是相同类型才行，否则会编译错误，而且是初始赋值后就确定类型，不会在运算时自动帮你转换。但是字面值不同，在不同的场景会转换成不同的类型，当然前提是可以转换，否则就跟上面的例子3.1一样，没办法转换成整形而报错。<br>所有代码在 <a href="https://github.com/ejunjsh/go-code/tree/master/literal" target="_blank" rel="external">https://github.com/ejunjsh/go-code/tree/master/literal</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前几天逛v2ex，无聊看到一个关于这个的话题 &lt;a href=&quot;https://www.v2ex.com/t/389157&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;golang 的字面值与类型转换，来猜猜结果&lt;/a&gt;，所以现在总结下，免得以后进坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;论述&quot;&gt;&lt;a href=&quot;#论述&quot; class=&quot;headerlink&quot; title=&quot;论述&quot;&gt;&lt;/a&gt;论述&lt;/h1&gt;&lt;p&gt;先上代码&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; a := &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; b := &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%T\n&quot;&lt;/span&gt;, a / b)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%T\n&quot;&lt;/span&gt;, a / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%T\n&quot;&lt;/span&gt;, a / &lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%T\n&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; fmt.Printf(&lt;span class=&quot;string&quot;&gt;&quot;%T\n&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;float64&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript是如何工作的(二)</title>
    <link href="http://idiotsky.me/2017/08/26/javascript-how-work-2/"/>
    <id>http://idiotsky.me/2017/08/26/javascript-how-work-2/</id>
    <published>2017-08-26T03:08:09.000Z</published>
    <updated>2017-09-03T11:06:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>几个星期前，我们开始了一个系列，目标是深入理解javascript和它怎么工作的：通过这些我们可以更容易的写出好代码和apps。</p>
</blockquote>
<p><a href="/2017/08/26/javascript-how-work">系列的第一篇</a>主要是提供一个关于引擎，运行时和调用栈的概括。这篇文章将深入到Google V8 javascript 引擎。同时，还提供一些快速的意见令你能够写出好的javascript代码。<br><a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>一个javascript引擎是一个解释器也是个程序，它执行javascript代码。它可以被实现为一个标准解释器，也可以是一个即时（just-in-time）的编译器（以不同形式编译javascript成字节码）<br>下面是一个流行的javascript引擎的列表：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/V8_%28JavaScript_engine%29" target="_blank" rel="external">V8</a> — 谷歌开源的, 用 C++写的。</li>
<li><a href="https://en.wikipedia.org/wiki/Rhino_%28JavaScript_engine%29" target="_blank" rel="external">Rhino</a> — 由Mozilla基金会管理,开源的, 完全用java写的。</li>
<li><a href="https://en.wikipedia.org/wiki/SpiderMonkey_%28JavaScript_engine%29" target="_blank" rel="external">SpiderMonkey</a> — 第一个javascript引擎 Netscape Navigator开发,现在Firefox维护。</li>
<li><a href="https://en.wikipedia.org/wiki/JavaScriptCore" target="_blank" rel="external">JavaScriptCore</a> — 开源，由Apple开发 ，Safari浏览器的引擎。</li>
<li><a href="https://en.wikipedia.org/wiki/KJS_%28KDE%29" target="_blank" rel="external">KJS</a> — KDE的引擎，由 Harri Porten开发，是Konqueror桌面系统的浏览器引擎。</li>
<li><a href="https://en.wikipedia.org/wiki/Chakra_%28JScript_engine%29" target="_blank" rel="external">Chakra (JScript9)</a> — IE的</li>
<li><a href="https://en.wikipedia.org/wiki/Chakra_%28JavaScript_engine%29" target="_blank" rel="external">Chakra (JavaScript)</a> — 微软Edge</li>
<li><a href="https://en.wikipedia.org/wiki/Nashorn_%28JavaScript_engine%29" target="_blank" rel="external">Nashorn</a> -  OpenJDK的开源一部分, 由Oracle Java 语言和工具组开发</li>
<li><a href="https://en.wikipedia.org/wiki/JerryScript" target="_blank" rel="external">JerryScript</a> — 一个轻量级引擎.</li>
</ul>
<h1 id="为什么要创造一个V8引擎？"><a href="#为什么要创造一个V8引擎？" class="headerlink" title="为什么要创造一个V8引擎？"></a>为什么要创造一个V8引擎？</h1><p>V8引擎由Google创建并开源，c++编写。用于Google的Chrome浏览器。不像其他引擎，V8还是流行的Node.js的运行时引擎。<br><a href="/images/js-how-work-2-1.png"><img src="/images/js-how-work-2-1.png" alt=""></a><br>V8是第一个为了性能提升的浏览器引擎。为了达到更好的性能，相比于使用解释器，V8更倾向于使用编译器编译javascript代码成更高效的机器码。它像其他现代化javascript引擎如SpiderMonkey或者Rhino (Mozilla)一样，使用<strong>JIT(Just-In-Time)</strong>编译器在执行阶段编译代码，唯一不同的是，V8不会生成字节码或任意中间代码。</p>
<h1 id="V8曾经有两个编译器"><a href="#V8曾经有两个编译器" class="headerlink" title="V8曾经有两个编译器"></a>V8曾经有两个编译器</h1><p>在5.9版本发布（今年早些时候）之前，V8曾经有两个编译器：</p>
<ul>
<li>full-codegen — 一个简单快速的编译器，用来生成简单，相对慢的机器码。</li>
<li>Crankshaft - 一个更复杂(Just-In-Time) 优化的编译，用来生成更优的机器码。</li>
</ul>
<p>V8引擎内部也用了一些线程：</p>
<ul>
<li>正如你想的，主线程就是拿到代码，编译代码和执行代码。</li>
<li>还有些线程用来编译和优化代码，协助主线程，让主线程继续执行代码。</li>
<li>一个剖析器线程用来汇报哪些方法需要Crankshaft编译器优化。</li>
<li>其他一些线程用来做垃圾回收</li>
</ul>
<p>当开始执行javascript代码，V8运用<strong>full-codegen</strong>来直接翻译解析过的javascript代码为机器码，这个过程没有任何中间转换，所以执行机器码<strong>非常快</strong>.由于没有用到任何中间的字节码，所以就没有需要解释器的必要了。</p>
<p>当你的代码运行一段时间后，剖析器线程就能收集到足够的数据来确定哪些方法应该被优化。</p>
<p>接下来，<strong>Crankshaft</strong> 优化编译器开始运行在其他线程。它翻译javascript抽象语法树到一个高级别的<a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank" rel="external">静态单赋值(SSA)</a> 形态,又叫<strong>Hydrogen(氢？)</strong>。然后优化这个Hydrogen图。大部分的优化都在这个层次上完成。</p>
<h1 id="内联（inlining）"><a href="#内联（inlining）" class="headerlink" title="内联（inlining）"></a>内联（inlining）</h1><p>首个优化方法就是内联，它会提前尽可能的内联更多的代码。内联是一个替换代码的一个过程，用方法体替换到调用的地方（其实就是方法展开）。这样一步简单的优化可以令接下来的优化更有意义。<br><a href="/images/js-how-work-2-2.png"><img src="/images/js-how-work-2-2.png" alt=""></a></p>
<h1 id="隐藏类-Hidden-class"><a href="#隐藏类-Hidden-class" class="headerlink" title="隐藏类(Hidden class)"></a>隐藏类(Hidden class)</h1><p>javascript是一种基于原型的语言：没有类和对象是通过克隆进程创建的(机翻😁)。javascript也是一种动态语言，他能够随意的添加和删除一个对象的属性，即使这个对象已经实例化了。<br>大部分javascript解释器使用类字典的结构(基于<a href="http://en.wikipedia.org/wiki/Hash_function" target="_blank" rel="external">哈希函数</a>)来存储对象属性值在内存的位置。相比非动态语言如java和c#，这种结构使得取值是种计算昂贵的操作。对java来说，在编译之前就已经确定对象的属性，运行时也不能随意添加和删除属性的（当然，c#支持<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic" target="_blank" rel="external">动态类型</a>,那就在其他话题里了）。所以，属性的值（或者属性的指针）可以存储在一个连续的缓存里面，属性之间的位移更是固定的，而且位移的长度可以容易的基于属性类型来确定。这些对于javascript来说是不可能的，因为javascript的类型可以在运行时改变。<br>由于这种字典的取地址方式是不高效的，所以V8用了一个不同的方法来取代：隐藏类(Hidden class)。隐藏类的运作方式跟java的固定对象布局类似，除了它们是在运行时创建的。下面举个栗子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>一旦<code>new Point(1, 2)</code>被调用，V8将创建一个<code>C0</code>的隐藏类。<br><a href="/images/js-how-work-2-3.png"><img src="/images/js-how-work-2-3.png" alt=""></a><br>由于<code>Point</code>没有属性定义,所以<code>C0</code>是空的。</p>
<p>一旦<code>this.x = x</code>(在<code>Point</code>函数)被执行，V8将创建一个基于<code>C0</code>的隐藏类<code>C1</code>。<code>C1</code>描述了x的内存的位置（相对于对象指针），在这个情况下，x的位置存在<a href="http://en.wikipedia.org/wiki/Offset_%28computer_science%29" target="_blank" rel="external">位移</a>0上，这代表了<code>point</code>对象是一个连续的内存，它的第一个位移对应的是属性x。同时V8也用“类转换”更新了<code>C0</code>，表明了如果一个属性x加到<code>point</code>对象，隐藏类就应该要从<code>C0</code>转换到<code>C1</code>。所以现在<code>point</code>对象的隐藏类为<code>C1</code>。<br><a href="/images/js-how-work-2-4.png"><img src="/images/js-how-work-2-4.png" alt=""></a><br><small><em>每一次一个新的属性加到一个对象，一条转换的路径更新到旧的隐藏类并指向新的隐藏类。隐藏类转换是很重要的，因为同样方式创建的对象都共享同一个隐藏类。如果两个对象共享一个隐藏类，同时相同的属性加到这个两个对象的话，那么转换将保证这两个对象还是共享同一个新的隐藏类，而且共享同一个隐藏类有益于优化代码。</em></small></p>
<p>当<code>this.y = y</code>被执行，一个新的隐藏类<code>C1</code>被创建，同时一个类转换加到<code>C1</code>上面，表明了如果一个属性y加到一个<code>point</code>对象（已经有x属性的），就要把隐藏类转换成<code>C2</code>。现在<code>point</code>对象的隐藏类就是<code>C2</code>了。<br><a href="/images/js-how-work-2-5.png"><img src="/images/js-how-work-2-5.png" alt=""></a></p>
<p>隐藏类的转换依赖于属性的加入顺序。看一下下面的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">p1.a = <span class="number">5</span>;</div><div class="line">p1.b = <span class="number">6</span>;</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</div><div class="line">p2.b = <span class="number">7</span>;</div><div class="line">p2.a = <span class="number">8</span>;</div></pre></td></tr></table></figure></p>
<p>现在你肯定会认为p1和p2都是共享同一个隐藏类和转换路径，其实不然。对于p1，第一个属性是a再到b，而p2的话是先b在到a，所以p1和p2是分别两个不同的隐藏类和不同的两条转换路径。<strong>所以，对于动态属性最好是用相同的顺序加入到对象里面，这样有利于隐藏类的重用。</strong></p>
<h1 id="内联缓存-Inline-caching"><a href="#内联缓存-Inline-caching" class="headerlink" title="内联缓存(Inline caching)"></a>内联缓存(Inline caching)</h1><p>V8利用内联缓存技术来优化动态类型语言。内联缓存依赖于观察哪些方法在哪些相同的对象类型被重复调用。更深的介绍可以看<a href="https://github.com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-caches" target="_blank" rel="external">这里</a><br>我们用更通用的概念来说说内联缓存（如果你没时间去看上面的介绍的链接的话。）<br>所以，内联缓存是怎么工作的呢？V8维护一个对象类型的缓存，当一个对象做为参数传递到一个函数调用中，那V8会缓存这个对象，并假设这个对象会在未来会再一次作为参数传递到一个函数调用中。如果V8的这个假设是正确的话，在下次传递对象到一个方法调用的时候，就会绕过查找类型对象的属性的过程，直接使用之前查找隐藏类所储存的信息。</p>
<p>所以隐藏类和内联缓存是怎么样关联起来的呢？无论一个指定对象方法什么时候被执行，V8引擎都会去查找那个对象的隐藏类去决定指定属性的访问位移。在两次成功调用相同隐藏类的相同方法后，V8就会忽略隐藏类的查找并简单的用属性位移和这个对象指针相加来确定地址。对于未来的那个方法的调用，V8都假设这个对象的隐藏类都没有改变，直接使用之前查找后对象内存的位移来访问属性，这样大大增加执行速度。</p>
<p>相同类型的对象共享相同隐藏类是很重要的，原因是内存缓存。如果你创建两个相同类型的对象，但它们的隐藏类不同（前面例子有提到），V8将没办法用到内联缓存，因为尽管类型相同，但是它们对应的隐藏类分配的属性位移是不同的。<br><a href="/images/js-how-work-2-6.png"><img src="/images/js-how-work-2-6.png" alt=""></a><br><small><em>这两个对象基本上是一样的，但是a和b属性是用不同的顺序创建的。</em></small></p>
<h1 id="编译机器码"><a href="#编译机器码" class="headerlink" title="编译机器码"></a>编译机器码</h1><p>一旦Hydrogen图被优化，Crankshaft降低它为一个低级别的表述，称为Lithium。大多数Lithium实现是架构指定的。注册器分配发生在这个级别。</p>
<p>最后，Lithium被编译为机器码。有一些编译发生在OSR:栈中替换。在我们编译和优化一个明显长时间运行的方法时，我们有可能已经运行了这个方法了。V8不会忘了这个方法重新运行一个优化的版本的方法，而是转换所有的上下文（栈，注册器），这样就可以在执行中切换到优化版本。这是一个复杂的任务，记得在其他优化里，V8已经一开始就内联代码了。V8不是唯一有这能力的引擎。</p>
<p>这里有个保障是，一旦引擎的假设不成立的话，会把优化过的代码回滚回之前未优化的代码。这个保障称之为去优化（deoptimization）</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>对于垃圾回收，V8使用传统的分代标记清理的方式来清除旧的对象。标记的阶段一般都会停止javascript的执行。为了控制GC的成本和令执行更加稳定，V8用了递增标记来取代全堆标记。递增标记只是在部分堆中递增标记可能的对象，之后回到正常的代码执行。到下次执行GC的时候，会从上次GC标记的堆中开始。这样的话，停止时间很少。之前提及过，清理过程是在不同的线程执行的。</p>
<h1 id="Ignition和TurboFan"><a href="#Ignition和TurboFan" class="headerlink" title="Ignition和TurboFan"></a>Ignition和TurboFan</h1><p>V8的5.9版本在2017年初发布，一个新的执行管道被引入。这个新的管道使得V8在现实的javascript应用程序中达到更高的性能和更少内存使用。</p>
<p>新的执行管道由V8解释器<a href="https://github.com/v8/v8/wiki/Interpreter" target="_blank" rel="external">Ignition</a>和V8最新优化编译器<a href="https://github.com/v8/v8/wiki/TurboFan" target="_blank" rel="external">TurboFan</a> 组成。</p>
<p>你可以在<a href="https://v8project.blogspot.bg/2017/05/launching-ignition-and-turbofan.html" target="_blank" rel="external">这里</a>查阅来自V8团队的博客文章.</p>
<p>自从5.9版本的V8发布，full-codegen和Crankshaft（这两个技术从2010就开始服务V8了）不再被V8用来执行javascript，当V8团队要跟上新的javascript语言特性的步伐和这些特性更需要优化的支持。</p>
<p>这就意味着V8总体来讲将是一个更简单和更容易维护的架构。<br><a href="/images/js-how-work-2-7.png"><img src="/images/js-how-work-2-7.png" alt=""></a><br><small><em>在网页和Node.js的性能改进</em></small></p>
<p>这些改进只是个开始。新的Ignition和TurboFan为更长远的优化铺平了道路，并在这几年提升javascript的性能和缩小Node.js和Chrome的差距。</p>
<h1 id="怎么写出最好的javascript代码"><a href="#怎么写出最好的javascript代码" class="headerlink" title="怎么写出最好的javascript代码"></a>怎么写出最好的javascript代码</h1><p>最后，这里有些建议帮助你们写出更优更好的javascript。我想，当你看到这里，你心里已经有所感悟了，但是，我还是总结下吧：</p>
<ol>
<li>对象属性的顺序:初始化对象属性最好要按相同顺序，这样，他们的隐藏类和后续的优化代码能够共享。</li>
<li>动态属性：加一个动态属性会令一个对象的隐藏类改变，和拖慢任何一个方法，因为这个方法已经针对前一个隐藏类优化的了。所以，尽可能分配在构造函数里面分配所有的对象属性。</li>
<li>方法：重复执行相同的方法比一次执行许多不同的方法快（因为内联缓存）</li>
<li>数组：避免稀疏数组，因为它们的key不是递增的。稀疏数组并不是每个索引都有元素，所以它更像个哈希表。还有访问这样的数组是昂贵的。还有就是不要一次分配个大数组，最好按需分配。最后，不要在数组中删除元素，这样就令key稀疏了。</li>
<li>标签值：V8用32位来代表对象和数字。它用一位来区分对象（flag=1）和整形（flag=0），这个整形也叫SMI（SMall Integer）,因为它只有31位。这样的话，如果一个数字值大于31位，V8将会将它转化为一个double并使用一个对象把它装箱。尽可能使用31位的有符号数字，这样能够避免昂贵的装箱操作。</li>
</ol>
<p>翻译 <a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="external">https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;几个星期前，我们开始了一个系列，目标是深入理解javascript和它怎么工作的：通过这些我们可以更容易的写出好代码和apps。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/2017/08/26/javascript-how-work&quot;&gt;系列的第一篇&lt;/a&gt;主要是提供一个关于引擎，运行时和调用栈的概括。这篇文章将深入到Google V8 javascript 引擎。同时，还提供一些快速的意见令你能够写出好的javascript代码。&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://idiotsky.me/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://idiotsky.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript是如何工作的(一)</title>
    <link href="http://idiotsky.me/2017/08/26/javascript-how-work/"/>
    <id>http://idiotsky.me/2017/08/26/javascript-how-work/</id>
    <published>2017-08-25T17:17:54.000Z</published>
    <updated>2017-08-26T06:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>简评</strong>：JavaScript 是越来越受欢迎了，很多团队都在采用这些语言工作。前端、后端、嵌入式设备等等，都可以看见它的身影。虽然我们知其然，但又知其所以然吗？</p>
</blockquote>
<a id="more"></a>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>大家应该都知道 JavaScript 是单线程的，以及听过 V8 引擎的概念。<br>这篇文章将会介绍这些概念，并解释 JavaScript 是如何运行的。通过了解这些细节，开发者能更好地编写代码，正确利用其提供的 API。</p>
<h1 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h1><p>比较流行的一个 JavaScript 引擎示例就是 Google 的 V8 引擎。下图是 V8 引擎在 Chrome 和 Node.js 中使用的一个简化视图：<br><a href="/images/js-how-work.png"><img src="/images/js-how-work.png" alt=""></a></p>
<p>引擎主要由两个组件组成：</p>
<ul>
<li>内存堆（Memory Heap ）：这是内存分配的地方</li>
<li>调用堆栈（Call Stack）：这是程序运行时函数的调用过程</li>
</ul>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>在浏览器中，例如「setTimeout」这样的 API 已经有很多开发者在用了，然后引擎并没有提供这些 API，所以它们从哪里来的呢？<br>实际情况是这样的：<br><a href="/images/js-how-work-1.png"><img src="/images/js-how-work-1.png" alt=""></a><br>所以，除了引擎之外，还有浏览器提供的 Web API（像 DOM、AJAX、setTimeout 等等）。另外，还有事件循环（event loop）和回调队列（callback queue）。</p>
<h1 id="调用堆栈（Call-Stack）"><a href="#调用堆栈（Call-Stack）" class="headerlink" title="调用堆栈（Call Stack）"></a>调用堆栈（Call Stack）</h1><p>JavaScript 是单线程语言，这意味着它只有一个单一的调用堆栈。因此，它每次只能做一件事。</p>
<p>调用堆栈是一个数据结构，按调用顺序保存所有在运行期被调用的方法。既然是个栈，那么它就满足先入后出的特性。</p>
<p>我们来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * y;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> s = multiply(x, x);</div><div class="line">    <span class="built_in">console</span>.log(s);</div><div class="line">&#125;</div><div class="line">printSquare(<span class="number">5</span>);</div></pre></td></tr></table></figure></p>
<p>当引擎开始执行这段代码时，调用堆栈将为空。然后，就会有以下步骤：<br><a href="/images/js-how-work-2.png"><img src="/images/js-how-work-2.png" alt=""></a></p>
<p>调用堆栈中的每个条目称为堆栈帧（Stack Frame）。当异常发生时，它基本上是调用堆栈的状态。再看看下面这段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'SessionStack will help you resolve crashes :)'</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    foo();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    bar();</div><div class="line">&#125;</div><div class="line">start();</div></pre></td></tr></table></figure></p>
<p>如果这是在 Chrome 中执行（假设此代码位于一个名为 foo.js 的文件中），则会产生这种情况：<br><a href="/images/js-how-work-3.png"><img src="/images/js-how-work-3.png" alt=""></a></p>
<p>当你达到最大调用堆栈时，会容易发生这种情况，特别是在没有测试代码时随意使用递归。<br>看看这个示例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    foo();</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p>
<p>代码执行时，首先调用函数「foo」。然而，这是递归函数，调用自身的同时又没有设置终止条件，所以每一次执行，相同的函数都会被添加进堆栈中，看起来就是这样：<br><a href="/images/js-how-work-4.png"><img src="/images/js-how-work-4.png" alt=""></a><br>某些时候，调用堆栈中的函数调用次数超过了调用堆栈的实际大小，那么浏览器就会抛出一个错误，看起来像这样：<br><a href="/images/js-how-work-5.png"><img src="/images/js-how-work-5.png" alt=""></a><br>单线程上编写代码相对多线程来说会简单得多，你不必考虑死锁这样的复杂场景。但单线程也有许多限制，由于 JavaScript 有调用堆栈，当执行代码需要耗费大量时间时是怎样的呢？</p>
<h1 id="并发和事件循环"><a href="#并发和事件循环" class="headerlink" title="并发和事件循环"></a>并发和事件循环</h1><p>当你在调用堆栈中进行函数调用，有时候需要大量时间才能进行处理。例如在浏览器中使用JavaScript 进行一些复杂的图像转换。在这个过程中又发生了什么？<br>这个问题的产生是因为，虽然调用堆栈具有执行的功能，但浏览器本身是无法渲染也不能运行其他任何代码，它被卡住了。当你想执行一套流畅的 UI 时，就会产生这样的问题。大多数浏览器通过抛出异常处理错误，询问用户是否要终止网页：<br><a href="/images/js-how-work-6.jpg"><img src="/images/js-how-work-6.jpg" alt=""></a><br>这个用户体验很糟糕。那么如何解决呢？答案是异步回调（asynchronous callbacks）。这是后话，下次再讲。</p>
<p>翻译和参考 <a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf" target="_blank" rel="external">https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;简评&lt;/strong&gt;：JavaScript 是越来越受欢迎了，很多团队都在采用这些语言工作。前端、后端、嵌入式设备等等，都可以看见它的身影。虽然我们知其然，但又知其所以然吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://idiotsky.me/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://idiotsky.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>openstack安装准备(二)-环境的安装</title>
    <link href="http://idiotsky.me/2017/08/19/openstack-install-prepare-2/"/>
    <id>http://idiotsky.me/2017/08/19/openstack-install-prepare-2/</id>
    <published>2017-08-19T14:50:07.000Z</published>
    <updated>2017-09-13T13:08:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/openstack-install-prepare-2-1.png"><img src="/images/openstack-install-prepare-2-1.png" alt=""></a><br>上图是整个openstack的架构图，里面的椭圆方块都是openstack的服务，所以安装openstack就是要安装这些服务。</p>
<p>按照官方建议，这次openstack安装的服务为：</p>
<ul>
<li>Identity service (keystone)</li>
<li>Image service (glance)</li>
<li>Compute service (nova)</li>
<li>Networking service (neutron)</li>
<li>Dashboard (horizon)</li>
<li>Block Storage service (cinder)</li>
</ul>
<a id="more"></a>
<p>在安装上面服务前，先要弄好环境的😁<br>这次安装的openstack为最新的release，<strong>pike</strong></p>
<h1 id="安装openstack仓库"><a href="#安装openstack仓库" class="headerlink" title="安装openstack仓库"></a>安装openstack仓库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># change to root</span></div><div class="line">$ sudo -i</div><div class="line">$ apt install software-properties-common</div><div class="line">$ add-apt-repository cloud-archive:pike</div><div class="line">$ apt update &amp;&amp; apt dist-upgrade</div><div class="line">$ apt install python-openstackclient</div></pre></td></tr></table></figure>
<p>上面的步骤两个节点都要安装。<br><strong>以下步骤安装在controller</strong></p>
<h1 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h1><p>openstack所用到的数据都会存到数据库里，所以安装一个数据库是准备的一个重要步骤。mariadb是官方建议的数据库。</p>
<h2 id="安装和配置mariadb"><a href="#安装和配置mariadb" class="headerlink" title="安装和配置mariadb"></a>安装和配置mariadb</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ apt install mariadb-server python-pymysql</div><div class="line">$ vi /etc/mysql/mariadb.conf.d/99-openstack.cnf</div><div class="line"><span class="comment"># 加一个[mysqld]区，bind-address为管理网络ip</span></div><div class="line">[mysqld]</div><div class="line"><span class="built_in">bind</span>-address = controller <span class="comment"># 192.168.199.10 </span></div><div class="line"></div><div class="line">default-storage-engine = innodb</div><div class="line">innodb_file_per_table = on</div><div class="line">max_connections = 4096</div><div class="line">collation-server = utf8_general_ci</div><div class="line">character-set-server = utf8</div></pre></td></tr></table></figure>
<h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>重启服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service mysql restart</div></pre></td></tr></table></figure></p>
<p>设置下root用户的密码，这个密码后面要用到，务必谨记。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mysql_secure_installation</div></pre></td></tr></table></figure></p>
<h1 id="安装消息队列"><a href="#安装消息队列" class="headerlink" title="安装消息队列"></a>安装消息队列</h1><p>openstack用消息队列来异步控制各种service，所以要装一个，rabbitmq是官方推荐，装之。</p>
<h2 id="安装和配置rabbitmq"><a href="#安装和配置rabbitmq" class="headerlink" title="安装和配置rabbitmq"></a>安装和配置rabbitmq</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt install rabbitmq-server</div></pre></td></tr></table></figure>
<p>加一个openstack用户。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rabbitmqctl add_user openstack RABBIT_PASS <span class="comment">#用你的密码替换下RABBIT_PASS，谨记这个密码，后面有用。</span></div></pre></td></tr></table></figure></p>
<p>赋予更多权限给openstack用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rabbitmqctl set_permissions openstack <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></div></pre></td></tr></table></figure></p>
<h1 id="安装缓存"><a href="#安装缓存" class="headerlink" title="安装缓存"></a>安装缓存</h1><p>openstack用到缓存，memcached是官方推荐，还是装之。</p>
<h2 id="安装和配置memcached"><a href="#安装和配置memcached" class="headerlink" title="安装和配置memcached"></a>安装和配置memcached</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ apt install memcached python-memcache</div><div class="line">$ vi /etc/memcached.conf</div><div class="line"><span class="comment">#监听管理网络ip</span></div><div class="line"><span class="comment">#-l 127.0.0.1 改成下面这样</span></div><div class="line">-l controller <span class="comment"># 192.168.199.10</span></div></pre></td></tr></table></figure>
<h2 id="收尾-1"><a href="#收尾-1" class="headerlink" title="收尾"></a>收尾</h2><p>重启服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service memcached restart</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基本上环境已经搭好了，接下来就要安装各种服务了。😈</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/openstack-install-prepare-2-1.png&quot;&gt;&lt;img src=&quot;/images/openstack-install-prepare-2-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;上图是整个openstack的架构图，里面的椭圆方块都是openstack的服务，所以安装openstack就是要安装这些服务。&lt;/p&gt;
&lt;p&gt;按照官方建议，这次openstack安装的服务为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Identity service (keystone)&lt;/li&gt;
&lt;li&gt;Image service (glance)&lt;/li&gt;
&lt;li&gt;Compute service (nova)&lt;/li&gt;
&lt;li&gt;Networking service (neutron)&lt;/li&gt;
&lt;li&gt;Dashboard (horizon)&lt;/li&gt;
&lt;li&gt;Block Storage service (cinder)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="openstack" scheme="http://idiotsky.me/categories/openstack/"/>
    
    
      <category term="openstack" scheme="http://idiotsky.me/tags/openstack/"/>
    
      <category term="ubuntu" scheme="http://idiotsky.me/tags/ubuntu/"/>
    
      <category term="kvm" scheme="http://idiotsky.me/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>openstack安装准备(一)</title>
    <link href="http://idiotsky.me/2017/08/18/openstack-install-prepare-1/"/>
    <id>http://idiotsky.me/2017/08/18/openstack-install-prepare-1/</id>
    <published>2017-08-18T14:50:07.000Z</published>
    <updated>2017-09-02T13:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备VMware"><a href="#准备VMware" class="headerlink" title="准备VMware"></a>准备VMware</h1><p>由于我是习惯了mac上做实验，所以用VMware fusion，随便下个破解版即可。</p>
<h1 id="准备Ubuntu"><a href="#准备Ubuntu" class="headerlink" title="准备Ubuntu"></a>准备Ubuntu</h1><p>Ubuntu去官网下载16.04的服务器版本的ISO即可。</p>
<a id="more"></a>
<h1 id="准备网络"><a href="#准备网络" class="headerlink" title="准备网络"></a>准备网络</h1><p>这次实验用到两台虚拟机： controller,compute</p>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/hostname</div><div class="line">controller</div><div class="line"></div><div class="line">$ cat /etc/hosts</div><div class="line">127.0.0.1	localhost</div><div class="line">192.168.199.11  compute</div><div class="line">192.168.199.10  controller</div><div class="line"></div><div class="line">$ cat /etc/network/interfaces</div><div class="line"><span class="comment"># The loopback network interface</span></div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"><span class="comment"># The primary network interface</span></div><div class="line">auto ens33</div><div class="line">iface ens33 inet static</div><div class="line">address 192.168.199.10</div><div class="line">netmask 255.255.255.0</div><div class="line">gateway 192.168.199.1</div><div class="line">dns-nameservers 192.168.199.1</div><div class="line"></div><div class="line">auto ens34</div><div class="line">iface ens34 inet static</div><div class="line">address 10.170.56.10</div><div class="line">netmask 255.255.255.0</div><div class="line"></div><div class="line">auto ens35</div><div class="line">iface ens35 inet manual</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>接口</th>
<th>ip</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>ens33</td>
<td>192.168.199.10</td>
<td>桥接</td>
</tr>
<tr>
<td>ens34</td>
<td>10.170.56.10</td>
<td>私有</td>
</tr>
<tr>
<td>ens35</td>
<td>网关192.168.112.2</td>
<td>nat</td>
</tr>
</tbody>
</table>
<h2 id="compute"><a href="#compute" class="headerlink" title="compute"></a>compute</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/hostname</div><div class="line">compute</div><div class="line"></div><div class="line">$ cat /etc/hosts</div><div class="line">127.0.0.1	localhost</div><div class="line">192.168.199.11  compute</div><div class="line">192.168.199.10  controller</div><div class="line"></div><div class="line">$ cat /etc/network/interfaces</div><div class="line"><span class="comment"># The loopback network interface</span></div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"><span class="comment"># The primary network interface</span></div><div class="line">auto ens33</div><div class="line">iface ens33 inet static</div><div class="line">address 192.168.199.11</div><div class="line">netmask 255.255.255.0</div><div class="line">gateway 192.168.199.1</div><div class="line">dns-nameservers 192.168.199.1</div><div class="line"></div><div class="line">auto ens34</div><div class="line">iface ens34 inet static</div><div class="line">address 10.170.56.11</div><div class="line">netmask 255.255.255.0</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>接口</th>
<th>ip</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>ens33</td>
<td>192.168.199.11</td>
<td>桥接</td>
</tr>
<tr>
<td>ens34</td>
<td>10.170.56.11</td>
<td>私有</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>PS:</p>
<ul>
<li>桥接模式是虚拟机可以更物理机所在网络共享一套网络，例如跟物理机同一个WiFi里面的设备都可以访问物理机里面的虚拟机。这里用来做管理节点的网络。</li>
<li>私有模式代表虚拟机只能跟物理机作为一个网络，其他设备访问不了，一般可以用来做内部网络</li>
<li>nat模式用来给虚拟机访问互联网用</li>
</ul>
<p>PSPS:<br>接下来会在上面的两台虚拟机安装openstack，安装完openstack后，两台虚拟机对于openstack来说，就是物理机，通过openstack，创建的就是云主机（或者叫租户）了。所以必须要谨记这点。</p>
<p>PSPSPS:</p>
<ul>
<li>桥接模式的ip必须是你电脑所在网络的任意不冲突的同子网的ip</li>
<li>私有模式的ip可以任意一个子网下的ip，这个网络是用来做租户网络的</li>
<li>nat网络不用配ip，这个给租户用来访问外网的，接下来实验会再提及，注意下他的网关即可，它是你的VMware的nat的一个网关。</li>
</ul>
<p>上面网络配置好后，可以开搞了，至于怎么安装虚拟机和配置网络，可以搜索相关文章😈。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备VMware&quot;&gt;&lt;a href=&quot;#准备VMware&quot; class=&quot;headerlink&quot; title=&quot;准备VMware&quot;&gt;&lt;/a&gt;准备VMware&lt;/h1&gt;&lt;p&gt;由于我是习惯了mac上做实验，所以用VMware fusion，随便下个破解版即可。&lt;/p&gt;
&lt;h1 id=&quot;准备Ubuntu&quot;&gt;&lt;a href=&quot;#准备Ubuntu&quot; class=&quot;headerlink&quot; title=&quot;准备Ubuntu&quot;&gt;&lt;/a&gt;准备Ubuntu&lt;/h1&gt;&lt;p&gt;Ubuntu去官网下载16.04的服务器版本的ISO即可。&lt;/p&gt;
    
    </summary>
    
      <category term="openstack" scheme="http://idiotsky.me/categories/openstack/"/>
    
    
      <category term="openstack" scheme="http://idiotsky.me/tags/openstack/"/>
    
      <category term="ubuntu" scheme="http://idiotsky.me/tags/ubuntu/"/>
    
      <category term="kvm" scheme="http://idiotsky.me/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>一张图了解三色标记法</title>
    <link href="http://idiotsky.me/2017/08/16/gc-three-color/"/>
    <id>http://idiotsky.me/2017/08/16/gc-three-color/</id>
    <published>2017-08-15T17:02:35.000Z</published>
    <updated>2017-08-20T03:32:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/gc-1.gif"><img src="/images/gc-1.gif" alt=""></a><br><a id="more"></a><br>三色标记法是传统 Mark-Sweep 的一个改进，它是一个并发的 GC 算法。<br>原理如下，</p>
<ol>
<li>首先创建三个集合：白、灰、黑。</li>
<li>将所有对象放入白色集合中。</li>
<li>然后从根节点开始遍历所有对象（注意这里并不<strong>递归遍历</strong>），把遍历到的对象从白色集合放入灰色集合。</li>
<li>之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</li>
<li>重复 4 直到灰色中无任何对象</li>
<li>通过write-barrier检测对象有变化，重复以上操作</li>
<li>收集所有白色对象（垃圾）</li>
</ol>
<p>这个算法可以实现 “on-the-fly”，也就是在程序执行的同时进行收集，并不需要暂停整个程序。<br>但是也会有一个缺陷，可能程序中的垃圾产生的速度会大于垃圾收集的速度，这样会导致程序中的垃圾越来越多无法被收集掉。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/gc-1.gif&quot;&gt;&lt;img src=&quot;/images/gc-1.gif&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="gc" scheme="http://idiotsky.me/tags/gc/"/>
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>一张图了解标记清除算法</title>
    <link href="http://idiotsky.me/2017/08/16/gc-mark-sweep/"/>
    <id>http://idiotsky.me/2017/08/16/gc-mark-sweep/</id>
    <published>2017-08-15T17:02:21.000Z</published>
    <updated>2017-08-15T17:06:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/gc.gif"><img src="/images/gc.gif" alt=""></a><br><a id="more"></a><br>这个算法分为两步，标记和清除。</p>
<ul>
<li>标记：从程序的根节点开始， 递归地 遍历所有对象，将能遍历到的对象打上标记。</li>
<li>清除：讲所有未标记的的对象当作垃圾销毁。</li>
</ul>
<p>但是这个算法也有一个缺陷，就是人们常常说的 STW 问题（Stop The World）。因为算法在标记时必须暂停整个程序，否则其他线程的代码可能会改变对象状态，从而可能把不应该回收的对象当做垃圾收集掉。<br>当程序中的对象逐渐增多时，递归遍历整个对象树会消耗很多的时间，在大型程序中这个时间可能会是毫秒级别的。让所有的用户等待几百毫秒的 GC 时间这是不能容忍的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/gc.gif&quot;&gt;&lt;img src=&quot;/images/gc.gif&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="gc" scheme="http://idiotsky.me/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>postman的几种body的使用介绍</title>
    <link href="http://idiotsky.me/2017/08/10/postman/"/>
    <id>http://idiotsky.me/2017/08/10/postman/</id>
    <published>2017-08-10T12:11:55.000Z</published>
    <updated>2017-08-15T16:51:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>postman,用来模拟发送http请求的工具，里面涉及的请求body有以下几个类型，所以记下，而且也能理解http body的几种格式，分享之。。</p>
</blockquote>
<a id="more"></a>
<h1 id="form-data"><a href="#form-data" class="headerlink" title="form-data"></a>form-data</h1><p>就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来表名文件类型；content-disposition，用来说明字段的一些信息；<br>由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。</p>
<p><a href="/images/postman-1.png"><img src="/images/postman-1.png" alt=""></a><br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">POST /login HTTP/1.1</div><div class="line">Host: 10.170.56.67</div><div class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Cache-Control: no-cache</div><div class="line">Postman-Token: 9843651a-5bf9-0544-03c1-fcc2a16f484b</div><div class="line"></div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;username&quot;</div><div class="line"></div><div class="line">admin</div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;password&quot;</div><div class="line"></div><div class="line">admin123</div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;abc&quot;; filename=&quot;&quot;</div><div class="line">Content-Type: </div><div class="line"></div><div class="line"></div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</div><div class="line">Content-Disposition: form-data; name=&quot;tttt&quot;; filename=&quot;&quot;</div><div class="line">Content-Type: </div><div class="line"></div><div class="line"></div><div class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</div></pre></td></tr></table></figure></p>
<h1 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h1><p>就是application/x-www-from-urlencoded,会将表单内的数据转换为键值对，并以urlencode为格式<br><a href="/images/postman-2.png"><img src="/images/postman-2.png" alt=""></a><br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">POST /login HTTP/1.1</div><div class="line">Host: 10.170.56.67</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Cache-Control: no-cache</div><div class="line">Postman-Token: e6887900-a46e-2ff4-8232-de878b75f5fd</div><div class="line"></div><div class="line">username=admin&amp;password=admin123</div></pre></td></tr></table></figure></p>
<h1 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h1><p>可以上传任意格式的文本，可以上传text、json、xml、html等<br><a href="/images/postman-3.png"><img src="/images/postman-3.png" alt=""></a><br>内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">POST /login HTTP/1.1</div><div class="line">Host: 10.170.56.67</div><div class="line">Content-Type: application/json</div><div class="line">Cache-Control: no-cache</div><div class="line">Postman-Token: 233df0e0-c6d9-98c7-4d7e-736329322683</div><div class="line"></div><div class="line">&#123;</div><div class="line">  &quot;abc&quot;:&quot;cba&quot;,</div><div class="line">  &quot;cba&quot;:&quot;abc&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从图片和内容对比，可以发现，基本，粘什么，就发什么，不会进行任何转意。</p>
<h1 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h1><p>相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。</p>
<h1 id="multipart-form-data与x-www-form-urlencoded区别"><a href="#multipart-form-data与x-www-form-urlencoded区别" class="headerlink" title="multipart/form-data与x-www-form-urlencoded区别"></a>multipart/form-data与x-www-form-urlencoded区别</h1><ul>
<li>multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息；</li>
<li>x-www-form-urlencoded：只能上传键值对，并且键值对都是间隔分开的</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;postman,用来模拟发送http请求的工具，里面涉及的请求body有以下几个类型，所以记下，而且也能理解http body的几种格式，分享之。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="http" scheme="http://idiotsky.me/categories/http/"/>
    
    
      <category term="postman" scheme="http://idiotsky.me/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>go的是否需要用goroutine pool？</title>
    <link href="http://idiotsky.me/2017/08/03/go-worker-pool-if-need/"/>
    <id>http://idiotsky.me/2017/08/03/go-worker-pool-if-need/</id>
    <published>2017-08-03T15:10:02.000Z</published>
    <updated>2017-08-05T14:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这几天无聊，想到java有自己的线程池，是否对应go也有它的goroutine pool呢，所以搜了下，标准库没有，github有，但都大同小异，所以自己实现了一个。</p>
</blockquote>
<a id="more"></a>
<h1 id="一个简单的goroutine-pool"><a href="#一个简单的goroutine-pool" class="headerlink" title="一个简单的goroutine pool"></a>一个简单的goroutine pool</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> workerpool</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> task <span class="function"><span class="keyword">func</span><span class="params">()</span></span></div><div class="line"></div><div class="line"><span class="title">type</span> <span class="title">worker</span> <span class="title">struct</span> &#123;</div><div class="line">	stopC <span class="keyword">chan</span> <span class="keyword">bool</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> WorkerPool <span class="keyword">struct</span> &#123;</div><div class="line">	num <span class="keyword">int</span></div><div class="line">	sync.Mutex</div><div class="line">	taskQ <span class="keyword">chan</span> task</div><div class="line">	workers []*worker</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorkerPool</span><span class="params">(workerNum <span class="keyword">int</span>,queueCap <span class="keyword">int</span>)</span> *<span class="title">WorkerPool</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> &amp;WorkerPool&#123;num:workerNum,taskQ:<span class="built_in">make</span>(<span class="keyword">chan</span> task,queueCap),workers:<span class="built_in">make</span>([]*worker,workerNum)&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span> <span class="title">Execute</span><span class="params">(t task)</span></span>&#123;</div><div class="line">	wp.taskQ&lt;-t</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span> <span class="title">Start</span><span class="params">()</span> *<span class="title">WorkerPool</span></span>&#123;</div><div class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;wp.num;i++&#123;</div><div class="line">		wp.workers[i]=&amp;worker&#123; <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)&#125;</div><div class="line">		w:=wp.workers[i]</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> &#123;</div><div class="line">				    stop:=<span class="literal">false</span></div><div class="line">					<span class="keyword">select</span> &#123;</div><div class="line">					    <span class="keyword">case</span> f:=&lt;-wp.taskQ:</div><div class="line">							f()</div><div class="line">					    <span class="keyword">case</span> stop=&lt;-w.stopC:</div><div class="line">						     <span class="keyword">break</span></div><div class="line"></div><div class="line">					&#125;</div><div class="line"></div><div class="line">				<span class="keyword">if</span> stop&#123;</div><div class="line">					<span class="keyword">break</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			fmt.Println(<span class="string">"stop"</span>)</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> wp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *WorkerPool)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">for</span> _,w:=<span class="keyword">range</span> wp.workers&#123;</div><div class="line">		w.stopC&lt;- <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很简单，就是<code>NewWorkerPool</code>一个池子的时候设置goroutine的数量和任务队列的大小。<code>Start</code>后就创建那么多goroutine去任务队列取任务执行，取不到任务就自循。<code>Execute</code>方法是把任务压进队列，如果队列满了就阻塞。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>要测试性能，肯定要有对比，以下是没有使用pool:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">nopool</span><span class="params">()</span></span> &#123;</div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">    <span class="comment">//执行1000000次，每次都启动一个goroutine</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			<span class="keyword">defer</span> wg.Done()</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	wg.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下是简单版的只是单纯限制goroutine数量和任务队列的代码，没有任何封装的:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopool</span><span class="params">()</span></span> &#123;</div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">    <span class="comment">//队列100</span></div><div class="line">	data := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</div><div class="line"></div><div class="line">    <span class="comment">//goroutine 数量10个</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">			<span class="keyword">defer</span> wg.Done()</div><div class="line">			<span class="keyword">for</span> _ = <span class="keyword">range</span> data &#123;</div><div class="line">				<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</div><div class="line">					<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</div><div class="line"></div><div class="line">					&#125;</div><div class="line">				&#125;()</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="comment">//执行1000000个任务</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</div><div class="line">		data &lt;- i</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">close</span>(data)</div><div class="line">	wg.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是主角:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">workerpool</span><span class="params">()</span></span> &#123;</div><div class="line">	wg := <span class="built_in">new</span>(sync.WaitGroup)</div><div class="line">    <span class="comment">//十个goroutine，队列容量100</span></div><div class="line">	wp:=NewWorkerPool(<span class="number">10</span>,<span class="number">100</span>)</div><div class="line">	wp.Start()</div><div class="line">    <span class="comment">//提交1000000任务</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</div><div class="line">		wg.Add(<span class="number">1</span>)</div><div class="line">		wp.Execute(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++ &#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			wg.Done()</div><div class="line">		&#125;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	wg.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码基本都是做同样一件事，但是后两个只开10个goroutine，第一个就开了1000000个，结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BenchmarkNopool-8                      1        7966900091 ns/op</div><div class="line">BenchmarkGopool-8                      1        7949844269 ns/op</div><div class="line">BenchmarkWorkerPool-8                  1        7997732135 ns/op</div></pre></td></tr></table></figure></p>
<p>可以看出来，没有区别，重新run几次基本没有多大变化。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于go本身有对goroutine有调度，所以自己实现的池子来调度其实好像没有什么用。还有可能我自己能力实现不好，没发挥池子的作用😀。<br>但是用更少的goroutine能完成同样的事情，应该是一种优化，而且这里的goroutine执行都是简单的循环，没有复杂的业务，一旦业务复杂，更少goroutine能够减少内存和goroutine切换时的cpu资源，有可能上面性能的比较会拉开。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这几天无聊，想到java有自己的线程池，是否对应go也有它的goroutine pool呢，所以搜了下，标准库没有，github有，但都大同小异，所以自己实现了一个。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>利用树莓派搭建一个简易的NAS</title>
    <link href="http://idiotsky.me/2017/07/20/raspberry-nas/"/>
    <id>http://idiotsky.me/2017/07/20/raspberry-nas/</id>
    <published>2017-07-20T14:39:35.000Z</published>
    <updated>2017-08-31T13:48:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>raspberry pi 3</li>
<li>硬盘（格式化过ext4的）</li>
<li>连接raspberry用的终端</li>
</ul>
<a id="more"></a>
<h1 id="安装samba"><a href="#安装samba" class="headerlink" title="安装samba"></a>安装samba</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install samba samba-common-bin</div></pre></td></tr></table></figure>
<h1 id="配置samba"><a href="#配置samba" class="headerlink" title="配置samba"></a>配置samba</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.back</div><div class="line">sudo vim /etc/samba/smb.conf</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在末尾加入如下内容</span></div><div class="line"><span class="comment"># 分享名称</span></div><div class="line">[MyNAS]</div><div class="line"><span class="comment"># 说明信息</span></div><div class="line">comment = NAS Storage</div><div class="line"><span class="comment"># 可以访问的用户</span></div><div class="line">valid users = pi,root</div><div class="line"><span class="comment"># 共享文件的路径,raspberry pi 会自动将连接到其上的外接存储设备挂载到/media/pi/目录下。</span></div><div class="line">path = /media/pi/</div><div class="line"><span class="comment"># 可被其他人看到资源名称（非内容）</span></div><div class="line">browseable = yes</div><div class="line"><span class="comment"># 可写</span></div><div class="line">writable = yes</div><div class="line"><span class="comment"># 新建文件的权限为 664</span></div><div class="line">create mask = 0664</div><div class="line"><span class="comment"># 新建目录的权限为 775</span></div><div class="line">directory mask = 0775</div></pre></td></tr></table></figure>
<p>可以把配置文件中你不需要的分享名称删除，例如 [homes], [printers] 等。<br>测试配置文件是否有错误，根据提示做相应修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">testparm</div></pre></td></tr></table></figure></p>
<p>添加登陆账户并创建密码，必须是 linux 已存在的用户<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo smbpasswd -a pi</div></pre></td></tr></table></figure></p>
<p>重启 samba 服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/samba restart</div></pre></td></tr></table></figure></p>
<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>一般树莓派跟你的WiFi相连的话，你的网络就能看到跟上面配置一样的分享名称，如mac上面这样的显示：<br><a href="/images/nas-screenshot.png"><img src="/images/nas-screenshot.png" alt=""></a><br>如果显示没权限，可以断开连接，用你上面添加的账号登录。</p>
<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><ul>
<li>基本上不是ext4格式的硬盘都不用上传到NAS上了，因为树莓对其他格式的硬盘只有读权限。</li>
<li>如果是ext4格式，也不要高兴，那上传速度可以😭的</li>
<li><p>如果是其他格式的话，上面都说只能读，一般情况拷进硬盘的片片是可以用pi用户读的，如果遇到连pi用户都没有读权限的话，而且登上树莓派进到硬盘里面强制改权限都是改不了的。所以，老老实实加个root用户吧。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo smbpasswd -a root</div></pre></td></tr></table></figure>
</li>
<li><p>用root用户连上去基本没有不能读的。但是还是不能写。老老实实还是拔硬盘到电脑烤吧。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;raspberry pi 3&lt;/li&gt;
&lt;li&gt;硬盘（格式化过ext4的）&lt;/li&gt;
&lt;li&gt;连接raspberry用的终端&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="raspberrypi" scheme="http://idiotsky.me/categories/raspberrypi/"/>
    
    
      <category term="python" scheme="http://idiotsky.me/tags/python/"/>
    
      <category term="raspberrypi" scheme="http://idiotsky.me/tags/raspberrypi/"/>
    
      <category term="NAS" scheme="http://idiotsky.me/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>利用树莓派实现一个能播放天气的闹钟</title>
    <link href="http://idiotsky.me/2017/07/18/raspberry-weather-clock/"/>
    <id>http://idiotsky.me/2017/07/18/raspberry-weather-clock/</id>
    <published>2017-07-17T17:12:25.000Z</published>
    <updated>2017-09-04T16:35:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>你要有个pi😄<br><a id="more"></a></p>
<h1 id="获取天气接口"><a href="#获取天气接口" class="headerlink" title="获取天气接口"></a>获取天气接口</h1><p>这里我是用图灵机器人来获取天气的接口，你可以自己上去注册一个，下面代码URL的Key是我注册的机器人给的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getWeatherText</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        response = requests.get(</div><div class="line">            <span class="string">"http://www.tuling123.com/openapi/api?key=652ae4a714794fe6b01faa990d7a981f&amp;info=%s"</span> % <span class="string">"广州今日天气"</span>)</div><div class="line">        json = response.json()</div><div class="line">        <span class="keyword">if</span> json[<span class="string">"code"</span>] == <span class="number">100000</span>:</div><div class="line">            <span class="keyword">return</span> json[<span class="string">"text"</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">""</span></div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span></div></pre></td></tr></table></figure></p>
<h1 id="播放文字"><a href="#播放文字" class="headerlink" title="播放文字"></a>播放文字</h1><p>利用百度的接口可以转换文本为语音。默认只有女声<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">text2voice</span><span class="params">(text)</span>:</span></div><div class="line">    url = <span class="string">'http://tts.baidu.com/text2audio?idx=1&amp;tex=&#123;0&#125;&amp;cuid=baidu_speech_'</span> \</div><div class="line">          <span class="string">'demo&amp;cod=2&amp;lan=zh&amp;ctp=1&amp;pdt=1&amp;spd=4&amp;per=4&amp;vol=5&amp;pit=5'</span>.format(text)</div><div class="line">    <span class="comment"># 用mplayer播放语音</span></div><div class="line">    os.system(<span class="string">'mplayer "%s"'</span> % url)</div></pre></td></tr></table></figure></p>
<h1 id="安装播放媒体软件"><a href="#安装播放媒体软件" class="headerlink" title="安装播放媒体软件"></a>安装播放媒体软件</h1><p>上面代码你看到的<code>mplayer</code>,就是用来播放语音的，传个url作为参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mplayer</div><div class="line">usage: mplayer [url]</div></pre></td></tr></table></figure></p>
<h1 id="播放音乐"><a href="#播放音乐" class="headerlink" title="播放音乐"></a>播放音乐</h1><p>有了上面这个神器，你可以给播报语音前后加一首音乐😄<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">playMusic</span><span class="params">(path)</span>:</span></div><div class="line">    os.system(<span class="string">'mplayer %s'</span> % path)</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用上面的东东，可以组合些好玩的东西了，至于闹钟的唤醒，可以cron job 做，也可以代码里面实现，enjoy…😄<br>全部代码地址 <a href="https://github.com/ejunjsh/raspberrypi-code/blob/master/clock/weather.py" target="_blank" rel="external">https://github.com/ejunjsh/raspberrypi-code/blob/master/clock/weather.py</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h1&gt;&lt;p&gt;你要有个pi😄&lt;br&gt;
    
    </summary>
    
      <category term="raspberrypi" scheme="http://idiotsky.me/categories/raspberrypi/"/>
    
    
      <category term="python" scheme="http://idiotsky.me/tags/python/"/>
    
      <category term="raspberrypi" scheme="http://idiotsky.me/tags/raspberrypi/"/>
    
  </entry>
  
  <entry>
    <title>用go实现一个简单的restful接口</title>
    <link href="http://idiotsky.me/2017/07/18/go-first-rest/"/>
    <id>http://idiotsky.me/2017/07/18/go-first-rest/</id>
    <published>2017-07-17T17:01:18.000Z</published>
    <updated>2017-07-22T08:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>go的标准库<code>http</code>已经封装好很多接口，可以很简单实现一个web服务器。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义 handler</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</div><div class="line">    io.WriteString(w, <span class="string">"hello, world!\n"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">//绑定pattern和handler</span></div><div class="line">    http.HandleFunc(<span class="string">"/hello"</span>, HelloServer)</div><div class="line">    err := http.ListenAndServe(<span class="string">":12345"</span>, <span class="literal">nil</span>)</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基于上面例子可以封装一个restful接口，不是难事。<br><a id="more"></a></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>从上面例子可以看到，一个url pattern对应一个handler，即对应一个处理，就可以处理http请求了，所以下面的实现是基于对这两个东西的封装开始</p>
<h2 id="封装一个restful-app-结构"><a href="#封装一个restful-app-结构" class="headerlink" title="封装一个restful app 结构"></a>封装一个restful app 结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> App <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">//一个map，key是pattern，value是handler</span></div><div class="line">	handlers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(r *HttpRequest,w HttpResponse)</span><span class="title">error</span></span></div><div class="line">    //<span class="title">pattern</span>数组，用来保证加入<span class="title">pattern</span>的顺序，因为上面的<span class="title">map</span>是无顺序的</div><div class="line">	<span class="title">patterns</span> []<span class="title">string</span></div><div class="line">    //一个<span class="title">map</span>，<span class="title">key</span>是<span class="title">pattern</span>，<span class="title">value</span>是<span class="title">http</span> <span class="title">method</span></div><div class="line">	<span class="title">methods</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></div><div class="line">    //用来实现在<span class="title">url</span> <span class="title">path</span>取出参数的。</div><div class="line">	<span class="title">regexps</span> <span class="title">map</span>[<span class="title">string</span>]*<span class="title">regexp</span>.<span class="title">Regexp</span></div><div class="line">	<span class="title">pathparamanmes</span> <span class="title">map</span>[<span class="title">string</span>][]<span class="title">string</span></div><div class="line">    //用来处理异常的<span class="title">handler</span></div><div class="line">	<span class="title">errHandler</span> <span class="title">func</span><span class="params">( err error, r *HttpRequest,w HttpResponse)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewApp</span><span class="params">()</span> *<span class="title">App</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;App&#123;</div><div class="line">		handlers: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>),</span></div><div class="line">		<span class="title">patterns</span>:<span class="title">make</span><span class="params">([]<span class="keyword">string</span>,0)</span>,</div><div class="line">		<span class="title">methods</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span>,</div><div class="line">		<span class="title">regexps</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]*regexp.Regexp)</span>,</div><div class="line">		<span class="title">pathparamanmes</span>:<span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span>,</div><div class="line">        //一个默认的异常处理，直接返回异常内容</div><div class="line">		<span class="title">errHandler</span>: <span class="title">func</span><span class="params">(err error, r *HttpRequest, w HttpResponse)</span> &#123;</div><div class="line">			w.Write( []<span class="keyword">byte</span>(err.Error()))</div><div class="line">		&#125;,</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="映射绑定"><a href="#映射绑定" class="headerlink" title="映射绑定"></a>映射绑定</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">handle</span><span class="params">(method <span class="keyword">string</span>,pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span> <span class="title">error</span>)</span>&#123;</div><div class="line">    <span class="comment">//绑定pattern和handler</span></div><div class="line">	a.handlers[pattern]=handler</div><div class="line">    <span class="comment">//绑定pattern和method</span></div><div class="line">	a.methods[pattern]=method</div><div class="line">    <span class="comment">//绑定pattern 正则，用来匹配url pattern,和获取url path 参数</span></div><div class="line">	a.regexps[pattern],a.pathparamanmes[pattern]=convertPatterntoRegex(pattern)</div><div class="line">	<span class="keyword">for</span> _,s:=<span class="keyword">range</span> a.patterns&#123;</div><div class="line">		<span class="keyword">if</span> s==pattern&#123;</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">//加入数组，方便用此数组确定顺序</span></div><div class="line">	a.patterns=<span class="built_in">append</span>(a.patterns,pattern)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//绑定GET</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Get</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"GET"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定POST</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Post</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"POST"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定DELETE</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Delete</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span><span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"DELETE"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"><span class="comment">//绑定PUT</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Put</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(r *HttpRequest,w HttpResponse)</span> <span class="title">error</span>)</span>  &#123;</div><div class="line">	a.handle(<span class="string">"PUT"</span>,pattern,handler)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span> <span class="title">Error</span><span class="params">(handler <span class="keyword">func</span>(err error,r *HttpRequest,w HttpResponse)</span>)</span>  &#123;</div><div class="line">	a.errHandler=handler</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了Restful接口的四个方法映射绑定，剩下的就要请求能进到来，所以接下来要写个入口才行。</p>
<h2 id="编写http入口"><a href="#编写http入口" class="headerlink" title="编写http入口"></a>编写http入口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//http 入口</span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">Run</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</div><div class="line">	fmt.Printf(<span class="string">"Server listens on %s"</span>,address)</div><div class="line">	err:=http.ListenAndServe(address,&amp;hodler&#123;app:a&#125;)</div><div class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//https 入口</span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(a *App)</span> <span class="title">RunTls</span><span class="params">(address <span class="keyword">string</span>,cert <span class="keyword">string</span>,key <span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</div><div class="line">	fmt.Printf(<span class="string">"Server listens on %s"</span>,address)</div><div class="line">	err:=http.ListenAndServeTLS(address,cert,key,&amp;hodler&#123;app:a&#125;)</div><div class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">		<span class="keyword">return</span> err</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>入口函数主要调用<code>http</code>库来启动http服务，然后把请求处理函数作为<code>ListenAndServe</code>第二个参数传入。这里由<code>holder</code>来实现这个处理函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hodler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</div><div class="line">	<span class="comment">//封装一下，附加更多功能</span></div><div class="line">    request:= newHttpRequest(r)</div><div class="line">	response:=newHttpResponse(w)</div><div class="line">	<span class="comment">//捕获panic，并让errhandler处理返回。</span></div><div class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="keyword">if</span> err:=<span class="built_in">recover</span>();err!=<span class="literal">nil</span>&#123;</div><div class="line">			<span class="keyword">if</span> e,ok:=err.(error);ok&#123;</div><div class="line">				h.app.errHandler(InternalError&#123;e,<span class="string">""</span>&#125;,request,response)</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> e,ok:=err.(<span class="keyword">string</span>);ok&#123;</div><div class="line">				h.app.errHandler(InternalError&#123;<span class="literal">nil</span>,e&#125;,request,response)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line">    <span class="comment">//根据pattern的添加顺序，循环判断</span></div><div class="line">   <span class="keyword">for</span> _,p:=<span class="keyword">range</span> h.app.patterns&#123;</div><div class="line">       <span class="keyword">if</span> reg,ok:= h.app.regexps[p];ok&#123;</div><div class="line">           <span class="comment">//匹配method</span></div><div class="line">		   <span class="keyword">if</span> method,ok:=h.app.methods[p];ok&amp;&amp;r.Method==method&#123;</div><div class="line">              <span class="comment">//匹配pattern</span></div><div class="line">			   <span class="keyword">if</span> reg.Match([]<span class="keyword">byte</span>(r.URL.Path)) &#123;</div><div class="line">                   <span class="comment">//抽取url path parameters</span></div><div class="line">				   matchers:=reg.FindSubmatch([]<span class="keyword">byte</span>(r.URL.Path))</div><div class="line">				   pathParamMap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</div><div class="line">				   <span class="keyword">if</span> <span class="built_in">len</span>(matchers)&gt;<span class="number">1</span>&#123;</div><div class="line">                       <span class="keyword">if</span> pathParamNames,ok:=h.app.pathparamanmes[p];ok&#123;</div><div class="line">						   <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(matchers);i++&#123;</div><div class="line">							   pathParamMap[pathParamNames[i]]=<span class="keyword">string</span>(matchers[i])</div><div class="line">						   &#125;</div><div class="line">					   &#125;</div><div class="line">				   &#125;</div><div class="line">                   <span class="comment">//PathParams是封装后的request独有的属性</span></div><div class="line">				   request.PathParams=pathParamMap</div><div class="line">				   <span class="keyword">if</span> handler,ok:=h.app.handlers[p];ok&#123;</div><div class="line">                       <span class="comment">//执行handler</span></div><div class="line">					   err:=handler(request,response)</div><div class="line">					   <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</div><div class="line">                           <span class="comment">//执行errhandler</span></div><div class="line">						   h.app.errHandler(err,request,response)</div><div class="line">					   &#125;</div><div class="line">					   <span class="keyword">return</span></div><div class="line">				   &#125;</div><div class="line">			   &#125;</div><div class="line">		   &#125;</div><div class="line">	   &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//执行no found errhandler</span></div><div class="line">	h.app.errHandler(NoFoundError&#123;&#125;,request,response)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基本一个请求的流程如下：<br>requset-&gt;ServeHTTP()-&gt;匹配url pattern-&gt;匹配method-&gt;匹配到你的handler-&gt;执行你的handler-&gt;你的handler返回结果</p>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>由于返回结果可以有很多，所以封装了<code>http</code>库的<code>http.ResponseWriter</code>来实现<code>WriteString,WriteJson,WriteXml,WriteFile</code>等方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//封装request，附件一个PathParams来保存url path parameters.</span></div><div class="line"><span class="keyword">type</span> HttpRequest <span class="keyword">struct</span> &#123;</div><div class="line">	*http.Request</div><div class="line">	PathParams <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> HttpResponse <span class="keyword">struct</span> &#123;</div><div class="line">	http.ResponseWriter</div><div class="line">&#125;</div><div class="line"><span class="comment">//用来返回字符</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteString</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回JSON</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteJson</span><span class="params">(jsonObj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回XML</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteXml</span><span class="params">(xmlObj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回文件</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteFile</span><span class="params">(filepath <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回一个模板html</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(response *HttpResponse)</span> <span class="title">WriteTemplates</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;,tplPath ...<span class="keyword">string</span>)</span> <span class="title">error</span></span>  &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//new 一个restful接口</span></div><div class="line">	app:=gorest.NewApp()</div><div class="line">    <span class="comment">//绑定</span></div><div class="line">	app.Get(<span class="string">"/json"</span>, <span class="function"><span class="keyword">func</span><span class="params">(r *gorest.HttpRequest, w gorest.HttpResponse)</span> <span class="title">error</span></span> &#123;</div><div class="line">		a:= <span class="keyword">struct</span> &#123;</div><div class="line">			Abc <span class="keyword">string</span> <span class="string">`json:"abc"`</span></div><div class="line">			Cba <span class="keyword">string</span> <span class="string">`json:"cba"`</span></div><div class="line">		&#125;&#123;<span class="string">"123"</span>,<span class="string">"321"</span>&#125;</div><div class="line">        <span class="comment">//返回json作为结果</span></div><div class="line">		<span class="keyword">return</span> w.WriteJson(a)</div><div class="line">	&#125;)</div><div class="line">	app.Error(<span class="function"><span class="keyword">func</span><span class="params">(err error, r *gorest.HttpRequest, w gorest.HttpResponse)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span> e,ok:=err.(gorest.NoFoundError);ok &#123;</div><div class="line">			w.Write([]<span class="keyword">byte</span>(e.Error()))</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> e,ok:=err.(gorest.InternalError);ok &#123;</div><div class="line">			w.Write([]<span class="keyword">byte</span>(e.Error()))</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">    <span class="comment">//启动</span></div><div class="line">	app.Run(<span class="string">":8081"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>收工😄</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>go的标准库封装了很多了，所以实现这个其实还是比较轻松的😄<br>详细代码见<a href="https://github.com/ejunjsh/gorest" target="_blank" rel="external">https://github.com/ejunjsh/gorest</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;go的标准库&lt;code&gt;http&lt;/code&gt;已经封装好很多接口，可以很简单实现一个web服务器。&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义 handler&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HelloServer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(w http.ResponseWriter, req *http.Request)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    io.WriteString(w, &lt;span class=&quot;string&quot;&gt;&quot;hello, world!\n&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//绑定pattern和handler&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    http.HandleFunc(&lt;span class=&quot;string&quot;&gt;&quot;/hello&quot;&lt;/span&gt;, HelloServer)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    err := http.ListenAndServe(&lt;span class=&quot;string&quot;&gt;&quot;:12345&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        log.Fatal(&lt;span class=&quot;string&quot;&gt;&quot;ListenAndServe: &quot;&lt;/span&gt;, err)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基于上面例子可以封装一个restful接口，不是难事。&lt;br&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
      <category term="restful" scheme="http://idiotsky.me/tags/restful/"/>
    
  </entry>
  
  <entry>
    <title>一张图了解一致性hash</title>
    <link href="http://idiotsky.me/2017/07/16/consistent-hash/"/>
    <id>http://idiotsky.me/2017/07/16/consistent-hash/</id>
    <published>2017-07-16T12:39:20.000Z</published>
    <updated>2017-07-19T12:39:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/consistent-hash.png"><img src="/images/consistent-hash.png" alt="one image describes how consistent-hash works"></a><br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/consistent-hash.png&quot;&gt;&lt;img src=&quot;/images/consistent-hash.png&quot; alt=&quot;one image describes how consistent-hash works&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>一张图了解hashmap</title>
    <link href="http://idiotsky.me/2017/07/15/hashmap/"/>
    <id>http://idiotsky.me/2017/07/15/hashmap/</id>
    <published>2017-07-15T10:03:15.000Z</published>
    <updated>2017-09-06T13:29:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/images/hashmap.png"><img src="/images/hashmap.png" alt="one image describes how hashmap works"></a><br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/images/hashmap.png&quot;&gt;&lt;img src=&quot;/images/hashmap.png&quot; alt=&quot;one image describes how hashmap works&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>redis基础、高级特性与性能调优</title>
    <link href="http://idiotsky.me/2017/04/09/redis-summary/"/>
    <id>http://idiotsky.me/2017/04/09/redis-summary/</id>
    <published>2017-04-09T13:52:30.000Z</published>
    <updated>2017-09-10T17:25:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文将从Redis的基本特性入手，通过讲述Redis的数据结构和主要命令对Redis的基本能力进行直观介绍。之后概览Redis提供的高级能力，并在部署、维护、性能调优等多个方面进行更深入的介绍和指导。<br>本文适合使用Redis的普通开发人员，以及对Redis进行选型、架构设计和性能调优的架构设计人员。</p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Redis是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。<br>Redis支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图、Hyperloglogs等。<br>Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。</p>
<p>Redis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求，同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p>
<ul>
<li>Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常</li>
<li>Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))</li>
<li>使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用）</li>
</ul>
<a id="more"></a>
<h1 id="Redis的数据结构和相关常用命令"><a href="#Redis的数据结构和相关常用命令" class="headerlink" title="Redis的数据结构和相关常用命令"></a>Redis的数据结构和相关常用命令</h1><p>本节中将介绍Redis支持的主要数据结构，以及相关的常用Redis命令。本节只对Redis命令进行扼要的介绍，且只列出了较常用的命令。如果想要了解完整的Redis命令集，或了解某个命令的详细使用方法，请参考官方文档：<a href="https://redis.io/commands" target="_blank" rel="external">https://redis.io/commands</a></p>
<h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><p>Redis采用Key-Value型的基本数据结构，任何二进制序列都可以作为Redis的Key使用（例如普通的字符串或一张JPEG图片）<br>关于Key的一些注意事项：</p>
<ul>
<li>不要使用过长的Key。例如使用一个1024字节的key就不是一个好主意，不仅会消耗更多的内存，还会导致查找的效率降低</li>
<li>Key短到缺失了可读性也是不好的，例如”u1000flw”比起”user:1000:followers”来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦</li>
<li>最好使用统一的规范来设计Key，比如”object-type:id:attr”，以这一规范设计出的Key可能是”user:1000”或”comment:1234:reply-to”</li>
<li>Redis允许的最大Key长度是512MB（对Value的长度限制也是512MB）</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String是Redis的基础数据类型，Redis没有Int、Float、Boolean等数据类型的概念，所有的基本类型在Redis中都以String体现。<br>与String相关的常用命令：</p>
<ul>
<li>SET：为一个key设置value，可以配合EX/PX参数指定key的有效期，通过NX/XX参数针对key是否存在的情况进行区别操作，时间复杂度O(1)</li>
<li>GET：获取某个key对应的value，时间复杂度O(1)</li>
<li>GETSET：为一个key设置value，并返回该key的原value，时间复杂度O(1)</li>
<li>MSET：为多个key设置value，时间复杂度O(N)</li>
<li>MSETNX：同MSET，如果指定的key中有任意一个已存在，则不进行任何操作，时间复杂度O(N)</li>
<li>MGET：获取多个key对应的value，时间复杂度O(N)</li>
</ul>
<p>上文提到过，Redis的基本数据类型只有String，但Redis可以把String作为整型或浮点型数字来使用，主要体现在INCR、DECR类的命令上：</p>
<ul>
<li>INCR：将key对应的value值自增1，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li>
<li>NCRBY：将key对应的value值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1)</li>
<li>DECR/DECRBY：同INCR/INCRBY，自增改为自减。<br>INCR/DECR系列命令要求操作的value类型为String，并可以转换为64位带符号的整型数字，否则会返回错误。</li>
</ul>
<p>也就是说，进行INCR/DECR系列命令的value，必须在[-2^63 ~ 2^63 - 1]范围内。<br>提到过，Redis采用单线程模型，天然是线程安全的，这使得INCR/DECR命令可以非常便利的实现高并发场景下的精确控制。</p>
<h3 id="例1：库存控制"><a href="#例1：库存控制" class="headerlink" title="例1：库存控制"></a>例1：库存控制</h3><p>在高并发场景下实现库存余量的精准校验，确保不出现超卖的情况。<br>设置库存总量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SET inv:remain <span class="string">"100"</span></div></pre></td></tr></table></figure></p>
<p>库存扣减+余量校验：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DECR inv:remain</div></pre></td></tr></table></figure></p>
<p>当DECR命令返回值大于等于0时，说明库存余量校验通过，如果返回小于0的值，则说明库存已耗尽。<br>假设同时有300个并发请求进行库存扣减，Redis能够确保这300个请求分别得到99到-200的返回值，每个请求得到的返回值都是唯一的，绝对不会找出现两个请求得到一样的返回值的情况。</p>
<h3 id="例2：自增序列生成"><a href="#例2：自增序列生成" class="headerlink" title="例2：自增序列生成"></a>例2：自增序列生成</h3><p>实现类似于RDBMS的Sequence功能，生成一系列唯一的序列号<br>设置序列起始值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SET sequence <span class="string">"10000"</span></div></pre></td></tr></table></figure></p>
<p>获取一个序列值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INCR sequence</div></pre></td></tr></table></figure></p>
<p>直接将返回值作为序列使用即可。</p>
<p>获取一批（如100个）序列值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INCRBY sequence 100</div></pre></td></tr></table></figure></p>
<p>假设返回值为N，那么[N - 99 ~ N]的数值都是可用的序列值。<br>当多个客户端同时向Redis申请自增序列时，Redis能够确保每个客户端得到的序列值或序列范围都是全局唯一的，绝对不会出现不同客户端得到了重复的序列值的情况。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>Redis的List是链表型的数据结构，可以使用LPUSH/RPUSH/LPOP/RPOP等命令在List的两端执行插入元素和弹出元素的操作。虽然List也支持在特定index上插入和读取元素的功能，但其时间复杂度较高（O(N)），应小心使用。<br>与List相关的常用命令：</p>
<ul>
<li>LPUSH：向指定List的左侧（即头部）插入1个或多个元素，返回插入后的List长度。时间复杂度O(N)，N为插入元素的数量</li>
<li>RPUSH：同LPUSH，向指定List的右侧（即尾部）插入1或多个元素</li>
<li>LPOP：从指定List的左侧（即头部）移除一个元素并返回，时间复杂度O(1)</li>
<li>RPOP：同LPOP，从指定List的右侧（即尾部）移除1个元素并返回</li>
<li>LPUSHX/RPUSHX：与LPUSH/RPUSH类似，区别在于，LPUSHX/RPUSHX操作的key如果不存在，则不会进行任何操作</li>
<li>LLEN：返回指定List的长度，时间复杂度O(1)</li>
<li>LRANGE：返回指定List中指定范围的元素（双端包含，即LRANGE key 0 10会返回11个元素），时间复杂度O(N)。应尽可能控制一次获取的元素数量，一次获取过大范围的List元素会导致延迟，同时对长度不可预知的List，避免使用LRANGE key 0 -1这样的完整遍历操作。</li>
</ul>
<p>应谨慎使用的List相关命令：</p>
<ul>
<li>LINDEX：返回指定List指定index上的元素，如果index越界，返回nil。index数值是回环的，即-1代表List最后一个位置，-2代表List倒数第二个位置。时间复杂度O(N)</li>
<li>LSET：将指定List指定index上的元素设置为value，如果index越界则返回错误，时间复杂度O(N)，如果操作的是头/尾部的元素，则时间复杂度为O(1)</li>
<li>LINSERT：向指定List中指定元素之前/之后插入一个新元素，并返回操作后的List长度。如果指定的元素不存在，返回-1。如果指定key不存在，不会进行任何操作，时间复杂度O(N)</li>
</ul>
<p>由于Redis的List是链表结构的，上述的三个命令的算法效率较低，需要对List进行遍历，命令的耗时无法预估，在List长度大的情况下耗时会明显增加，应谨慎使用。</p>
<p>换句话说，Redis的List实际是设计来用于实现队列，而不是用于实现类似ArrayList这样的列表的。如果你不是想要实现一个双端出入的队列，那么请尽量不要使用Redis的List数据结构。</p>
<p>为了更好支持队列的特性，Redis还提供了一系列阻塞式的操作命令，如BLPOP/BRPOP等，能够实现类似于BlockingQueue的能力，即在List为空时，阻塞该连接，直到List中有对象可以出队时再返回。针对阻塞类的命令，此处不做详细探讨，请参考官方文档（<a href="https://redis.io/topics/data-types-intro）" target="_blank" rel="external">https://redis.io/topics/data-types-intro）</a> 中”Blocking operations on lists”一节。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Hash即哈希表，Redis的Hash和传统的哈希表一样，是一种field-value型的数据结构，可以理解成将HashMap搬入Redis。<br>Hash非常适合用于表现对象类型的数据，用Hash中的field对应对象的field即可。<br>Hash的优点包括：</p>
<ul>
<li>可以实现二元查找，如”查找ID为1000的用户的年龄”</li>
<li>比起将整个对象序列化后作为String存储的方法，Hash能够有效地减少网络传输的消耗</li>
<li>当使用Hash维护一个集合时，提供了比List效率高得多的随机访问命令</li>
</ul>
<p>与Hash相关的常用命令：</p>
<ul>
<li>HSET：将key对应的Hash中的field设置为value。如果该Hash不存在，会自动创建一个。时间复杂度O(1)</li>
<li>HGET：返回指定Hash中field字段的值，时间复杂度O(1)</li>
<li>HMSET/HMGET：同HSET和HGET，可以批量操作同一个key下的多个field，时间复杂度：O(N)，N为一次操作的field数量</li>
<li>HSETNX：同HSET，但如field已经存在，HSETNX不会进行任何操作，时间复杂度O(1)</li>
<li>HEXISTS：判断指定Hash中field是否存在，存在返回1，不存在返回0，时间复杂度O(1)</li>
<li>HDEL：删除指定Hash中的field（1个或多个），时间复杂度：O(N)，N为操作的field数量</li>
<li>HINCRBY：同INCRBY命令，对指定Hash中的一个field进行INCRBY，时间复杂度O(1)</li>
</ul>
<p>应谨慎使用的Hash相关命令：</p>
<ul>
<li>HGETALL：返回指定Hash中所有的field-value对。返回结果为数组，数组中field和value交替出现。时间复杂度O(N)</li>
<li>HKEYS/HVALS：返回指定Hash中所有的field/value，时间复杂度O(N)</li>
</ul>
<p>上述三个命令都会对Hash进行完整遍历，Hash中的field数量与命令的耗时线性相关，对于尺寸不可预知的Hash，应严格避免使用上面三个命令，而改为使用HSCAN命令进行游标式的遍历，具体请见 <a href="https://redis.io/commands/scan" target="_blank" rel="external">https://redis.io/commands/scan</a></p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Redis Set是无序的，不可重复的String集合。<br>与Set相关的常用命令：</p>
<ul>
<li>SADD：向指定Set中添加1个或多个member，如果指定Set不存在，会自动创建一个。时间复杂度O(N)，N为添加的member个数</li>
<li>SREM：从指定Set中移除1个或多个member，时间复杂度O(N)，N为移除的member个数</li>
<li>SRANDMEMBER：从指定Set中随机返回1个或多个member，时间复杂度O(N)，N为返回的member个数</li>
<li>SPOP：从指定Set中随机移除并返回count个member，时间复杂度O(N)，N为移除的member个数</li>
<li>SCARD：返回指定Set中的member个数，时间复杂度O(1)</li>
<li>SISMEMBER：判断指定的value是否存在于指定Set中，时间复杂度O(1)</li>
<li>SMOVE：将指定member从一个Set移至另一个Set</li>
</ul>
<p>慎用的Set相关命令：</p>
<ul>
<li>SMEMBERS：返回指定Hash中所有的member，时间复杂度O(N)</li>
<li>SUNION/SUNIONSTORE：计算多个Set的并集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
<li>SINTER/SINTERSTORE：计算多个Set的交集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
<li>SDIFF/SDIFFSTORE：计算1个Set与1或多个Set的差集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数</li>
</ul>
<p>上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的Set尺寸不可知的情况下，应严格避免使用。可以考虑通过SSCAN命令遍历获取相关Set的全部member（具体请见 <a href="https://redis.io/commands/scan" target="_blank" rel="external">https://redis.io/commands/scan</a> ），如果需要做并集/交集/差集计算，可以在客户端进行，或在不服务实时查询请求的Slave上进行。</p>
<h2 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h2><p>Redis Sorted Set是有序的、不可重复的String集合。Sorted Set中的每个元素都需要指派一个分数(score)，Sorted Set会根据score对元素进行升序排序。如果多个member拥有相同的score，则以字典序进行升序排序。</p>
<p>Sorted Set非常适合用于实现排名。</p>
<p>Sorted Set的主要命令：</p>
<ul>
<li>ZADD：向指定Sorted Set中添加1个或多个member，时间复杂度O(Mlog(N))，M为添加的member数量，N为Sorted Set中的member数量</li>
<li>ZREM：从指定Sorted Set中删除1个或多个member，时间复杂度O(Mlog(N))，M为删除的member数量，N为Sorted Set中的member数量</li>
<li>ZCOUNT：返回指定Sorted Set中指定score范围内的member数量，时间复杂度：O(log(N))</li>
<li>ZCARD：返回指定Sorted Set中的member数量，时间复杂度O(1)</li>
<li>ZSCORE：返回指定Sorted Set中指定member的score，时间复杂度O(1)</li>
<li>ZRANK/ZREVRANK：返回指定member在Sorted Set中的排名，ZRANK返回按升序排序的排名，ZREVRANK则返回按降序排序的排名。时间复杂度O(log(N))</li>
<li>ZINCRBY：同INCRBY，对指定Sorted Set中的指定member的score进行自增，时间复杂度O(log(N))</li>
</ul>
<p>慎用的Sorted Set相关命令：</p>
<ul>
<li>ZRANGE/ZREVRANGE：返回指定Sorted Set中指定排名范围内的所有member，ZRANGE为按score升序排序，ZREVRANGE为按score降序排序，时间复杂度O(log(N)+M)，M为本次返回的member数</li>
<li>ZRANGEBYSCORE/ZREVRANGEBYSCORE：返回指定Sorted Set中指定score范围内的所有member，返回结果以升序/降序排序，min和max可以指定为-inf和+inf，代表返回所有的member。时间复杂度O(log(N)+M)</li>
<li>ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除Sorted Set中指定排名范围/指定score范围内的所有member。时间复杂度O(log(N)+M)</li>
</ul>
<p>上述几个命令，应尽量避免传递[0 -1]或[-inf +inf]这样的参数，来对Sorted Set做一次性的完整遍历，特别是在Sorted Set的尺寸不可预知的情况下。可以通过ZSCAN命令来进行游标式的遍历（具体请见 <a href="https://redis.io/commands/scan" target="_blank" rel="external">https://redis.io/commands/scan</a> ），或通过LIMIT参数来限制返回member的数量（适用于ZRANGEBYSCORE和ZREVRANGEBYSCORE命令），以实现游标式的遍历。</p>
<h2 id="Bitmap和HyperLogLog"><a href="#Bitmap和HyperLogLog" class="headerlink" title="Bitmap和HyperLogLog"></a>Bitmap和HyperLogLog</h2><p>Redis的这两种数据结构相较之前的并不常用，在本文中只做简要介绍，如想要详细了解这两种数据结构与其相关的命令，请参考官方文档<a href="https://redis.io/topics/data-types-intro" target="_blank" rel="external">https://redis.io/topics/data-types-intro</a> 中的相关章节</p>
<p>Bitmap在Redis中不是一种实际的数据类型，而是一种将String作为Bitmap使用的方法。可以理解为将String转换为bit数组。使用Bitmap来存储true/false类型的简单数据极为节省空间。</p>
<p>HyperLogLogs是一种主要用于数量统计的数据结构，它和Set类似，维护一个不可重复的String集合，但是HyperLogLogs并不维护具体的member内容，只维护member的个数。也就是说，HyperLogLogs只能用于计算一个集合中不重复的元素数量，所以它比Set要节省很多内存空间。</p>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><ul>
<li>EXISTS：判断指定的key是否存在，返回1代表存在，0代表不存在，时间复杂度O(1)</li>
<li>DEL：删除指定的key及其对应的value，时间复杂度O(N)，N为删除的key数量</li>
<li>EXPIRE/PEXPIRE：为一个key设置有效期，单位为秒或毫秒，时间复杂度O(1)</li>
<li>TTL/PTTL：返回一个key剩余的有效时间，单位为秒或毫秒，时间复杂度O(1)</li>
<li>RENAME/RENAMENX：将key重命名为newkey。使用RENAME时，如果newkey已经存在，其值会被覆盖；使用RENAMENX时，如果newkey已经存在，则不会进行任何操作，时间复杂度O(1)</li>
<li>TYPE：返回指定key的类型，string, list, set, zset, hash。时间复杂度O(1)</li>
<li>CONFIG GET：获得Redis某配置项的当前值，可以使用*通配符，时间复杂度O(1)</li>
<li>CONFIG SET：为Redis某个配置项设置新值，时间复杂度O(1)</li>
<li>CONFIG REWRITE：让Redis重新加载redis.conf中的配置</li>
</ul>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><p>Redis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案，两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。</p>
<h2 id="必须使用数据持久化吗？"><a href="#必须使用数据持久化吗？" class="headerlink" title="必须使用数据持久化吗？"></a>必须使用数据持久化吗？</h2><p>Redis的数据持久化机制是可以关闭的。如果你只把Redis作为缓存服务使用，Redis中存储的所有数据都不是该数据的主体而仅仅是同步过来的备份，那么可以关闭Redis的数据持久化机制。<br>但通常来说，仍然建议至少开启RDB方式的数据持久化，因为：</p>
<ul>
<li>RDB方式的持久化几乎不损耗Redis本身的性能，在进行RDB持久化时，Redis主进程唯一需要做的事情就是fork出一个子进程，所有持久化工作都由子进程完成</li>
<li>Redis无论因为什么原因crash掉之后，重启时能够自动恢复到上一次RDB快照中记录的数据。这省去了手工从其他数据源（如DB）同步数据的过程，而且要比其他任何的数据恢复方式都要快</li>
<li>现在硬盘那么大，真的不缺那一点地方</li>
</ul>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。可以在配置文件中配置Redis进行快照保存的时机：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save [seconds] [changes]</div></pre></td></tr></table></figure></p>
<p>意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save 60 100</div></pre></td></tr></table></figure></p>
<p>会让Redis每60秒检查一次数据变更情况，如果发生了100次或以上的数据变更，则进行RDB快照保存。<br>可以配置多条save指令，让Redis执行多级的快照保存策略。<br>Redis默认开启RDB快照，默认的RDB策略如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">save 900 1</div><div class="line">save 300 10</div><div class="line">save 60 10000</div></pre></td></tr></table></figure></p>
<p>也可以通过BGSAVE命令手工触发RDB快照保存。</p>
<p>RDB的优点：</p>
<ul>
<li>对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。</li>
<li>每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。</li>
<li>使用RDB文件进行数据恢复比使用AOF要快很多。</li>
</ul>
<p>RDB的缺点：</p>
<ul>
<li>快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。</li>
<li>如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。</p>
<p>AOF默认是关闭的，如要开启，进行如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendonly yes</div></pre></td></tr></table></figure></p>
<p>AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：</p>
<ul>
<li>appendfsync no：不进行fsync，将flush文件的时机交给OS决定，速度最快</li>
<li>appendfsync always：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢</li>
<li>appendfsync everysec：折中的做法，交由后台线程每秒fsync一次</li>
</ul>
<p>随着AOF不断地记录写操作日志，必定会出现一些无用的日志，例如某个时间点执行了命令<strong>SET key1 “abc”</strong>，在之后某个时间点又执行了<strong>SET key1 “bcd”</strong>，那么第一条命令很显然是没有用的。大量的无用日志会让AOF文件过大，也会让数据恢复的时间过长。<br>所以Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。<br>AOF rewrite可以通过BGREWRITEAOF命令触发，也可以配置Redis定期自动进行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto-aof-rewrite-percentage 100</div><div class="line">auto-aof-rewrite-min-size 64mb</div></pre></td></tr></table></figure></p>
<p>上面两行配置的含义是，Redis在每次AOF rewrite时，会记录完成rewrite后的AOF日志大小，当AOF日志大小在该基础上增长了100%后，自动进行AOF rewrite。同时如果增长的大小没有达到64mb，则不会进行rewrite。</p>
<p>AOF的优点：</p>
<ul>
<li>最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。</li>
<li>AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。</li>
<li>AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。</li>
</ul>
<p>AOF的缺点：</p>
<ul>
<li>AOF文件通常比RDB文件更大</li>
<li>性能消耗比RDB高</li>
<li>数据恢复速度比RDB慢</li>
</ul>
<h1 id="内存管理与数据淘汰机制"><a href="#内存管理与数据淘汰机制" class="headerlink" title="内存管理与数据淘汰机制"></a>内存管理与数据淘汰机制</h1><h2 id="最大内存设置"><a href="#最大内存设置" class="headerlink" title="最大内存设置"></a>最大内存设置</h2><p>默认情况下，在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。</p>
<p>在使用Redis时，应该对数据占用的最大空间有一个基本准确的预估，并为Redis设定最大使用的内存。否则在64位OS中Redis会无限制地占用内存（当物理内存被占满后会使用swap空间），容易引发各种各样的问题。</p>
<p>通过如下配置控制Redis使用的最大内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">maxmemory 100mb</div></pre></td></tr></table></figure></p>
<p>在内存占用达到了maxmemory后，再向Redis写入数据时，Redis会：</p>
<ul>
<li>根据配置的数据淘汰策略尝试淘汰数据，释放空间</li>
<li>如果没有数据可以淘汰，或者没有配置数据淘汰策略，那么Redis会对所有写请求返回错误，但读请求仍然可以正常执行</li>
</ul>
<p>在为Redis设置maxmemory时，需要注意：</p>
<ul>
<li>如果采用了Redis的主从同步，主节点向从节点同步数据时，会占用掉一部分内存空间，如果maxmemory过于接近主机的可用内存，导致数据同步时内存不足。所以设置的maxmemory不要过于接近主机可用的内存，留出一部分预留用作主从同步。</li>
</ul>
<h2 id="数据淘汰机制"><a href="#数据淘汰机制" class="headerlink" title="数据淘汰机制"></a>数据淘汰机制</h2><p>Redis提供了5种数据淘汰策略：</p>
<ul>
<li>volatile-lru：使用LRU算法进行数据淘汰（淘汰上次使用时间最早的，且使用次数最少的key），只淘汰设定了有效期的key</li>
<li>allkeys-lru：使用LRU算法进行数据淘汰，所有的key都可以被淘汰</li>
<li>volatile-random：随机淘汰数据，只淘汰设定了有效期的key</li>
<li>allkeys-random：随机淘汰数据，所有的key都可以被淘汰</li>
<li>volatile-ttl：淘汰剩余有效期最短的key</li>
</ul>
<p>最好为Redis指定一种有效的数据淘汰策略以配合maxmemory设置，避免在内存使用满后发生写入失败的情况。</p>
<p>一般来说，推荐使用的策略是volatile-lru，并辨识Redis中保存的数据的重要性。对于那些重要的，绝对不能丢弃的数据（如配置类数据等），应不设置有效期，这样Redis就永远不会淘汰这些数据。对于那些相对不是那么重要的，并且能够热加载的数据（比如缓存最近登录的用户信息，当在Redis中找不到时，程序会去DB中读取），可以设置上有效期，这样在内存不够时Redis就会淘汰这部分数据。</p>
<p>配置方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">maxmemory-policy volatile-lru   #默认是noeviction，即不进行数据淘汰</div></pre></td></tr></table></figure></p>
<h1 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a>Pipelining</h1><p>Redis提供许多批量操作的命令，如MSET/MGET/HMSET/HMGET等等，这些命令存在的意义是减少维护网络连接和传输数据所消耗的资源和时间。<br>例如连续使用5次SET命令设置5个不同的key，比起使用一次MSET命令设置5个不同的key，效果是一样的，但前者会消耗更多的RTT(Round Trip Time)时长，永远应优先使用后者。</p>
<p>然而，如果客户端要连续执行的多次操作无法通过Redis命令组合在一起，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SET a &quot;abc&quot;</div><div class="line">INCR b</div><div class="line">HSET c name &quot;hi&quot;</div></pre></td></tr></table></figure></p>
<p>此时便可以使用Redis提供的pipelining功能来实现在一次交互中执行多条命令。<br>使用pipelining时，只需要从客户端一次向Redis发送多条命令（以\r\n）分隔，Redis就会依次执行这些命令，并且把每个命令的返回按顺序组装在一起一次返回，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ (<span class="built_in">printf</span> <span class="string">"PING\r\nPING\r\nPING\r\n"</span>; sleep 1) | nc localhost 6379</div><div class="line">+PONG</div><div class="line">+PONG</div><div class="line">+PONG</div></pre></td></tr></table></figure></p>
<p>大部分的Redis客户端都对Pipelining提供支持，所以开发者通常并不需要自己手工拼装命令列表。</p>
<h2 id="Pipelining的局限性"><a href="#Pipelining的局限性" class="headerlink" title="Pipelining的局限性"></a>Pipelining的局限性</h2><p>Pipelining只能用于执行<strong>连续且无相关性</strong>的命令，当某个命令的生成需要依赖于前一个命令的返回时，就无法使用Pipelining了。</p>
<p>通过Scripting功能，可以规避这一局限性</p>
<h1 id="事务与Scripting"><a href="#事务与Scripting" class="headerlink" title="事务与Scripting"></a>事务与Scripting</h1><p>Pipelining能够让Redis在一次交互中处理多条命令，然而在一些场景下，我们可能需要在此基础上确保这一组命令是连续执行的。</p>
<p>比如获取当前累计的PV数并将其清0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; GET vCount</div><div class="line">12384</div><div class="line">&gt; SET vCount 0</div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p>如果在GET和SET命令之间插进来一个INCR vCount，就会使客户端拿到的vCount不准确。</p>
<p>Redis的事务可以确保复数命令执行时的原子性。也就是说Redis能够保证：一个事务中的一组命令是绝对连续执行的，在这些命令执行完成之前，绝对不会有来自于其他连接的其他命令插进去执行。</p>
<p>通过MULTI和EXEC命令来把这两个命令加入一个事务中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; MULTI</div><div class="line">OK</div><div class="line">&gt; GET vCount</div><div class="line">QUEUED</div><div class="line">&gt; SET vCount 0</div><div class="line">QUEUED</div><div class="line">&gt; EXEC</div><div class="line">1) 12384</div><div class="line">2) OK</div></pre></td></tr></table></figure></p>
<p>Redis在接收到MULTI命令后便会开启一个事务，这之后的所有读写命令都会保存在队列中但并不执行，直到接收到EXEC命令后，Redis会把队列中的所有命令连续顺序执行，并以数组形式返回每个命令的返回结果。</p>
<p>可以使用DISCARD命令放弃当前的事务，将保存的命令队列清空。</p>
<p>需要注意的是，<strong>Redis事务不支持回滚</strong>：<br>如果一个事务中的命令出现了语法错误，大部分客户端驱动会返回错误，2.6.5版本以上的Redis也会在执行EXEC时检查队列中的命令是否存在语法错误，如果存在，则会自动放弃事务并返回错误。<br>但如果一个事务中的命令有非语法类的错误（比如对String执行HSET操作），无论客户端驱动还是Redis都无法在真正执行这条命令之前发现，所以事务中的所有命令仍然会被依次执行。在这种情况下，会出现一个事务中部分命令成功部分命令失败的情况，然而与RDBMS不同，Redis不提供事务回滚的功能，所以只能通过其他方法进行数据的回滚。</p>
<h2 id="通过事务实现CAS"><a href="#通过事务实现CAS" class="headerlink" title="通过事务实现CAS"></a>通过事务实现CAS</h2><p>Redis提供了WATCH命令与事务搭配使用，实现CAS乐观锁的机制。</p>
<p>假设要实现将某个商品的状态改为已售：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if(exec(HGET stock:1001 state) == &quot;in stock&quot;)</div><div class="line">    exec(HSET stock:1001 state &quot;sold&quot;);</div></pre></td></tr></table></figure></p>
<p>这一伪代码执行时，无法确保并发安全性，有可能多个客户端都获取到了”in stock”的状态，导致一个库存被售卖多次。</p>
<p>使用WATCH命令和事务可以解决这一问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">exec(WATCH stock:1001);</div><div class="line">if(exec(HGET stock:1001 state) == &quot;in stock&quot;) &#123;</div><div class="line">    exec(MULTI);</div><div class="line">    exec(HSET stock:1001 state &quot;sold&quot;);</div><div class="line">    exec(EXEC);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WATCH的机制是：在事务EXEC命令执行时，Redis会检查被WATCH的key，只有被WATCH的key从WATCH起始时至今没有发生过变更，EXEC才会被执行。如果WATCH的key在WATCH命令到EXEC命令之间发生过变化，则EXEC命令会返回失败。</p>
<h2 id="Scripting"><a href="#Scripting" class="headerlink" title="Scripting"></a>Scripting</h2><p>通过EVAL与EVALSHA命令，可以让Redis执行LUA脚本。这就类似于RDBMS的存储过程一样，可以把客户端与Redis之间密集的读/写交互放在服务端进行，避免过多的数据交互，提升性能。</p>
<p>Scripting功能是作为事务功能的替代者诞生的，事务提供的所有能力Scripting都可以做到。Redis官方推荐使用LUA Script来代替事务，前者的效率和便利性都超过了事务。</p>
<p>关于Scripting的具体使用，本文不做详细介绍，请参考官方文档 <a href="https://redis.io/commands/eval" target="_blank" rel="external">https://redis.io/commands/eval</a></p>
<h1 id="Redis性能调优"><a href="#Redis性能调优" class="headerlink" title="Redis性能调优"></a>Redis性能调优</h1><p>尽管Redis是一个非常快速的内存数据存储媒介，也并不代表Redis不会产生性能问题。<br>前文中提到过，Redis采用单线程模型，所有的命令都是由一个线程串行执行的，所以当某个命令执行耗时较长时，会拖慢其后的所有命令，这使得Redis对每个任务的执行效率更加敏感。</p>
<p>针对Redis的性能优化，主要从下面几个层面入手：</p>
<ul>
<li>最初的也是最重要的，确保没有让Redis执行耗时长的命令</li>
<li>使用pipelining将连续执行的命令组合执行</li>
<li><p>操作系统的Transparent huge pages功能必须关闭：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</div></pre></td></tr></table></figure>
</li>
<li><p>如果在虚拟机中运行Redis，可能天然就有虚拟机环境带来的固有延迟。可以通过./redis-cli –intrinsic-latency 100命令查看固有延迟。同时如果对Redis的性能有较高要求的话，应尽可能在物理机上直接部署Redis。</p>
</li>
<li>检查数据持久化策略</li>
<li>考虑引入读写分离机制</li>
</ul>
<h2 id="长耗时命令"><a href="#长耗时命令" class="headerlink" title="长耗时命令"></a>长耗时命令</h2><p>Redis绝大多数读写命令的时间复杂度都在O(1)到O(N)之间，在文本和官方文档中均对每个命令的时间复杂度有说明。</p>
<p>通常来说，O(1)的命令是安全的，O(N)命令在使用时需要注意，如果N的数量级不可预知，则应避免使用。例如对一个field数未知的Hash数据执行HGETALL/HKEYS/HVALS命令，通常来说这些命令执行的很快，但如果这个Hash中的field数量极多，耗时就会成倍增长。<br>又如使用SUNION对两个Set执行Union操作，或使用SORT对List/Set执行排序操作等时，都应该严加注意。</p>
<p>避免在使用这些O(N)命令时发生问题主要有几个办法：</p>
<ul>
<li>不要把List当做列表使用，仅当做队列来使用</li>
<li>通过机制严格控制Hash、Set、Sorted Set的大小</li>
<li>可能的话，将排序、并集、交集等操作放在客户端执行</li>
<li>绝对禁止使用KEYS命令</li>
<li>避免一次性遍历集合类型的所有成员，而应使用SCAN类的命令进行分批的，游标式的遍历</li>
</ul>
<p>Redis提供了SCAN命令，可以对Redis中存储的所有key进行游标式的遍历，避免使用KEYS命令带来的性能问题。同时还有SSCAN/HSCAN/ZSCAN等命令，分别用于对Set/Hash/Sorted Set中的元素进行游标式遍历。SCAN类命令的使用请参考官方文档：<a href="https://redis.io/commands/scan" target="_blank" rel="external">https://redis.io/commands/scan</a></p>
<p>Redis提供了Slow Log功能，可以自动记录耗时较长的命令。相关的配置参数有两个：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">slowlog-log-slower-than xxxms  <span class="comment">#执行时间慢于xxx毫秒的命令计入Slow Log</span></div><div class="line">slowlog-max-len xxx  <span class="comment">#Slow Log的长度，即最大纪录多少条Slow Log</span></div></pre></td></tr></table></figure></p>
<p>使用<strong>SLOWLOG GET [number]</strong>命令，可以输出最近进入Slow Log的number条命令。<br>使用<strong>SLOWLOG RESET</strong>命令，可以重置Slow Log</p>
<h2 id="网络引发的延迟"><a href="#网络引发的延迟" class="headerlink" title="网络引发的延迟"></a>网络引发的延迟</h2><ul>
<li>尽可能使用长连接或连接池，避免频繁创建销毁连接</li>
<li>客户端进行的批量数据操作，应使用Pipeline特性在一次交互中完成。具体请参照本文的Pipelining章节</li>
</ul>
<h2 id="数据持久化引发的延迟"><a href="#数据持久化引发的延迟" class="headerlink" title="数据持久化引发的延迟"></a>数据持久化引发的延迟</h2><p>Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：</p>
<ul>
<li>AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响</li>
<li>AOF + fsync every second是比较好的折中方案，每秒fsync一次</li>
<li>AOF + fsync never会提供AOF持久化方案下的最优性能</li>
<li>使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置</li>
<li>每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟</li>
</ul>
<blockquote>
<p>Redis在fork子进程时需要将内存分页表拷贝至子进程，以占用了24GB内存的Redis实例为例，共需要拷贝24GB / 4kB * 8 = 48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。</p>
<p>可以通过INFO命令返回的latest_fork_usec字段查看上一次fork操作的耗时（微秒）</p>
</blockquote>
<h2 id="Swap引发的延迟"><a href="#Swap引发的延迟" class="headerlink" title="Swap引发的延迟"></a>Swap引发的延迟</h2><p>当Linux将Redis所用的内存分页移至swap空间时，将会阻塞Redis进程，导致Redis出现不正常的延迟。Swap通常在物理内存不足或一些进程在进行大量I/O操作时发生，应尽可能避免上述两种情况的出现。</p>
<p><code>/proc/&lt;pid&gt;/smaps</code>文件中会保存进程的swap记录，通过查看这个文件，能够判断Redis的延迟是否由Swap产生。如果这个文件中记录了较大的Swap size，则说明延迟很有可能是Swap造成的。</p>
<h2 id="数据淘汰引发的延迟"><a href="#数据淘汰引发的延迟" class="headerlink" title="数据淘汰引发的延迟"></a>数据淘汰引发的延迟</h2><p>当同一秒内有大量key过期时，也会引发Redis的延迟。在使用时应尽量将key的失效时间错开。</p>
<h2 id="引入读写分离机制"><a href="#引入读写分离机制" class="headerlink" title="引入读写分离机制"></a>引入读写分离机制</h2><p>Redis的主从复制能力可以实现一主多从的多节点架构，在这一架构下，主节点接收所有写请求，并将数据同步给多个从节点。<br>在这一基础上，我们可以让从节点提供对实时性要求不高的读请求服务，以减小主节点的压力。<br>尤其是针对一些使用了长耗时命令的统计类任务，完全可以指定在一个或多个从节点上执行，避免这些长耗时命令影响其他请求的响应。</p>
<h1 id="主从复制与集群分片"><a href="#主从复制与集群分片" class="headerlink" title="主从复制与集群分片"></a>主从复制与集群分片</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis支持一主多从的主从复制架构。一个Master实例负责处理所有的写请求，Master将写操作同步至所有Slave。<br>借助Redis的主从复制，可以实现读写分离和高可用：</p>
<ul>
<li>实时性要求不是特别高的读请求，可以在Slave上完成，提升效率。特别是一些周期性执行的统计任务，这些任务可能需要执行一些长耗时的Redis命令，可以专门规划出1个或几个Slave用于服务这些统计任务</li>
<li>借助Redis Sentinel可以实现高可用，当Master crash后，Redis Sentinel能够自动将一个Slave晋升为Master，继续提供服务</li>
</ul>
<p>启用主从复制非常简单，只需要配置多个Redis实例，在作为Slave的Redis实例中配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slaveof 192.168.1.1 6379  <span class="comment">#指定Master的IP和端口</span></div></pre></td></tr></table></figure></p>
<p>当Slave启动后，会从Master进行一次冷启动数据同步，由Master触发BGSAVE生成RDB文件推送给Slave进行导入，导入完成后Master再将增量数据通过Redis Protocol同步给Slave。之后主从之间的数据便一直以Redis Protocol进行同步</p>
<h2 id="使用Sentinel做自动failover"><a href="#使用Sentinel做自动failover" class="headerlink" title="使用Sentinel做自动failover"></a>使用Sentinel做自动failover</h2><p>Redis的主从复制功能本身只是做数据同步，并不提供监控和自动failover能力，要通过主从复制功能来实现Redis的高可用，还需要引入一个组件：Redis Sentinel</p>
<p>Redis Sentinel是Redis官方开发的监控组件，可以监控Redis实例的状态，通过Master节点自动发现Slave节点，并在监测到Master节点失效时选举出一个新的Master，并向所有Redis实例推送新的主从配置。</p>
<p>Redis Sentinel需要至少部署3个实例才能形成选举关系。</p>
<p>关键配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sentinel monitor mymaster 127.0.0.1 6379 2  <span class="comment">#Master实例的IP、端口，以及选举需要的赞成票数</span></div><div class="line">sentinel down-after-milliseconds mymaster 60000  <span class="comment">#多长时间没有响应视为Master失效</span></div><div class="line">sentinel failover-timeout mymaster 180000  <span class="comment">#两次failover尝试间的间隔时长</span></div><div class="line">sentinel parallel-syncs mymaster 1  <span class="comment">#如果有多个Slave，可以通过此配置指定同时从新Master进行数据同步的Slave数，避免所有Slave同时进行数据同步导致查询服务也不可用</span></div></pre></td></tr></table></figure></p>
<p>另外需要注意的是，Redis Sentinel实现的自动failover不是在同一个IP和端口上完成的，也就是说自动failover产生的新Master提供服务的IP和端口与之前的Master是不一样的，所以要实现HA，还要求客户端必须支持Sentinel，能够与Sentinel交互获得新Master的信息才行。</p>
<h2 id="集群分片"><a href="#集群分片" class="headerlink" title="集群分片"></a>集群分片</h2><p>为何要做集群分片：</p>
<ul>
<li>Redis中存储的数据量大，一台主机的物理内存已经无法容纳</li>
<li>Redis的写请求并发量大，一个Redis实例以无法承载</li>
</ul>
<p>当上述两个问题出现时，就必须要对Redis进行分片了。<br>Redis的分片方案有很多种，例如很多Redis的客户端都自行实现了分片功能，也有向Twemproxy这样的以代理方式实现的Redis分片方案。然而首选的方案还应该是Redis官方在3.0版本中推出的Redis Cluster分片方案。</p>
<p>本文不会对Redis Cluster的具体安装和部署细节进行介绍，重点介绍Redis Cluster带来的好处与弊端。</p>
<h3 id="Redis-Cluster的能力"><a href="#Redis-Cluster的能力" class="headerlink" title="Redis Cluster的能力"></a>Redis Cluster的能力</h3><ul>
<li>能够自动将数据分散在多个节点上</li>
<li>当访问的key不在当前分片上时，能够自动将请求转发至正确的分片</li>
<li>当集群中部分节点失效时仍能提供服务</li>
</ul>
<p>其中第三点是基于主从复制来实现的，Redis Cluster的每个数据分片都采用了主从复制的结构，原理和前文所述的主从复制完全一致，唯一的区别是省去了Redis Sentinel这一额外的组件，由Redis Cluster负责进行一个分片内部的节点监控和自动failover。</p>
<h3 id="Redis-Cluster分片原理"><a href="#Redis-Cluster分片原理" class="headerlink" title="Redis Cluster分片原理"></a>Redis Cluster分片原理</h3><p>Redis Cluster中共有16384个hash slot，Redis会计算每个key的CRC16，将结果与16384取模，来决定该key存储在哪一个hash slot中，同时需要指定Redis Cluster中每个数据分片负责的Slot数。Slot的分配在任何时间点都可以进行重新分配。</p>
<p>客户端在对key进行读写操作时，可以连接Cluster中的任意一个分片，如果操作的key不在此分片负责的Slot范围内，Redis Cluster会自动将请求重定向到正确的分片上。</p>
<h3 id="hash-tags"><a href="#hash-tags" class="headerlink" title="hash tags"></a>hash tags</h3><p>在基础的分片原则上，Redis还支持hash tags功能，以hash tags要求的格式明明的key，将会确保进入同一个Slot中。例如：{uiv}user:1000和{uiv}user:1001拥有同样的hash tag {uiv}，会保存在同一个Slot中。</p>
<p>使用Redis Cluster时，pipelining、事务和LUA Script功能涉及的key必须在同一个数据分片上，否则将会返回错误。如要在Redis Cluster中使用上述功能，就必须通过hash tags来确保一个pipeline或一个事务中操作的所有key都位于同一个Slot中。</p>
<blockquote>
<p>有一些客户端（如Redisson）实现了集群化的pipelining操作，可以自动将一个pipeline里的命令按key所在的分片进行分组，分别发到不同的分片上执行。但是Redis不支持跨分片的事务，事务和LUA Script还是必须遵循所有key在一个分片上的规则要求。</p>
</blockquote>
<h2 id="主从复制-vs-集群分片"><a href="#主从复制-vs-集群分片" class="headerlink" title="主从复制 vs 集群分片"></a>主从复制 vs 集群分片</h2><p>设计软件架构时，要如何在主从复制和集群分片两种部署方案中取舍呢？</p>
<p>从各个方面看，Redis Cluster都是优于主从复制的方案</p>
<ul>
<li>Redis Cluster能够解决单节点上数据量过大的问题</li>
<li>Redis Cluster能够解决单节点访问压力过大的问题</li>
<li>Redis Cluster包含了主从复制的能力<br>那是不是代表Redis Cluster永远是优于主从复制的选择呢？</li>
</ul>
<p>并不是。</p>
<p>软件架构永远不是越复杂越好，复杂的架构在带来显著好处的同时，一定也会带来相应的弊端。采用Redis Cluster的弊端包括：</p>
<ul>
<li>维护难度增加。在使用Redis Cluster时，需要维护的Redis实例数倍增，需要监控的主机数量也相应增加，数据备份/持久化的复杂度也会增加。同时在进行分片的增减操作时，还需要进行reshard操作，远比主从模式下增加一个Slave的复杂度要高。</li>
<li>客户端资源消耗增加。当客户端使用连接池时，需要为每一个数据分片维护一个连接池，客户端同时需要保持的连接数成倍增多，加大了客户端本身和操作系统资源的消耗。</li>
<li>性能优化难度增加。你可能需要在多个分片上查看Slow Log和Swap日志才能定位性能问题。</li>
<li>事务和LUA Script的使用成本增加。在Redis Cluster中使用事务和LUA Script特性有严格的限制条件，事务和Script中操作的key必须位于同一个分片上，这就使得在开发时必须对相应场景下涉及的key进行额外的规划和规范要求。如果应用的场景中大量涉及事务和Script的使用，如何在保证这两个功能的正常运作前提下把数据平均分到多个数据分片中就会成为难点。</li>
</ul>
<p>所以说，在主从复制和集群分片两个方案中做出选择时，应该从应用软件的功能特性、数据和访问量级、未来发展规划等方面综合考虑，只在确实有必要引入数据分片时再使用Redis Cluster。<br>下面是一些建议：</p>
<ol>
<li>需要在Redis中存储的数据有多大？未来2年内可能发展为多大？这些数据是否都需要长期保存？是否可以使用LRU算法进行非热点数据的淘汰？综合考虑前面几个因素，评估出Redis需要使用的物理内存。</li>
<li>用于部署Redis的主机物理内存有多大？有多少可以分配给Redis使用？对比(1)中的内存需求评估，是否足够用？</li>
<li>Redis面临的并发写压力会有多大？在不使用pipelining时，Redis的写性能可以超过10万次/秒（更多的benchmark可以参考 <a href="https://redis.io/topics/benchmarks" target="_blank" rel="external">https://redis.io/topics/benchmarks</a> ）</li>
<li>在使用Redis时，是否会使用到pipelining和事务功能？使用的场景多不多？</li>
</ol>
<p>综合上面几点考虑，如果单台主机的可用物理内存完全足以支撑对Redis的容量需求，且Redis面临的并发写压力距离Benchmark值还尚有距离，建议采用主从复制的架构，可以省去很多不必要的麻烦。同时，如果应用中大量使用pipelining和事务，也建议尽可能选择主从复制架构，可以减少设计和开发时的复杂度。</p>
<h1 id="Redis-Java客户端的选择"><a href="#Redis-Java客户端的选择" class="headerlink" title="Redis Java客户端的选择"></a>Redis Java客户端的选择</h1><p>Redis的Java客户端很多，官方推荐的有三种：Jedis、Redisson和lettuce。</p>
<p>在这里对Jedis和Redisson进行对比介绍</p>
<p>Jedis：</p>
<ul>
<li>轻量，简洁，便于集成和改造</li>
<li>支持连接池</li>
<li>支持pipelining、事务、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持读写分离，需要自己实现</li>
<li>文档差（真的很差，几乎没有……）</li>
</ul>
<p>Redisson：</p>
<ul>
<li>基于Netty实现，采用非阻塞IO，性能高</li>
<li>支持异步请求</li>
<li>支持连接池</li>
<li>支持pipelining、LUA Scripting、Redis Sentinel、Redis Cluster</li>
<li>不支持事务，官方建议以LUA Scripting代替事务</li>
<li>支持在Redis Cluster架构下使用pipelining</li>
<li>支持读写分离，支持读负载均衡，在主从复制和Redis Cluster架构下都可以使用</li>
<li>内建Tomcat Session Manager，为Tomcat 6/7/8提供了会话共享功能</li>
<li>可以与Spring Session集成，实现基于Redis的会话共享</li>
<li>文档较丰富，有中文文档</li>
</ul>
<p>对于Jedis和Redisson的选择，同样应遵循前述的原理，尽管Jedis比起Redisson有各种各样的不足，但也应该在需要使用Redisson的高级特性时再选用Redisson，避免造成不必要的程序复杂度提升。</p>
<p>Jedis：<br>github：<a href="https://github.com/xetorthio/jedis" target="_blank" rel="external">https://github.com/xetorthio/jedis</a><br>文档：<a href="https://github.com/xetorthio/jedis/wiki" target="_blank" rel="external">https://github.com/xetorthio/jedis/wiki</a></p>
<p>Redisson：<br>github：<a href="https://github.com/redisson/redisson" target="_blank" rel="external">https://github.com/redisson/redisson</a><br>文档：<a href="https://github.com/redisson/redisson/wiki" target="_blank" rel="external">https://github.com/redisson/redisson/wiki</a></p>
<p>from <a href="http://www.jianshu.com/p/2f14bc570563" target="_blank" rel="external">http://www.jianshu.com/p/2f14bc570563</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文将从Redis的基本特性入手，通过讲述Redis的数据结构和主要命令对Redis的基本能力进行直观介绍。之后概览Redis提供的高级能力，并在部署、维护、性能调优等多个方面进行更深入的介绍和指导。&lt;br&gt;本文适合使用Redis的普通开发人员，以及对Redis进行选型、架构设计和性能调优的架构设计人员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Redis是一个开源的，基于内存的结构化数据存储媒介，可以作为数据库、缓存服务或消息服务使用。&lt;br&gt;Redis支持多种数据结构，包括字符串、哈希表、链表、集合、有序集合、位图、Hyperloglogs等。&lt;br&gt;Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。&lt;/p&gt;
&lt;p&gt;Redis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求，同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常&lt;/li&gt;
&lt;li&gt;Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))&lt;/li&gt;
&lt;li&gt;使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="redis" scheme="http://idiotsky.me/categories/redis/"/>
    
    
      <category term="redis" scheme="http://idiotsky.me/tags/redis/"/>
    
      <category term="redis cluster" scheme="http://idiotsky.me/tags/redis-cluster/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile 指令 VOLUME 介绍</title>
    <link href="http://idiotsky.me/2017/04/06/docker-dockerfile-volume/"/>
    <id>http://idiotsky.me/2017/04/06/docker-dockerfile-volume/</id>
    <published>2017-04-06T14:47:17.000Z</published>
    <updated>2017-09-06T15:03:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍VOLUME指令之前，我们来看下如下场景需求：</p>
<ol>
<li>容器是基于镜像创建的，最后的容器文件系统包括镜像的只读层+可写层，容器中的进程操作的数据持久化都是保存在容器的可写层上。一旦容器删除后，这些数据就没了，除非我们人工备份下来（或者基于容器创建新的镜像）。能否可以让容器进程持久化的数据保存在主机上呢？这样即使容器删除了，数据还在。</li>
<li>当我们在开发一个web应用时，开发环境是在主机本地，但运行测试环境是放在docker容器上。<br>这样的话，我在主机上修改文件（如html，js等）后，需要再同步到容器中。这显然比较麻烦。</li>
<li>多个容器运行一组相关联的服务，如果他们要共享一些数据怎么办？<br>对于这些问题，我们当然能想到各种解决方案。而docker本身提供了一种机制，可以将主机上的某个目录与容器的某个目录（称为挂载点、或者叫卷）关联起来，容器上的挂载点下的内容就是主机的这个目录下的内容，这类似linux系统下mount的机制。 这样的话，我们修改主机上该目录的内容时，不需要同步容器，对容器来说是立即生效的。 挂载点可以让多个容器共享。</li>
</ol>
<p>下面我们来介绍具体的机制。<br><a id="more"></a></p>
<h1 id="通过docker-run命令"><a href="#通过docker-run命令" class="headerlink" title="通过docker run命令"></a>通过docker run命令</h1><ol>
<li><p>运行命令：<code>docker run --name test -it -v /home/xqh/myimage:/data ubuntu /bin/bash</code><br>其中的 -v 标记 在容器中设置了一个挂载点 /data（就是容器中的一个目录），并将主机上的 /home/xqh/myimage 目录中的内容关联到 /data下。<br>这样在容器中对/data目录下的操作，还是在主机上对/home/xqh/myimage的操作，都是完全实时同步的，因为这两个目录实际都是指向主机目录。</p>
</li>
<li><p>运行命令：<code>docker run --name test1 -it -v /data ubuntu /bin/bash</code><br>上面-v的标记只设置了容器的挂载点，并没有指定关联的主机目录。这时docker会自动绑定主机上的一个目录。通过docker inspect 命令可以查看到。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="string">"Mounts"</span>: [</div><div class="line">    &#123;</div><div class="line">        <span class="string">"Name"</span>: <span class="string">"0ab0aaf0d6ef391cb68b72bd8c43216a8f8ae9205f0ae941ef16ebe32dc9fc01"</span>,</div><div class="line">        <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/0ab0aaf0d6ef391cb68b72bd8c43216a8f8ae9205f0ae941ef16ebe32dc9fc01/_data"</span>,</div><div class="line">        <span class="string">"Destination"</span>: <span class="string">"/data"</span>,</div><div class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</div><div class="line">        <span class="string">"Mode"</span>: <span class="string">""</span>,</div><div class="line">        <span class="string">"RW"</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure>
<p> 上面 Mounts下的每条信息记录了容器上一个挂载点的信息，”Destination” 值是容器的挂载点，”Source”值是对应的主机目录。<br> 可以看出这种方式对应的主机目录是自动创建的，其目的不是让在主机上修改，而是让多个容器共享。</p>
</li>
</ol>
<h1 id="通过dockerfile创建挂载点"><a href="#通过dockerfile创建挂载点" class="headerlink" title="通过dockerfile创建挂载点"></a>通过dockerfile创建挂载点</h1><p>上面介绍的通过docker run命令的-v标识创建的挂载点只能对创建的容器有效。<br>通过dockerfile的 VOLUME 指令可以在镜像中创建挂载点，这样只要通过该镜像创建的容器都有了挂载点。<br>还有一个区别是，通过 VOLUME 指令创建的挂载点，无法指定主机上对应的目录，是自动生成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#test</div><div class="line">FROM ubuntu</div><div class="line">MAINTAINER hello1</div><div class="line">VOLUME [&quot;/data1&quot;,&quot;/data2&quot;]</div></pre></td></tr></table></figure></p>
<p>上面的dockfile文件通过VOLUME指令指定了两个挂载点 /data1 和 /data2.<br>我们通过docker inspect 查看通过该dockerfile创建的镜像生成的容器，可以看到如下信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&quot;Mounts&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;Name&quot;: &quot;d411f6b8f17f4418629d4e5a1ab69679dee369b39e13bb68bed77aa4a0d12d21&quot;,</div><div class="line">            &quot;Source&quot;: &quot;/var/lib/docker/volumes/d411f6b8f17f4418629d4e5a1ab69679dee369b39e13bb68bed77aa4a0d12d21/_data&quot;,</div><div class="line">            &quot;Destination&quot;: &quot;/data1&quot;,</div><div class="line">            &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">            &quot;Mode&quot;: &quot;&quot;,</div><div class="line">            &quot;RW&quot;: true</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            &quot;Name&quot;: &quot;6d3badcf47c4ac5955deda6f6ae56f4aaf1037a871275f46220c14ebd762fc36&quot;,</div><div class="line">            &quot;Source&quot;: &quot;/var/lib/docker/volumes/6d3badcf47c4ac5955deda6f6ae56f4aaf1037a871275f46220c14ebd762fc36/_data&quot;,</div><div class="line">            &quot;Destination&quot;: &quot;/data2&quot;,</div><div class="line">            &quot;Driver&quot;: &quot;local&quot;,</div><div class="line">            &quot;Mode&quot;: &quot;&quot;,</div><div class="line">            &quot;RW&quot;: true</div><div class="line">        &#125;</div><div class="line">    ],</div></pre></td></tr></table></figure></p>
<p>可以看到两个挂载点的信息。</p>
<h1 id="容器共享卷（挂载点）"><a href="#容器共享卷（挂载点）" class="headerlink" title="容器共享卷（挂载点）"></a>容器共享卷（挂载点）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name test1 -it myimage /bin/bash</div></pre></td></tr></table></figure>
<p>上面命令中的 myimage是用前面的dockerfile文件构建的镜像。 这样容器test1就有了 /data1 和 /data2两个挂载点。<br>下面我们创建另一个容器可以和test1共享 /data1 和 /data2卷 ，这是在 docker run中使用 –volumes-from标记，如：<br>可以是来源不同镜像，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name test2 -it --volumes-from test1  ubuntu  /bin/bash</div></pre></td></tr></table></figure></p>
<p>也可以是同一镜像，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name test3 -it --volumes-from test1  myimage  /bin/bash</div></pre></td></tr></table></figure></p>
<p>上面的三个容器 test1 , test2 , test3 均有 /data1 和 /data2 两个目录，且目录中内容是共享的，任何一个容器修改了内容，别的容器都能获取到。</p>
<h1 id="最佳实践：数据容器"><a href="#最佳实践：数据容器" class="headerlink" title="最佳实践：数据容器"></a>最佳实践：数据容器</h1><p>如果多个容器需要共享数据（如持久化数据库、配置文件或者数据文件等），可以考虑创建一个特定的数据容器，该容器有1个或多个卷。<br>其它容器通过–volumes-from 来共享这个数据容器的卷。<br>因为容器的卷本质上对应主机上的目录，所以这个数据容器也不需要启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name dbdata myimage echo &quot;data container&quot;</div></pre></td></tr></table></figure></p>
<p>from <a href="http://www.cnblogs.com/51kata/p/5266626.html" target="_blank" rel="external">http://www.cnblogs.com/51kata/p/5266626.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在介绍VOLUME指令之前，我们来看下如下场景需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容器是基于镜像创建的，最后的容器文件系统包括镜像的只读层+可写层，容器中的进程操作的数据持久化都是保存在容器的可写层上。一旦容器删除后，这些数据就没了，除非我们人工备份下来（或者基于容器创建新的镜像）。能否可以让容器进程持久化的数据保存在主机上呢？这样即使容器删除了，数据还在。&lt;/li&gt;
&lt;li&gt;当我们在开发一个web应用时，开发环境是在主机本地，但运行测试环境是放在docker容器上。&lt;br&gt;这样的话，我在主机上修改文件（如html，js等）后，需要再同步到容器中。这显然比较麻烦。&lt;/li&gt;
&lt;li&gt;多个容器运行一组相关联的服务，如果他们要共享一些数据怎么办？&lt;br&gt;对于这些问题，我们当然能想到各种解决方案。而docker本身提供了一种机制，可以将主机上的某个目录与容器的某个目录（称为挂载点、或者叫卷）关联起来，容器上的挂载点下的内容就是主机的这个目录下的内容，这类似linux系统下mount的机制。 这样的话，我们修改主机上该目录的内容时，不需要同步容器，对容器来说是立即生效的。 挂载点可以让多个容器共享。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们来介绍具体的机制。&lt;br&gt;
    
    </summary>
    
      <category term="docker" scheme="http://idiotsky.me/categories/docker/"/>
    
    
      <category term="docker" scheme="http://idiotsky.me/tags/docker/"/>
    
  </entry>
  
</feed>
