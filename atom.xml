<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IdiotSky</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://idiotsky.me/"/>
  <updated>2018-05-07T14:31:33.474Z</updated>
  <id>http://idiotsky.me/</id>
  
  <author>
    <name>ejunjsh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>看书总结-深入理解计算机系统</title>
    <link href="http://idiotsky.me/2018/03/21/csapp-summary/"/>
    <id>http://idiotsky.me/2018/03/21/csapp-summary/</id>
    <published>2018-03-21T11:42:47.000Z</published>
    <updated>2018-05-07T14:31:33.474Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>看了几个月，终于看完了，感觉就是相见恨晚，如果早看，现在应该不同了吧。目前还在做习题，顺便用这篇来记录一些笔记吧</p>
</blockquote>
<h1 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h1><p>这一章里面基本是对整本书的一个概括吧。</p>
<ul>
<li>gcc 翻译源码的的四个阶段：预处理，编译，汇编，链接</li>
<li>系统硬件组成：总线，I/O设备，主存，处理器</li>
<li>存储设备的层次结构：L0(寄存器)，L1,L2,L3(SRAM),L4(主存DRAM),L5(磁盘),L6(…)</li>
<li>并发运行则是说一个进程的指令和另一个进程的指令交错执行的</li>
<li>无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。</li>
<li>操作系统实现这种交错执行的机制称为上下文切换</li>
<li>虚拟内存是一个抽象概念，它为每个进程提供一个假象，即每个进程都是独占地使用主存。每个进程看到的内存都是一致的，称为虚拟内存空间</li>
<li>每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩</li>
<li>一个进程实际上可以由多个称为线程的执行单位组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</li>
<li>超线程是一项允许一个cpu执行多个控制流的技术</li>
</ul>
<a id="more"></a>
<h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><ul>
<li>大多数计算机使用8位的块，或者字节（byte）,作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，成为虚拟内存。内存的每个字节都由一个唯一的数字来表识，称为它的地址，所有可能的地址的集合就称为虚拟内存空间</li>
<li>c的指针包含值和类型，它的值表示某个对象的位置，它的类型表示那个位置上所存储对象的类型</li>
<li>对于一个字长为w位的机器，虚拟地址范围为0～2^w-1,程序最多访问2^w个字节</li>
<li>最低有效字节在最前面的方式，称为小端法，最高有效字节在最前面的方式，称为大端法。</li>
<li>最常见的有符号数的计算机表示方式就是补码</li>
<li>几乎所有的编译器/机器组合都对有符号数使用算数右移</li>
<li>对于大多数c语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变</li>
<li>两个数的w位补码之和与无符号之和有完全相同的位级表示，乘法也一样</li>
</ul>
<h1 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><p>这篇是汇编相关，精华👿</p>
<ul>
<li>汇编代码是机器代码的文本表示</li>
<li>目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。</li>
<li>x86-64的虚拟地址是由64位的字来表示的，目前的实现中，高16位都必须设置为0，所以一个地址实际上能够指定的是2^48或者64TB范围内的一个字节。</li>
<li>传送指令的两个操作数不能都指向内存位置</li>
<li>由于是从16位体系结构扩展成32位的，Intel用术语“字(word)”表示16位数据类型。因此，32位数为“双字(double words)”，64位数为“四字(quad words)”</li>
<li>函数通过把值存储在寄存器%rax或寄存器的某个低位部分中返回</li>
<li>栈向下增长，栈顶元素的地址是所有栈中元素地址中最低的，栈指针%rsp保存着栈顶元素的地址。</li>
<li>跳转指令有几种不同的编码，但是最常用都是PC相对的(PC-relative)</li>
<li>将栈指针减少一个适当的量可以为没有指定初始值的数据在栈上分配空间。类似的，可以通过增加栈指针来释放空间</li>
<li>当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分成为过程的栈帧(stack frame)</li>
<li>可以通过寄存器最多传递6个整型（例如整数和指针）的参数，超出6个的部分就要通过栈来传递</li>
<li>根据惯例，寄存器%rbx,%rbp和%r12～%r15被划分为被调用者保存寄存器</li>
<li>所有其他的寄存器，除了栈指针%rsp,都分类为调用者保存寄存器</li>
<li>数组元素在内存中按照“行优先”的顺序排列</li>
<li>一个联合的总大小等于它最大字段的大小</li>
</ul>
<blockquote>
<p>to be continue….</p>
</blockquote>
<!-- more -->]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;看了几个月，终于看完了，感觉就是相见恨晚，如果早看，现在应该不同了吧。目前还在做习题，顺便用这篇来记录一些笔记吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;计算机系统漫游&quot;&gt;&lt;a href=&quot;#计算机系统漫游&quot; class=&quot;headerlink&quot; title=&quot;计算机系统漫游&quot;&gt;&lt;/a&gt;计算机系统漫游&lt;/h1&gt;&lt;p&gt;这一章里面基本是对整本书的一个概括吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gcc 翻译源码的的四个阶段：预处理，编译，汇编，链接&lt;/li&gt;
&lt;li&gt;系统硬件组成：总线，I/O设备，主存，处理器&lt;/li&gt;
&lt;li&gt;存储设备的层次结构：L0(寄存器)，L1,L2,L3(SRAM),L4(主存DRAM),L5(磁盘),L6(…)&lt;/li&gt;
&lt;li&gt;并发运行则是说一个进程的指令和另一个进程的指令交错执行的&lt;/li&gt;
&lt;li&gt;无论是在单核还是多核系统中，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。&lt;/li&gt;
&lt;li&gt;操作系统实现这种交错执行的机制称为上下文切换&lt;/li&gt;
&lt;li&gt;虚拟内存是一个抽象概念，它为每个进程提供一个假象，即每个进程都是独占地使用主存。每个进程看到的内存都是一致的，称为虚拟内存空间&lt;/li&gt;
&lt;li&gt;每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩&lt;/li&gt;
&lt;li&gt;一个进程实际上可以由多个称为线程的执行单位组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。&lt;/li&gt;
&lt;li&gt;超线程是一项允许一个cpu执行多个控制流的技术&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="books" scheme="http://idiotsky.me/categories/books/"/>
    
    
      <category term="csapp" scheme="http://idiotsky.me/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>Unicode和UTF-8</title>
    <link href="http://idiotsky.me/2018/03/19/unicode-utf8/"/>
    <id>http://idiotsky.me/2018/03/19/unicode-utf8/</id>
    <published>2018-03-19T15:43:59.000Z</published>
    <updated>2018-03-20T14:12:23.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这个很简单的说明了unicode和UTF-8的关系 👿</p>
</blockquote>
<ul>
<li>Unicode 是「字符集」</li>
<li>UTF-8 是「编码规则」</li>
</ul>
<p>其中：</p>
<ul>
<li>字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）</li>
<li>编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）</li>
</ul>
<a id="more"></a>
<p>广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和 UTF-8、UTF-16、UTF-32 等等编码……</p>
<p>Unicode 字符集为每一个字符分配一个码位，例如「知」的码位是 30693，记作 U+77E5（30693 的十六进制为 0x77E5）。</p>
<p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会将一个码位编码为 1 到 4 个字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">U+ 0000 ~ U+ 007F: 0XXXXXXX</div><div class="line">U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX</div><div class="line">U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX</div><div class="line">U+10000 ~ U+1FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</div></pre></td></tr></table></figure>
<p>根据上表中的编码规则，之前的「知」字的码位 U+77E5 属于第三行的范围：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">       7    7    E    5    </div><div class="line">    0111 0111 1110 0101    二进制的 77E5</div><div class="line">--------------------------</div><div class="line">    0111   011111   100101 二进制的 77E5</div><div class="line">1110XXXX 10XXXXXX 10XXXXXX 模版（上表第三行）</div><div class="line">11100111 10011111 10100101 代入模版</div><div class="line">   E   7    9   F    A   5</div></pre></td></tr></table></figure></p>
<p>这就是将 U+77E5 按照 UTF-8 编码为字节序列 E79FA5 的过程。反之亦然。</p>
<p>ref <a href="https://www.zhihu.com/question/23374078" target="_blank" rel="external">https://www.zhihu.com/question/23374078</a></p>
<p>百度百科其实也说得不错了<br><a href="https://baike.baidu.com/item/Unicode/750500" target="_blank" rel="external">https://baike.baidu.com/item/Unicode/750500</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个很简单的说明了unicode和UTF-8的关系 👿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Unicode 是「字符集」&lt;/li&gt;
&lt;li&gt;UTF-8 是「编码规则」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）&lt;/li&gt;
&lt;li&gt;编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编码" scheme="http://idiotsky.me/categories/%E7%BC%96%E7%A0%81/"/>
    
    
      <category term="Unicode" scheme="http://idiotsky.me/tags/Unicode/"/>
    
      <category term="UTF-8" scheme="http://idiotsky.me/tags/UTF-8/"/>
    
  </entry>
  
  <entry>
    <title>linux的写时复制</title>
    <link href="http://idiotsky.me/2018/03/13/linux-copy-on-write/"/>
    <id>http://idiotsky.me/2018/03/13/linux-copy-on-write/</id>
    <published>2018-03-13T15:32:23.000Z</published>
    <updated>2018-03-13T15:44:27.929Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前面一篇文章又给自己挖坑，所以必须再mark一篇，这篇文章很好的说了关于写时复制的原理。</p>
</blockquote>
<p>当调用fork()系统调用创建一个子进程时，Linux并不会为子进程创建新的物理内存空间，而是公用父进程的物理内存。这是因为Linux的内核开发者觉得，调用者调用fork()系统调用后会立刻调用exec()系统调用执行新的程序，这样旧的物理内存内容就没有什么作用了（因为新的程序与旧的程序完全没有关联），所以为子进程复制父进程的物理内存内容是一件徒劳无功的事情。</p>
<p>所以Linux的做法就是：父子进程共用同一物理内存。如下图：</p>
<p><a href="http://idiotsky.me/images2/linux-copy-on-write-1.png"><img src="http://idiotsky.me/images2/linux-copy-on-write-1.png" alt=""></a><br><a id="more"></a></p>
<p>但操作系统的要求是：进程之间的内存应该要独立，就是读写A进程的内存空间不应该影响B进程的内存内容。读操作是不会改变内存中的内容，所以对于读操作来说，共享物理内存是安全的。但是对于写操作就不一样，如果父子进程共用了相同的物理内存，那么对子进程的内存进行写操作同时会影响到父进程，所以违反了操作系统的要求。</p>
<p>Linux的解决方案是：把共用的物理内存设置为只读，因为读操作不会改变内存的内容，所以对于父子进程都是允许的。而当父子进程其中一个进行写操作时，因为内存被设置为只读，所以CPU会触发 “page fault” 的错误，从而调用内核的<code>do_page_fault()</code>函数。而<code>do_page_fault()</code>函数又会调用<code>do_wp_page()</code>函数去进行复制父进程内存的内容。</p>
<p><code>do_wp_page()</code>函数先进行一些安全监测，然后调用<code>__do_wp_page()</code>函数做最后的复制操作。去掉一些监测后，<code>__do_wp_page()</code>函数的代码如下图：</p>
<p><a href="http://idiotsky.me/images2/linux-copy-on-write-3.jpg"><img src="http://idiotsky.me/images2/linux-copy-on-write-3.jpg" alt=""></a> </p>
<p><code>__do_wp_page()</code>首先会申请一块新的物理内存，然后复制旧的物理内存页的内容到新的物理内存也中，然后设置虚拟内存与物理内存的映射关系。最后把父子进程的物理内存设置可读写，这样父子进程相同的虚拟内存都指向不同的物理内存，所以达到进程之间内存隔离的目的。如下图：</p>
<p><a href="http://idiotsky.me/images2/linux-copy-on-write-2.png"><img src="http://idiotsky.me/images2/linux-copy-on-write-2.png" alt=""></a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前面一篇文章又给自己挖坑，所以必须再mark一篇，这篇文章很好的说了关于写时复制的原理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当调用fork()系统调用创建一个子进程时，Linux并不会为子进程创建新的物理内存空间，而是公用父进程的物理内存。这是因为Linux的内核开发者觉得，调用者调用fork()系统调用后会立刻调用exec()系统调用执行新的程序，这样旧的物理内存内容就没有什么作用了（因为新的程序与旧的程序完全没有关联），所以为子进程复制父进程的物理内存内容是一件徒劳无功的事情。&lt;/p&gt;
&lt;p&gt;所以Linux的做法就是：父子进程共用同一物理内存。如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://idiotsky.me/images2/linux-copy-on-write-1.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images2/linux-copy-on-write-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://idiotsky.me/categories/linux/"/>
    
    
      <category term="linux" scheme="http://idiotsky.me/tags/linux/"/>
    
      <category term="linux内核" scheme="http://idiotsky.me/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>linux的零拷贝技术</title>
    <link href="http://idiotsky.me/2018/03/13/linux-zero-copy/"/>
    <id>http://idiotsky.me/2018/03/13/linux-zero-copy/</id>
    <published>2018-03-13T14:01:39.000Z</published>
    <updated>2018-03-24T03:07:11.029Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>👿 linux内核里面为所有文件描述符建立缓存的，而用户层也有自己的缓存，那样每次read和write等相关系统调用，不但有可能上下文切换，而且还要不断从用户态拷贝到内核态或者从内核态拷贝到用户态。如果有些数据不用经过用户层的话（例如网络代理服务），可以不用这种拷贝来浪费资源，所以Linux的系统调用就有了几个零拷贝的函数来解决这种问题。（虽说零拷贝，但其实也只是减少了用户态拷贝，把所有拷贝都在内核里面处理了）</p>
</blockquote>
<h1 id="引文"><a href="#引文" class="headerlink" title="引文"></a>引文</h1><p>在写一个服务端程序时（Web Server或者文件服务器），文件下载是一个基本功能。这时候服务端的任务是：<strong>将服务端主机磁盘中的文件不做修改地从已连接的socket发出去</strong>，我们通常用下面的代码完成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>((n = read(diskfd, buf, BUF_SIZE)) &gt; <span class="number">0</span>)</div><div class="line">    write(sockfd, buf , n);</div></pre></td></tr></table></figure></p>
<p>基本操作就是循环的从磁盘读入文件内容到缓冲区，再将缓冲区的内容发送到socket。但是由于Linux的I/O操作默认是缓冲I/O。这里面主要使用的也就是read和write两个系统调用，我们并不知道操作系统在其中做了什么。实际上在以上I/O操作中，发生了多次的数据拷贝。<br><a id="more"></a></p>
<p>当应用程序访问某块数据时，操作系统首先会检查，是不是最近访问过此文件，文件内容是否缓存在内核缓冲区，如果是，操作系统则直接根据read系统调用提供的buf地址，将内核缓冲区的内容拷贝到buf所指定的用户空间缓冲区中去。如果不是，操作系统则首先将磁盘上的数据拷贝的内核缓冲区，这一步目前主要依靠DMA来传输，然后再把内核缓冲区上的内容拷贝到用户缓冲区中。<br>接下来，write系统调用再把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后socket再把内核缓冲区的内容发送到网卡上。<br>说了这么多，不如看图清楚：</p>
<p><a href="http://idiotsky.me/images2/linux-zero-copy-1.png"><img src="http://idiotsky.me/images2/linux-zero-copy-1.png" alt=""></a> </p>
<p>从上图中可以看出，共产生了四次数据拷贝，即使使用了DMA来处理了与硬件的通讯，CPU仍然需要处理两次数据拷贝，与此同时，在用户态与内核态也发生了多次上下文切换，无疑也加重了CPU负担。<br>在此过程中，我们没有对文件内容做任何修改，那么在内核空间和用户空间来回拷贝数据无疑就是一种浪费，而零拷贝主要就是为了解决这种低效性。</p>
<h1 id="什么是零拷贝技术（zero-copy）？"><a href="#什么是零拷贝技术（zero-copy）？" class="headerlink" title="什么是零拷贝技术（zero-copy）？"></a>什么是零拷贝技术（zero-copy）？</h1><p>零拷贝主要的任务就是避免CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。</p>
<p>我们继续回到引文中的例子，我们如何减少数据拷贝的次数呢？一个很明显的着力点就是减少数据在内核空间和用户空间来回拷贝，这也引入了零拷贝的一个类型：</p>
<h2 id="使用mmap"><a href="#使用mmap" class="headerlink" title="使用mmap"></a>使用mmap</h2><p>我们减少拷贝次数的一种方法是调用mmap()来代替read调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">buf = mmap(diskfd, len);</div><div class="line">write(sockfd, buf, len);</div></pre></td></tr></table></figure></p>
<p>应用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。<br>同样的，看图很简单：</p>
<p><a href="http://idiotsky.me/images2/linux-zero-copy-2.png"><img src="http://idiotsky.me/images2/linux-zero-copy-2.png" alt=""></a> </p>
<p>使用mmap替代read很明显减少了一次拷贝，当拷贝数据量很大时，无疑提升了效率。但是使用mmap是有代价的。当你使用mmap时，你可能会遇到一些隐藏的陷阱。例如，当你的程序map了一个文件，但是当这个文件被另一个进程截断(truncate)时, write系统调用会因为访问非法地址而被SIGBUS信号终止。SIGBUS信号默认会杀死你的进程并产生一个coredump,如果你的服务器这样被中止了，那会产生一笔损失。</p>
<p>通常我们使用以下解决方案避免这种问题：</p>
<ol>
<li>为SIGBUS信号建立信号处理程序<br>当遇到SIGBUS信号时，信号处理程序简单地返回，write系统调用在被中断之前会返回已经写入的字节数，并且errno会被设置成success,但是这是一种糟糕的处理办法，因为你并没有解决问题的实质核心。</li>
<li>使用文件租借锁<br>通常我们使用这种方法，在文件描述符上使用租借锁，我们为文件向内核申请一个租借锁，当其它进程想要截断这个文件时，内核会向我们发送一个实时的RT_SIGNAL_LEASE信号，告诉我们内核正在破坏你加持在文件上的读写锁。这样在程序访问非法内存并且被SIGBUS杀死之前，你的write系统调用会被中断。write会返回已经写入的字节数，并且置errno为success。</li>
</ol>
<p>我们应该在mmap文件之前加锁，并且在操作完文件后解锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(fcntl(diskfd, F_SETSIG, RT_SIGNAL_LEASE) == <span class="number">-1</span>) &#123;</div><div class="line">    perror(<span class="string">"kernel lease set signal"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* l_type can be F_RDLCK F_WRLCK  加锁*/</span></div><div class="line"><span class="comment">/* l_type can be  F_UNLCK 解锁*/</span></div><div class="line"><span class="keyword">if</span>(fcntl(diskfd, F_SETLEASE, l_type))&#123;</div><div class="line">    perror(<span class="string">"kernel lease set type"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="使用sendfile"><a href="#使用sendfile" class="headerlink" title="使用sendfile"></a>使用sendfile</h2><p>从2.1版内核开始，Linux引入了sendfile来简化操作:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> sendfile(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count);</div></pre></td></tr></table></figure></p>
<p>系统调用sendfile()在代表输入文件的描述符in_fd和代表输出文件的描述符out_fd之间传送文件内容（字节）。描述符out_fd必须指向一个套接字，而in_fd指向的文件必须是可以mmap的。这些局限限制了sendfile的使用，使sendfile只能将数据从文件传递到套接字上，反之则不行。<br>使用sendfile不仅减少了数据拷贝的次数，还减少了上下文切换，数据传送始终只发生在kernel space。</p>
<p><a href="http://idiotsky.me/images2/linux-zero-copy-3.png"><img src="http://idiotsky.me/images2/linux-zero-copy-3.png" alt=""></a> </p>
<p>在我们调用sendfile时，如果有其它进程截断了文件会发生什么呢？假设我们没有设置任何信号处理程序，sendfile调用仅仅返回它在被中断之前已经传输的字节数，errno会被置为success。如果我们在调用sendfile之前给文件加了锁，sendfile的行为仍然和之前相同，我们还会收到RT_SIGNAL_LEASE的信号。</p>
<p>目前为止，我们已经减少了数据拷贝的次数了，但是仍然存在一次拷贝，就是页缓存到socket缓存的拷贝。那么能不能把这个拷贝也省略呢？</p>
<p>借助于硬件上的帮助，我们是可以办到的。之前我们是把页缓存的数据拷贝到socket缓存中，实际上，我们仅仅需要把缓冲区描述符传到socket缓冲区，再把数据长度传过去，这样DMA控制器直接将页缓存中的数据打包发送到网络中就可以了。</p>
<p>总结一下，sendfile系统调用利用DMA引擎将文件内容拷贝到内核缓冲区去，然后将带有文件位置和长度信息的缓冲区描述符添加socket缓冲区去，这一步不会将内核中的数据拷贝到socket缓冲区中，DMA引擎会将内核缓冲区的数据拷贝到协议引擎中去，避免了最后一次拷贝。</p>
<p><a href="http://idiotsky.me/images2/linux-zero-copy-4.png"><img src="http://idiotsky.me/images2/linux-zero-copy-4.png" alt=""></a> </p>
<p>不过这一种收集拷贝功能是需要硬件以及驱动程序支持的。</p>
<h2 id="使用splice"><a href="#使用splice" class="headerlink" title="使用splice"></a>使用splice</h2><p>sendfile只适用于将数据从文件拷贝到套接字上，限定了它的使用范围。Linux在2.6.17版本引入splice系统调用，用于在两个文件描述符中移动数据：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="keyword">ssize_t</span> splice(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span> *off_in, <span class="keyword">int</span> fd_out, <span class="keyword">loff_t</span> *off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags);</div></pre></td></tr></table></figure></p>
<p>splice调用在两个文件描述符之间移动数据，而不需要数据在内核空间和用户空间来回拷贝。他从fd_in拷贝len长度的数据到fd_out，但是有一方必须是管道设备，这也是目前splice的一些局限性。flags参数有以下几种取值：</p>
<ul>
<li>SPLICE_F_MOVE ：尝试去移动数据而不是拷贝数据。这仅仅是对内核的一个小提示：如果内核不能从pipe移动数据或者pipe的缓存不是一个整页面，仍然需要拷贝数据。Linux最初的实现有些问题，所以从2.6.21开始这个选项不起作用，后面的Linux版本应该会实现。</li>
<li>SPLICE_F_NONBLOCK ：splice 操作不会被阻塞。然而，如果文件描述符没有被设置为不可被阻塞方式的 I/O ，那么调用 splice 有可能仍然被阻塞。</li>
<li>SPLICE_F_MORE ： 后面的splice调用会有更多的数据。</li>
</ul>
<p>splice调用利用了Linux提出的管道缓冲区机制， 所以至少一个描述符要为管道。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上几种零拷贝技术都是减少数据在用户空间和内核空间拷贝技术实现的，但是有些时候，数据必须在用户空间和内核空间之间拷贝。这时候，我们只能针对数据在用户空间和内核空间拷贝的时机上下功夫了。Linux通常利用写时复制(copy on write)来减少系统开销，这个技术又时常称作COW。</p>
<p>由于篇幅原因，本文不详细介绍写时复制。大概描述下就是：如果多个程序同时访问同一块数据，那么每个程序都拥有指向这块数据的指针，在每个程序看来，自己都是独立拥有这块数据的，只有当程序需要对数据内容进行修改时，才会把数据内容拷贝到程序自己的应用空间里去，这时候，数据才成为该程序的私有数据。如果程序不需要对数据进行修改，那么永远都不需要拷贝数据到自己的应用空间里。这样就减少了数据的拷贝</p>
<p>除此之外，还有一些零拷贝技术，比如传统的Linux I/O中加上O_DIRECT标记可以直接I/O，避免了自动缓存，还有尚未成熟的fbufs技术，本文尚未覆盖所有零拷贝技术，只是介绍常见的一些，如有兴趣，可以自行研究，一般成熟的服务端项目也会自己改造内核中有关I/O的部分，提高自己的数据传输速率。</p>
<p>ref <a href="https://www.jianshu.com/p/fad3339e3448" target="_blank" rel="external">https://www.jianshu.com/p/fad3339e3448</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;👿 linux内核里面为所有文件描述符建立缓存的，而用户层也有自己的缓存，那样每次read和write等相关系统调用，不但有可能上下文切换，而且还要不断从用户态拷贝到内核态或者从内核态拷贝到用户态。如果有些数据不用经过用户层的话（例如网络代理服务），可以不用这种拷贝来浪费资源，所以Linux的系统调用就有了几个零拷贝的函数来解决这种问题。（虽说零拷贝，但其实也只是减少了用户态拷贝，把所有拷贝都在内核里面处理了）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;引文&quot;&gt;&lt;a href=&quot;#引文&quot; class=&quot;headerlink&quot; title=&quot;引文&quot;&gt;&lt;/a&gt;引文&lt;/h1&gt;&lt;p&gt;在写一个服务端程序时（Web Server或者文件服务器），文件下载是一个基本功能。这时候服务端的任务是：&lt;strong&gt;将服务端主机磁盘中的文件不做修改地从已连接的socket发出去&lt;/strong&gt;，我们通常用下面的代码完成：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;((n = read(diskfd, buf, BUF_SIZE)) &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    write(sockfd, buf , n);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;基本操作就是循环的从磁盘读入文件内容到缓冲区，再将缓冲区的内容发送到socket。但是由于Linux的I/O操作默认是缓冲I/O。这里面主要使用的也就是read和write两个系统调用，我们并不知道操作系统在其中做了什么。实际上在以上I/O操作中，发生了多次的数据拷贝。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://idiotsky.me/categories/linux/"/>
    
    
      <category term="linux" scheme="http://idiotsky.me/tags/linux/"/>
    
      <category term="sendfile" scheme="http://idiotsky.me/tags/sendfile/"/>
    
      <category term="mmap" scheme="http://idiotsky.me/tags/mmap/"/>
    
      <category term="splice" scheme="http://idiotsky.me/tags/splice/"/>
    
  </entry>
  
  <entry>
    <title>linux的阻塞和非阻塞socket的区别</title>
    <link href="http://idiotsky.me/2018/03/12/linux-non-blocking-io/"/>
    <id>http://idiotsky.me/2018/03/12/linux-non-blocking-io/</id>
    <published>2018-03-12T15:44:11.000Z</published>
    <updated>2018-03-13T13:59:01.325Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在上一篇文章有提到非阻塞socket，所以这篇文章就看看这个是什么东东👿</p>
</blockquote>
<h1 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h1><p>对于阻塞的socket,当socket的接收缓冲区中没有数据时，read调用会一直阻塞住，直到有数据到来才返回。当socket缓冲区中的数据量小于期望读取的数据量时，返回实际读取的字节数。当sockt的接收缓冲区中的数据大于期望读取的字节数时，读取期望读取的字节数，返回实际读取的长度。</p>
<p>对于非阻塞socket而言，socket的接收缓冲区中有没有数据，read调用都会立刻返回。接收缓冲区中有数据时，与阻塞socket有数据的情况是一样的，如果接收缓冲区中没有数据，则返回错误号为EWOULDBLOCK,表示该操作本来应该阻塞的，但是由于本socket为非阻塞的socket，因此立刻返回，遇到这样的情况，可以在下次接着去尝试读取。如果返回值是其它负值，则表明读取错误。</p>
<p>因此，非阻塞的rea调用一般这样写:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((nread = read(sock_fd, buffer, len)) &lt; <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"> <span class="keyword">if</span> (errno == EWOULDBLOCK)</div><div class="line">  &#123;</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//表示没有读到数据</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> </div><div class="line">   <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//表示读取失败</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> </div><div class="line">   <span class="keyword">return</span> nread;读到数据长度</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h1><p>对于写操作write,原理是类似的，非阻塞socket在发送缓冲区没有空间时会直接返回错误号EWOULDBLOCK,表示没有空间可写数据，如果错误号是别的值，则表明发送失败。如果发送缓冲区中有足够空间或者是不足以拷贝所有待发送数据的空间的话，则拷贝前面N个能够容纳的数据，返回实际拷贝的字节数。</p>
<p>而对于阻塞Socket而言，如果发送缓冲区没有空间或者空间不足的话，write操作会直接阻塞住，如果有足够空间，则拷贝所有数据到发送缓冲区，然后返回.</p>
<p>非阻塞的write操作一般写法是:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> write_pos = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> nLeft = nLen;</div><div class="line"><span class="keyword">while</span> (nLeft &gt; <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"> <span class="keyword">int</span> nWrite = <span class="number">0</span>;</div><div class="line"> <span class="keyword">if</span> ((nWrite = write(sock_fd, data + write_pos, nLeft)) &lt;= <span class="number">0</span>)</div><div class="line"> &#123;</div><div class="line">  <span class="keyword">if</span> (errno == EWOULDBLOCK)</div><div class="line">  &#123;</div><div class="line">    nWrite = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//表示写失败</span></div><div class="line"> &#125;</div><div class="line"> nLeft -= nWrite;</div><div class="line"> write_pos += nWrite;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> nLen;</div></pre></td></tr></table></figure></p>
<h1 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h1><p>阻塞方式下，connect首先发送SYN请求道服务器，当客户端收到服务器返回的SYN的确认时，则connect返回.否则的话一直阻塞.</p>
<p>非阻塞方式，connect将启用TCP协议的三次握手，但是connect函数并不等待连接建立好才返回，而是立即返回。返回的错误码为EINPROGRESS,表示正在进行某种过程.</p>
<h1 id="接收连接"><a href="#接收连接" class="headerlink" title="接收连接"></a>接收连接</h1><p>对于阻塞方式的倾听socket,accept在连接队列中没有建立好的连接时将阻塞，直到有可用的连接，才返回。</p>
<p>非阻塞倾听socket,在有没有连接时都立即返回，没有连接时，返回的错误码为EWOULDBLOCK,表示本来应该阻塞。</p>
<h1 id="无阻塞的设置方法"><a href="#无阻塞的设置方法" class="headerlink" title="无阻塞的设置方法"></a>无阻塞的设置方法</h1><p>方法一:fcntl<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> flag;</div><div class="line"><span class="keyword">if</span> (flag = fcntl(fd, F_GETFL, <span class="number">0</span>) &lt;<span class="number">0</span>) perror(<span class="string">"get flag"</span>);</div><div class="line">flag |= O_NONBLOCK;</div><div class="line"><span class="keyword">if</span> (fcntl(fd, F_SETFL, flag) &lt; <span class="number">0</span>)</div><div class="line">perror(<span class="string">"set flag"</span>);</div></pre></td></tr></table></figure></p>
<p>方法二:ioctl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int b_on = 1;</div><div class="line">ioctl (fd, FIONBIO, &amp;b_on);</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>非阻塞socket可以通过不断轮询来实现类似io复用的效果，但是不建议，因为会造成cpu的空转（如果一直没数据读写的话）。感觉跟java的nio上设置channel为非阻塞有点关系吧👿</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在上一篇文章有提到非阻塞socket，所以这篇文章就看看这个是什么东东👿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;读操作&quot;&gt;&lt;a href=&quot;#读操作&quot; class=&quot;headerlink&quot; title=&quot;读操作&quot;&gt;&lt;/a&gt;读操作&lt;/h1&gt;&lt;p&gt;对于阻塞的socket,当socket的接收缓冲区中没有数据时，read调用会一直阻塞住，直到有数据到来才返回。当socket缓冲区中的数据量小于期望读取的数据量时，返回实际读取的字节数。当sockt的接收缓冲区中的数据大于期望读取的字节数时，读取期望读取的字节数，返回实际读取的长度。&lt;/p&gt;
&lt;p&gt;对于非阻塞socket而言，socket的接收缓冲区中有没有数据，read调用都会立刻返回。接收缓冲区中有数据时，与阻塞socket有数据的情况是一样的，如果接收缓冲区中没有数据，则返回错误号为EWOULDBLOCK,表示该操作本来应该阻塞的，但是由于本socket为非阻塞的socket，因此立刻返回，遇到这样的情况，可以在下次接着去尝试读取。如果返回值是其它负值，则表明读取错误。&lt;/p&gt;
&lt;p&gt;因此，非阻塞的rea调用一般这样写:&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((nread = read(sock_fd, buffer, len)) &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (errno == EWOULDBLOCK)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//表示没有读到数据&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//表示读取失败&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; nread;读到数据长度&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://idiotsky.me/categories/linux/"/>
    
    
      <category term="linux" scheme="http://idiotsky.me/tags/linux/"/>
    
      <category term="nio" scheme="http://idiotsky.me/tags/nio/"/>
    
      <category term="非阻塞socket" scheme="http://idiotsky.me/tags/%E9%9D%9E%E9%98%BB%E5%A1%9Esocket/"/>
    
      <category term="阻塞socket" scheme="http://idiotsky.me/tags/%E9%98%BB%E5%A1%9Esocket/"/>
    
  </entry>
  
  <entry>
    <title>linux epoll通俗理解</title>
    <link href="http://idiotsky.me/2018/03/12/epoll-easy-understanding/"/>
    <id>http://idiotsky.me/2018/03/12/epoll-easy-understanding/</id>
    <published>2018-03-12T14:39:46.000Z</published>
    <updated>2018-03-12T15:43:50.651Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一个epoll通俗简单理解的文章，mark👿</p>
</blockquote>
<p>首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。<br>不管是文件，还是套接字，还是管道，我们都可以把他们看作流。<br>之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？</p>
<ul>
<li>阻塞。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。</li>
<li>非阻塞忙轮询。接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”</li>
</ul>
<a id="more"></a>
<p>很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。<br>大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。</p>
<p>为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。<br>假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。</p>
<ol>
<li>假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。</li>
<li>但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。</li>
<li>假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”</li>
<li>也许像3那样已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，直到内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。</li>
</ol>
<p>这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。</p>
<p>然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。<br>于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">while true &#123;</div><div class="line">for i in stream[]; &#123;</div><div class="line">if i has data</div><div class="line">read until unavailable</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。</p>
<p>为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。代码长这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">while true &#123;</div><div class="line">select(streams[])</div><div class="line">for i in streams[] &#123;</div><div class="line">if i has data</div><div class="line">read until unavailable</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。<br>但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。再次</p>
<p><strong>说了这么多，终于能好好解释epoll了</strong></p>
<p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(k)，k为产生I/O事件的流的个数)<br>在讨论epoll的实现细节之前，先把epoll的相关操作列出：<br>epoll_create 创建一个epoll对象，一般epollfd = epoll_create()<br>epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件<br>比如<br>epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//有缓冲区内有数据时epoll_wait返回<br>epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLOUT);//缓冲区可写入时epoll_wait返回<br>epoll_wait(epollfd,…)等待直到注册的事件发生<br>（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。<br>一个epoll模式的代码大概的样子是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">while true &#123;</div><div class="line">active_stream[] = epoll_wait(epollfd)</div><div class="line">for i in active_stream[] &#123;</div><div class="line">read or write till unavailable</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>限于篇幅，我只说这么多，以揭示原理性的东西，至于epoll的使用细节，请参考man和google，实现细节，请参阅linux kernel source。</p>
<p>ref <a href="https://www.zhihu.com/question/20122137" target="_blank" rel="external">https://www.zhihu.com/question/20122137</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个epoll通俗简单理解的文章，mark👿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。&lt;br&gt;不管是文件，还是套接字，还是管道，我们都可以把他们看作流。&lt;br&gt;之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。&lt;/li&gt;
&lt;li&gt;非阻塞忙轮询。接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux" scheme="http://idiotsky.me/categories/linux/"/>
    
    
      <category term="linux" scheme="http://idiotsky.me/tags/linux/"/>
    
      <category term="nio" scheme="http://idiotsky.me/tags/nio/"/>
    
      <category term="epoll" scheme="http://idiotsky.me/tags/epoll/"/>
    
      <category term="select" scheme="http://idiotsky.me/tags/select/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引背后的数据结构及算法原理</title>
    <link href="http://idiotsky.me/2018/03/04/b-tree/"/>
    <id>http://idiotsky.me/2018/03/04/b-tree/</id>
    <published>2018-03-04T14:23:29.000Z</published>
    <updated>2018-03-06T14:46:11.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转一个不错的文章，里面的干货还是很多的，包括局部性，硬盘等数据库以外的东西，Mark之👿</p>
</blockquote>
<h1 id="数据结构及算法基础"><a href="#数据结构及算法基础" class="headerlink" title="数据结构及算法基础"></a>数据结构及算法基础</h1><h2 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h2><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是<a href="http://en.wikipedia.org/wiki/Linear_search" target="_blank" rel="external">顺序查找</a>（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如<a href="http://en.wikipedia.org/wiki/Binary_search_algorithm" target="_blank" rel="external">二分查找</a>（binary search）、<a href="http://en.wikipedia.org/wiki/Binary_search_tree" target="_blank" rel="external">二叉树查找树</a>（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于<a href="http://en.wikipedia.org/wiki/Binary_search_tree" target="_blank" rel="external">二叉查找树</a>上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>看一个例子：</p>
<p><a href="http://idiotsky.me/images2/b-tree-1.png"><img src="http://idiotsky.me/images2/b-tree-1.png" alt=""></a></p>
<a id="more"></a>
<p>上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)<br>的复杂度内获取到相应数据。</p>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种<a href="http://en.wikipedia.org/wiki/Red-black_tree" target="_blank" rel="external">红黑树</a>（red-black tree）实现的，原因会在下文介绍。</p>
<h2 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h2><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p>
<p>d为大于1的一个正整数，称为B-Tree的度。</p>
<p>h为一个正整数，称为B-Tree的高度。</p>
<p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p>
<p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p>
<p>所有叶节点具有相同的深度，等于树高h。</p>
<p>key和指针互相间隔，节点两端是指针。</p>
<p>一个节点中的key从左到右非递减排列。</p>
<p>所有节点组成树结构。</p>
<p>每个指针要么为null，要么指向另外一个节点。</p>
<p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于key[1]，其中key[1]为node的第一个key的值。</p>
<p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于key[m]，其中key[m]为node的最后一个key的值。</p>
<p>如果某个指针在节点node的左右相邻key分别是key[i]和key[i+1]且不为null，则其指向节点的所有key小于key[i+1]且大于key[i].</p>
<p>下图是一个d=2的B-Tree示意图。</p>
<p><a href="http://idiotsky.me/images2/b-tree-2.png"><img src="http://idiotsky.me/images2/b-tree-2.png" alt=""></a></p>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">BTree_Search(node, key) &#123;</div><div class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    foreach(node.key)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(node.key[i] == key) <span class="keyword">return</span> node.data[i];</div><div class="line">            <span class="keyword">if</span>(node.key[i] &gt; key) <span class="keyword">return</span> BTree_Search(point[i]-&gt;node);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> BTree_Search(point[i+<span class="number">1</span>]-&gt;node);</div><div class="line">&#125;</div><div class="line">data = BTree_Search(root, my_key);</div></pre></td></tr></table></figure>
<p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p>
<p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以找百度谷歌维基进行阅读。</p>
<h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<p>每个节点的指针上限为2d而不是2d+1。</p>
<p>内节点不存储data，只存储key；叶子节点不存储指针。</p>
<p>下图是一个简单的B+Tree示意。</p>
<p><a href="http://idiotsky.me/images2/b-tree-3.png"><img src="http://idiotsky.me/images2/b-tree-3.png" alt=""></a></p>
<p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p>
<p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p>
<h3 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h3><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p>
<p><a href="http://idiotsky.me/images2/b-tree-4.png"><img src="http://idiotsky.me/images2/b-tree-4.png" alt=""></a></p>
<p>如上图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<p>这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p>
<h2 id="为什么使用B-Tree（B-Tree）"><a href="#为什么使用B-Tree（B-Tree）" class="headerlink" title="为什么使用B-Tree（B+Tree）"></a>为什么使用B-Tree（B+Tree）</h2><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p>
<h3 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h3><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。</p>
<p><a href="http://idiotsky.me/images2/b-tree-5.png"><img src="http://idiotsky.me/images2/b-tree-5.png" alt=""></a></p>
<p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。上图展示了一个4 x 4的主存模型。</p>
<p>主存的存取过程如下：</p>
<p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p>
<p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p>
<p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p>
<h3 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h3><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p>
<p>下图是磁盘的整体结构示意图。</p>
<p><a href="http://idiotsky.me/images2/b-tree-6.png"><img src="http://idiotsky.me/images2/b-tree-6.png" alt=""></a></p>
<p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p>
<p>下图是磁盘结构的示意图。</p>
<p><a href="http://idiotsky.me/images2/b-tree-7.png"><img src="http://idiotsky.me/images2/b-tree-7.png" alt=""></a></p>
<p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p>
<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>
<h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<p>程序运行期间所需要的数据通常比较集中。</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>到这里终于可以分析B-/+Tree索引的性能了。</p>
<p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p>
<p>dmax=floor(pagesize/(keysize+datasize+pointsize)) floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p>
<h1 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h1><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p>
<h2 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h2><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p>
<p><a href="http://idiotsky.me/images2/b-tree-8.png"><img src="http://idiotsky.me/images2/b-tree-8.png" alt=""></a></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><a href="http://idiotsky.me/images2/b-tree-9.png"><img src="http://idiotsky.me/images2/b-tree-9.png" alt=""></a></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h2 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h2><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><a href="http://idiotsky.me/images2/b-tree-10.png"><img src="http://idiotsky.me/images2/b-tree-10.png" alt=""></a></p>
<p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引：</p>
<p><a href="http://idiotsky.me/images2/b-tree-11.png"><img src="http://idiotsky.me/images2/b-tree-11.png" alt=""></a></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<p>下一章将具体讨论这些与索引有关的优化策略。</p>
<h1 id="索引使用策略及优化"><a href="#索引使用策略及优化" class="headerlink" title="索引使用策略及优化"></a>索引使用策略及优化</h1><p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。</p>
<h2 id="示例数据库"><a href="#示例数据库" class="headerlink" title="示例数据库"></a>示例数据库</h2><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：</p>
<p><a href="http://idiotsky.me/images2/b-tree-12.png"><img src="http://idiotsky.me/images2/b-tree-12.png" alt=""></a></p>
<h2 id="最左前缀原理与相关优化"><a href="#最左前缀原理与相关优化" class="headerlink" title="最左前缀原理与相关优化"></a>最左前缀原理与相关优化</h2><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p>
<p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组<code>&lt;a1, a2, …, an&gt;</code>，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。</p>
<p>以employees.titles表为例，下面先查看其上都有哪些索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SHOW INDEX FROM employees.titles;</div><div class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</div><div class="line">| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |</div><div class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</div><div class="line">| titles |          0 | PRIMARY  |            1 | emp_no      | A         |        NULL |      | BTREE      |</div><div class="line">| titles |          0 | PRIMARY  |            2 | title       | A         |        NULL |      | BTREE      |</div><div class="line">| titles |          0 | PRIMARY  |            3 | from_date   | A         |      443308 |      | BTREE      |</div><div class="line">| titles |          1 | emp_no   |            1 | emp_no      | A         |      443308 |      | BTREE      |</div><div class="line">+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</div></pre></td></tr></table></figure>
<p>从结果中可以到titles表的主索引为<code>&lt;emp_no, title, from_date&gt;</code>，还有一个辅助索引<code>&lt;emp_no&gt;</code>。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employees.titles <span class="keyword">DROP</span> <span class="keyword">INDEX</span> emp_no;</div></pre></td></tr></table></figure>
<p>这样就可以专心分析索引PRIMARY的行为了。</p>
<h3 id="情况一：全列匹配。"><a href="#情况一：全列匹配。" class="headerlink" title="情况一：全列匹配。"></a>情况一：全列匹配。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND title=&apos;Senior Engineer&apos; AND from_date=&apos;1986-06-26&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</div><div class="line">|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</div></pre></td></tr></table></figure>
<p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE from_date=&apos;1986-06-26&apos; AND emp_no=&apos;10001&apos; AND title=&apos;Senior Engineer&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</div><div class="line">|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</div></pre></td></tr></table></figure>
<p>效果是一样的。</p>
<h3 id="情况二：最左前缀匹配。"><a href="#情况二：最左前缀匹配。" class="headerlink" title="情况二：最左前缀匹配。"></a>情况二：最左前缀匹配。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos;;</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</div><div class="line">| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra |</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</div><div class="line">|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |       |</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</div></pre></td></tr></table></figure>
<p>当查询条件精确匹配索引的左边连续一个或几个列时，如<code>&lt;emp_no&gt;</code>或<code>&lt;emp_no, title&gt;</code>，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</p>
<h3 id="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"><a href="#情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。" class="headerlink" title="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"></a>情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND from_date=&apos;1986-06-26&apos;;</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</div><div class="line">| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</div></pre></td></tr></table></figure>
<p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引<code>&lt;emp_no, from_date&gt;</code>，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</p>
<p>首先我们看下title一共有几种不同的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">SELECT DISTINCT(title) FROM employees.titles;</div><div class="line">+--------------------+</div><div class="line">| title              |</div><div class="line">+--------------------+</div><div class="line">| Senior Engineer    |</div><div class="line">| Staff              |</div><div class="line">| Engineer           |</div><div class="line">| Senior Staff       |</div><div class="line">| Assistant Engineer |</div><div class="line">| Technique Leader   |</div><div class="line">| Manager            |</div><div class="line">+--------------------+</div></pre></td></tr></table></figure></p>
<p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles</div><div class="line">WHERE emp_no=&apos;10001&apos;</div><div class="line">AND title IN (&apos;Senior Engineer&apos;, &apos;Staff&apos;, &apos;Engineer&apos;, &apos;Senior Staff&apos;, &apos;Assistant Engineer&apos;, &apos;Technique Leader&apos;, &apos;Manager&apos;)</div><div class="line">AND from_date=&apos;1986-06-26&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |    7 | Using where |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div></pre></td></tr></table></figure></p>
<p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SHOW PROFILES;</div><div class="line">+----------+------------+-------------------------------------------------------------------------------+</div><div class="line">| Query_ID | Duration   | Query                                                                         |</div><div class="line">+----------+------------+-------------------------------------------------------------------------------+</div><div class="line">|       10 | 0.00058000 | SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND from_date=&apos;1986-06-26&apos;|</div><div class="line">|       11 | 0.00052500 | SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND title IN ...          |</div><div class="line">+----------+------------+-------------------------------------------------------------------------------+</div></pre></td></tr></table></figure></p>
<p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p>
<h3 id="情况四：查询条件没有指定索引第一列。"><a href="#情况四：查询条件没有指定索引第一列。" class="headerlink" title="情况四：查询条件没有指定索引第一列。"></a>情况四：查询条件没有指定索引第一列。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE from_date=&apos;1986-06-26&apos;;</div><div class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |</div><div class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</div></pre></td></tr></table></figure>
<p>由于不是最左前缀，索引这样的查询显然用不到索引。</p>
<h3 id="情况五：匹配某列的前缀字符串。"><a href="#情况五：匹配某列的前缀字符串。" class="headerlink" title="情况五：匹配某列的前缀字符串。"></a>情况五：匹配某列的前缀字符串。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND title LIKE &apos;Senior%&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 56      | NULL |    1 | Using where |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div></pre></td></tr></table></figure>
<p>如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀.</p>
<h3 id="情况六：范围查询。"><a href="#情况六：范围查询。" class="headerlink" title="情况六：范围查询。"></a>情况六：范围查询。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; &apos;10010&apos; and title=&apos;Senior Engineer&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div></pre></td></tr></table></figure>
<p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles</div><div class="line">WHERE emp_no &lt; &apos;10010&apos;</div><div class="line">AND title=&apos;Senior Engineer&apos;</div><div class="line">AND from_date BETWEEN &apos;1986-01-01&apos; AND &apos;1986-12-31&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div></pre></td></tr></table></figure></p>
<p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles</div><div class="line">WHERE emp_no BETWEEN &apos;10001&apos; AND &apos;10010&apos;</div><div class="line">AND title=&apos;Senior Engineer&apos;</div><div class="line">AND from_date BETWEEN &apos;1986-01-01&apos; AND &apos;1986-12-31&apos;;</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |   16 | Using where |</div><div class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</div></pre></td></tr></table></figure></p>
<p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p>
<h3 id="情况七：查询条件中含有函数或表达式。"><a href="#情况七：查询条件中含有函数或表达式。" class="headerlink" title="情况七：查询条件中含有函数或表达式。"></a>情况七：查询条件中含有函数或表达式。</h3><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&apos;10001&apos; AND left(title, 6)=&apos;Senior&apos;;</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</div><div class="line">| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |</div><div class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</div></pre></td></tr></table></figure></p>
<p>虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1=&apos;10000&apos;;</div><div class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |</div><div class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</div></pre></td></tr></table></figure></p>
<p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p>
<h2 id="索引选择性与前缀索引"><a href="#索引选择性与前缀索引" class="headerlink" title="索引选择性与前缀索引"></a>索引选择性与前缀索引</h2><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p>
<p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p>
<p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p>
<p>Index Selectivity = Cardinality / #T</p>
<p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span>(title))/<span class="keyword">count</span>(*) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.titles;</div><div class="line">+<span class="comment">-------------+</span></div><div class="line">| Selectivity |</div><div class="line">+<span class="comment">-------------+</span></div><div class="line">|      0.0000 |</div><div class="line">+<span class="comment">-------------+</span></div></pre></td></tr></table></figure></p>
<p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p>
<p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p>
<p>从上图可以看到employees表只有一个索引<code>&lt;emp_no&gt;</code>，那么如果我们想按名字搜索一个人，就只能全表扫描了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EXPLAIN SELECT * FROM employees.employees WHERE first_name=&apos;Eric&apos; AND last_name=&apos;Anido&apos;;</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</div><div class="line">|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |</div><div class="line">+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</div></pre></td></tr></table></figure></p>
<p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<code>&lt;first_name&gt;</code>或<code>&lt;first_name, last_name&gt;</code>，看下两个索引的选择性：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span>(first_name))/<span class="keyword">count</span>(*) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;</div><div class="line">+<span class="comment">-------------+</span></div><div class="line">| Selectivity |</div><div class="line">+<span class="comment">-------------+</span></div><div class="line">|      0.0042 |</div><div class="line">+<span class="comment">-------------+</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span>(<span class="keyword">concat</span>(first_name, last_name)))/<span class="keyword">count</span>(*) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;</div><div class="line">+<span class="comment">-------------+</span></div><div class="line">| Selectivity |</div><div class="line">+<span class="comment">-------------+</span></div><div class="line">|      0.9313 |</div><div class="line">+<span class="comment">-------------+</span></div></pre></td></tr></table></figure></p>
<p><code>&lt;first_name&gt;</code>显然选择性太低，<code>&lt;first_name, last_name&gt;</code>选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如<code>&lt;first_name, left(last_name, 3)&gt;</code>，看看其选择性：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span>(<span class="keyword">concat</span>(first_name, <span class="keyword">left</span>(last_name, <span class="number">3</span>))))/<span class="keyword">count</span>(*) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;</div><div class="line">+<span class="comment">-------------+</span></div><div class="line">| Selectivity |</div><div class="line">+<span class="comment">-------------+</span></div><div class="line">|      0.7879 |</div><div class="line">+<span class="comment">-------------+</span></div></pre></td></tr></table></figure></p>
<p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span>(<span class="keyword">concat</span>(first_name, <span class="keyword">left</span>(last_name, <span class="number">4</span>))))/<span class="keyword">count</span>(*) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;</div><div class="line">+<span class="comment">-------------+</span></div><div class="line">| Selectivity |</div><div class="line">+<span class="comment">-------------+</span></div><div class="line">|      0.9007 |</div><div class="line">+<span class="comment">-------------+</span></div></pre></td></tr></table></figure></p>
<p>这时选择性已经很理想了，而这个索引的长度只有18，比<code>&lt;first_name, last_name&gt;</code>短了接近一半，我们把这个前缀索引 建上：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employees.employees</div><div class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> <span class="string">`first_name_last_name4`</span> (first_name, last_name(<span class="number">4</span>));</div></pre></td></tr></table></figure></p>
<p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SHOW</span> <span class="keyword">PROFILES</span>;</div><div class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------------+</span></div><div class="line">| Query_ID | Duration   | Query                                                                           |</div><div class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------------+</span></div><div class="line">|       87 | 0.11941700 | <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.employees <span class="keyword">WHERE</span> first_name=<span class="string">'Eric'</span> <span class="keyword">AND</span> last_name=<span class="string">'Anido'</span> |</div><div class="line">|       <span class="number">90</span> | <span class="number">0.00092400</span> | <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.employees <span class="keyword">WHERE</span> first_name=<span class="string">'Eric'</span> <span class="keyword">AND</span> last_name=<span class="string">'Anido'</span> |</div><div class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------------+</span></div></pre></td></tr></table></figure></p>
<p>性能的提升是显著的，查询速度提高了120多倍。</p>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>
<h2 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h2><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p>
<p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p>
<p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p>
<p><a href="http://idiotsky.me/images2/b-tree-13.png"><img src="http://idiotsky.me/images2/b-tree-13.png" alt=""></a></p>
<p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p>
<p><a href="http://idiotsky.me/images2/b-tree-14.png"><img src="http://idiotsky.me/images2/b-tree-14.png" alt=""></a></p>
<p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
<p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>
<p>from <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转一个不错的文章，里面的干货还是很多的，包括局部性，硬盘等数据库以外的东西，Mark之👿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;数据结构及算法基础&quot;&gt;&lt;a href=&quot;#数据结构及算法基础&quot; class=&quot;headerlink&quot; title=&quot;数据结构及算法基础&quot;&gt;&lt;/a&gt;数据结构及算法基础&lt;/h1&gt;&lt;h2 id=&quot;索引的本质&quot;&gt;&lt;a href=&quot;#索引的本质&quot; class=&quot;headerlink&quot; title=&quot;索引的本质&quot;&gt;&lt;/a&gt;索引的本质&lt;/h2&gt;&lt;p&gt;MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。&lt;/p&gt;
&lt;p&gt;我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是&lt;a href=&quot;http://en.wikipedia.org/wiki/Linear_search&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;顺序查找&lt;/a&gt;（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;二分查找&lt;/a&gt;（binary search）、&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;二叉树查找树&lt;/a&gt;（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;二叉查找树&lt;/a&gt;上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。&lt;/p&gt;
&lt;p&gt;看一个例子：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://idiotsky.me/images2/b-tree-1.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images2/b-tree-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://idiotsky.me/categories/mysql/"/>
    
    
      <category term="B树" scheme="http://idiotsky.me/tags/B%E6%A0%91/"/>
    
      <category term="B+树" scheme="http://idiotsky.me/tags/B-%E6%A0%91/"/>
    
      <category term="mysql" scheme="http://idiotsky.me/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>深入go之goroutine</title>
    <link href="http://idiotsky.me/2018/02/26/go-goroutine/"/>
    <id>http://idiotsky.me/2018/02/26/go-goroutine/</id>
    <published>2018-02-26T11:56:31.000Z</published>
    <updated>2018-03-07T14:54:37.664Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>goroutine是go的核心，没有goroutine，go就没什么意思了👿。goroutine离不开协程，线程和并发，所以下面会说说相关的内容。</p>
</blockquote>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程(coroutine)其实就是一个函数，方法或者例程（routine）。一般情况下函数都是在用户线程下面执行的，线程的调度由内核触发，所以函数在执行过程中，用户线程没办法控制函数的执行调度，只能任由内核主宰。协程就不同，它可以由用户线程控制调度，在任何时候调度协程的执行。函数在执行时，内核调度会陷入内核并保存当前线程的栈和上下文，然后恢复之前被停止线程继续执行，代价比较高。而协程的调度，不用陷入内核，用户线程只是保存当前协程的栈和上下文，恢复之前的被停止协程继续执行。</p>
<p>还有种说法是说函数是协程的一种特例。因为函数只有在return语句才会返回，而协程可以在任何时刻返回。</p>
<p>协程很早就提出来了，可是在现在才火起来吧，大概由于某种语言（lua）的广泛使用吧。而go更是把协程用到底，基本可以理解go的所有代码都跑在协程下，并用goroutine来代表它自己的协程。<br><a id="more"></a></p>
<h1 id="协程-vs-线程"><a href="#协程-vs-线程" class="headerlink" title="协程 vs 线程"></a>协程 vs 线程</h1><p>线程是处理器调度的基本单位，在CPU切分时间片的前提下，操作系统进行抢占式调度。</p>
<p>协程也可以理解为一种更小的调度基本单位。它由运行在用户线程的调度器来调度。</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>调度</th>
<th>内存消耗</th>
<th>切换代价</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程</td>
<td>内核进行调度</td>
<td>较大（1MB~8MB）</td>
<td>陷入内核，各种寄存器的保存和刷新</td>
</tr>
<tr>
<td>协程</td>
<td>用户线程调度</td>
<td>较小（2KB~5KB）</td>
<td>各种寄存器的保存和刷新</td>
</tr>
</tbody>
</table>
<p>从上表可以发现，线程比协程更加耗费内存，而且还会造成陷入内核。但是协程的切换完全交给用户线程来调度，这个增加了实现的难度。还有就是协程的调度是由单个线程调度，如果处理器是多核的话，没办法充分利用。很庆幸的是，go已经实现了它自己的协程调度逻辑，并且充分利用多线程来调度goroutine。</p>
<h1 id="要协程何用？"><a href="#要协程何用？" class="headerlink" title="要协程何用？"></a>要协程何用？</h1><p>协程能火也是有各种理由的。</p>
<ul>
<li>高并发处理。在用户空间切换上下文，不用陷入内核来做线程切换，避免不必要用户空间和内核空间的数据拷贝。</li>
<li>用同步的方式去写异步代码，高效率且不容易出错 (nodejs里面的asyn/await，就是这种)</li>
<li>非抢占式模型，能控制中断位置，不会发生由于强行切换线程导致的资源竞争。(极端情况下还是会执行抢占，防止协程长时间占用CPU，但这不是标准抢占式模型）</li>
</ul>
<h1 id="并发-VS-并行"><a href="#并发-VS-并行" class="headerlink" title="并发 VS 并行"></a>并发 VS 并行</h1><p>先上图：</p>
<p><a href="http://idiotsky.me/images2/go-goroutine.jpg"><img src="http://idiotsky.me/images2/go-goroutine.jpg" alt=""></a></p>
<ul>
<li>并发：处理器被划分为一个个时间分片，多个线程在处理器中交替执行，同一个时刻，只有一个线程被执行（通用地来说，支持并发是一种系统拥有交替执行多个任务的能力的表现）</li>
<li>并行：多个线程，在多个处理器上同时执行。</li>
</ul>
<blockquote>
<p>举个最简单的例子，医院诊室看病。把病人当做线程，医生当做处理器。</p>
<p>并发：只有一个医生，病人A看了一会儿，医生让他下楼拍X光，然后病人B进来看诊，之后医生让B去做彩超，然后A此时回来了，医生继续给A看病。（任意瞬间，医生只在给其中一个人看病）</p>
<p>并行： 有3个医生，3个病人，一个病人对应一个医生，同时问诊。</p>
</blockquote>
<p>如果并发交替的速度够快，就能达到“逻辑并行”的效果，对外看起来就和并行一样。</p>
<p>并发执行多线程并不能真的充分利用CPU，达到减少单个线程执行时间的效果，这种交替挂起执行的方式却能够给用户带来每个线程都在”同时执行“的感觉，从而增强了服务的响应速度。就像上面例子中的病人B不用一直排队等待 A拍完X光并且医生确定A的病看完了 才能去看病。</p>
<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><p>goroutine的调度可以理解为多线程调度协程（goroutine）。所以这里调度会有三个角色：线程，调度器，协程。它们分别用M,P,G来表示吧。</p>
<p><a href="http://idiotsky.me/images2/go-goroutine-1.jpg"><img src="http://idiotsky.me/images2/go-goroutine-1.jpg" alt=""></a></p>
<ul>
<li>M代表系统线程，也就是前面说的普通线程。</li>
<li>P代表调度器，我们可以把它当做单线程的本地调度器。（注：GOMAXPROCS环境变量代表的个数是P的个数，推荐值为CPU的核心数）</li>
<li>G代表goroutine，它包含了SP、PC寄存器，以及其它调度相关信息。</li>
</ul>
<p><a href="http://idiotsky.me/images2/go-goroutine-2.jpg"><img src="http://idiotsky.me/images2/go-goroutine-2.jpg" alt=""></a></p>
<p>上图是2个M（线程），每个线程对应一个处理器（P），M是必须关联P才能执行协程（G）的。图中蓝G代表的是运行中的goroutine，灰G表示的待执行的Goroutine，待执行的Goroutine存储在 P 中的一个局部队列中，此时P执行Goroutine会这个队列中取，不用加锁，提高了并发度。（Go1.0版本中，调度器取Goroutine是去一个全局队列中取，需要加锁，线程会经常阻塞等待锁）</p>
<p><strong>如果其中一个G执行的时候，发生了系统调用，阻塞了怎么办？</strong></p>
<p><a href="http://idiotsky.me/images2/go-goroutine-3.jpg"><img src="http://idiotsky.me/images2/go-goroutine-3.jpg" alt=""></a></p>
<p>上图左边，G0中陷入系统调用，导致M0阻塞。</p>
<p>此时，M0放弃了它的P，让M1去处理P中剩下的Goroutine。这里的M1可能是在线程缓存中取的，或者运行中生成的。</p>
<p>当M0从系统调用中恢复，它会去别的M中找P来执行G0（比如说别的M阻塞丢出了P），如果没有P，那么它会把G0放到全局队列中，并且把它自己放到线程缓存中。</p>
<p>全局队列保存了Goroutine，当各自P中的局部队列没有Goroutine时，P会到全局队列中取Goroutine。并且即使P中局部队列有Goroutine，也会周期性地从全局队列中取Goroutine，保持全局队列中的Goroutine能够尽快被执行。</p>
<p>处理系统调用，也是go程序为什么跑在多线程上的一个原因，即使GOMAXPROCS是1，也可能会有多个工作线程。</p>
<p><strong>当P局部队列不均衡时怎么处理？如果有多个P，其中一个P的局部队列Goroutine执行完了。</strong></p>
<p><a href="http://idiotsky.me/images2/go-goroutine-4.jpg"><img src="http://idiotsky.me/images2/go-goroutine-4.jpg" alt=""></a></p>
<p>如果一个P局部队列为空，那么它尝试从全局队列中取Goroutine，如全局队列为空，则会随机从其它P的局部队列中“挪”一半Goroutine到自己的队列当中， 以保证所有的M都是有任务执行的，间接做到负载均衡（可以参考go源码的findrunnable()函数 ）</p>
<p><strong>最后一个问题，关于抢占。如果一个P连续执行长时间，没有切换G，怎么处理？</strong></p>
<p>虽然协程强调的是协作式调度，但是如果其中一个协程不够“合作”，不主动让出控制权，那么会导致这个线程一直被占用，降低并发度。Go中有相应的处理方案~</p>
<p>首先，Go 在启动时会创建一个系统线程，这个系统线程会监控所有Goroutine的状态。它是通过遍历所有的P，如果P连续长时间执行，就会被抢占。表现为改P对应当前执行的G会被移除，放置到全局Goroutine队列中，然后P去捞新的G来执行。</p>
<blockquote>
<p>to be continue….</p>
</blockquote>
<p>ref<br><a href="https://zhuanlan.zhihu.com/p/32497435" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/32497435</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;goroutine是go的核心，没有goroutine，go就没什么意思了👿。goroutine离不开协程，线程和并发，所以下面会说说相关的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;协程&quot;&gt;&lt;a href=&quot;#协程&quot; class=&quot;headerlink&quot; title=&quot;协程&quot;&gt;&lt;/a&gt;协程&lt;/h1&gt;&lt;p&gt;协程(coroutine)其实就是一个函数，方法或者例程（routine）。一般情况下函数都是在用户线程下面执行的，线程的调度由内核触发，所以函数在执行过程中，用户线程没办法控制函数的执行调度，只能任由内核主宰。协程就不同，它可以由用户线程控制调度，在任何时候调度协程的执行。函数在执行时，内核调度会陷入内核并保存当前线程的栈和上下文，然后恢复之前被停止线程继续执行，代价比较高。而协程的调度，不用陷入内核，用户线程只是保存当前协程的栈和上下文，恢复之前的被停止协程继续执行。&lt;/p&gt;
&lt;p&gt;还有种说法是说函数是协程的一种特例。因为函数只有在return语句才会返回，而协程可以在任何时刻返回。&lt;/p&gt;
&lt;p&gt;协程很早就提出来了，可是在现在才火起来吧，大概由于某种语言（lua）的广泛使用吧。而go更是把协程用到底，基本可以理解go的所有代码都跑在协程下，并用goroutine来代表它自己的协程。&lt;br&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
      <category term="goroutine" scheme="http://idiotsky.me/tags/goroutine/"/>
    
      <category term="协程" scheme="http://idiotsky.me/tags/%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://idiotsky.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="并行" scheme="http://idiotsky.me/tags/%E5%B9%B6%E8%A1%8C/"/>
    
      <category term="多线程" scheme="http://idiotsky.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux的12个ip命令范例</title>
    <link href="http://idiotsky.me/2018/01/26/linux-ip/"/>
    <id>http://idiotsky.me/2018/01/26/linux-ip/</id>
    <published>2018-01-26T13:21:23.000Z</published>
    <updated>2018-03-26T15:47:07.936Z</updated>
    
    <content type="html"><![CDATA[<p>一年又一年，我们一直在使用 ifconfig 命令来执行网络相关的任务，比如检查和配置网卡信息。但是 ifconfig 已经不再被维护，并且在最近版本的 Linux 中被废除了！ ifconfig 命令已经被 ip 命令所替代了。</p>
<p>ip 命令跟 ifconfig 命令有些类似，但要强力的多，它有许多新功能。ip 命令完成很多 ifconfig 命令无法完成的任务。</p>
<h1 id="案例-1：检查网卡信息"><a href="#案例-1：检查网卡信息" class="headerlink" title="案例 1：检查网卡信息"></a>案例 1：检查网卡信息</h1><p>检查网卡的诸如 IP 地址，子网等网络信息，使用 ip addr show 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> ip addr show</span></div><div class="line">或</div><div class="line"><span class="meta">$</span><span class="bash"> ip a s</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>这会显示系统中所有可用网卡的相关网络信息，不过如果你想查看某块网卡的信息，则命令为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> ip addr show enp0s3</span></div></pre></td></tr></table></figure></p>
<p>这里 enp0s3 是网卡的名字。</p>
<p><a href="http://idiotsky.me/images3/linux-ip-1.jpg"><img src="http://idiotsky.me/images3/linux-ip-1.jpg" alt=""></a> </p>
<h1 id="案例-2：启用-禁用网卡"><a href="#案例-2：启用-禁用网卡" class="headerlink" title="案例 2：启用/禁用网卡"></a>案例 2：启用/禁用网卡</h1><p>使用 ip 命令来启用一个被禁用的网卡：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo ip link <span class="built_in">set</span> enp0s3 up</span></div></pre></td></tr></table></figure></p>
<p>而要禁用网卡则使用 down 触发器：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo ip link <span class="built_in">set</span> enp0s3 down</span></div></pre></td></tr></table></figure></p>
<h1 id="案例-3：为网卡分配-IP-地址以及其他网络信息"><a href="#案例-3：为网卡分配-IP-地址以及其他网络信息" class="headerlink" title="案例 3：为网卡分配 IP 地址以及其他网络信息"></a>案例 3：为网卡分配 IP 地址以及其他网络信息</h1><p>要为网卡分配 IP 地址，我们使用下面命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo ip addr add 192.168.0.50/255.255.255.0 dev enp0s3</span></div></pre></td></tr></table></figure></p>
<p>也可以使用 ip 命令来设置广播地址。默认是没有设置广播地址的，设置广播地址的命令为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo  ip addr add broadcast 192.168.0.255 dev enp0s3</span></div></pre></td></tr></table></figure></p>
<p>我们也可以使用下面命令来根据 IP 地址设置标准的广播地址：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash">  sudo ip addr add 192.168.0.10/24 brd + dev enp0s3</span></div></pre></td></tr></table></figure></p>
<p>如上面例子所示，我们可以使用 brd 代替 broadcast 来设置广播地址。</p>
<h1 id="案例-4：删除网卡中配置的-IP-地址"><a href="#案例-4：删除网卡中配置的-IP-地址" class="headerlink" title="案例 4：删除网卡中配置的 IP 地址"></a>案例 4：删除网卡中配置的 IP 地址</h1><p>若想从网卡中删掉某个 IP，使用如下 ip 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo ip addr del 192.168.0.10/24 dev enp0s3</span></div></pre></td></tr></table></figure></p>
<h1 id="案例-5：为网卡添加别名"><a href="#案例-5：为网卡添加别名" class="headerlink" title="案例 5：为网卡添加别名"></a>案例 5：为网卡添加别名</h1><p>假设网卡名为 enp0s3,添加别名，即为网卡添加不止一个 IP，执行下面命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash">  sudo ip addr add 192.168.0.20/24 dev enp0s3 label enp0s3:1</span></div></pre></td></tr></table></figure></p>
<p><a href="http://idiotsky.me/images3/linux-ip-2.jpg"><img src="http://idiotsky.me/images3/linux-ip-2.jpg" alt=""></a> </p>
<h1 id="案例-6：检查路由-默认网关的信息"><a href="#案例-6：检查路由-默认网关的信息" class="headerlink" title="案例 6：检查路由/默认网关的信息"></a>案例 6：检查路由/默认网关的信息</h1><p>查看路由信息会给我们显示数据包到达目的地的路由路径。要查看网络路由信息，执行下面命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash">  ip route show</span></div></pre></td></tr></table></figure></p>
<p><a href="http://idiotsky.me/images3/linux-ip-3.jpg"><img src="http://idiotsky.me/images3/linux-ip-3.jpg" alt=""></a> </p>
<p>在上面输出结果中，我们能够看到所有网卡上数据包的路由信息。我们也可以获取特定 IP 的路由信息，方法是：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo ip route get 192.168.0.1</span></div></pre></td></tr></table></figure></p>
<h1 id="案例-7：添加静态路由"><a href="#案例-7：添加静态路由" class="headerlink" title="案例 7：添加静态路由"></a>案例 7：添加静态路由</h1><p>我们也可以使用 IP 来修改数据包的默认路由。方法是使用 ip route 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo ip route add default via 192.168.0.150/24</span></div></pre></td></tr></table></figure></p>
<p>这样所有的网络数据包通过 192.168.0.150 来转发，而不是以前的默认路由了。若要修改某个网卡的默认路由，执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo ip route add 172.16.32.32 via 192.168.0.150/24 dev enp0s3</span></div></pre></td></tr></table></figure></p>
<h1 id="案例-8：删除默认路由"><a href="#案例-8：删除默认路由" class="headerlink" title="案例 8：删除默认路由"></a>案例 8：删除默认路由</h1><p>要删除之前设置的默认路由，打开终端然后运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash">  sudo ip route del 192.168.0.150/24</span></div></pre></td></tr></table></figure></p>
<p>注意： 用上面方法修改的默认路由只是临时有效的，在系统重启后所有的改动都会丢失。要永久修改路由，需要修改或创建 route-enp0s3 文件。将下面这行加入其中：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash">  sudo vi /etc/sysconfig/network-scripts/route-enp0s3</span></div><div class="line"></div><div class="line">172.16.32.32 via 192.168.0.150/24 dev enp0s3</div></pre></td></tr></table></figure></p>
<p>保存并退出该文件。</p>
<p>若你使用的是基于 Ubuntu 或 debian 的操作系统，则该要修改的文件为 /etc/network/interfaces，然后添加 ip route add 172.16.32.32 via 192.168.0.150/24 dev enp0s3 这行到文件末尾。</p>
<h1 id="案例-9：检查所有的-ARP-记录"><a href="#案例-9：检查所有的-ARP-记录" class="headerlink" title="案例 9：检查所有的 ARP 记录"></a>案例 9：检查所有的 ARP 记录</h1><p>RP，是地址解析协议Address Resolution Protocol的缩写，用于将 IP 地址转换为物理地址（也就是 MAC 地址）。所有的 IP 和其对应的 MAC 明细都存储在一张表中，这张表叫做 ARP 缓存。</p>
<p>要查看 ARP 缓存中的记录，即连接到局域网中设备的 MAC 地址，则使用如下 ip 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip neigh</div></pre></td></tr></table></figure></p>
<p><a href="http://idiotsky.me/images3/linux-ip-4.jpg"><img src="http://idiotsky.me/images3/linux-ip-4.jpg" alt=""></a> </p>
<h1 id="案例-10：修改-ARP-记录"><a href="#案例-10：修改-ARP-记录" class="headerlink" title="案例 10：修改 ARP 记录"></a>案例 10：修改 ARP 记录</h1><p>删除 ARP 记录的命令为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo ip neigh del 192.168.0.106 dev enp0s3</span></div></pre></td></tr></table></figure></p>
<p>若想往 ARP 缓存中添加新记录，则命令为：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo ip neigh add 192.168.0.150 lladdr 33:1g:75:37:r3:84 dev enp0s3 nud perm</span></div></pre></td></tr></table></figure></p>
<p>这里 nud 的意思是 “neghbour state”（网络邻居状态），它的值可以是：</p>
<ul>
<li>perm - 永久有效并且只能被管理员删除</li>
<li>noarp - 记录有效，但在生命周期过期后就允许被删除了</li>
<li>stale - 记录有效，但可能已经过期</li>
<li>reachable - 记录有效，但超时后就失效了</li>
</ul>
<h1 id="案例-11：查看网络统计信息"><a href="#案例-11：查看网络统计信息" class="headerlink" title="案例 11：查看网络统计信息"></a>案例 11：查看网络统计信息</h1><p>通过 ip 命令还能查看网络的统计信息，比如所有网卡上传输的字节数和报文数，错误或丢弃的报文数等。使用 ip -s link 命令来查看：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> ip -s link</span></div></pre></td></tr></table></figure></p>
<p><a href="http://idiotsky.me/images3/linux-ip-5.jpg"><img src="http://idiotsky.me/images3/linux-ip-5.jpg" alt=""></a> </p>
<h1 id="案例-12：获取帮助"><a href="#案例-12：获取帮助" class="headerlink" title="案例 12：获取帮助"></a>案例 12：获取帮助</h1><p>若你想查看某个上面例子中没有的选项，那么你可以查看帮助。事实上对任何命令你都可以寻求帮助。要列出 ip 命令的所有可选项，执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> ip <span class="built_in">help</span></span></div></pre></td></tr></table></figure></p>
<p>记住，ip 命令是一个对 Linux 系统管理来说特别重要的命令，学习并掌握它能够让配置网络变得容易。</p>
<p>ref <a href="https://zhuanlan.zhihu.com/p/32945498" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/32945498</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一年又一年，我们一直在使用 ifconfig 命令来执行网络相关的任务，比如检查和配置网卡信息。但是 ifconfig 已经不再被维护，并且在最近版本的 Linux 中被废除了！ ifconfig 命令已经被 ip 命令所替代了。&lt;/p&gt;
&lt;p&gt;ip 命令跟 ifconfig 命令有些类似，但要强力的多，它有许多新功能。ip 命令完成很多 ifconfig 命令无法完成的任务。&lt;/p&gt;
&lt;h1 id=&quot;案例-1：检查网卡信息&quot;&gt;&lt;a href=&quot;#案例-1：检查网卡信息&quot; class=&quot;headerlink&quot; title=&quot;案例 1：检查网卡信息&quot;&gt;&lt;/a&gt;案例 1：检查网卡信息&lt;/h1&gt;&lt;p&gt;检查网卡的诸如 IP 地址，子网等网络信息，使用 ip addr show 命令：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ip addr show&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;或&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; ip a s&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://idiotsky.me/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="linux" scheme="http://idiotsky.me/tags/linux/"/>
    
      <category term="route" scheme="http://idiotsky.me/tags/route/"/>
    
      <category term="ip" scheme="http://idiotsky.me/tags/ip/"/>
    
      <category term="arp" scheme="http://idiotsky.me/tags/arp/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个malloc</title>
    <link href="http://idiotsky.me/2018/01/16/c-malloc/"/>
    <id>http://idiotsky.me/2018/01/16/c-malloc/</id>
    <published>2018-01-16T15:46:42.000Z</published>
    <updated>2018-04-24T16:17:14.209Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这篇文章很好的总结了很多关于内存的知识，虽然它讲的只是一个c标准库的一个函数，mark之👿</p>
</blockquote>
<p>任何一个用过或学过C的人对malloc都不会陌生。大家都知道malloc可以分配一段连续的内存空间，并且在不再使用时可以通过free释放掉。但是，许多程序员对malloc背后的事情并不熟悉，许多人甚至把malloc当做操作系统所提供的系统调用或C的关键字。实际上，malloc只是C的标准库中提供的一个普通函数，而且实现malloc的<strong>基本</strong>思想并不复杂，任何一个对C和操作系统有些许了解的程序员都可以很容易理解。</p>
<p>这篇文章通过实现一个简单的malloc来描述malloc背后的机制。当然与现有C的标准库实现（例如glibc）相比，我们实现的malloc并不是特别高效，但是这个实现比目前真实的malloc实现要简单很多，因此易于理解。重要的是，这个实现和真实实现在基本原理上是一致的。</p>
<p>这篇文章将首先介绍一些所需的基本知识，如操作系统对进程的内存管理以及相关的系统调用，然后逐步实现一个简单的malloc。为了简单起见，这篇文章将只考虑x86_64体系结构，操作系统为Linux。</p>
<a id="more"></a>
<h1 id="什么是malloc"><a href="#什么是malloc" class="headerlink" title="什么是malloc"></a>什么是malloc</h1><p>在实现malloc之前，先要相对正式地对malloc做一个定义。</p>
<p>根据标准C库函数的定义，malloc具有如下原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：</p>
<ul>
<li>malloc分配的内存大小<strong>至少</strong>为size参数所指定的字节数</li>
<li>malloc的返回值是一个指针，指向一段可用内存的起始地址</li>
<li>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</li>
<li>malloc应该尽快完成内存分配并返回（不能使用<a href="http://en.wikipedia.org/wiki/NP-hard" target="_blank" rel="external">NP-hard</a>的内存分配算法）</li>
<li>实现malloc时应同时实现内存大小调整和内存释放函数（即realloc和free）</li>
</ul>
<p>对于malloc更多的说明可以在命令行中键入以下命令查看：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man malloc</div></pre></td></tr></table></figure></p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>在实现malloc之前，需要先解释一些Linux系统内存相关的知识。</p>
<h2 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h2><h3 id="虚拟内存地址与物理内存地址"><a href="#虚拟内存地址与物理内存地址" class="headerlink" title="虚拟内存地址与物理内存地址"></a>虚拟内存地址与物理内存地址</h3><p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时，都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片2^N字节的内存，其中N是机器位数。例如在64位CPU和64位操作系统下，每个进程的虚拟地址空间为2^64Byte.</p>
<p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p>
<p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫<a href="http://en.wikipedia.org/wiki/Memory_management_unit" target="_blank" rel="external">MMU</a>（Memory Management Unit）的硬件完成。</p>
<h3 id="页与地址构成"><a href="#页与地址构成" class="headerlink" title="页与地址构成"></a>页与地址构成</h3><p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p>
<p>所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：<br><a href="http://idiotsky.me/images2/c-malloc-1.png"><img src="http://idiotsky.me/images2/c-malloc-1.png" alt=""></a></p>
<p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内便宜都是用低12位表示，而剩下的高地址表示页号。</p>
<p>MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构<a href="http://en.wikipedia.org/wiki/Page_table" target="_blank" rel="external">页表</a>来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank" rel="external">TLB</a>等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。<br><a href="http://idiotsky.me/images2/c-malloc-2.png"><img src="http://idiotsky.me/images2/c-malloc-2.png" alt=""></a></p>
<h3 id="内存页与磁盘页"><a href="#内存页与磁盘页" class="headerlink" title="内存页与磁盘页"></a>内存页与磁盘页</h3><p>我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。<br><a href="http://idiotsky.me/images2/c-malloc-3.png"><img src="http://idiotsky.me/images2/c-malloc-3.png" alt=""></a></p>
<h2 id="Linux进程级内存管理"><a href="#Linux进程级内存管理" class="headerlink" title="Linux进程级内存管理"></a>Linux进程级内存管理</h2><h3 id="内存排布"><a href="#内存排布" class="headerlink" title="内存排布"></a>内存排布</h3><p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p>
<p>以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p>
<p>根据<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt" target="_blank" rel="external">Linux内核相关文档</a>描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：<br><a href="http://idiotsky.me/images2/c-malloc-4.png"><img src="http://idiotsky.me/images2/c-malloc-4.png" alt=""></a></p>
<p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p>
<ul>
<li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li>
<li>Data：这里存放的是初始化过的全局变量</li>
<li>BSS：这里存放的是未初始化的全局变量</li>
<li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li>
<li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li>
<li>Stack：这是栈区域，自高地址向低地址增长</li>
</ul>
<p>下面我们主要关注Heap区域的操作。对整个Linux内存排布有兴趣的同学可以参考其它资料。</p>
<h3 id="Heap内存模型"><a href="#Heap内存模型" class="headerlink" title="Heap内存模型"></a>Heap内存模型</h3><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p>
<p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：<br><a href="http://idiotsky.me/images2/c-malloc-5.png"><img src="http://idiotsky.me/images2/c-malloc-5.png" alt=""></a></p>
<p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p>
<h3 id="brk与sbrk"><a href="#brk与sbrk" class="headerlink" title="brk与sbrk"></a>brk与sbrk</h3><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;</div></pre></td></tr></table></figure></p>
<p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p>
<p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p>
<p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</p>
<h3 id="资源限制与rlimit"><a href="#资源限制与rlimit" class="headerlink" title="资源限制与rlimit"></a>资源限制与rlimit</h3><p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> *<span class="title">limit</span> = (<span class="title">struct</span> <span class="title">rlimit</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">rlimit</span>));</span></div><div class="line">    getrlimit(RLIMIT_AS, limit);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"soft limit: %ld, hard limit: %ld\n"</span>, limit-&gt;rlim_cur, limit-&gt;rlim_max);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中rlimit是一个结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></div><div class="line">    <span class="keyword">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></div><div class="line">    <span class="keyword">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p>
<h1 id="实现malloc"><a href="#实现malloc" class="headerlink" title="实现malloc"></a>实现malloc</h1><h2 id="玩具实现"><a href="#玩具实现" class="headerlink" title="玩具实现"></a>玩具实现</h2><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 一个玩具malloc */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *p;</div><div class="line">    p = sbrk(<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (sbrk(size) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p>
<h2 id="正式实现"><a href="#正式实现" class="headerlink" title="正式实现"></a>正式实现</h2><p>下面严肃点讨论malloc的实现方案。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p>
<p>可以用如下结构体定义一个block：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></div><div class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></div><div class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></div><div class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></div><div class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：<br><a href="http://idiotsky.me/images2/c-malloc-6.png"><img src="http://idiotsky.me/images2/c-malloc-6.png" alt=""></a></p>
<h3 id="寻找合适的block"><a href="#寻找合适的block" class="headerlink" title="寻找合适的block"></a>寻找合适的block</h3><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p>
<ul>
<li><strong>First fit</strong>：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块</li>
<li><strong>Best fit</strong>：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</li>
</ul>
<p>两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* First fit */</span></div><div class="line"><span class="function">t_block <span class="title">find_block</span><span class="params">(t_block *last, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    t_block b = first_block;</div><div class="line">    <span class="keyword">while</span>(b &amp;&amp; !(b-&gt;<span class="built_in">free</span> &amp;&amp; b-&gt;size &gt;= size)) &#123;</div><div class="line">        *last = b;</div><div class="line">        b = b-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到这返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新block使用的，具体会在接下来的一节用到。</p>
<h3 id="开辟新的block"><a href="#开辟新的block" class="headerlink" title="开辟新的block"></a>开辟新的block</h3><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE 24 <span class="comment">/* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */</span></span></div><div class="line"> </div><div class="line"><span class="function">t_block <span class="title">extend_heap</span><span class="params">(t_block last, <span class="keyword">size_t</span> s)</span> </span>&#123;</div><div class="line">    t_block b;</div><div class="line">    b = sbrk(<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span>(sbrk(BLOCK_SIZE + s) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    b-&gt;size = s;</div><div class="line">    b-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span>(last)</div><div class="line">        last-&gt;next = b;</div><div class="line">    b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="分裂block"><a href="#分裂block" class="headerlink" title="分裂block"></a>分裂block</h3><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：<br><a href="http://idiotsky.me/images2/c-malloc-7.png"><img src="http://idiotsky.me/images2/c-malloc-7.png" alt=""></a></p>
<p>实现代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_block</span><span class="params">(t_block b, <span class="keyword">size_t</span> s)</span> </span>&#123;</div><div class="line">    t_block <span class="keyword">new</span>;</div><div class="line">    <span class="keyword">new</span> = b-&gt;data + s;</div><div class="line">    <span class="keyword">new</span>-&gt;size = b-&gt;size - s - BLOCK_SIZE ;</div><div class="line">    <span class="keyword">new</span>-&gt;next = b-&gt;next;</div><div class="line">    <span class="keyword">new</span>-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">    b-&gt;size = s;</div><div class="line">    b-&gt;next = <span class="keyword">new</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="malloc的实现"><a href="#malloc的实现" class="headerlink" title="malloc的实现"></a>malloc的实现</h3><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p>
<p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> align8(<span class="keyword">size_t</span> s) &#123;</div><div class="line">    <span class="keyword">if</span>(s &amp; <span class="number">0x7</span> == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    <span class="keyword">return</span> ((s &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE 24</span></div><div class="line"><span class="keyword">void</span> *first_block=<span class="literal">NULL</span>;</div><div class="line"> </div><div class="line"><span class="comment">/* other functions... */</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    t_block b, last;</div><div class="line">    <span class="keyword">size_t</span> s;</div><div class="line">    <span class="comment">/* 对齐地址 */</span></div><div class="line">    s = align8(size);</div><div class="line">    <span class="keyword">if</span>(first_block) &#123;</div><div class="line">        <span class="comment">/* 查找合适的block */</span></div><div class="line">        last = first_block;</div><div class="line">        b = find_block(&amp;last, s);</div><div class="line">        <span class="keyword">if</span>(b) &#123;</div><div class="line">            <span class="comment">/* 如果可以，则分裂 */</span></div><div class="line">            <span class="keyword">if</span> ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + <span class="number">8</span>))</div><div class="line">                split_block(b, s);</div><div class="line">            b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* 没有合适的block，开辟一个新的 */</span></div><div class="line">            b = extend_heap(last, s);</div><div class="line">            <span class="keyword">if</span>(!b)</div><div class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        b = extend_heap(<span class="literal">NULL</span>, s);</div><div class="line">        <span class="keyword">if</span>(!b)</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        first_block = b;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b-&gt;data;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="calloc的实现"><a href="#calloc的实现" class="headerlink" title="calloc的实现"></a>calloc的实现</h3><p>有了malloc，实现calloc只要两步：</p>
<ol>
<li>malloc一段内存</li>
<li>将数据区内容置为0</li>
</ol>
<p>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> number, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> *<span class="keyword">new</span>;</div><div class="line">    <span class="keyword">size_t</span> s8, i;</div><div class="line">    <span class="keyword">new</span> = <span class="built_in">malloc</span>(number * size);</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>) &#123;</div><div class="line">        s8 = align8(number * size) &gt;&gt; <span class="number">3</span>;</div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s8; i++)</div><div class="line">            <span class="keyword">new</span>[i] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="free的实现"><a href="#free的实现" class="headerlink" title="free的实现"></a>free的实现</h3><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p>
<ol>
<li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li>
<li>如何解决碎片问题</li>
</ol>
<p>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</p>
<ol>
<li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li>
<li>这个地址确实是之前通过我们自己的malloc分配的</li>
</ol>
<p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p>
<p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></div><div class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></div><div class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></div><div class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></div><div class="line">    <span class="keyword">void</span> *ptr;    <span class="comment">/* Magic pointer，指向data */</span></div><div class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>然后我们定义检查地址合法性的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function">t_block <span class="title">get_block</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span> *tmp;  </div><div class="line">    tmp = p;</div><div class="line">    <span class="keyword">return</span> (p = tmp -= BLOCK_SIZE);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">valid_addr</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(first_block) &#123;</div><div class="line">        <span class="keyword">if</span>(p &gt; first_block &amp;&amp; p &lt; sbrk(<span class="number">0</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> p == (get_block(p))-&gt;ptr;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p>
<p>一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> &#123;</span></div><div class="line">    <span class="keyword">size_t</span> size;  <span class="comment">/* 数据区大小 */</span></div><div class="line">    t_block prev; <span class="comment">/* 指向上个块的指针 */</span></div><div class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></div><div class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;     <span class="comment">/* 是否是空闲块 */</span></div><div class="line">    <span class="keyword">int</span> padding;  <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></div><div class="line">    <span class="keyword">void</span> *ptr;    <span class="comment">/* Magic pointer，指向data */</span></div><div class="line">    <span class="keyword">char</span> data[<span class="number">1</span>]  <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>合并方法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">t_block <span class="title">fusion</span><span class="params">(t_block b)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (b-&gt;next &amp;&amp; b-&gt;next-&gt;<span class="built_in">free</span>) &#123;</div><div class="line">        b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size;</div><div class="line">        b-&gt;next = b-&gt;next-&gt;next;</div><div class="line">        <span class="keyword">if</span>(b-&gt;next)</div><div class="line">            b-&gt;next-&gt;prev = b;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</div><div class="line">    t_block b;</div><div class="line">    <span class="keyword">if</span>(valid_addr(p)) &#123;</div><div class="line">        b = get_block(p);</div><div class="line">        b-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;<span class="built_in">free</span>)</div><div class="line">            b = fusion(b-&gt;prev);</div><div class="line">        <span class="keyword">if</span>(b-&gt;next)</div><div class="line">            fusion(b);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(b-&gt;prev)</div><div class="line">                b-&gt;prev-&gt;prev = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                first_block = <span class="literal">NULL</span>;</div><div class="line">            brk(b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="realloc的实现"><a href="#realloc的实现" class="headerlink" title="realloc的实现"></a>realloc的实现</h3><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_block</span><span class="params">(t_block src, t_block dst)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> *sdata, *ddata;</div><div class="line">    <span class="keyword">size_t</span> i;</div><div class="line">    sdata = src-&gt;ptr;</div><div class="line">    ddata = dst-&gt;ptr;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; (i * <span class="number">8</span>) &lt; src-&gt;size &amp;&amp; (i * <span class="number">8</span>) &lt; dst-&gt;size; i++)</div><div class="line">        ddata[i] = sdata[i];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p>
<ul>
<li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li>
<li>如果新的size变小了，考虑split</li>
<li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li>
</ul>
<p>下面是realloc的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">size_t</span> s;</div><div class="line">    t_block b, <span class="keyword">new</span>;</div><div class="line">    <span class="keyword">void</span> *newp;</div><div class="line">    <span class="keyword">if</span> (!p)</div><div class="line">        <span class="comment">/* 根据标准库文档，当p传入NULL时，相当于调用malloc */</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</div><div class="line">    <span class="keyword">if</span>(valid_addr(p)) &#123;</div><div class="line">        s = align8(size);</div><div class="line">        b = get_block(p);</div><div class="line">        <span class="keyword">if</span>(b-&gt;size &gt;= s) &#123;</div><div class="line">            <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))</div><div class="line">                split_block(b,s);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* 看是否可进行合并 */</span></div><div class="line">            <span class="keyword">if</span>(b-&gt;next &amp;&amp; b-&gt;next-&gt;<span class="built_in">free</span></div><div class="line">                    &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) &#123;</div><div class="line">                fusion(b);</div><div class="line">                <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))</div><div class="line">                    split_block(b, s);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* 新malloc */</span></div><div class="line">                newp = <span class="built_in">malloc</span> (s);</div><div class="line">                <span class="keyword">if</span> (!newp)</div><div class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">                <span class="keyword">new</span> = get_block(newp);</div><div class="line">                copy_block(b, <span class="keyword">new</span>);</div><div class="line">                <span class="built_in">free</span>(p);</div><div class="line">                <span class="keyword">return</span>(newp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> (p);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="遗留问题和优化"><a href="#遗留问题和优化" class="headerlink" title="遗留问题和优化"></a>遗留问题和优化</h2><p>以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p>
<ul>
<li>同时兼容32位和64位系统</li>
<li>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效</li>
<li>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度</li>
<li>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率</li>
</ul>
<p>还有很多可能的优化，这里不一一赘述。</p>
<p>from <a href="http://blog.codinglabs.org/articles/a-malloc-tutorial.html" target="_blank" rel="external">http://blog.codinglabs.org/articles/a-malloc-tutorial.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章很好的总结了很多关于内存的知识，虽然它讲的只是一个c标准库的一个函数，mark之👿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;任何一个用过或学过C的人对malloc都不会陌生。大家都知道malloc可以分配一段连续的内存空间，并且在不再使用时可以通过free释放掉。但是，许多程序员对malloc背后的事情并不熟悉，许多人甚至把malloc当做操作系统所提供的系统调用或C的关键字。实际上，malloc只是C的标准库中提供的一个普通函数，而且实现malloc的&lt;strong&gt;基本&lt;/strong&gt;思想并不复杂，任何一个对C和操作系统有些许了解的程序员都可以很容易理解。&lt;/p&gt;
&lt;p&gt;这篇文章通过实现一个简单的malloc来描述malloc背后的机制。当然与现有C的标准库实现（例如glibc）相比，我们实现的malloc并不是特别高效，但是这个实现比目前真实的malloc实现要简单很多，因此易于理解。重要的是，这个实现和真实实现在基本原理上是一致的。&lt;/p&gt;
&lt;p&gt;这篇文章将首先介绍一些所需的基本知识，如操作系统对进程的内存管理以及相关的系统调用，然后逐步实现一个简单的malloc。为了简单起见，这篇文章将只考虑x86_64体系结构，操作系统为Linux。&lt;/p&gt;
    
    </summary>
    
      <category term="c" scheme="http://idiotsky.me/categories/c/"/>
    
    
      <category term="c" scheme="http://idiotsky.me/tags/c/"/>
    
      <category term="malloc" scheme="http://idiotsky.me/tags/malloc/"/>
    
  </entry>
  
  <entry>
    <title>深入go接口</title>
    <link href="http://idiotsky.me/2018/01/15/go-interface/"/>
    <id>http://idiotsky.me/2018/01/15/go-interface/</id>
    <published>2018-01-15T07:44:21.000Z</published>
    <updated>2018-02-26T11:25:41.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="接口是什么"><a href="#接口是什么" class="headerlink" title="接口是什么"></a>接口是什么</h1><p>接口就是一个抽象类型，与之对应的就是具体类型，同时接口也是抽象方法接口。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> human <span class="keyword">interface</span>&#123;</div><div class="line">	walk()</div><div class="line">	run()</div><div class="line">	eat()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码定义了接口，接口里定义了几个抽象方法，一般其他语言例如Java，都会定义一个具体的类型来实现这个接口，像这样<code>class man implements human</code> 声明<code>man</code>实现了<code>human</code>。但是go上使用了一种<code>duck typing</code>来定义具体类型。<br><a id="more"></a></p>
<blockquote>
<p>When I see a bird that walks like a duck and swins like a duck and quacks like a duck, I call that bird a duck. – James Whitcomb Riley</p>
</blockquote>
<p>结合维基百科的<a href="https://en.wikipedia.org/wiki/Duck_typing" target="_blank" rel="external">定义</a>，duck typing是面向对象编程语言的一种类型定义方法。我们判断一个对象是什么不是通过它的类型定义来判断，而是判断它是否满足某些特定的方法和属性定义。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> man <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *man)</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"man walk"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *man)</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"man run"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *man)</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"man eat"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面定义的<code>man</code> 并没有声明它实现了哪些接口，但是，它确切是<code>human</code>的具体类型<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">var</span> h human=&amp;man&#123;&#125;</div><div class="line">	h.eat()</div><div class="line">	h.run()</div><div class="line">	h.walk()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">man eat</div><div class="line">man run</div><div class="line">man walk</div></pre></td></tr></table></figure></p>
<p>上面结果说明了，不用声明某具体类型实现哪个接口，只要它有某接口的所有方法，那它就是某接口的具体类型。</p>
<h1 id="接口实现多态"><a href="#接口实现多态" class="headerlink" title="接口实现多态"></a>接口实现多态</h1><p>很明显，再加个<code>woman</code>类型，实现所有方法就可以实现个多态（方法重载）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> woman <span class="keyword">struct</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *woman)</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"woman walk"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *woman)</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"woman run"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *woman)</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"woman eat"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">var</span> h human=&amp;man&#123;&#125;</div><div class="line">	h.eat()</div><div class="line">	h.run()</div><div class="line">    h.walk()</div><div class="line">    h=&amp;woman&#123;&#125;</div><div class="line">    h.eat()</div><div class="line">	h.run()</div><div class="line">    h.walk()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">man eat</div><div class="line">man run</div><div class="line">man walk</div><div class="line">woman eat</div><div class="line">woman run</div><div class="line">woman walk</div></pre></td></tr></table></figure></p>
<h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>所谓类型断言，就是一个接口类型，转化成具体类型时候使用。还有go里面<code>interface{}</code>是一个万能的类型，有点像java的<code>Object</code>类型<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">    n := v.(<span class="keyword">int</span>)    <span class="comment">// might panic</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</div><div class="line">    n, ok := v.(<span class="keyword">int</span>)</div><div class="line">    <span class="keyword">if</span> !ok &#123;</div><div class="line">        <span class="comment">// 断言失败处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的方法可以用所有的不同类型的参数调用，所以如果不是<code>int</code>类型参数的话就是panic了，所以第二个<code>do</code>可以进行断言失败处理，避免错误发生。</p>
<h1 id="深入源码"><a href="#深入源码" class="headerlink" title="深入源码"></a>深入源码</h1><h2 id="interface-底层结构"><a href="#interface-底层结构" class="headerlink" title="interface 底层结构"></a>interface 底层结构</h2><p>根据 interface 是否包含有 method，底层实现上用两种 struct 来表示：iface 和 eface。eface表示不含 method 的 interface 结构，或者叫 empty interface。对于 Golang 中的大部分数据类型都可以抽象出来 _type 结构，同时针对不同的类型还会有一些其他信息。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</div><div class="line">    _type *_type</div><div class="line">    data  unsafe.Pointer</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</div><div class="line">    size       <span class="keyword">uintptr</span> <span class="comment">// type size</span></div><div class="line">    ptrdata    <span class="keyword">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></div><div class="line">    hash       <span class="keyword">uint32</span>  <span class="comment">// hash of type; avoids computation in hash tables</span></div><div class="line">    tflag      tflag   <span class="comment">// extra type information flags</span></div><div class="line">    align      <span class="keyword">uint8</span>   <span class="comment">// alignment of variable with this type</span></div><div class="line">    fieldalign <span class="keyword">uint8</span>   <span class="comment">// alignment of struct field with this type</span></div><div class="line">    kind       <span class="keyword">uint8</span>   <span class="comment">// enumeration for C</span></div><div class="line">    alg        *typeAlg  <span class="comment">// algorithm table</span></div><div class="line">    gcdata    *<span class="keyword">byte</span>    <span class="comment">// garbage collection data</span></div><div class="line">    str       nameOff  <span class="comment">// string form</span></div><div class="line">    ptrToThis typeOff  <span class="comment">// type for pointer to this type, may be zero</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>iface 表示 non-empty interface 的底层实现。相比于 empty interface，non-empty 要包含一些 method。method 的具体实现存放在 itab.fun 变量里。如果 interface 包含多个 method，这里只有一个 fun 变量怎么存呢？这个下面再细说。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</div><div class="line">    tab  *itab</div><div class="line">    data unsafe.Pointer</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// layout of Itab known to compilers</span></div><div class="line"><span class="comment">// allocated in non-garbage-collected memory</span></div><div class="line"><span class="comment">// Needs to be in sync with</span></div><div class="line"><span class="comment">// ../cmd/compile/internal/gc/reflect.go:/^func.dumptypestructs.</span></div><div class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</div><div class="line">    inter  *interfacetype</div><div class="line">    _type  *_type</div><div class="line">    link   *itab</div><div class="line">    bad    <span class="keyword">int32</span></div><div class="line">    inhash <span class="keyword">int32</span>      <span class="comment">// has this itab been added to hash?</span></div><div class="line">    fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们使用实际程序来看一下。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</div><div class="line">    Print()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms MyStruct)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    x := <span class="number">1</span></div><div class="line">    <span class="keyword">var</span> y <span class="keyword">interface</span>&#123;&#125; = x</div><div class="line">    <span class="keyword">var</span> s MyStruct</div><div class="line">    <span class="keyword">var</span> t MyInterface = s</div><div class="line">    fmt.Println(y, z)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看汇编代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">$ go build -gcflags &apos;-l&apos; -o interface11 interface11.go</div><div class="line">$ go tool objdump -s &quot;main\.main&quot; interface11</div><div class="line">TEXT main.main(SB) /Users/kltao/code/go/examples/interface11.go</div><div class="line">    interface11.go:15   0x10870f0   65488b0c25a0080000  GS MOVQ GS:0x8a0, CX</div><div class="line">    interface11.go:15   0x10870f9   483b6110        CMPQ 0x10(CX), SP</div><div class="line">    interface11.go:15   0x10870fd   0f86de000000        JBE 0x10871e1</div><div class="line">    interface11.go:15   0x1087103   4883ec70        SUBQ $0x70, SP</div><div class="line">    interface11.go:15   0x1087107   48896c2468      MOVQ BP, 0x68(SP)</div><div class="line">    interface11.go:15   0x108710c   488d6c2468      LEAQ 0x68(SP), BP</div><div class="line">    interface11.go:17   0x1087111   48c744243001000000  MOVQ $0x1, 0x30(SP)</div><div class="line">    interface11.go:17   0x108711a   488d057fde0000      LEAQ 0xde7f(IP), AX</div><div class="line">    interface11.go:17   0x1087121   48890424        MOVQ AX, 0(SP)</div><div class="line">    interface11.go:17   0x1087125   488d442430      LEAQ 0x30(SP), AX</div><div class="line">    interface11.go:17   0x108712a   4889442408      MOVQ AX, 0x8(SP)</div><div class="line">    interface11.go:17   0x108712f   e87c45f8ff      CALL runtime.convT2E(SB)</div><div class="line">    interface11.go:17   0x1087134   488b442410      MOVQ 0x10(SP), AX</div><div class="line">    interface11.go:17   0x1087139   4889442438      MOVQ AX, 0x38(SP)</div><div class="line">    interface11.go:17   0x108713e   488b4c2418      MOVQ 0x18(SP), CX</div><div class="line">    interface11.go:17   0x1087143   48894c2440      MOVQ CX, 0x40(SP)</div><div class="line">    interface11.go:19   0x1087148   488d15b1000800      LEAQ 0x800b1(IP), DX</div><div class="line">    interface11.go:19   0x108714f   48891424        MOVQ DX, 0(SP)</div><div class="line">    interface11.go:19   0x1087153   488d542430      LEAQ 0x30(SP), DX</div><div class="line">    interface11.go:19   0x1087158   4889542408      MOVQ DX, 0x8(SP)</div><div class="line">    interface11.go:19   0x108715d   e8fe45f8ff      CALL runtime.convT2I(SB)</div></pre></td></tr></table></figure></p>
<p>代码 17 行 var y interface{} = x 调用了函数 runtime.convT2E，将 int 类型的 x 转换成 empty interface。代码 19 行 var t MyInterface = s 将 MyStruct 类型转换成 non-empty interface: MyInterface。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2E</span><span class="params">(t *_type, elem unsafe.Pointer)</span> <span class="params">(e eface)</span></span> &#123;</div><div class="line">    ...</div><div class="line">  </div><div class="line">    x := newobject(t)</div><div class="line">    typedmemmove(t, x, elem)</div><div class="line">    e._type = t</div><div class="line">    e.data = x</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">convT2I</span><span class="params">(tab *itab, elem unsafe.Pointer)</span> <span class="params">(i iface)</span></span> &#123;</div><div class="line">    t := tab._type</div><div class="line">    </div><div class="line">    ...</div><div class="line">  </div><div class="line">    x := newobject(t)</div><div class="line">    typedmemmove(t, x, elem)</div><div class="line">    i.tab = tab</div><div class="line">    i.data = x</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看上面的函数原型，可以看出中间过程编译器将根据我们的转换目标类型的 empty interface 还是 non-empty interface，来对原数据类型进行转换（转换成 &lt;<em>_type, unsafe.Pointer&gt; 或者 &lt;</em>itab, unsafe.Pointer&gt;）。这里对于 struct 满不满足 interface 的类型要求（也就是 struct 是否实现了 interface 的所有 method），是由编译器来检测的。</p>
<h2 id="itab"><a href="#itab" class="headerlink" title="itab"></a>itab</h2><p>iface 结构中最重要的是 itab 结构。itab 可以理解为 <code>pair&lt;interface type, concrete type&gt;</code> 。当然 itab 里面还包含一些其他信息，比如 interface 里面包含的 method 的具体实现。下面细说。itab 的结构如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</div><div class="line">    inter  *interfacetype</div><div class="line">    _type  *_type</div><div class="line">    link   *itab</div><div class="line">    bad    <span class="keyword">int32</span></div><div class="line">    inhash <span class="keyword">int32</span>      <span class="comment">// has this itab been added to hash?</span></div><div class="line">    fun    [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// variable sized</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 interfacetype 包含了一些关于 interface 本身的信息，比如 package path，包含的 method。上面提到的 iface 和 eface 是数据类型（built-in 和 type-define）转换成 interface 之后的实体的 struct 结构，而这里的 interfacetype 是我们定义 interface 时候的一种抽象表示。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</div><div class="line">    typ     _type</div><div class="line">    pkgpath name</div><div class="line">    mhdr    []imethod</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;   <span class="comment">//这里的 method 只是一种函数声明的抽象，比如  func Print() error</span></div><div class="line">    name nameOff</div><div class="line">    ityp typeOff</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>_type 表示 concrete type。fun 表示的 interface 里面的 method 的具体实现。比如 interface type 包含了 method A, B，则通过 fun 就可以找到这两个 method 的具体实现。这里有个问题 fun 是长度为 1 的 uintptr 数组，那么怎么表示多个 method 呢？看一下测试程序。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">type</span> MyInterface <span class="keyword">interface</span> &#123;</div><div class="line">    Print()</div><div class="line">    Hello()</div><div class="line">    World()</div><div class="line">    AWK()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(me MyInterface)</span></span> &#123;</div><div class="line">    me.Print()</div><div class="line">    me.Hello()</div><div class="line">    me.World()</div><div class="line">    me.AWK()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(me MyStruct)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(me MyStruct)</span> <span class="title">Hello</span><span class="params">()</span></span> &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(me MyStruct)</span> <span class="title">World</span><span class="params">()</span></span> &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(me MyStruct)</span> <span class="title">AWK</span><span class="params">()</span></span> &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> me MyStruct</div><div class="line">    Foo(me)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看一下函数调用对应的汇编代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">$ go build -gcflags &apos;-l&apos; -o interface8 interface8.go</div><div class="line">$ go tool objdump -s &quot;main\.Foo&quot; interface8</div><div class="line">TEXT main.Foo(SB) /Users/kltao/code/go/examples/interface8.go</div><div class="line">    interface8.go:10    0x104c060   65488b0c25a0080000  GS MOVQ GS:0x8a0, CX</div><div class="line">    interface8.go:10    0x104c069   483b6110        CMPQ 0x10(CX), SP</div><div class="line">    interface8.go:10    0x104c06d   7668            JBE 0x104c0d7</div><div class="line">    interface8.go:10    0x104c06f   4883ec10        SUBQ $0x10, SP</div><div class="line">    interface8.go:10    0x104c073   48896c2408      MOVQ BP, 0x8(SP)</div><div class="line">    interface8.go:10    0x104c078   488d6c2408      LEAQ 0x8(SP), BP</div><div class="line">    interface8.go:11    0x104c07d   488b442418      MOVQ 0x18(SP), AX</div><div class="line">    interface8.go:11    0x104c082   488b4830        MOVQ 0x30(AX), CX //取得 Print 函数地址</div><div class="line">    interface8.go:11    0x104c086   488b542420      MOVQ 0x20(SP), DX</div><div class="line">    interface8.go:11    0x104c08b   48891424        MOVQ DX, 0(SP)</div><div class="line">    interface8.go:11    0x104c08f   ffd1            CALL CX     // 调用 Print()</div><div class="line">    interface8.go:12    0x104c091   488b442418      MOVQ 0x18(SP), AX</div><div class="line">    interface8.go:12    0x104c096   488b4828        MOVQ 0x28(AX), CX //取得 Hello 函数地址</div><div class="line">    interface8.go:12    0x104c09a   488b542420      MOVQ 0x20(SP), DX</div><div class="line">    interface8.go:12    0x104c09f   48891424        MOVQ DX, 0(SP)</div><div class="line">    interface8.go:12    0x104c0a3   ffd1            CALL CX           //调用 Hello()</div><div class="line">    interface8.go:13    0x104c0a5   488b442418      MOVQ 0x18(SP), AX</div><div class="line">    interface8.go:13    0x104c0aa   488b4838        MOVQ 0x38(AX), CX //取得 World 函数地址</div><div class="line">    interface8.go:13    0x104c0ae   488b542420      MOVQ 0x20(SP), DX </div><div class="line">    interface8.go:13    0x104c0b3   48891424        MOVQ DX, 0(SP)</div><div class="line">    interface8.go:13    0x104c0b7   ffd1            CALL CX           //调用 World()</div><div class="line">    interface8.go:14    0x104c0b9   488b442418      MOVQ 0x18(SP), AX</div><div class="line">    interface8.go:14    0x104c0be   488b4020        MOVQ 0x20(AX), AX //取得 AWK 函数地址</div><div class="line">    interface8.go:14    0x104c0c2   488b4c2420      MOVQ 0x20(SP), CX</div><div class="line">    interface8.go:14    0x104c0c7   48890c24        MOVQ CX, 0(SP)</div><div class="line">    interface8.go:14    0x104c0cb   ffd0            CALL AX           //调用 AWK()</div><div class="line">    interface8.go:15    0x104c0cd   488b6c2408      MOVQ 0x8(SP), BP</div><div class="line">    interface8.go:15    0x104c0d2   4883c410        ADDQ $0x10, SP</div><div class="line">    interface8.go:15    0x104c0d6   c3          RET</div><div class="line">    interface8.go:10    0x104c0d7   e8f48bffff      CALL runtime.morestack_noctxt(SB)</div><div class="line">    interface8.go:10    0x104c0dc   eb82            JMP main.Foo(SB)</div></pre></td></tr></table></figure></p>
<p>其中 0x18(SP) 对应的 itab 的地址。fun 在 x86-64 机器上对应 itab 内的地址偏移为 8+8+8+4+4 = 32 = 0x20，也就是 0x20(AX) 对应的 fun 的值，此时存放的 AWK 函数地址。然后 0x28(AX) = &amp;Hello，0x30(AX) = &amp;Print，0x38(AX) = &amp;World。对的，每次函数是按字典序排序存放的。</p>
<p>我们再来看一下函数地址究竟是怎么写入的？首先 Golang 中的 uintptr 一般用来存放指针的值，这里对应的就是函数指针的值（也就是函数的调用地址）。但是这里的 fun 是一个长度为 1 的 uintptr 数组。我们看一下 runtime 包的 additab 函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">additab</span><span class="params">(m *itab, locked, canfail <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">    ...</div><div class="line">    *(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="number">0</span>]), <span class="keyword">uintptr</span>(k)*sys.PtrSize)) = ifn</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码的意思是在 fun[0] 的地址后面依次写入其他 method 对应的函数指针。熟悉 C++ 的同学可以类比 C++ 的虚函数表指针来看。</p>
<p>剩下的还有 bad，link，inhash。其中 bad 是一个表征 itab 状态的变量。而这里的 link 是 *itab 类型，是不是表示 interface 的嵌套呢？并不是，interface 的嵌套也是把 method 平铺而已。link 要和 inhash 一起来说。在 runtime 包里面有一个 hash 表，通过 hash[hashitab(interface_type, concrete_type)] 可以取得 itab，这是出于性能方面的考虑。主要代码如下，这里就不再赘述了。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> (</div><div class="line">    hashSize = <span class="number">1009</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    ifaceLock mutex <span class="comment">// lock for accessing hash</span></div><div class="line">    hash      [hashSize]*itab</div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabhash</span><span class="params">(inter *interfacetype, typ *_type)</span> <span class="title">uint32</span></span> &#123;</div><div class="line">    <span class="comment">// compiler has provided some good hash codes for us.</span></div><div class="line">    h := inter.typ.hash</div><div class="line">    h += <span class="number">17</span> * typ.hash</div><div class="line">    <span class="comment">// TODO(rsc): h += 23 * x.mhash ?</span></div><div class="line">    <span class="keyword">return</span> h % hashSize</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">additab</span><span class="params">(...)</span></span> &#123;</div><div class="line">    ...</div><div class="line">    h := itabhash(inter, typ)</div><div class="line">    m.link = hash[h]</div><div class="line">    m.inhash = <span class="number">1</span></div><div class="line">    atomicstorep(unsafe.Pointer(&amp;hash[h]), unsafe.Pointer(m))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="类型断言-1"><a href="#类型断言-1" class="headerlink" title="类型断言"></a>类型断言</h2><p>上面有说到的断言，它的实现源码如下几个函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The assertXXX functions may fail (either panicking or returning false,</span></div><div class="line"><span class="comment">// depending on whether they are 1-result or 2-result).</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertI2I</span><span class="params">(inter *interfacetype, i iface)</span> <span class="params">(r iface)</span></span> &#123;</div><div class="line">    tab := i.tab</div><div class="line">    <span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</div><div class="line">        <span class="comment">// explicit conversions require non-nil interface value.</span></div><div class="line">        <span class="built_in">panic</span>(&amp;TypeAssertionError&#123;<span class="string">""</span>, <span class="string">""</span>, inter.typ.<span class="keyword">string</span>(), <span class="string">""</span>&#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> tab.inter == inter &#123;</div><div class="line">        r.tab = tab</div><div class="line">        r.data = i.data</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    r.tab = getitab(inter, tab._type, <span class="literal">false</span>)</div><div class="line">    r.data = i.data</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertI2I2</span><span class="params">(inter *interfacetype, i iface)</span> <span class="params">(r iface, b <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">    tab := i.tab</div><div class="line">    <span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> tab.inter != inter &#123;</div><div class="line">        tab = getitab(inter, tab._type, <span class="literal">true</span>)</div><div class="line">        <span class="keyword">if</span> tab == <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    r.tab = tab</div><div class="line">    r.data = i.data</div><div class="line">    b = <span class="literal">true</span></div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 类似</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">assertE2I</span><span class="params">(inter *interfacetype, e eface)</span> <span class="params">(r iface)</span></span></div><div class="line"><span class="title">func</span> <span class="title">assertE2I2</span><span class="params">(inter *interfacetype, e eface)</span> <span class="params">(r iface, b <span class="keyword">bool</span>)</span></div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>go的interface是一种类型，从源码来看，其他类型在赋值给一个接口的时候，会创建结构（iface和eface）来包装这个原始数据。还有go的鸭子类型这种特点，方便多态的实现。</p>
<p>参考 <a href="https://zhuanlan.zhihu.com/p/27652856" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/27652856</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;接口是什么&quot;&gt;&lt;a href=&quot;#接口是什么&quot; class=&quot;headerlink&quot; title=&quot;接口是什么&quot;&gt;&lt;/a&gt;接口是什么&lt;/h1&gt;&lt;p&gt;接口就是一个抽象类型，与之对应的就是具体类型，同时接口也是抽象方法接口。&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; human &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	walk()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	run()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	eat()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的代码定义了接口，接口里定义了几个抽象方法，一般其他语言例如Java，都会定义一个具体的类型来实现这个接口，像这样&lt;code&gt;class man implements human&lt;/code&gt; 声明&lt;code&gt;man&lt;/code&gt;实现了&lt;code&gt;human&lt;/code&gt;。但是go上使用了一种&lt;code&gt;duck typing&lt;/code&gt;来定义具体类型。&lt;br&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>使用scroll实现Elasticsearch数据遍历和深度分页</title>
    <link href="http://idiotsky.me/2018/01/11/elasticsearch-scroll/"/>
    <id>http://idiotsky.me/2018/01/11/elasticsearch-scroll/</id>
    <published>2018-01-11T02:09:18.000Z</published>
    <updated>2018-01-11T12:40:46.639Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>之前面试被问到深分页的问题，现在mark一下吧</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Elasticsearch 是一个实时的分布式搜索与分析引擎，被广泛用来做全文搜索、结构化搜索、分析。在使用过程中，有一些典型的使用场景，比如分页、遍历等。在使用关系型数据库中，我们被告知要注意甚至被明确禁止使用深度分页，同理，在 Elasticsearch 中，也应该尽量避免使用深度分页。这篇文章主要介绍 Elasticsearch 中使用分页的方式、Elasticsearch 搜索执行过程以及为什么深度分页应该被禁止，最后再介绍使用 scroll 的方式遍历数据。</p>
<h1 id="Elasticsearch-搜索内部执行原理"><a href="#Elasticsearch-搜索内部执行原理" class="headerlink" title="Elasticsearch 搜索内部执行原理"></a>Elasticsearch 搜索内部执行原理</h1><p>一个最基本的 Elasticsearch 查询语句是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST /my_index/my_type/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,</div><div class="line">    &quot;from&quot;: 100,</div><div class="line">    &quot;size&quot;:  10</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的查询表示从搜索结果中取第100条开始的10条数据。下面讲解搜索过程时也以这个请求为例。</p>
<p>那么，这个查询语句在 Elasticsearch 集群内部是怎么执行的呢？为了方便描述，我们假设该 index 只有primary shards，没有 replica shards。</p>
<p>在 Elasticsearch 中，搜索一般包括两个阶段，query 和 fetch 阶段，可以简单的理解，query 阶段确定要取哪些doc，fetch 阶段取出具体的 doc。<br><a id="more"></a></p>
<h2 id="Query-阶段"><a href="#Query-阶段" class="headerlink" title="Query 阶段"></a>Query 阶段</h2><p><a href="http://idiotsky.me/images2/es-scroll-1.jpg"><img src="http://idiotsky.me/images2/es-scroll-1.jpg" alt=""></a></p>
<p>如上图所示，描述了一次搜索请求的 query 阶段。</p>
<ol>
<li>Client 发送一次搜索请求，node1 接收到请求，然后，node1 创建一个大小为 from + size 的优先级队列用来存结果，我们管 node1 叫 coordinating node。</li>
<li>coordinating node将请求广播到涉及到的 shards，每个 shard 在内部执行搜索请求，然后，将结果存到内部的大小同样为 from + size 的优先级队列里，可以把优先级队列理解为一个包含 top N 结果的列表。</li>
<li>每个 shard 把暂存在自身优先级队列里的数据返回给 coordinating node，coordinating node 拿到各个 shards 返回的结果后对结果进行一次合并，产生一个全局的优先级队列，存到自身的优先级队列里。</li>
</ol>
<p>在上面的例子中，coordinating node 拿到 (from + size) * 6 条数据，然后合并并排序后选择前面的 from + size 条数据存到优先级队列，以便 fetch 阶段使用。另外，各个分片返回给 coordinating node 的数据用于选出前 from + size 条数据，所以，只需要返回唯一标记 doc 的 _id 以及用于排序的 _score 即可，这样也可以保证返回的数据量足够小。</p>
<p>coordinating node 计算好自己的优先级队列后，query 阶段结束，进入 fetch 阶段。</p>
<h2 id="Fetch-阶段"><a href="#Fetch-阶段" class="headerlink" title="Fetch 阶段"></a>Fetch 阶段</h2><p>query 阶段知道了要取哪些数据，但是并没有取具体的数据，这就是 fetch 阶段要做的。<br><a href="http://idiotsky.me/images2/es-scroll-2.jpg"><img src="http://idiotsky.me/images2/es-scroll-2.jpg" alt=""></a></p>
<p>上图展示了 fetch 过程：</p>
<ol>
<li>coordinating node 发送 GET 请求到相关shards。</li>
<li>shard 根据 doc 的 _id 取到数据详情，然后返回给 coordinating node。</li>
<li>coordinating node 返回数据给 Client。</li>
</ol>
<p>coordinating node 的优先级队列里有 from + size 个 _doc _id，但是，在 fetch 阶段，并不需要取回所有数据，在上面的例子中，前100条数据是不需要取的，只需要取优先级队列里的第101到110条数据即可。</p>
<p>需要取的数据可能在不同分片，也可能在同一分片，coordinating node 使用 multi-get 来避免多次去同一分片取数据，从而提高性能。</p>
<h1 id="深度分页的问题"><a href="#深度分页的问题" class="headerlink" title="深度分页的问题"></a>深度分页的问题</h1><p>Elasticsearch 的这种方式提供了分页的功能，同时，也有相应的限制。举个例子，一个索引，有10亿数据，分10个 shards，然后，一个搜索请求，from=1,000,000，size=100，这时候，会带来严重的性能问题：</p>
<ul>
<li>CPU</li>
<li>内存</li>
<li>IO</li>
<li>网络带宽</li>
</ul>
<p>CPU、内存和IO消耗容易理解，网络带宽问题稍难理解一点。在 query 阶段，每个shards需要返回 1,000,100 条数据给 coordinating node，而 coordinating node 需要接收 10 * 1,000,100 条数据，即使每条数据只有 _doc _id 和 _score，这数据量也很大了，而且，这才一个查询请求，那如果再乘以100呢？</p>
<p>在另一方面，我们意识到，这种深度分页的请求并不合理，因为我们是很少人为的看很后面的请求的，在很多的业务场景中，都直接限制分页，比如只能看前100页。</p>
<p>不过，这种深度分页确实存在，比如，被爬虫了，这个时候，直接干掉深度分页就好；又或者，业务上有遍历数据的需要，比如，有1千万粉丝的微信大V，要给所有粉丝群发消息，或者给某省粉丝群发，这时候就需要取得所有符合条件的粉丝，而最容易想到的就是利用 from + size 来实现，不过，这个是不现实的，这时，可以采用 Elasticsearch 提供的 scroll 方式来实现遍历。</p>
<h1 id="利用-scroll-遍历数据"><a href="#利用-scroll-遍历数据" class="headerlink" title="利用 scroll 遍历数据"></a>利用 scroll 遍历数据</h1><p>可以把 scroll 理解为关系型数据库里的 cursor，因此，scroll 并不适合用来做实时搜索，而更适用于后台批处理任务，比如群发。</p>
<p>可以把 scroll 分为初始化和遍历两步，初始化时将所有符合搜索条件的搜索结果缓存起来，可以想象成快照，在遍历时，从这个快照里取数据，也就是说，在初始化后对索引插入、删除、更新数据都不会影响遍历结果。</p>
<h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><p>下面介绍下scroll的使用，可以通过 Elasticsearch 的 HTTP 接口做试验下，包括初始化和遍历两个部分。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">POST ip:port/my_index/my_type/_search?scroll=1m</div><div class="line">&#123;</div><div class="line">	&quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化时需要像普通 search 一样，指明 index 和 type (当然，search 是可以不指明 index 和 type 的)，然后，加上参数 scroll，表示暂存搜索结果的时间，其它就像一个普通的search请求一样。</p>
<p>初始化返回一个 _scroll_id，_scroll_id 用来下次取数据用。</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">POST /_search?scroll=1m</div><div class="line">&#123;</div><div class="line">    &quot;scroll_id&quot;:&quot;XXXXXXXXXXXXXXXXXXXXXXX I am scroll id XXXXXXXXXXXXXXX&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 scroll_id 即 上一次遍历取回的 _scroll_id 或者是初始化返回的 _scroll_id，同样的，需要带 scroll 参数。 重复这一步骤，直到返回的数据为空，即遍历完成。注意，每次都要传参数 scroll，刷新搜索结果的缓存时间。另外，不需要指定 index 和 type。</p>
<p>设置scroll的时候，需要使搜索结果缓存到下一次遍历完成，同时，也不能太长，毕竟空间有限。</p>
<h2 id="Scroll-Scan"><a href="#Scroll-Scan" class="headerlink" title="Scroll-Scan"></a>Scroll-Scan</h2><p>Elasticsearch 提供了 Scroll-Scan 方式进一步提高遍历性能。还是上面的例子，微信大V要给粉丝群发这种后台任务，是不需要关注顺序的，只要能遍历所有数据即可，这时候，就可以用Scroll-Scan。</p>
<p>Scroll-Scan 的遍历与普通 Scroll 一样，初始化存在一点差别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">POST ip:port/my_index/my_type/_search?search_type=scan&amp;scroll=1m&amp;size=50</div><div class="line">&#123;</div><div class="line">	&quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要指明参数：</p>
<ul>
<li>search_type。赋值为scan，表示采用 Scroll-Scan 的方式遍历，同时告诉 Elasticsearch 搜索结果不需要排序。</li>
<li>scroll。同上，传时间。</li>
<li>size。与普通的 size 不同，这个 size 表示的是每个 shard 返回的 size 数，最终结果最大为 number_of_shards * size。</li>
</ul>
<p>Scroll-Scan 方式与普通 scroll 有几点不同：</p>
<ol>
<li>Scroll-Scan 结果没有排序，按 index 顺序返回，没有排序，可以提高取数据性能。</li>
<li>初始化时只返回 _scroll_id，没有具体的 hits 结果。</li>
<li>size 控制的是每个分片的返回的数据量而不是整个请求返回的数据量。</li>
</ol>
<h2 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h2><p>用 Java 举个例子。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    response = esClient.prepareSearch(index)</div><div class="line">            .setTypes(type)</div><div class="line">            .setSearchType(SearchType.SCAN)</div><div class="line">            .setQuery(query)</div><div class="line">            .setScroll(<span class="keyword">new</span> TimeValue(timeout))</div><div class="line">            .setSize(size)</div><div class="line">            .execute()</div><div class="line">            .actionGet();</div><div class="line">&#125; <span class="keyword">catch</span> (ElasticsearchException e) &#123;</div><div class="line">    <span class="comment">// handle Exception</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化返回 _scroll_id，然后，用 _scroll_id 去遍历，注意，上面的query是一个JSONObject，不过这里很多种实现方式，我这儿只是个例子。</p>
<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    response = esClient.prepareSearchScroll(scrollId)</div><div class="line">            .setScroll(<span class="keyword">new</span> TimeValue(timeout))</div><div class="line">            .execute()</div><div class="line">            .actionGet();</div><div class="line">&#125; <span class="keyword">catch</span> (ElasticsearchException e) &#123;</div><div class="line">    <span class="comment">// handle Exception</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>深度分页不管是关系型数据库还是Elasticsearch还是其他搜索引擎，都会带来巨大性能开销，特别是在分布式情况下。</li>
<li>有些问题可以考业务解决而不是靠技术解决，比如很多业务都对页码有限制，google 搜索，往后翻到一定页码就不行了。</li>
<li>Elasticsearch 提供的 Scroll 接口专门用来获取大量数据甚至全部数据，在顺序无关情况下，首推Scroll-Scan。</li>
<li>描述搜索过程时，为了简化描述，假设 index 没有备份，实际上，index 肯定会有备份，这时候，就涉及到选择 shard。</li>
</ol>
<p>from <a href="http://lxwei.github.io/posts/%E4%BD%BF%E7%94%A8scroll%E5%AE%9E%E7%8E%B0Elasticsearch%E6%95%B0%E6%8D%AE%E9%81%8D%E5%8E%86%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5.html" target="_blank" rel="external">http://lxwei.github.io/posts/%E4%BD%BF%E7%94%A8scroll%E5%AE%9E%E7%8E%B0Elasticsearch%E6%95%B0%E6%8D%AE%E9%81%8D%E5%8E%86%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前面试被问到深分页的问题，现在mark一下吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Elasticsearch 是一个实时的分布式搜索与分析引擎，被广泛用来做全文搜索、结构化搜索、分析。在使用过程中，有一些典型的使用场景，比如分页、遍历等。在使用关系型数据库中，我们被告知要注意甚至被明确禁止使用深度分页，同理，在 Elasticsearch 中，也应该尽量避免使用深度分页。这篇文章主要介绍 Elasticsearch 中使用分页的方式、Elasticsearch 搜索执行过程以及为什么深度分页应该被禁止，最后再介绍使用 scroll 的方式遍历数据。&lt;/p&gt;
&lt;h1 id=&quot;Elasticsearch-搜索内部执行原理&quot;&gt;&lt;a href=&quot;#Elasticsearch-搜索内部执行原理&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch 搜索内部执行原理&quot;&gt;&lt;/a&gt;Elasticsearch 搜索内部执行原理&lt;/h1&gt;&lt;p&gt;一个最基本的 Elasticsearch 查询语句是这样的：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;POST /my_index/my_type/_search&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;quot;query&amp;quot;: &amp;#123; &amp;quot;match_all&amp;quot;: &amp;#123;&amp;#125;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;quot;from&amp;quot;: 100,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;quot;size&amp;quot;:  10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的查询表示从搜索结果中取第100条开始的10条数据。下面讲解搜索过程时也以这个请求为例。&lt;/p&gt;
&lt;p&gt;那么，这个查询语句在 Elasticsearch 集群内部是怎么执行的呢？为了方便描述，我们假设该 index 只有primary shards，没有 replica shards。&lt;/p&gt;
&lt;p&gt;在 Elasticsearch 中，搜索一般包括两个阶段，query 和 fetch 阶段，可以简单的理解，query 阶段确定要取哪些doc，fetch 阶段取出具体的 doc。&lt;br&gt;
    
    </summary>
    
      <category term="elasticsearch" scheme="http://idiotsky.me/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="http://idiotsky.me/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>用go小试websocket</title>
    <link href="http://idiotsky.me/2018/01/10/go-websocket/"/>
    <id>http://idiotsky.me/2018/01/10/go-websocket/</id>
    <published>2018-01-10T07:44:21.000Z</published>
    <updated>2018-01-10T14:02:38.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是websocket"><a href="#什么是websocket" class="headerlink" title="什么是websocket"></a>什么是websocket</h1><p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？<br>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p>
<p>举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。<br>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p>
<p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p>
<p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href="https://en.wikipedia.org/wiki/Push_technology" target="_blank" rel="external">服务器推送</a>技术的一种。<br><a href="http://idiotsky.me/images2/go-websocket-1.png"><img src="http://idiotsky.me/images2/go-websocket-1.png" alt=""></a></p>
<a id="more"></a>
<p>其他特点包括：</p>
<ol>
<li>建立在 TCP 协议之上，服务器端的实现比较容易。</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
<li>数据格式比较轻量，性能开销小，通信高效。</li>
<li>可以发送文本，也可以发送二进制数据。</li>
<li>没有同源限制，客户端可以与任意服务器通信。</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ws://example.com:80/some/path</div></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="http://idiotsky.me/images2/go-websocket-2.jpg"><img src="http://idiotsky.me/images2/go-websocket-2.jpg" alt=""></a></p>
<h1 id="小试"><a href="#小试" class="headerlink" title="小试"></a>小试</h1><p>用一个echo的例子来试一下websocket</p>
<h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="keyword">var</span> ws;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            ws= <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8080/echo"</span>);</div><div class="line">            ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></div><div class="line">            &#123;</div><div class="line">                alert(<span class="string">"connection is successful"</span>);</div><div class="line">            &#125;;</div><div class="line">            ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">var</span> msg = e.data;</div><div class="line">                <span class="keyword">var</span> li=<span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">                li.innerText=msg;</div><div class="line">                <span class="built_in">document</span>.getElementsByTagName(<span class="string">"ul"</span>)[<span class="number">0</span>].appendChild(li);</div><div class="line">            &#125;;</div><div class="line">            ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></div><div class="line">            &#123;</div><div class="line">                <span class="comment">// websocket is closed.</span></div><div class="line">                alert(<span class="string">"Connection is closed..."</span>);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(ws)&#123;</div><div class="line">                <span class="keyword">var</span> msg=<span class="built_in">document</span>.getElementById(<span class="string">"txt"</span>).value;</div><div class="line">                ws.send(msg);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            alert(<span class="string">"connect first!!!"</span>);</div><div class="line">        &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:connect()"</span>&gt;</span>connect<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"txt"</span> <span class="attr">style</span>=<span class="string">"width: 100%"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"sendBtn"</span> <span class="attr">onclick</span>=<span class="string">"send()"</span>&gt;</span>send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>代码很简单，就是用<code>new WebSocket(&quot;ws://localhost:8080/echo&quot;)</code>初始化websocket，然后注册相关事件，就可以完成一个简单websocket客户端了。</p>
<h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>go的标准库没有实现websocket的功能，所以要用<code>github.com/gorilla/websocket</code>这个库来实现服务端<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"net/http"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/gorilla/websocket"</span></div><div class="line"></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> upgrader = websocket.Upgrader&#123;</div><div class="line">	ReadBufferSize:  <span class="number">1024</span>,</div><div class="line">	WriteBufferSize: <span class="number">1024</span>,</div><div class="line">	CheckOrigin: <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span> <span class="title">bool</span></span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span></div><div class="line">	&#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	static := http.FileServer(http.Dir(<span class="string">"./static"</span>))</div><div class="line">	http.Handle(<span class="string">"/"</span>, static)</div><div class="line"></div><div class="line">	http.HandleFunc(<span class="string">"/echo"</span>, echo)</div><div class="line"></div><div class="line">	log.Printf(<span class="string">"Service started on %d \n"</span>, <span class="number">8080</span>)</div><div class="line">	log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</div><div class="line">	conn, err := upgrader.Upgrade(w, r, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Println(<span class="string">"upgrade error:"</span>, err.Error())</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	log.Println(<span class="string">"Connected..."</span>)</div><div class="line">	<span class="keyword">defer</span> conn.Close()</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		messageType, p, err := conn.ReadMessage()</div><div class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">			log.Println(<span class="string">"read message error:"</span>, err.Error())</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> err := conn.WriteMessage(messageType, p); err != <span class="literal">nil</span> &#123;</div><div class="line">			log.Println(<span class="string">"write message error:"</span>, err.Error())</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	log.Println(<span class="string">"Disconnect."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先创建一个http服务，然后把上面的html作为静态资源，同时定义一个<code>echo</code>的处理函数。函数里面对请求进行<code>upgrade</code>，表示从普通的请求变成websocket（前提是请求头里面要包含<code>upgrade</code>标记），之后就获取了connection，接下来就跟平常tcp的连接那样读写数据了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>用go实现的websocket简直是简单到爆了，基本第三方库已经封装好了👿</p>
<p>所有代码在 <a href="https://github.com/ejunjsh/go-code/tree/master/websocket" target="_blank" rel="external">https://github.com/ejunjsh/go-code/tree/master/websocket</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是websocket&quot;&gt;&lt;a href=&quot;#什么是websocket&quot; class=&quot;headerlink&quot; title=&quot;什么是websocket&quot;&gt;&lt;/a&gt;什么是websocket&lt;/h1&gt;&lt;p&gt;初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？&lt;br&gt;答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。&lt;/p&gt;
&lt;p&gt;举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。&lt;br&gt;这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。&lt;/p&gt;
&lt;p&gt;轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。&lt;/p&gt;
&lt;p&gt;WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。&lt;/p&gt;
&lt;p&gt;它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于&lt;a href=&quot;https://en.wikipedia.org/wiki/Push_technology&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;服务器推送&lt;/a&gt;技术的一种。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images2/go-websocket-1.png&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images2/go-websocket-1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
      <category term="websocket" scheme="http://idiotsky.me/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>go基础-nil</title>
    <link href="http://idiotsky.me/2018/01/03/go-nil/"/>
    <id>http://idiotsky.me/2018/01/03/go-nil/</id>
    <published>2018-01-03T15:48:13.000Z</published>
    <updated>2018-01-06T06:43:45.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nil是什么"><a href="#nil是什么" class="headerlink" title="nil是什么"></a>nil是什么</h1><blockquote>
<p>The “nil” identifier can be used as the “zero value” for interfaces, functions, pointers, maps, slices, and channels</p>
</blockquote>
<p>这是对nil的官方解释，意思就是说nil是接口，函数，指针，map，slice和管道的零值。零值，zero value，在Go语言中，如果你声明了一个变量但是没有对它进行赋值操作，那么这个变量就会有一个类型的默认零值。这是每种类型对应的零值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span>      -&gt; <span class="literal">false</span>                              </div><div class="line">numbers -&gt; <span class="number">0</span>                                 </div><div class="line"><span class="keyword">string</span>    -&gt; <span class="string">""</span>      </div><div class="line"></div><div class="line">pointers -&gt; <span class="literal">nil</span></div><div class="line">slices -&gt; <span class="literal">nil</span></div><div class="line">maps -&gt; <span class="literal">nil</span></div><div class="line">channels -&gt; <span class="literal">nil</span></div><div class="line">functions -&gt; <span class="literal">nil</span></div><div class="line">interfaces -&gt; <span class="literal">nil</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>举个例子，当你定义了一个struct：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</div><div class="line">  AgeYears <span class="keyword">int</span></div><div class="line">  Name <span class="keyword">string</span></div><div class="line">  Friends []Person</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p Person <span class="comment">// Person&#123;0, "", nil&#125;</span></div></pre></td></tr></table></figure></p>
<p>上面官方解释还有一句<code>The &quot;nil&quot; identifier</code>,意思就是说nil是一个标识符（变量），连go的关键字都不算，是一个预定义的变量而已，你甚至可以改变它<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="literal">nil</span> = errors.New(<span class="string">"hi"</span>)</div></pre></td></tr></table></figure></p>
<p>这样是完全可以编译得过的，但是最好不要这样子去做。</p>
<h1 id="nil有什么用"><a href="#nil有什么用" class="headerlink" title="nil有什么用"></a>nil有什么用</h1><p>在了解了什么是nil之后，再来说说nil有什么用。</p>
<h2 id="pointers"><a href="#pointers" class="headerlink" title="pointers"></a>pointers</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></div><div class="line">p == <span class="literal">nil</span>    <span class="comment">// true</span></div><div class="line">*p          <span class="comment">// panic: invalid memory address or nil pointer dereference</span></div></pre></td></tr></table></figure>
<p>指针表示指向内存的地址，如果对为nil的指针进行解引用的话就会导致panic。那么为nil的指针有什么用呢？先来看一个计算二叉树和的例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</div><div class="line">  v <span class="keyword">int</span></div><div class="line">  l *tree</div><div class="line">  r *tree</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// first solution</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">  sum := t.v</div><div class="line">  <span class="keyword">if</span> t.l != <span class="literal">nil</span> &#123;</div><div class="line">    sum += t.l.Sum()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> t.r != <span class="literal">nil</span> &#123;</div><div class="line">    sum += t.r.Sum()</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sum</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码有两个问题，一个是代码重复：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> t.l != <span class="literal">nil</span> &#123;</div><div class="line">  <span class="comment">//....</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> t.r != <span class="literal">nil</span> &#123;</div><div class="line">  <span class="comment">//....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一个是当t是nil的时候会panic：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t *tree</div><div class="line">sum := t.Sum()   <span class="comment">// panic: invalid memory address or nil pointer dereference</span></div></pre></td></tr></table></figure></p>
<p>怎么解决上面的问题？我们先来看看一个指针接收器的例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">(p *person)</span></span> &#123; fmt.Println(<span class="string">"hi"</span>) &#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">sayHi</span><span class="params">()</span></span> &#123; fmt.Println(<span class="string">"hi"</span>) &#125;</div><div class="line"><span class="keyword">var</span> p *person</div><div class="line">p.sayHi() <span class="comment">// hi</span></div></pre></td></tr></table></figure></p>
<p>这里就有点疑问，为什么<code>t.sum()</code>会报错，而<code>p.sayHi()</code>不报错，其实是因为<code>t.sum()</code>函数里面<code>sum := t.v</code>这句，其实它相当于<code>sum := (*t).v</code>,所以，对于指针对象的方法来说，就算指针的值为nil也是可以调用它们的方法,至于方法执行过程会不会报错就要做处理了，基于此，我们可以对刚刚计算二叉树和的例子进行一下改造：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(t *tree)</span> <span class="title">Sum</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> t.v + t.l.Sum() + t.r.Sum()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>跟刚才的代码一对比是不是简洁了很多？对于nil指针，只需要在方法前面判断一下就ok了，无需重复判断。换成打印二叉树的值或者查找二叉树的某个值都是一样的：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(t *tree)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> fmt.Sprint(t.l, t.v, t.r)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// nil receivers are useful: Find</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *tree)</span> <span class="title">Find</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">  <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> t.v == v || t.l.Find(v) || t.r.Find(v)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以如果不是很需要的话，不要用NewX()去初始化值，而是使用它们的默认值。</p>
<h2 id="slices"><a href="#slices" class="headerlink" title="slices"></a>slices</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// nil slices</span></div><div class="line"><span class="keyword">var</span> s []slice</div><div class="line"><span class="built_in">len</span>(s)  <span class="comment">// 0</span></div><div class="line"><span class="built_in">cap</span>(s)  <span class="comment">// 0</span></div><div class="line"><span class="keyword">for</span> <span class="keyword">range</span> s  <span class="comment">// iterates zero times</span></div><div class="line">s[i]  <span class="comment">// panic: index out of range</span></div></pre></td></tr></table></figure>
<p>一个为nil的slice，除了不能索引外，其他的操作都是可以的，当你需要填充值的时候可以使用append函数，slice会自动进行扩充。那么为nil的slice的底层结构是怎样的呢？根据官方的文档，slice有三个元素，分别是长度、容量、指向数组的指针：<br><a href="http://idiotsky.me/images2/go-nil.png"><img src="http://idiotsky.me/images2/go-nil.png" alt=""></a></p>
<p>当有元素的时候：<br><a href="http://idiotsky.me/images2/go-nil-1.png"><img src="http://idiotsky.me/images2/go-nil-1.png" alt=""></a></p>
<p>所以我们并不需要担心slice的大小，使用append的话slice会自动扩容。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// nil maps</span></div><div class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[t]u</div><div class="line"><span class="built_in">len</span>(m)  <span class="comment">// 0</span></div><div class="line"><span class="keyword">for</span> <span class="keyword">range</span> m <span class="comment">// iterates zero times</span></div><div class="line">v, ok := m[i] <span class="comment">// zero(u), false</span></div><div class="line">m[i] = x <span class="comment">// panic: assignment to entry in nil map</span></div></pre></td></tr></table></figure>
<p>对于nil的map，我们可以简单把它看成是一个只读的map，不能进行写操作，否则就会panic。那么nil的map有什么用呢？看一下这个例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGet</span><span class="params">(url <span class="keyword">string</span>, headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="params">(*http.Request, error)</span></span> &#123;</div><div class="line">  req, err := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</div><div class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> headers &#123;</div><div class="line">    req.Header.Set(k, v)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> req, <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于NewGet来说，我们需要传入一个类型为map的参数，并且这个函数只是对这个参数进行读取，我们可以传入一个非空的值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NewGet(<span class="string">"http://google.com"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</div><div class="line">  <span class="string">"USER_AGENT"</span>: <span class="string">"golang/gopher"</span>,</div><div class="line">&#125;,)</div></pre></td></tr></table></figure></p>
<p>或者这样传：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NewGet(<span class="string">"http://google.com"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;)</div></pre></td></tr></table></figure></p>
<p>但是前面也说了，map的零值是nil，所以当header为空的时候，我们也可以直接传入一个nil：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NewGet(<span class="string">"http://google.com"</span>, <span class="literal">nil</span>)</div></pre></td></tr></table></figure></p>
<p>是不是简洁很多？所以，把nil map作为一个只读的空的map进行读取吧。</p>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// nil channels</span></div><div class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> t</div><div class="line">&lt;- c      <span class="comment">// blocks forever</span></div><div class="line">c &lt;- x    <span class="comment">// blocks forever</span></div><div class="line"><span class="built_in">close</span>(c)  <span class="comment">// panic: close of nil channel</span></div></pre></td></tr></table></figure>
<p>举个例子，假如现在有两个channel负责输入，一个channel负责汇总，简单的实现代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> &#123;</div><div class="line">    <span class="keyword">select</span> &#123;</div><div class="line">      <span class="keyword">case</span> v := &lt;-a:</div><div class="line">        out &lt;- v</div><div class="line">      <span class="keyword">case</span> v := &lt;- b:</div><div class="line">        out &lt;- v</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果在外部调用中关闭了a或者b，那么就会不断地从a或者b中读出0，这和我们想要的不一样，我们想关闭a和b后就停止汇总了，修改一下代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">  <span class="keyword">for</span> a != <span class="literal">nil</span> || b != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="keyword">select</span> &#123;</div><div class="line">      <span class="keyword">case</span> v, ok := &lt;-a:</div><div class="line">          <span class="keyword">if</span> !ok &#123;</div><div class="line">            a = <span class="literal">nil</span></div><div class="line">            fmt.Println(<span class="string">"a is nil"</span>)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">          &#125;</div><div class="line">          out &lt;- v</div><div class="line">      <span class="keyword">case</span> v, ok := &lt;-b:</div><div class="line">          <span class="keyword">if</span> !ok &#123;</div><div class="line">            b = <span class="literal">nil</span></div><div class="line">            fmt.Println(<span class="string">"b is nil"</span>)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">          &#125;</div><div class="line">          out &lt;- v</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  fmt.Println(<span class="string">"close out"</span>)</div><div class="line">  <span class="built_in">close</span>(out)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在知道channel关闭后，将channel的值设为nil，这样子就相当于将这个select case子句停用了，因为nil的channel是永远阻塞的。</p>
<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>interface并不是一个指针，它的底层实现由两部分组成，一个是类型，一个值，也就是类似于：(Type, Value)。只有当类型和值都是nil的时候，才等于nil。看看下面的代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> doError <span class="keyword">struct</span> &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *doError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">""</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> <span class="title">error</span></span> &#123;   <span class="comment">// error(*doError, nil)</span></div><div class="line">	<span class="keyword">var</span> err *doError</div><div class="line">	<span class="keyword">return</span> err  <span class="comment">// nil of type *doError</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	err := do()</div><div class="line">	fmt.Println(err == <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果是false。do函数声明了一个*doErro的变量err，然后返回，返回值是error接口，但是这个时候的Type已经变成了：（*doError，nil），所以和nil肯定是不会相等的。所以我们在写函数的时候，不要声明具体的error变量，而是应该直接返回nil：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再来看看这个例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> *<span class="title">doError</span></span> &#123;  <span class="comment">// nil of type *doError</span></div><div class="line">  <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">wrapDo</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="comment">// error (*doError, nil)</span></div><div class="line">  <span class="keyword">return</span> do()       <span class="comment">// nil of type *doError</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">  err := wrapDo()   <span class="comment">// error  (*doError, nil)</span></div><div class="line">  fmt.Println(err == <span class="literal">nil</span>) <span class="comment">// false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里最终的输出结果也是false。为什么呢？尽管wrapDo函数返回的是error类型，但是do返回的却是*doError类型，也就是变成了（*doError，nil），自然也就和nil不相等了。因此，不要返回具体的错误类型。遵从这两条建议，才可以放心地使用<code>if x != nil</code>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>nil指针可以执行方法，nil的map和slice只是可读，nil的chan可以用来做为select的停止标记，而nil的interface可能就是个坑👿</p>
<p>参考 <a href="https://www.jianshu.com/p/dd80f6be7969" target="_blank" rel="external">https://www.jianshu.com/p/dd80f6be7969</a><br>部分代码 <a href="https://github.com/ejunjsh/go-code/tree/master/nil" target="_blank" rel="external">https://github.com/ejunjsh/go-code/tree/master/nil</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;nil是什么&quot;&gt;&lt;a href=&quot;#nil是什么&quot; class=&quot;headerlink&quot; title=&quot;nil是什么&quot;&gt;&lt;/a&gt;nil是什么&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;The “nil” identifier can be used as the “zero value” for interfaces, functions, pointers, maps, slices, and channels&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是对nil的官方解释，意思就是说nil是接口，函数，指针，map，slice和管道的零值。零值，zero value，在Go语言中，如果你声明了一个变量但是没有对它进行赋值操作，那么这个变量就会有一个类型的默认零值。这是每种类型对应的零值：&lt;br&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;      -&amp;gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;                              &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;numbers -&amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;                                 &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;    -&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;      &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;pointers -&amp;gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;slices -&amp;gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;maps -&amp;gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;channels -&amp;gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;functions -&amp;gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;interfaces -&amp;gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://idiotsky.me/categories/go/"/>
    
    
      <category term="go" scheme="http://idiotsky.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>linux命令-gdb</title>
    <link href="http://idiotsky.me/2017/12/28/linux-gdb/"/>
    <id>http://idiotsky.me/2017/12/28/linux-gdb/</id>
    <published>2017-12-28T03:31:23.000Z</published>
    <updated>2018-03-27T14:44:05.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>备忘，mark 👿</p>
</blockquote>
<h1 id="GDB-基础知识"><a href="#GDB-基础知识" class="headerlink" title="GDB 基础知识"></a>GDB 基础知识</h1><h2 id="GDB-相关概念"><a href="#GDB-相关概念" class="headerlink" title="GDB 相关概念"></a>GDB 相关概念</h2><p>GDB, 是 The GNU Project Debugger 的缩写, 是 Linux 下功能全面的调试工具。GDB 支持断点、单步执行、打印变量、观察变量、查看寄存器、查看堆栈等调试手段。在 Linux 环境软件开发中，GDB 是主要的调试工具，用来调试 C 和 C++ 程序。</p>
<h2 id="GDB-的进入和退出"><a href="#GDB-的进入和退出" class="headerlink" title="GDB 的进入和退出"></a>GDB 的进入和退出</h2><p>如果要调试程序，需要在 gcc 编译可执行程序时加上 -g 参数，首先我们编译 bugging.c 程序，生成可执行文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -g -o bugging bugging.c</div></pre></td></tr></table></figure></p>
<p>输入 gdb bugging 进入 gdb 调试 bugging 程序的界面：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gdb bugging</div></pre></td></tr></table></figure></p>
<p>在 gdb 命令行界面，输入run 执行待调试程序：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) run</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在 gdb 命令行界面，输入quit 退出 gdb：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) quit</div></pre></td></tr></table></figure></p>
<p>上述步骤的输出<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">sky@ubuntu:~/gdbtest$ gcc -g -o bugging bugging.c</div><div class="line">sky@ubuntu:~/gdbtest$ gdb bugging</div><div class="line">GNU gdb (Ubuntu 8.0.1-0ubuntu1) 8.0.1</div><div class="line">Copyright (C) 2017 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type "show copying"</div><div class="line">and "show warranty" for details.</div><div class="line">This GDB was configured as "x86_64-linux-gnu".</div><div class="line">Type "show configuration" for configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For help, type "help".</div><div class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</div><div class="line">Type "apropos word" to search for commands related to "word"...</div><div class="line">Reading symbols from bugging...done.</div><div class="line">(gdb) run</div><div class="line">Starting program: /home/sky/gdbtest/bugging</div><div class="line">1+2+3+...+100= 1431657159</div><div class="line">[Inferior 1 (process 27193) exited normally]</div><div class="line">(gdb) q</div><div class="line">sky@ubuntu:~/gdbtest$</div></pre></td></tr></table></figure></p>
<h2 id="GDB-命令行界面使用技巧"><a href="#GDB-命令行界面使用技巧" class="headerlink" title="GDB 命令行界面使用技巧"></a>GDB 命令行界面使用技巧</h2><h3 id="命令补全"><a href="#命令补全" class="headerlink" title="命令补全"></a>命令补全</h3><p>任何时候都可以使用<code>TAB</code>进行补全，如果只有一个待选选项则直接补全；否则会列出可选选项，继续键入命令，同时结合<code>TAB</code>即可快速输入命令。</p>
<h3 id="部分-gdb-常用命令一览表"><a href="#部分-gdb-常用命令一览表" class="headerlink" title="部分 gdb 常用命令一览表"></a>部分 gdb 常用命令一览表</h3><table>
<thead>
<tr>
<th>命令</th>
<th>简写形式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td>l</td>
<td>查看源码</td>
</tr>
<tr>
<td>backtrace</td>
<td>bt、where</td>
<td>打印函数栈信息</td>
</tr>
<tr>
<td>next</td>
<td>n</td>
<td>执行下一行</td>
</tr>
<tr>
<td>step</td>
<td>s</td>
<td>一次执行一行，遇到函数会进入</td>
</tr>
<tr>
<td>finish</td>
<td></td>
<td>运行到函数结束</td>
</tr>
<tr>
<td>continue</td>
<td>c</td>
<td>继续运行</td>
</tr>
<tr>
<td>break</td>
<td>b</td>
<td>设置断点</td>
</tr>
<tr>
<td>info breakpoints</td>
<td></td>
<td>显示断点信息</td>
</tr>
<tr>
<td>delete</td>
<td>d</td>
<td>删除断点</td>
</tr>
<tr>
<td>print</td>
<td>p</td>
<td>打印表达式的值</td>
</tr>
<tr>
<td>run</td>
<td>r</td>
<td>启动程序</td>
</tr>
<tr>
<td>until</td>
<td>u</td>
<td>执行到指定行</td>
</tr>
<tr>
<td>info</td>
<td>i</td>
<td>显示信息</td>
</tr>
<tr>
<td>help</td>
<td>h</td>
<td>帮助信息</td>
</tr>
</tbody>
</table>
<h3 id="查询用法"><a href="#查询用法" class="headerlink" title="查询用法"></a>查询用法</h3><p>在 gdb 命令行界面，使用 <code>(gdb) help command</code> 可以查看命令的用法。</p>
<h3 id="执行-Shell-命令"><a href="#执行-Shell-命令" class="headerlink" title="执行 Shell 命令"></a>执行 Shell 命令</h3><p>在 gdb 命令行界面可以执行外部的 Shell 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) !shell 命令</div></pre></td></tr></table></figure></p>
<p>例如查看当前目录的文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(gdb) !ls</div><div class="line">bugging  bugging.c</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<h1 id="GDB-断点"><a href="#GDB-断点" class="headerlink" title="GDB 断点"></a>GDB 断点</h1><h2 id="重新进入-debugging-调试界面"><a href="#重新进入-debugging-调试界面" class="headerlink" title="重新进入 debugging 调试界面"></a>重新进入 debugging 调试界面</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gdb bugging</div></pre></td></tr></table></figure>
<h2 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h2><p>list 命令用来显示源文件中的代码。</p>
<h3 id="通过行号查看源码"><a href="#通过行号查看源码" class="headerlink" title="通过行号查看源码"></a>通过行号查看源码</h3><p>list 行号，显示某一行附近的代码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(gdb) list 2</div><div class="line">1       /* bugging.c */</div><div class="line">2</div><div class="line">3       #include &lt;stdio.h&gt;</div><div class="line">4</div><div class="line">5       int foo(int n)</div><div class="line">6       &#123;</div><div class="line">7</div><div class="line">8           int sum;</div><div class="line">9           int i;</div><div class="line">10</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>list 文件名 : 行号，显示某一个文件某一行附近的代码，用于多个源文件的情况。</p>
<h3 id="通过函数查看源码"><a href="#通过函数查看源码" class="headerlink" title="通过函数查看源码"></a>通过函数查看源码</h3><p>list 函数名，显示某个函数附近的代码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(gdb) list main</div><div class="line">15</div><div class="line">16          return sum;</div><div class="line">17      &#125;</div><div class="line">18</div><div class="line">19      int main(int argc, char** argv)</div><div class="line">20      &#123;</div><div class="line">21          int result = 0;</div><div class="line">22          int N = 100;</div><div class="line">23</div><div class="line">24          result = foo(N);</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>list 文件名 : 函数名，显示某一个文件某个函数附近的代码，用于多个源文件的情况。</p>
<h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><p>break 命令用来设置断点。</p>
<h3 id="通过行号设置断点"><a href="#通过行号设置断点" class="headerlink" title="通过行号设置断点"></a>通过行号设置断点</h3><p>break 行号，断点设置在该行开始处，<strong>注意：该行代码未被执行：</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(gdb) break 19</div><div class="line">Breakpoint 1 at 0x680: file bugging.c, line 19.</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>break 文件名 : 行号，适用于有多个源文件的情况。</p>
<h3 id="通过函数设置断点"><a href="#通过函数设置断点" class="headerlink" title="通过函数设置断点"></a>通过函数设置断点</h3><p>break 函数名，断点设置在该函数的开始处，<strong>断点所在行未被执行：</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(gdb) break foo</div><div class="line">Breakpoint 2 at 0x651: file bugging.c, line 11.</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>break 文件名 : 函数名，适用于有多个源文件的情况。</p>
<h2 id="查看断点信息"><a href="#查看断点信息" class="headerlink" title="查看断点信息"></a>查看断点信息</h2><p>info breakpoints 命令用于显示当前断点信息。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(gdb) info breakpoints</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     keep y   0x0000000000000680 in main at bugging.c:19</div><div class="line">2       breakpoint     keep y   0x0000000000000651 in foo at bugging.c:11</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>其中每一项的信息：</p>
<ul>
<li>Num 列代表断点编号，该编号可以作为 delete/enalbe/disable 等控制断点命令的参数</li>
<li>Type 列代表断点类型，一般为 breakpoint</li>
<li>Disp 列代表断点被命中后，该断点保留(keep)、删除(del)还是关闭(dis)</li>
<li>Enb 列代表该断点是 enable(y) 还是 disable(n)</li>
<li>Address 列代表该断点处虚拟内存的地址</li>
<li>What 列代表该断点在源文件中的信息</li>
</ul>
<h2 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h2><p>delete 命令用于删除断点。</p>
<h3 id="删除指定断点"><a href="#删除指定断点" class="headerlink" title="删除指定断点"></a>删除指定断点</h3><p>delete Num，删除指定断点，断点编号可通过 info breakpoints 获得：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(gdb) info breakpoints</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     keep y   0x0000000000000680 in main at bugging.c:19</div><div class="line">2       breakpoint     keep y   0x0000000000000651 in foo at bugging.c:11</div><div class="line">(gdb) delete 2</div><div class="line">(gdb) info breakpoints</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     keep y   0x0000000000000680 in main at bugging.c:19</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<h3 id="删除所有断点"><a href="#删除所有断点" class="headerlink" title="删除所有断点"></a>删除所有断点</h3><p>delete，不带任何参数，默认删除所有断点。</p>
<h2 id="关闭和启用断点"><a href="#关闭和启用断点" class="headerlink" title="关闭和启用断点"></a>关闭和启用断点</h2><p>disable 命令用于关闭断点，有些断点可能暂时不需要但又不想删除，便可以 disable 该断点。<br>enable 命令用于启用断点。</p>
<h3 id="关闭所有断点"><a href="#关闭所有断点" class="headerlink" title="关闭所有断点"></a>关闭所有断点</h3><p>disable，不带任何参数，默认关闭所有断点。</p>
<h3 id="关闭指定断点"><a href="#关闭指定断点" class="headerlink" title="关闭指定断点"></a>关闭指定断点</h3><p>disable Num，关闭指定断点，断点编号可通过 info breakpoints 获得：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(gdb) disable 1</div><div class="line">(gdb) info breakpoints</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     keep n   0x0000000000000680 in main at bugging.c:19</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<h3 id="启用所有断点"><a href="#启用所有断点" class="headerlink" title="启用所有断点"></a>启用所有断点</h3><p>enable，不带任何参数，默认启用所有断点。</p>
<h3 id="启用指定断点"><a href="#启用指定断点" class="headerlink" title="启用指定断点"></a>启用指定断点</h3><p>enable Num，启用指定断点，断点编号可通过 info breakpoints 获得。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(gdb) enable 1</div><div class="line">(gdb) info breakpoints</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     keep y   0x0000000000000680 in main at bugging.c:19</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>disable 和 enable 命令影响的是 info breakpoints 的 Enb 列，表示该断点是启用还是关闭</p>
<h2 id="断点启用的更多方式"><a href="#断点启用的更多方式" class="headerlink" title="断点启用的更多方式"></a>断点启用的更多方式</h2><p>enable 命令还可以用来设置断点被执行的次数，比如当断点设在循环中的时候，某断点可能多次被命中。</p>
<h3 id="断点-hit-一次之后关闭该断点"><a href="#断点-hit-一次之后关闭该断点" class="headerlink" title="断点 hit 一次之后关闭该断点"></a>断点 hit 一次之后关闭该断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enable once Num</div></pre></td></tr></table></figure>
<h3 id="断点-hit-一次之后删除该断点"><a href="#断点-hit-一次之后删除该断点" class="headerlink" title="断点 hit 一次之后删除该断点"></a>断点 hit 一次之后删除该断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enable delete Num</div></pre></td></tr></table></figure>
<p>实验中我们可以如下图测试该功能：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(gdb) info breakpoints</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     keep y   0x0000000000000680 in main at bugging.c:19</div><div class="line">3       breakpoint     keep y   0x0000000000000651 in foo at bugging.c:11</div><div class="line">(gdb) enable once 1</div><div class="line">(gdb) enable delete 3</div><div class="line">(gdb) info breakpoints</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     dis  y   0x0000000000000680 in main at bugging.c:19</div><div class="line">3       breakpoint     del  y   0x0000000000000651 in foo at bugging.c:11</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>这两个命令影响的是 info breakpoints 的 Disp 列，表示该断点被命中之后的行为</p>
<h2 id="断点小结"><a href="#断点小结" class="headerlink" title="断点小结"></a>断点小结</h2><p>断点是调试最基本的方法之一，这一节主要介绍了断点相关的知识。主要是几个断点相关的命令。</p>
<ul>
<li>list</li>
<li>info breakpoints</li>
<li>break</li>
<li>delete</li>
<li>disable 和 enable</li>
<li>enable once 和 enable delete</li>
</ul>
<p>不熟悉命令的时候，记得在 gdb 命令行下键入 help info breakpoints 等命令，查询帮助文档。</p>
<h1 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h1><p>如果已经设置断点后，执行<code>run</code>,就会运行到断点：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(gdb) info breakpoints</div><div class="line">Num     Type           Disp Enb Address            What</div><div class="line">1       breakpoint     dis  y   0x0000000000000680 in main at bugging.c:19</div><div class="line">3       breakpoint     del  y   0x0000000000000651 in foo at bugging.c:11</div><div class="line">(gdb) run</div><div class="line">Starting program: /home/sky/gdbtest/bugging</div><div class="line"></div><div class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdfd8) at bugging.c:21</div><div class="line">21          int result = 0;</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<h2 id="继续单步调试"><a href="#继续单步调试" class="headerlink" title="继续单步调试"></a>继续单步调试</h2><p>上面输出会停到<code>main</code>函数这个断点，<code>next</code>或者<code>n</code>，就会单步运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdfd8) at bugging.c:21</div><div class="line">21          int result = 0;</div><div class="line">(gdb) n</div><div class="line">22          int N = 100;</div><div class="line">(gdb) next</div><div class="line">24          result = foo(N);</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<h2 id="显示变量"><a href="#显示变量" class="headerlink" title="显示变量"></a>显示变量</h2><p>如果想显示某个变量的值，用<code>display &lt;变量名&gt;</code> ：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Temporary breakpoint 3, foo (n=100) at bugging.c:11</div><div class="line">11          for (i=0; i&lt;=n; i++)</div><div class="line">(gdb) display sum</div><div class="line">1: sum = 1431652109</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<p>上面代码我想显示<code>sum</code>这个变量，而且单步调试的时候，这个变量会一直显示。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(gdb) n</div><div class="line">13              sum = sum+i;</div><div class="line">1: sum = 1431652109</div><div class="line">(gdb) n</div><div class="line">11          for (i=0; i&lt;=n; i++)</div><div class="line">1: sum = 1431652109</div><div class="line">(gdb) n</div><div class="line">13              sum = sum+i;</div><div class="line">1: sum = 1431652109</div><div class="line">(gdb) n</div><div class="line">11          for (i=0; i&lt;=n; i++)</div><div class="line">1: sum = 1431652110</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<h2 id="退出单步调试"><a href="#退出单步调试" class="headerlink" title="退出单步调试"></a>退出单步调试</h2><p>用<code>continue</code>或者<code>c</code>,退出单步调试<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(gdb) c</div><div class="line">Continuing.</div><div class="line">1+2+3+...+100= 1431657159</div><div class="line">[Inferior 1 (process 27595) exited normally]</div><div class="line">(gdb)</div></pre></td></tr></table></figure></p>
<h1 id="bugging-c代码"><a href="#bugging-c代码" class="headerlink" title="bugging.c代码"></a>bugging.c代码</h1><p>这是上面调试用的代码，此代码用来输出<code>1+2+3+...+100</code>的和，很明显上面最后的结果是一个很大值，为什么呢，你可以看上面单步调试里面显示某个变量的值还有以下注释👿<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* bugging.c */</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> sum;  <span class="comment">//没有初始化为0，所以这个变量的值为不确定</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</div><div class="line">    &#123;</div><div class="line">        sum = sum+i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> N = <span class="number">100</span>;</div><div class="line"></div><div class="line">    result = foo(N);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"1+2+3+...+%d= %d\n"</span>, N, result);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>很好用的工具用来调试c的代码，缺点当然就是没有图形界面咯。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;备忘，mark 👿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;GDB-基础知识&quot;&gt;&lt;a href=&quot;#GDB-基础知识&quot; class=&quot;headerlink&quot; title=&quot;GDB 基础知识&quot;&gt;&lt;/a&gt;GDB 基础知识&lt;/h1&gt;&lt;h2 id=&quot;GDB-相关概念&quot;&gt;&lt;a href=&quot;#GDB-相关概念&quot; class=&quot;headerlink&quot; title=&quot;GDB 相关概念&quot;&gt;&lt;/a&gt;GDB 相关概念&lt;/h2&gt;&lt;p&gt;GDB, 是 The GNU Project Debugger 的缩写, 是 Linux 下功能全面的调试工具。GDB 支持断点、单步执行、打印变量、观察变量、查看寄存器、查看堆栈等调试手段。在 Linux 环境软件开发中，GDB 是主要的调试工具，用来调试 C 和 C++ 程序。&lt;/p&gt;
&lt;h2 id=&quot;GDB-的进入和退出&quot;&gt;&lt;a href=&quot;#GDB-的进入和退出&quot; class=&quot;headerlink&quot; title=&quot;GDB 的进入和退出&quot;&gt;&lt;/a&gt;GDB 的进入和退出&lt;/h2&gt;&lt;p&gt;如果要调试程序，需要在 gcc 编译可执行程序时加上 -g 参数，首先我们编译 bugging.c 程序，生成可执行文件：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;gcc -g -o bugging bugging.c&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;输入 gdb bugging 进入 gdb 调试 bugging 程序的界面：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;gdb bugging&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在 gdb 命令行界面，输入run 执行待调试程序：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(gdb) run&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://idiotsky.me/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="linux" scheme="http://idiotsky.me/tags/linux/"/>
    
      <category term="gdb" scheme="http://idiotsky.me/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>linux命令-gcc</title>
    <link href="http://idiotsky.me/2017/12/27/linux-gcc/"/>
    <id>http://idiotsky.me/2017/12/27/linux-gcc/</id>
    <published>2017-12-27T03:31:23.000Z</published>
    <updated>2018-03-27T14:44:01.861Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>备忘，mark 👿</p>
</blockquote>
<p>gcc命令使用GNU推出的基于C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现在很多程序员都应用GCC，怎样才能更好的应用GCC。目前，GCC可以用来编译C/C++、FORTRAN、JAVA、OBJC、ADA等语言的程序，可根据需要选择安装支持的语言。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc(选项)(参数)</div></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-o：指定生成的输出文件；</div><div class="line">-E：仅执行编译预处理；</div><div class="line">-S：将C代码转换为汇编代码；</div><div class="line">-wall：显示警告信息；</div><div class="line">-c：仅执行编译操作，不进行连接操作。</div></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>C源文件：指定C语言源代码文件。<br><a id="more"></a></p>
<h1 id="常用编译命令选项"><a href="#常用编译命令选项" class="headerlink" title="常用编译命令选项"></a>常用编译命令选项</h1><p>假设源程序文件名为test.c</p>
<h2 id="无选项编译链接"><a href="#无选项编译链接" class="headerlink" title="无选项编译链接"></a>无选项编译链接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test.c</div></pre></td></tr></table></figure>
<p>将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。</p>
<h2 id="选项-o"><a href="#选项-o" class="headerlink" title="选项 -o"></a>选项 -o</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test.c -o test</div></pre></td></tr></table></figure>
<p>将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。</p>
<h2 id="选项-E"><a href="#选项-E" class="headerlink" title="选项 -E"></a>选项 -E</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -E test.c -o test.i</div></pre></td></tr></table></figure>
<p>将test.c预处理输出test.i文件。</p>
<h2 id="选项-S"><a href="#选项-S" class="headerlink" title="选项 -S"></a>选项 -S</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -S test.i</div></pre></td></tr></table></figure>
<p>将预处理输出文件test.i汇编成test.s文件。</p>
<h2 id="选项-c"><a href="#选项-c" class="headerlink" title="选项 -c"></a>选项 -c</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c test.s</div></pre></td></tr></table></figure>
<p>将汇编输出文件test.s编译输出test.o文件。</p>
<h2 id="无选项链接"><a href="#无选项链接" class="headerlink" title="无选项链接"></a>无选项链接</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test.o -o test</div></pre></td></tr></table></figure>
<p>将编译输出文件test.o链接成最终可执行文件test。</p>
<h2 id="选项-O"><a href="#选项-O" class="headerlink" title="选项 -O"></a>选项 -O</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -O1 test.c -o test</div></pre></td></tr></table></figure>
<p>使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。</p>
<h1 id="多源文件的编译方法"><a href="#多源文件的编译方法" class="headerlink" title="多源文件的编译方法"></a>多源文件的编译方法</h1><p>如果有多个源文件，基本上有两种编译方法：</p>
<p>假设有两个源文件为test.c和testfun.c</p>
<h2 id="多个文件一起编译"><a href="#多个文件一起编译" class="headerlink" title="多个文件一起编译"></a>多个文件一起编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc testfun.c test.c -o test</div></pre></td></tr></table></figure>
<p>将testfun.c和test.c分别编译后链接成test可执行文件。</p>
<h2 id="分别编译各个源文件，之后对编译后输出的目标文件链接。"><a href="#分别编译各个源文件，之后对编译后输出的目标文件链接。" class="headerlink" title="分别编译各个源文件，之后对编译后输出的目标文件链接。"></a>分别编译各个源文件，之后对编译后输出的目标文件链接。</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -c testfun.c    #将testfun.c编译成testfun.o</div><div class="line">gcc -c test.c       #将test.c编译成test.o</div><div class="line">gcc -o testfun.o test.o -o test    #将testfun.o和test.o链接成test</div></pre></td></tr></table></figure>
<p>以上两种方法相比较，第一中方法编译时需要所有文件重新编译，而第二种方法可以只重新编译修改的文件，未修改的文件不用重新编译。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;备忘，mark 👿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;gcc命令使用GNU推出的基于C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点。现在很多程序员都应用GCC，怎样才能更好的应用GCC。目前，GCC可以用来编译C/C++、FORTRAN、JAVA、OBJC、ADA等语言的程序，可根据需要选择安装支持的语言。&lt;/p&gt;
&lt;h1 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;gcc(选项)(参数)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;选项&quot;&gt;&lt;a href=&quot;#选项&quot; class=&quot;headerlink&quot; title=&quot;选项&quot;&gt;&lt;/a&gt;选项&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;-o：指定生成的输出文件；&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-E：仅执行编译预处理；&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-S：将C代码转换为汇编代码；&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-wall：显示警告信息；&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-c：仅执行编译操作，不进行连接操作。&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参数&quot;&gt;&lt;/a&gt;参数&lt;/h2&gt;&lt;p&gt;C源文件：指定C语言源代码文件。&lt;br&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://idiotsky.me/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="linux" scheme="http://idiotsky.me/tags/linux/"/>
    
      <category term="gcc" scheme="http://idiotsky.me/tags/gcc/"/>
    
  </entry>
  
  <entry>
    <title>mysql explain详解</title>
    <link href="http://idiotsky.me/2017/11/30/mysql-explain/"/>
    <id>http://idiotsky.me/2017/11/30/mysql-explain/</id>
    <published>2017-11-30T15:00:28.000Z</published>
    <updated>2018-03-22T15:18:37.311Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>👿 mark</p>
</blockquote>
<h1 id="Explain简介"><a href="#Explain简介" class="headerlink" title="Explain简介"></a>Explain简介</h1><p>本文主要讲述如何通过 explain 命令获取 select 语句的执行计划，通过 explain 我们可以知道以下信息：表的读取顺序，数据读取操作的类型，哪些索引可以使用，哪些索引实际使用了，表之间的引用，每张表有多少行被优化器查询等信息。</p>
<p>下面是使用 explain 的例子： </p>
<p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from actor;</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</div><div class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</div><div class="line">|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</div></pre></td></tr></table></figure></p>
<p>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。表的意义相当广泛：可以是子查询、一个 union 结果等。<br><a id="more"></a></p>
<h1 id="explain-中的列"><a href="#explain-中的列" class="headerlink" title="explain 中的列"></a>explain 中的列</h1><p>接下来我们将展示 explain 中每个列的信息。</p>
<h2 id="id列"><a href="#id列" class="headerlink" title="id列"></a>id列</h2><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。MySQL将 select 查询分为简单查询和复杂查询。复杂查询分为三类：简单子查询、派生表（from语句中的子查询）、union 查询。</p>
<h3 id="简单子查询"><a href="#简单子查询" class="headerlink" title="简单子查询"></a>简单子查询</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select (select 1 from actor limit 1) from film;</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</div><div class="line">| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</div><div class="line">|  1 | PRIMARY     | film  | index | NULL          | idx_name | 32      | NULL |    1 | Using index |</div><div class="line">|  2 | SUBQUERY    | actor | index | NULL          | PRIMARY  | 4       | NULL |    2 | Using index |</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</div></pre></td></tr></table></figure>
<h3 id="from子句中的子查询"><a href="#from子句中的子查询" class="headerlink" title="from子句中的子查询"></a>from子句中的子查询</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select id from (select id from film) as der;</div><div class="line">+----+-------------+------------+-------+---------------+----------+---------+------+------+-------------+</div><div class="line">| id | select_type | table      | type  | possible_keys | key      | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+------------+-------+---------------+----------+---------+------+------+-------------+</div><div class="line">|  1 | PRIMARY     | &lt;derived2&gt; | ALL   | NULL          | NULL     | NULL    | NULL |    2 | NULL        |</div><div class="line">|  2 | DERIVED     | film       | index | NULL          | idx_name | 32      | NULL |    1 | Using index |</div><div class="line">+----+-------------+------------+-------+---------------+----------+---------+------+------+-------------+</div></pre></td></tr></table></figure>
<p>这个查询执行时有个临时表别名为<code>&lt;derived2&gt;</code>，外部 select 查询引用了这个临时表</p>
<h3 id="union查询"><a href="#union查询" class="headerlink" title="union查询"></a>union查询</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select 1 union all select 1;</div><div class="line">+------+--------------+------------+------+---------------+------+---------+------+------+-----------------+</div><div class="line">| id   | select_type  | table      | type | possible_keys | key  | key_len | ref  | rows | Extra           |</div><div class="line">+------+--------------+------------+------+---------------+------+---------+------+------+-----------------+</div><div class="line">|  1   | PRIMARY      | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used  |</div><div class="line">|  2   | UNION        | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used  |</div><div class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL  | NULL          | NULL | NULL    | NULL | NULL | Using temporary |</div><div class="line">+----+--------------+------------+------+---------------+------+---------+------+------+-------------------+</div></pre></td></tr></table></figure>
<p>union结果总是放在一个匿名临时表中，临时表不在SQL总出现，因此它的id是NULL。</p>
<h2 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h2><p>select_type 表示对应行是是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。</p>
<ul>
<li><p>simple：简单查询。查询不包含子查询和union</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from film where id = 2;</div><div class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra |</div><div class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</div><div class="line">|  1 | SIMPLE      | film  | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |</div><div class="line">+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</div></pre></td></tr></table></figure>
</li>
<li><p>primary：复杂查询中最外层的 select</p>
</li>
<li>subquery：包含在 select 中的子查询（不在 from 子句中）</li>
<li><p>derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）</p>
<p>  用这个例子来了解 primary、subquery 和 derived 类型</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;</div><div class="line">+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+</div><div class="line">| id | select_type | table      | type   | possible_keys | key     | key_len | ref   | rows | Extra       |</div><div class="line">+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+</div><div class="line">|  1 | PRIMARY     | &lt;derived3&gt; | system | NULL          | NULL    | NULL    | NULL  |    1 | NULL        |</div><div class="line">|  3 | DERIVED     | film       | const  | PRIMARY       | PRIMARY | 4       | const |    1 | NULL        |</div><div class="line">|  2 | SUBQUERY    | actor      | const  | PRIMARY       | PRIMARY | 4       | const |    1 | Using index |</div><div class="line">+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+</div></pre></td></tr></table></figure>
<ul>
<li>union：在 union 中的第二个和随后的 select</li>
<li><p>union result：从 union 临时表检索结果的 select</p>
<p>  用这个例子来了解 union 和 union result 类型：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select 1 union all select 1;</div><div class="line">+------+--------------+------------+------+---------------+------+---------+------+------+-----------------+</div><div class="line">| id   | select_type  | table      | type | possible_keys | key  | key_len | ref  | rows | Extra           |</div><div class="line">+------+--------------+------------+------+---------------+------+---------+------+------+-----------------+</div><div class="line">|  1   | PRIMARY      | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used  |</div><div class="line">|  2   | UNION        | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used  |</div><div class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL  | NULL          | NULL | NULL    | NULL | NULL | Using temporary |</div><div class="line">+----+--------------+------------+------+---------------+------+---------+------+------+-------------------+</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="table列"><a href="#table列" class="headerlink" title="table列"></a>table列</h2><p>这一列表示 explain 的一行正在访问哪个表。</p>
<p>当 from 子句中有子查询时，table列是 <code>&lt;derivenN&gt;</code> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。当有 union 时，UNION RESULT 的 table 列的值为 <code>&lt;union1,2&gt;</code>，1和2表示参与 union 的 select 行id。</p>
<h2 id="type列"><a href="#type列" class="headerlink" title="type列"></a>type列</h2><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行。</p>
<p>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select min(id) from film;</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+</div><div class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                        |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+</div><div class="line">|  1 | SIMPLE      | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | Select tables optimized away |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+</div></pre></td></tr></table></figure></p>
<p><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain extended select * from (select * from film where id = 1) tmp;</div><div class="line">+----+-------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+</div><div class="line">| id | select_type | table      | type   | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</div><div class="line">+----+-------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+</div><div class="line">|  1 | PRIMARY     | &lt;derived2&gt; | system | NULL          | NULL    | NULL    | NULL  |    1 |   100.00 | NULL  |</div><div class="line">|  2 | DERIVED     | film       | const  | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</div><div class="line">+----+-------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+</div><div class="line"></div><div class="line">mysql&gt; show warnings;</div><div class="line">+-------+------+---------------------------------------------------------------+</div><div class="line">| Level | Code | Message                                                       |</div><div class="line">+-------+------+---------------------------------------------------------------+</div><div class="line">| Note  | 1003 | /* select#1 */ select '1' AS `id`,'film1' AS `name` from dual |</div><div class="line">+-------+------+---------------------------------------------------------------+</div></pre></td></tr></table></figure></p>
<p><strong>eq_ref</strong>：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;</div><div class="line">+----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+</div><div class="line">| id | select_type | table      | type   | possible_keys | key               | key_len | ref                     | rows | Extra       |</div><div class="line">+----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+</div><div class="line">|  1 | SIMPLE      | film_actor | index  | NULL          | idx_film_actor_id | 8       | NULL                    |    3 | Using index |</div><div class="line">|  1 | SIMPLE      | film       | eq_ref | PRIMARY       | PRIMARY           | 4       | test.film_actor.film_id |    1 | NULL        |</div><div class="line">+----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+</div></pre></td></tr></table></figure></p>
<p><strong>ref</strong>：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">1. 简单 select 查询，name是普通索引（非唯一索引）</div><div class="line">mysql&gt; explain select * from film where name = "film1";</div><div class="line">+----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+</div><div class="line">| id | select_type | table | type | possible_keys | key      | key_len | ref   | rows | Extra                    |</div><div class="line">+----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | film  | ref  | idx_name      | idx_name | 33      | const |    1 | Using where; Using index |</div><div class="line">+----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+</div><div class="line"></div><div class="line">2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。</div><div class="line">mysql&gt; explain select * from film left join film_actor on film.id = film_actor.film_id;</div><div class="line">+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+</div><div class="line">| id | select_type | table      | type  | possible_keys     | key               | key_len | ref          | rows | Extra       |</div><div class="line">+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+</div><div class="line">|  1 | SIMPLE      | film       | index | NULL              | idx_name          | 33      | NULL         |    3 | Using index |</div><div class="line">|  1 | SIMPLE      | film_actor | ref   | idx_film_actor_id | idx_film_actor_id | 4       | test.film.id |    1 | Using index |</div><div class="line">+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+</div></pre></td></tr></table></figure></p>
<p><strong>ref_or_null</strong>：类似ref，但是可以搜索值为NULL的行。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from film where name = "film1" or name is null;</div><div class="line">+----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+</div><div class="line">| id | select_type | table | type        | possible_keys | key      | key_len | ref   | rows | Extra                    |</div><div class="line">+----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | film  | ref_or_null | idx_name      | idx_name | 33      | const |    2 | Using where; Using index |</div><div class="line">+----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+</div></pre></td></tr></table></figure></p>
<p><strong>index_merge</strong>：表示使用了索引合并的优化方法。 例如下表：id是主键，tenant_id是普通索引。or 的时候没有用 primary key，而是使用了 primary key(id) 和 tenant_id 索引</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from role where id = 11011 or tenant_id = 8888;</div><div class="line">+----+-------------+-------+-------------+-----------------------+-----------------------+---------+------+------+-------------------------------------------------+</div><div class="line">| id | select_type | table | type        | possible_keys         | key                   | key_len | ref  | rows | Extra                                           |</div><div class="line">+----+-------------+-------+-------------+-----------------------+-----------------------+---------+------+------+-------------------------------------------------+</div><div class="line">|  1 | SIMPLE      | role  | index_merge | PRIMARY,idx_tenant_id | PRIMARY,idx_tenant_id | 4,4     | NULL |  134 | Using union(PRIMARY,idx_tenant_id); Using where |</div><div class="line">+----+-------------+-------+-------------+-----------------------+-----------------------+---------+------+------+-------------------------------------------------+</div></pre></td></tr></table></figure>
<p><strong>range</strong>：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from actor where id &gt; 1;</div><div class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | actor | range | PRIMARY       | PRIMARY | 4       | NULL |    2 | Using where |</div><div class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</div></pre></td></tr></table></figure></p>
<p><strong>index</strong>：和ALL一样，不同就是mysql只需扫描索引树，这通常比ALL快一些。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select count(*) from film;</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</div><div class="line">| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | film  | index | NULL          | idx_name | 33      | NULL |    3 | Using index |</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</div></pre></td></tr></table></figure></p>
<p><strong>ALL</strong>：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from actor;</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</div><div class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</div><div class="line">|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------+</div></pre></td></tr></table></figure></p>
<h2 id="possible-keys列"><a href="#possible-keys列" class="headerlink" title="possible_keys列"></a>possible_keys列</h2><p>这一列显示查询可能使用哪些索引来查找。<br>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p>
<h2 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h2><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>
<h2 id="key-len列"><a href="#key-len列" class="headerlink" title="key_len列"></a>key_len列</h2><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。<br>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from film_actor where film_id = 2;</div><div class="line">+----+-------------+------------+------+-------------------+-------------------+---------+-------+------+-------------+</div><div class="line">| id | select_type | table      | type | possible_keys     | key               | key_len | ref   | rows | Extra       |</div><div class="line">+----+-------------+------------+------+-------------------+-------------------+---------+-------+------+-------------+</div><div class="line">|  1 | SIMPLE      | film_actor | ref  | idx_film_actor_id | idx_film_actor_id | 4       | const |    1 | Using index |</div><div class="line">+----+-------------+------------+------+-------------------+-------------------+---------+-------+------+-------------+</div></pre></td></tr></table></figure></p>
<p>key_len计算规则如下：</p>
<ul>
<li>符串<ul>
<li>char(n)：n字节长度</li>
<li>varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2</li>
</ul>
</li>
<li>数值类型<ul>
<li>tinyint：1字节</li>
<li>smallint：2字节</li>
<li>int：4字节</li>
<li>bigint：8字节　　</li>
</ul>
</li>
<li>时间类型　<ul>
<li>date：3字节</li>
<li>timestamp：4字节</li>
<li>datetime：8字节</li>
</ul>
</li>
<li>如果字段允许为 NULL，需要1字节记录是否为 NULL</li>
</ul>
<p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<h2 id="ref列"><a href="#ref列" class="headerlink" title="ref列"></a>ref列</h2><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，NULL，字段名（例：film.id）</p>
<h2 id="rows列"><a href="#rows列" class="headerlink" title="rows列"></a>rows列</h2><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>
<h2 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h2><p>这一列展示的是额外信息。常见的重要值如下：<br><strong>distinct</strong>: 一旦mysql找到了与行相联合匹配的行，就不再搜索了<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select distinct name from film left join film_actor on film.id = film_actor.film_id;</div><div class="line">+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+------------------------------+</div><div class="line">| id | select_type | table      | type  | possible_keys     | key               | key_len | ref          | rows | Extra                        |</div><div class="line">+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+------------------------------+</div><div class="line">|  1 | SIMPLE      | film       | index | idx_name          | idx_name          | 33      | NULL         |    3 | Using index; Using temporary |</div><div class="line">|  1 | SIMPLE      | film_actor | ref   | idx_film_actor_id | idx_film_actor_id | 4       | test.film.id |    1 | Using index; Distinct        |</div><div class="line">+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+------------------------------+</div></pre></td></tr></table></figure></p>
<p><strong>Using index</strong>：这发生在对表的请求列都是同一索引的部分的时候，返回的列数据只使用了索引中的信息，而没有再去访问表中的行记录。是性能高的表现。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select id from film order by id;</div><div class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | film  | index | NULL          | PRIMARY | 4       | NULL |    3 | Using index |</div><div class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</div></pre></td></tr></table></figure></p>
<p><strong>Using where</strong>：mysql服务器将在存储引擎检索行后再进行过滤。就是先读取整行数据，再按 where 条件进行检查，符合就留下，不符合就丢弃。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; explain select * from film where id &gt; 1;</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+--------------------------+</div><div class="line">| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra                    |</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+--------------------------+</div><div class="line">|  1 | SIMPLE      | film  | index | PRIMARY       | idx_name | 33      | NULL |    3 | Using where; Using index |</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+--------------------------+</div></pre></td></tr></table></figure></p>
<p><strong>Using temporary</strong>：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1. actor.name没有索引，此时创建了张临时表来distinct</div><div class="line">mysql&gt; explain select distinct name from actor;</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-----------------+</div><div class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra           |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-----------------+</div><div class="line">|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using temporary |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-----------------+</div><div class="line"></div><div class="line">2. film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表</div><div class="line">mysql&gt; explain select distinct name from film;</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</div><div class="line">| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | film  | index | idx_name      | idx_name | 33      | NULL |    3 | Using index |</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</div></pre></td></tr></table></figure></p>
<p><strong>Using filesort</strong>：如果排序字段不是索引的话，就会出现这个，这种情况下一般也是要考虑使用索引来优化的。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">1. actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录</div><div class="line">mysql&gt; explain select * from actor order by name;</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------------+</div><div class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra          |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------------+</div><div class="line">|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using filesort |</div><div class="line">+----+-------------+-------+------+---------------+------+---------+------+------+----------------+</div><div class="line"></div><div class="line">2. film.name建立了idx_name索引,此时查询时extra是using index</div><div class="line">mysql&gt; explain select * from film order by name;</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</div><div class="line">| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</div><div class="line">|  1 | SIMPLE      | film  | index | NULL          | idx_name | 33      | NULL |    3 | Using index |</div><div class="line">+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</div></pre></td></tr></table></figure></p>
<h1 id="使用的表"><a href="#使用的表" class="headerlink" title="使用的表"></a>使用的表</h1><p>以上所有sql使用的表和数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`actor`</span>;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`actor`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`actor`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`update_time`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'a'</span>,<span class="string">'2017-12-22 15:27:18'</span>), (<span class="number">2</span>,<span class="string">'b'</span>,<span class="string">'2017-12-22 15:27:18'</span>), (<span class="number">3</span>,<span class="string">'c'</span>,<span class="string">'2017-12-22 15:27:18'</span>);</div><div class="line"></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`film`</span>;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`film`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</div><div class="line">  <span class="keyword">KEY</span> <span class="string">`idx_name`</span> (<span class="string">`name`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`film`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">'film0'</span>),(<span class="number">1</span>,<span class="string">'film1'</span>),(<span class="number">2</span>,<span class="string">'film2'</span>);</div><div class="line"></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`film_actor`</span>;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`film_actor`</span> (</div><div class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`film_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`actor_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</div><div class="line">  <span class="keyword">KEY</span> <span class="string">`idx_film_actor_id`</span> (<span class="string">`film_id`</span>,<span class="string">`actor_id`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`film_actor`</span> (<span class="string">`id`</span>, <span class="string">`film_id`</span>, <span class="string">`actor_id`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;👿 mark&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Explain简介&quot;&gt;&lt;a href=&quot;#Explain简介&quot; class=&quot;headerlink&quot; title=&quot;Explain简介&quot;&gt;&lt;/a&gt;Explain简介&lt;/h1&gt;&lt;p&gt;本文主要讲述如何通过 explain 命令获取 select 语句的执行计划，通过 explain 我们可以知道以下信息：表的读取顺序，数据读取操作的类型，哪些索引可以使用，哪些索引实际使用了，表之间的引用，每张表有多少行被优化器查询等信息。&lt;/p&gt;
&lt;p&gt;下面是使用 explain 的例子： &lt;/p&gt;
&lt;p&gt;在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）。&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; explain select * from actor;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+----+-------------+-------+------+---------------+------+---------+------+------+-------+&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+----+-------------+-------+------+---------------+------+---------+------+------+-------+&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+----+-------------+-------+------+---------------+------+---------+------+------+-------+&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。表的意义相当广泛：可以是子查询、一个 union 结果等。&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://idiotsky.me/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://idiotsky.me/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>jvm full gc 解惑</title>
    <link href="http://idiotsky.me/2017/11/06/java-fullgc/"/>
    <id>http://idiotsky.me/2017/11/06/java-fullgc/</id>
    <published>2017-11-06T10:03:15.000Z</published>
    <updated>2017-11-07T14:09:00.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一直以来，都觉得full gc就是对old区的gc，然后就打脸了。。。。</p>
</blockquote>
<p>下面先引用R大的原文：</p>
<blockquote>
<p>针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：</p>
<ul>
<li>Partial GC：并不收集整个GC堆的模式<ul>
<li>Young GC：只收集young gen的GC</li>
<li>Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式</li>
<li>Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式</li>
</ul>
</li>
<li>Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。</li>
</ul>
</blockquote>
<a id="more"></a>
<blockquote>
<p>Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。</p>
<p>最简单的分代式GC策略，按HotSpot VM的serial GC的实现来看，触发条件是：</p>
<ul>
<li>young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。</li>
<li>full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。</li>
</ul>
<p>HotSpot VM里其它非并发GC的触发条件复杂一些，不过大致的原理与上面说的其实一样。当然也总有例外。Parallel Scavenge（-XX:+UseParallelGC）框架下，默认是在要触发full GC前先执行一次young GC，并且两次GC之间能让应用程序稍微运行一小下，以期降低full GC的暂停时间（因为young GC会尽量清理了young gen的死对象，减少了full GC的工作量）。控制这个行为的VM参数是-XX:+ScavengeBeforeFullGC。这是HotSpot VM里的奇葩嗯。</p>
<p>并发GC的触发条件就不太一样。以CMS GC为例，它主要是定时去检查old gen的使用量，当使用量超过了触发比例就会启动一次CMS GC，对old gen做并发收集。</p>
</blockquote>
<p>总结一下：</p>
<ol>
<li>full gc 是全区回收(打脸)</li>
<li>full gc 之前不会触发young gc（一般情况）</li>
</ol>
<p>再引用下别的大牛的话：</p>
<blockquote>
<p>先看一下HotSpot VM的GC家族的组合示意图：<br><a href="http://idiotsky.me/images1/java-fullgc-1.jpg"><img src="http://idiotsky.me/images1/java-fullgc-1.jpg" alt=""></a><br>不同的GC组合套装之中，具备Full GC能力的大概有三种：</p>
<ol>
<li>ParallelOld(PSMarkSweep)</li>
<li>Serial Old(MarkSweep)</li>
<li>“?”所代表的G1</li>
</ol>
<p>暂不考虑G1，除了CMS具备在年老代进行Major GC之外，其他情况下年老代的GC都是由Full GC触发的。Full GC的收集范围包含整个Heap区域( Eden + S1 + S2 + Tenured)，它发生时Mutator停止工作——Stop The World。对于Serial Collector，它采用MSC(Mark-Sweep-Compact)的算法对全堆进行Full GC，在HotSpot VM的实现中，主要用MarkSweep这个类来实现；对于Parallel Collector而言，PSMarkSweep是多线程的MarkSweep，名不副实，这玩意儿其实是个实现了Lisp2的Mark-Compact GC算法。PSMarkSweep有个特殊的地方是如果配置了<strong>ScavengeBeforeFullGC</strong> 这个flag，则会在Full GC之前对年轻代进行一次Minor GC；其他情况根本不需要Full GC之前先执行Minor GC，Full GC会对年轻代发起GC。Full GC前后Heap的对比示意参见：<br><a href="http://idiotsky.me/images1/java-fullgc-2.jpg"><img src="http://idiotsky.me/images1/java-fullgc-2.jpg" alt=""></a></p>
<p>可见，一般情况下，年轻代的存活对象都被Compact到了年老代，所以，你看到年轻代都被清空了；只有当年老代满了的时候，才会Compact到Eden区域。</p>
<p>对于Concurrent Collector，CMS在Remark Phase，可以通过设置 <strong>CMSScavengeBeforeRemark</strong> 在remark之前先行YGC，这给了CMS在Major GC时触发Minor GC的机会，但这个Flag默认是false；当CMS发生 <strong>Concurrent Mode Failure</strong> 时，CMS会退化为Serial Old GC，从而采用与Serial Collector相同的算法进行Full GC。CMS发生 <strong>Concurrent Mode Failure</strong> 的原因：1. 因为是并发收集，所以Mutator仍可能在不断占用年老代的空间，当然还包括这一趟无法收集的Float Garbage会占用内存空间，如果年老代空间被占满但并发收集还未结束，就会发生并发模式失败；2. 因为CMS采用的是Mark Sweep算法，本身内存碎片化无法解决，很可能发生大对象分配时没有连续空间，或者本身剩余空间不够大对象分配时，也会发生并发模式失败。</p>
</blockquote>
<p>再总结下:</p>
<ol>
<li>Serial Old 做full gc 时候不会执行young gc，而 ParallelOld 会根据 <strong>ScavengeBeforeFullGC</strong> 来决定是否在full gc前执行一次young gc</li>
<li>CMS 有自己的major gc，单独执行old区的gc，但是如果 <strong>Concurrent Mode Failure</strong> 的话，就还是老老实实做Serial Old的full gc吧。</li>
<li>CMS 的 <strong>CMSScavengeBeforeRemark</strong> 标记决定了是否在remark阶段之前执行一次young gc（网上说这个标记还能解决跨代引用问题），</li>
</ol>
<p>参考 <a href="https://www.zhihu.com/question/62604570" target="_blank" rel="external">https://www.zhihu.com/question/62604570</a><br>参考 <a href="https://www.zhihu.com/question/41922036" target="_blank" rel="external">https://www.zhihu.com/question/41922036</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一直以来，都觉得full gc就是对old区的gc，然后就打脸了。。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面先引用R大的原文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Partial GC：并不收集整个GC堆的模式&lt;ul&gt;
&lt;li&gt;Young GC：只收集young gen的GC&lt;/li&gt;
&lt;li&gt;Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式&lt;/li&gt;
&lt;li&gt;Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java" scheme="http://idiotsky.me/categories/java/"/>
    
    
      <category term="java" scheme="http://idiotsky.me/tags/java/"/>
    
      <category term="jvm" scheme="http://idiotsky.me/tags/jvm/"/>
    
      <category term="gc" scheme="http://idiotsky.me/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>Git先生的故事</title>
    <link href="http://idiotsky.me/2017/11/05/git-story/"/>
    <id>http://idiotsky.me/2017/11/05/git-story/</id>
    <published>2017-11-05T14:44:05.000Z</published>
    <updated>2017-11-07T14:52:01.852Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>很有意思的通俗的总结了git。👿</p>
</blockquote>
<p>Git先生是一位很出名的摄影专家，他的主要职责是用它强大的拍摄技术帮我们共享成果，共创未来。为此它准备了许许多多的工具来实现这样的目标。下面我们就来看看Git先生的工作场所，和他为我们的一些痛点带来了哪些解决方案吧。</p>
<h1 id="初次见面"><a href="#初次见面" class="headerlink" title="初次见面"></a>初次见面</h1><p>老板（用户自己）新买了一块地皮（创建了一个目录），想聘请Git先生到此开设一个工作室来加快这个地皮的建设工作。老板用<code>git init</code> 招来了Git先生，Git先生在该目录下生成一个.git目录，用来作为自己的办公室，办公室用来记录自己的工作日志和成果。</p>
<p>让我们来从空中俯瞰下这块新的地皮，和Git先生为它所设计的蓝图吧。<br><a href="http://idiotsky.me/images1/git-story-1.jpg"><img src="http://idiotsky.me/images1/git-story-1.jpg" alt=""></a></p>
<p>下面我们来解释下，这几个区域的作用：<br>Working Directory：Git先生的老板所买下的地皮，这个是实实在在物理层面的地皮，我们可以在上面种些花花草草，建点高楼大厦啥的。</p>
<p>Staging Area：Git先生摄影棚所在地，位置位于Git先生的办公室。每当老板完成了某件名垂青史的伟事，他就会命令Git先生把自己这个阶段所干的事情一五一十的搬到摄影棚拍照记录下来。<code>git add</code> 就是把修改搬到摄影棚，<code>git commit</code>就是命令Git先生拍照，而拍完照后，摄影棚马上会被打扫干净。</p>
<p>Repository：Git先生办公室的某个区域，专门用来存储照片用的。</p>
<p>Remote：这是一块云端区域，Git先生会在工作完一段时间后，就把自己的作品上传上去。这样做，一方面是用来保存自己的作品，以备意外发生，另一方面也是提供给其他有兴趣的老板们一起做这个项目。<br><a id="more"></a></p>
<h1 id="Go-to-work"><a href="#Go-to-work" class="headerlink" title="Go to work"></a>Go to work</h1><p>一切准备妥当后，Git先生马上就投入到了紧张的工作当中。老板首先就迫不及待的在地皮上上种了一朵花，然后马上命令Git来拍照留念。<br><a href="http://idiotsky.me/images1/git-story-2.jpg"><img src="http://idiotsky.me/images1/git-story-2.jpg" alt=""></a><br>当然结果是失败的，Git也很苦恼，自己已经把所有流程和老板说过一遍了，但老板还是会鲁莽行事。然后Git先生又向老板耐心的解释了一下针对Git目录下某个修改的4种状态。</p>
<blockquote>
<p>Untracked/Tracked<br>Not Staged/Staged<br>比如你新建一个文件，它的状态就是 Untracked 的，你不能对 Untracked 的文件进行任何Git操作，除了先使用<code>git add</code> 让它先变为Tracked 状态。一个文件被Track后，以后的修改如果未用<code>git add</code>，那这个修改就叫Not Staged，需要add后，让它变为Staged才能进行Commit。</p>
</blockquote>
<p>老板按照Git先生的说法又执行了一遍，这次他成功了。Git又向老板说，你可以用<code>git log</code>来查看我已经拍过的照片。</p>
<p>老板学会这招后，又给这块地皮创建了树、草，并且也都分别让Git先生拍了照片保存。</p>
<p><code>git log</code>后我们看到了这三张照片，如果要查看详情还可以使用<code>git log -p</code>。<br><a href="http://idiotsky.me/images1/git-story-3.jpg"><img src="http://idiotsky.me/images1/git-story-3.jpg" alt=""></a></p>
<blockquote>
<p>导演注：Commit的id为对当前文件夹内容做SHA-1得来。</p>
</blockquote>
<h1 id="上点儿色吧"><a href="#上点儿色吧" class="headerlink" title="上点儿色吧"></a>上点儿色吧</h1><p>老板想把树涂成红色的，再给树取个名字叫big tree。他记得Git先生告诉过他可以用<code>git diff</code>来查看自己所做的改动<br><a href="http://idiotsky.me/images1/git-story-4.jpg"><img src="http://idiotsky.me/images1/git-story-4.jpg" alt=""></a><br>看到了自己的修改后，老板满意的点点头，然后用<code>git add .</code>把它们都丢进了摄影棚。过后就出去忙其他事情了，回来后他发现自己忘记离开前做了啥事情了。此时他再用<code>git diff</code>查看，发现里面空空如也。老板愤怒的叫来了Git先生问他是咋回事。Git先生友善的解释了原因。</p>
<p>“<code>git diff</code>显示了您当前修改和我办公室中所记录的最新一张照片之间的差异，但是您已经把这些改动都挪到我的摄影棚里了，git diff就没法查看了，如果您想看我摄影棚里摆了哪些东西。你可以使用<code>git diff --staged/cached</code>哦”</p>
<p>老板按照Git先生所说，果然看到了他以前的修改记录。</p>
<blockquote>
<p>导演注：stage相关的命令一般都与Staging Area相关，git add 也可以写成 git stage，这两个命令是一样的。</p>
</blockquote>
<p>不过当老板看到他把树设成了红色，觉得不合理，想放弃这次修改。他要如何去做呢？</p>
<p><code>git reset &lt;file&gt;</code> 把这个文件的修改从Staging Area中去除<br><code>git checkout -- &lt;file&gt;</code> 放弃工作区文件的修改</p>
<blockquote>
<p>导演注：这里使用 <code>git checkout &lt;file&gt;</code> 也行，之所以使用–，因为该命令与切换分支的命令一样，万一这个文件名和某个分支名重名，则<code>git checkout &lt;file&gt;</code>就变成切换分支了。</p>
</blockquote>
<p>老板不禁感叹，幸好自己没有进行commit。Git先生告诉老板说，即使你commit了，也不用怕，我也有几种解决方案。<br>一，放弃整张照片<br><code>git reset HEAD~1</code> HEAD表示指向最新那张照片的指针，～1表示要想起回退一张，此时我们有三种回退方式可选<code>--soft</code>表示只删除照片，照片的修改恢复到Staging Area中,<code>--mixed</code>不但删除照片，也不恢复Staging Area中的状态（不加选项时就为此中方法）,<code>--hard</code>不但删除照片，而且连工作区域的修改也被回退掉</p>
<p>二，我们再产生一张想放弃的照片的反修改的照片<br><code>git revert &lt;commit-id&gt;</code> 产生此commit的反修改，并提交此处commit-id不必是最新一次，可以是任意处的。<br>第一种方案适用于，你的commit还未push到云端的场景，第二种，如果你的修改已经push到云端，那么为了尊重历史记录，最好就是生成一个方向修改来回退错误部分，让其他人知道历史。</p>
<blockquote>
<p>导演注：HEAD指针记录了正在操作的节点的commit id，每个分支都有属于自己的HEAD指针，并且只有一个</p>
</blockquote>
<h1 id="拨弄你的指针"><a href="#拨弄你的指针" class="headerlink" title="拨弄你的指针"></a>拨弄你的指针</h1><p>老板经过上次的事件，发现自己可能会因为一时冲动做出一些错误的决定。就问Git先生是否有办法把自己所有操作行为都记录下来，而且还允许自己撤销任何一种错误的操作。Git先生向老板解释说：所有对HEAD指针的操作都会被记录下来。</p>
<p>可以用<code>git reflog</code>查看到老板的所有HEAD操作<br><a href="http://idiotsky.me/images1/git-story-5.jpg"><img src="http://idiotsky.me/images1/git-story-5.jpg" alt=""></a><br>最上面，我们可以看到是老板彻底回退了给树添加名字和颜色修改，执行了<code>git reset --hard HEAD~1</code>，而如果老板突然又后悔了，想恢复添加名字和颜色的修改。那么我们就可以通过执行<code>git reset --hard HEAD@{1}</code>来把操作回退到<code>HEAD@{1}</code>时，也就是加入名字和颜色那次commit。</p>
<blockquote>
<p>这里的reset也有三个选项，<code>--soft</code>，<code>--mixed</code>，<code>--hard</code>，因为这里执行的是恢复操作，所以这三个选项在这里的作用也需要反过来理解，hard自不用说，就是完全恢复到某个操作时的状态，而soft表示，虽然把HEAD指针拨到了某个操作时的状态，但在staging area中会产生可以让恢复后的状态重新修改回来的修改，就像物质与反物质那样。mixed同理。</p>
</blockquote>
<p>以上可能难以理解，这里我们再举个应用场景来说明下：<br>我们知道<code>git revert</code>每次只能回退某个commit，那我们如何同时revert掉多个commit呢。针对这种场景我们就可以进行以下操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//拨动HEAD指针到5add0e9</div><div class="line">git reset --hard 5add0e9 </div><div class="line">//恢复到以前的commit处信息，并且在staging area生成了中反修改</div><div class="line">git reset --soft HEAD@&#123;1&#125; </div><div class="line">// 注意此处用了--soft</div><div class="line">git commit -m &apos;revert to 5add0e9&apos;</div></pre></td></tr></table></figure></p>
<h1 id="多干点事"><a href="#多干点事" class="headerlink" title="多干点事"></a>多干点事</h1><p>老板：地皮准备好了， 我们既要种花，种草，还要盖个楼房啥的，种花要花几天功夫，种草好又得花几天。这几样事咱能不能一起干呢？干完了，分别拍个照片再合一块岂不美哉。</p>
<p>Git先生：老板英明，针对这种情况我也早有准备。</p>
<p><code>git branch &lt;branch-name&gt;</code> 创建一个分支，不加<code>&lt;branch-name&gt;</code>则为列出当前所有分支<code>git branch -d &lt;branch-name&gt;</code>删除分支 -D 为强制删除分支<code>git checkout &lt;branch-name&gt;</code> 切换到该分支下<code>git merge &lt;branch-name&gt;</code> 合并<code>&lt;branch-name&gt;</code>分支内容到本分支下</p>
<blockquote>
<p>针对老板说的这种情况，我们只需要创建如下分支。然后分别在flower里种花，grass中种草，building中盖楼，最后在master分支中把完成的照片merge过来就行。<br>➜ GitTestRepo git:(master) git branch flower<br>➜ GitTestRepo git:(master) git branch grass<br>➜ GitTestRepo git:(master) git branch building<br>➜ GitTestRepo git:(master) git branch<br>building<br>flower<br>grass<br>* master</p>
<p>导演注：分支前加*号的为当前工作分支</p>
</blockquote>
<h1 id="合作共赢"><a href="#合作共赢" class="headerlink" title="合作共赢"></a>合作共赢</h1><p>Git先生：报告老板，您这块地皮很大，要是只有我们开发，那得花上很久时间，何不把它开放出去，让其他老板们一起进来把这块蛋糕做大呢。</p>
<p>老板：好主意，我们要怎么做呢？</p>
<p>Git先生：一切交给我，不过因为地皮开放出去后，涉及到多方共同开发。有些注意事项还希望老板能听我说道说道，否则危害甚大。</p>
<p>老板：请讲请讲！</p>
<p>如我们第一张图所示，我们可以利用git push来把自己所有的照片上传到云端，让其他人也可以参与进来开发。既然是云端，那么首先我们就需要指明下这个云端地皮的地址是哪里。</p>
<p><code>git remote add origin https://github.com/CPPAlien/GitTestRepo.git</code>//这里一般用origin，当然你可以换成其他任何名，你也可以添加多个remote地址git remote -v 可以用来查看所有云端地址信息<br><code>git push -u &lt;remote&gt; &lt;branch&gt; git push --set-upstream &lt;remote&gt; &lt;branch&gt;</code>用这两个命令来指明某个分支所对应到的remote地址。如果不指定，你在执行git push时需要明确写出remote和branch。<br><a href="http://idiotsky.me/images1/git-story-6.jpg"><img src="http://idiotsky.me/images1/git-story-6.jpg" alt=""></a></p>
<p>因为是多人合作，所以就有可能别人在云端先与你提交了一些修改，而此时就需要进行git pull操作，把别人的修改拉取下来合并到本地。但直接git pull行为是不太安全的，因为它会直接产生merge行为，可能会导致你本地数据错乱。所以我们一般用git fetch，正确流程如下</p>
<p><code>git fetch origin master</code>//获取origin上的master分支，会在本地自动创建一个的origin/master的临时分支。<br><code>git log -p master..origin/master</code>//比较本地的master分支和远端的master分支，看下差别。<br><code>git merge origin/master</code> 或 <code>git rebase origin/master</code> //如果差别是在自己的认知范围，那么就进行合并操作，这样本地的master分支就与云端保持一致了。如果本地有未push的commit，则会产生Merge的commit行为。Merge的过程中有可能因为多人对同一个文件的修改而造成冲突。<br><code>git mergetool</code>//打开merge工具，merge完后保存，然后手动提交merge后的结果。完成上述操作后，就可以把自己本地的commit提交到云端了。</p>
<blockquote>
<p>导演注：git merge 和 git rebase的区别，rebase是找到两者共同的commit处，把它者的修改接上去，然后再把自己的修改接在它者的修改后面，不会产生merge行为。看历史图时也不会像merge那样有分叉。</p>
</blockquote>
<p>从以下执行rebase后的提示，也可知二三</p>
<blockquote>
<p>➜ GitTest git:(master) git rebase origin/masterFirst<br>rewinding head to replay your work on top of it…Fast-forwarded master to origin/master.</p>
</blockquote>
<h1 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h1><p><code>git cherry-pick &lt;commit-id&gt;</code><br>老板如果想把其他分支上的一些照片拣过来使用，可以使用此命令。如果该照片与本分支无冲突，则直接会在本分支上加上一条commit，如果有冲突，则需要解决冲突后重新提交。<br><code>git stash/ git stash pop</code><br>如果老板当前有些工作没有commit。但有些云端的commit或者其他分支的commit是自己后续开发所要依赖的，那就可以使用git stash把当前未提交的修改放入到缓存栈，等合并操作完成后，再用git stash pop，把修改再加回来，你可以用git stash list查看当前的缓存栈。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Git和Mercurial 都是在2005年时出现，分别由Linus和Matt主导开发。而两者的出现也源于一个共同的事件，2005年初BitKeeper宣布向开源社区收费。Mercurial在英语中有反复无常的意思，而Git也可以翻译成无用之人，Matt直接说他取名Mercurial的用意就是讽刺BitKeeper的开发者。</p>
<p>from <a href="https://www.toutiao.com/i6484504341452440077/" target="_blank" rel="external">https://www.toutiao.com/i6484504341452440077/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;很有意思的通俗的总结了git。👿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git先生是一位很出名的摄影专家，他的主要职责是用它强大的拍摄技术帮我们共享成果，共创未来。为此它准备了许许多多的工具来实现这样的目标。下面我们就来看看Git先生的工作场所，和他为我们的一些痛点带来了哪些解决方案吧。&lt;/p&gt;
&lt;h1 id=&quot;初次见面&quot;&gt;&lt;a href=&quot;#初次见面&quot; class=&quot;headerlink&quot; title=&quot;初次见面&quot;&gt;&lt;/a&gt;初次见面&lt;/h1&gt;&lt;p&gt;老板（用户自己）新买了一块地皮（创建了一个目录），想聘请Git先生到此开设一个工作室来加快这个地皮的建设工作。老板用&lt;code&gt;git init&lt;/code&gt; 招来了Git先生，Git先生在该目录下生成一个.git目录，用来作为自己的办公室，办公室用来记录自己的工作日志和成果。&lt;/p&gt;
&lt;p&gt;让我们来从空中俯瞰下这块新的地皮，和Git先生为它所设计的蓝图吧。&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images1/git-story-1.jpg&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images1/git-story-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我们来解释下，这几个区域的作用：&lt;br&gt;Working Directory：Git先生的老板所买下的地皮，这个是实实在在物理层面的地皮，我们可以在上面种些花花草草，建点高楼大厦啥的。&lt;/p&gt;
&lt;p&gt;Staging Area：Git先生摄影棚所在地，位置位于Git先生的办公室。每当老板完成了某件名垂青史的伟事，他就会命令Git先生把自己这个阶段所干的事情一五一十的搬到摄影棚拍照记录下来。&lt;code&gt;git add&lt;/code&gt; 就是把修改搬到摄影棚，&lt;code&gt;git commit&lt;/code&gt;就是命令Git先生拍照，而拍完照后，摄影棚马上会被打扫干净。&lt;/p&gt;
&lt;p&gt;Repository：Git先生办公室的某个区域，专门用来存储照片用的。&lt;/p&gt;
&lt;p&gt;Remote：这是一块云端区域，Git先生会在工作完一段时间后，就把自己的作品上传上去。这样做，一方面是用来保存自己的作品，以备意外发生，另一方面也是提供给其他有兴趣的老板们一起做这个项目。&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://idiotsky.me/categories/git/"/>
    
    
      <category term="git" scheme="http://idiotsky.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>TCP 的那些事儿</title>
    <link href="http://idiotsky.me/2017/11/01/tcp-something/"/>
    <id>http://idiotsky.me/2017/11/01/tcp-something/</id>
    <published>2017-11-01T14:56:41.000Z</published>
    <updated>2018-02-26T11:25:41.824Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>tcp看了很多的文章，这篇总结的很好。此文有点长👿</p>
</blockquote>
<p>tcp在网络OSI的七层模型中的第四层——Transport(传输)层，IP在第三层——Network(网络)层，ARP在第二层——Data Link(数据链路)层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。</p>
<p>首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p>
<h1 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h1><p>接下来，我们来看一下TCP头的格式<br><a href="http://idiotsky.me/images1/tcp-something-1.jpg"><img src="http://idiotsky.me/images1/tcp-something-1.jpg" alt=""></a><br>你需要注意这么几点：</p>
<ul>
<li>TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</li>
<li>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：<ul>
<li>Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。</li>
<li>Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。</li>
<li>Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。</li>
<li>TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>关于其它的东西，可以参看下面的图示<br><a href="http://idiotsky.me/images1/tcp-something-2.jpg"><img src="http://idiotsky.me/images1/tcp-something-2.jpg" alt=""></a></p>
<h1 id="TCP的状态机"><a href="#TCP的状态机" class="headerlink" title="TCP的状态机"></a>TCP的状态机</h1><p>其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。</p>
<p>下面是：“TCP协议的状态机”  和 “TCP建链接”、“TCP断链接”、“传数据” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。<br><a href="http://idiotsky.me/images1/tcp-something-3.png"><img src="http://idiotsky.me/images1/tcp-something-3.png" alt=""></a><br><a href="http://idiotsky.me/images1/tcp-something-4.jpg"><img src="http://idiotsky.me/images1/tcp-something-4.jpg" alt=""></a><br>很多人会问，为什么建链接要3次握手，断链接需要4次挥手？</p>
<ul>
<li><strong>对于建链接的3次握手</strong>，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</li>
<li><strong>对于4次挥手</strong>，其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。下图是双方同时断连接的示意图（你同样可以对照着TCP状态机看）：</li>
</ul>
<p><a href="http://idiotsky.me/images1/tcp-something-5.png"><img src="http://idiotsky.me/images1/tcp-something-5.png" alt=""></a><br>另外，有几个事情需要注意一下：</p>
<ul>
<li><strong>关于建连接时SYN超时</strong>。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</li>
<li><strong>关于SYN Flood攻击</strong>。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</li>
<li><strong>关于ISN的初始化</strong>。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。<a href="http://tools.ietf.org/html/rfc793" target="_blank" rel="external">RFC793</a>中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – <a href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime" target="_blank" rel="external">Wikipedia语条</a>），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</li>
<li><strong>关于 MSL 和 TIME_WAIT</strong>。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（RFC793定义了MSL为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《<a href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html" target="_blank" rel="external">TIME_WAIT and its design implications for protocols and scalable client server systems</a>》</li>
<li><strong>关于TIME_WAIT数量太多</strong>。从上面的描述我们可以知道，TIME_WAIT是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫tcp_tw_reuse，另一个叫tcp_tw_recycle的参数，这两个参数默认值都是被关闭的，后者recyle比前者resue更为激进，resue要温柔一些。另外，如果使用tcp_tw_reuse，必需设置tcp_timestamps=1，否则无效。这里，你一定要注意，打开这两个参数会有比较大的坑——可能会让TCP连接出一些诡异的问题（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如官方文档上说的一样“<strong>It should not be changed without advice/request of technical experts</strong>”）。<ul>
<li><strong>关于tcp_tw_reuse</strong>。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下<a href="http://lxr.free-electrons.com/ident?i=tcp_twsk_unique" target="_blank" rel="external">tcp_twsk_unique</a>的源码 ）。我个人估计还是有一些场景会有问题。</li>
<li><strong>关于tcp_tw_recycle</strong>。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建链接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）（如果你想观摩一下Linux的内核代码，请参看源码 <a href="http://lxr.free-electrons.com/ident?i=tcp_timewait_state_process" target="_blank" rel="external">tcp_timewait_state_process</a>）。</li>
<li><strong>关于tcp_max_tw_buckets</strong>。这个是控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗DDoS攻击的。也说的默认值180000并不小。这个还是需要根据实际情况考虑。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Again，使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（<a href="http://tools.ietf.org/html/rfc1122" target="_blank" rel="external">RFC 1122</a>）</p>
</blockquote>
<p>其实，TIME_WAIT表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于HTTP服务器，那么设置一个<a href="http://en.wikipedia.org/wiki/HTTP_persistent_connection" target="_blank" rel="external">HTTP的KeepAlive</a>有多重要（浏览器会重用一个TCP连接来处理多个HTTP请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。</p>
<h1 id="数据传输中的Sequence-Number"><a href="#数据传输中的Sequence-Number" class="headerlink" title="数据传输中的Sequence Number"></a>数据传输中的Sequence Number</h1><p>下图是我从Wireshark中截了个我在访问coolshell.cn时的有数据传输的图给你看一下，SeqNum是怎么变的。（使用Wireshark菜单中的Statistics -&gt;Flow Graph… ）<br><a href="http://idiotsky.me/images1/tcp-something-6.jpg"><img src="http://idiotsky.me/images1/tcp-something-6.jpg" alt=""></a><br>你可以看到，<strong>SeqNum的增加是和传输的字节数相关的</strong>。上图中，三次握手后，来了两个Len:1440的包，而第二个包的SeqNum就成了1441。然后第一个ACK回的是1441，表示第一个1440收到了。</p>
<p><em>SeqNum为当前成功发送的数据字节数，ACK为当前成功接收的数据字节数</em></p>
<p><strong>注意</strong>：如果你用Wireshark抓包程序看3次握手，你会发现SeqNum总是为0，不是这样的，Wireshark为了显示更友好，使用了Relative SeqNum——相对序号，你只要在右键菜单中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p>
<h1 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h1><p>TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。</p>
<h2 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h2><p>一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。</p>
<p>但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。</p>
<p>对此有两种选择：</p>
<ul>
<li>一种是仅重传timeout的包。也就是第3份数据。</li>
<li>另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。</li>
</ul>
<p>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的）</p>
<h2 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h2><p>于是，TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。</p>
<p>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：<br><a href="http://idiotsky.me/images1/tcp-something-7.png"><img src="http://idiotsky.me/images1/tcp-something-7.png" alt=""></a><br>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p>
<h2 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h2><p>另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看<a href="http://tools.ietf.org/html/rfc2018" target="_blank" rel="external">RFC 2018</a>），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：<br><a href="http://idiotsky.me/images1/tcp-something-8.jpg"><img src="http://idiotsky.me/images1/tcp-something-8.jpg" alt=""></a></p>
<p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。</p>
<p>这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。</p>
<p>注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《<a href="http://www.ibm.com/developerworks/cn/linux/l-tcp-sack/" target="_blank" rel="external">TCP SACK的性能权衡</a>》</p>
<h2 id="Duplicate-SACK-–-重复收到数据的问题"><a href="#Duplicate-SACK-–-重复收到数据的问题" class="headerlink" title="Duplicate SACK – 重复收到数据的问题"></a>Duplicate SACK – 重复收到数据的问题</h2><p>Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了。<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank" rel="external">RFC-2883</a> 里有详细描述和示例。下面举几个例子（来源于<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank" rel="external">RFC-2883</a>）</p>
<p>D-SACK使用了SACK的第一个段来做标志，</p>
<ul>
<li>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK</li>
<li>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK</li>
</ul>
<h3 id="示例一：ACK丢包"><a href="#示例一：ACK丢包" class="headerlink" title="示例一：ACK丢包"></a>示例一：ACK丢包</h3><p>下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Transmitted  Received    ACK Sent</div><div class="line">Segment      Segment     (Including SACK Blocks)</div><div class="line"> </div><div class="line">3000-3499    3000-3499   3500 (ACK dropped)</div><div class="line">3500-3999    3500-3999   4000 (ACK dropped)</div><div class="line">3000-3499    3000-3499   4000, SACK=3000-3500</div><div class="line">                                    ---------</div></pre></td></tr></table></figure></p>
<h3 id="示例二，网络延误"><a href="#示例二，网络延误" class="headerlink" title="示例二，网络延误"></a>示例二，网络延误</h3><p>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D-SACK——标识收到了重复的包。</p>
<p>这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Transmitted    Received    ACK Sent</div><div class="line">Segment        Segment     (Including SACK Blocks)</div><div class="line"> </div><div class="line">500-999        500-999     1000</div><div class="line">1000-1499      (delayed)</div><div class="line">1500-1999      1500-1999   1000, SACK=1500-2000</div><div class="line">2000-2499      2000-2499   1000, SACK=1500-2500</div><div class="line">2500-2999      2500-2999   1000, SACK=1500-3000</div><div class="line">1000-1499      1000-1499   3000</div><div class="line">               1000-1499   3000, SACK=1000-1500</div><div class="line">                                      ---------</div></pre></td></tr></table></figure></p>
<p>可见，引入了D-SACK，有这么几个好处：</p>
<ol>
<li>可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</li>
<li>是不是自己的timeout太小了，导致重传。</li>
<li>网络上出现了先发的包后到的情况（又称reordering）</li>
<li>网络上是不是把我的数据包给复制了。</li>
</ol>
<p>知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控。<br>Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开）</p>
<h1 id="TCP的RTT算法"><a href="#TCP的RTT算法" class="headerlink" title="TCP的RTT算法"></a>TCP的RTT算法</h1><p>从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。</p>
<ul>
<li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p>
<h2 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h2><p><a href="http://tools.ietf.org/html/rfc793" target="_blank" rel="external">RFC793</a>中定义的经典算法是这样的：</p>
<ol>
<li>首先，先采样RTT，记下最近好几次的RTT值。</li>
<li>然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）<br>SRTT = ( α <em> SRTT ) + ((1- α) </em> RTT)</li>
<li>开始计算RTO。公式如下：<br>RTO = min [ UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]</li>
</ol>
<p>其中：</p>
<ul>
<li>UBOUND是最大的timeout时间，上限值</li>
<li>LBOUND是最小的timeout时间，下限值</li>
<li>β 值一般在1.3到2.0之间。</li>
</ul>
<h2 id="Karn-Partridge-算法"><a href="#Karn-Partridge-算法" class="headerlink" title="Karn / Partridge 算法"></a>Karn / Partridge 算法</h2><p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？</p>
<p>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p>
<ul>
<li>情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。</li>
<li>情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。<br><a href="http://idiotsky.me/images1/tcp-something-9.jpg"><img src="http://idiotsky.me/images1/tcp-something-9.jpg" alt=""></a></li>
</ul>
<p>所以1987年的时候，搞了一个叫<a href="http://en.wikipedia.org/wiki/Karn&#39;s_Algorithm" target="_blank" rel="external">Karn / Partridge Algorithm</a>，这个算法的最大特点是——<strong>忽略重传，不把重传的RTT做采样</strong>（你看，你不需要去解决不存在的问题）。</p>
<p>但是，这样一来，又会引发一个大BUG——<strong>如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难</strong>。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。</p>
<h2 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h2><p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看<a href="http://tools.ietf.org/html/rfc6298" target="_blank" rel="external">RFC6289</a>）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）<br>SRTT = SRTT + α (RTT – SRTT)  —— 计算平滑RTT</p>
<p>DevRTT = (1-β)*DevRTT + β*(|RTT-SRTT|) ——计算平滑RTT和真实的差距（加权移动平均）</p>
<p>RTO= µ <em> SRTT + ∂ </em>DevRTT —— 神一样的公式</p>
<p>（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：tcp_rtt_estimator）。</p>
<h1 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h1><p>需要说明一下，如果你不了解TCP的滑动窗口这个事，你等于不了解TCP协议。我们都知道，<strong>TCP必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 前面我们说过，TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：<br><a href="http://idiotsky.me/images1/tcp-something-10.jpg"><img src="http://idiotsky.me/images1/tcp-something-10.jpg" alt=""></a></p>
<p>上图中，我们可以看到：</p>
<ul>
<li>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li>
<li>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</li>
</ul>
<p>于是：</p>
<ul>
<li>接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li>
<li>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</li>
</ul>
<p>下面我们来看一下发送方的滑动窗口示意图：<br><a href="http://idiotsky.me/images1/tcp-something-11.png"><img src="http://idiotsky.me/images1/tcp-something-11.png" alt=""></a></p>
<p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ul>
<li>#1已收到ack确认的数据。</li>
<li>#2发还没收到ack的。</li>
<li>#3在窗口中还没有发出的（接收方还有空间）。</li>
<li>#4窗口以外的数据（接收方没空间）</li>
</ul>
<p>下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：<br><a href="http://idiotsky.me/images1/tcp-something-12.png"><img src="http://idiotsky.me/images1/tcp-something-12.png" alt=""></a></p>
<p>下面我们来看一个接受端控制发送端的图示：<br><a href="http://idiotsky.me/images1/tcp-something-13.png"><img src="http://idiotsky.me/images1/tcp-something-13.png" alt=""></a></p>
<h2 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h2><p>上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？</p>
<p>解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<p><strong>注意</strong>：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a href="http://en.wikipedia.org/wiki/Sockstress" target="_blank" rel="external">Wikipedia的SockStress词条</a>）</p>
<p>另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。</p>
<h2 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h2><p>Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。</p>
<p>要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p>
<p>另外，你需要知道网络上有个MTU，对于以太网来说，MTU是1500字节，除去TCP+IP头的40个字节，真正的数据传输可以有1460，这就是所谓的MSS（Max Segment Size）注意，TCP的RFC定义这个MSS的默认值是536，这是因为 RFC 791里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，而576减去IP头的20个字节就是536）。</p>
<p><strong>如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽</strong>。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。</p>
<p>所以，<strong>Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。</p>
<ul>
<li>如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。</li>
<li>如果这个问题是由Sender端引起的，那么就会使用著名的 Nagle’s algorithm。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的ack回包，他才会发数据，否则就是在攒数据。</li>
</ul>
<p>另外，Nagle算法默认是打开的，所以，对于一些需要小包场景的程序——比如像telnet或ssh这样的交互性比较强的程序，你需要关闭这个算法。你可以在Socket设置TCP_NODELAY选项来关闭这个算法（关闭Nagle算法没有全局参数，需要根据每个应用自己的特点来关闭）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<span class="keyword">char</span> *)&amp;value,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div></pre></td></tr></table></figure></p>
<p>另外，网上有些文章说TCP_CORK的socket option是也关闭Nagle算法，这不对。<strong>TCP_CORK其实是更新激进的Nagle算汉，完全禁止小包发送，而Nagle算法没有禁止小包发送，只是禁止了大量的小包发送</strong>。最好不要两个选项都设置。</p>
<h1 id="TCP的拥塞处理-–-Congestion-Handling"><a href="#TCP的拥塞处理-–-Congestion-Handling" class="headerlink" title="TCP的拥塞处理 – Congestion Handling"></a>TCP的拥塞处理 – Congestion Handling</h1><p>上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。</p>
<p>具体一点，我们知道TCP通过一个timer采样了RTT并计算RTO，但是，<strong>如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络</strong>。这是一个灾难。</p>
<p>所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：<strong>TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了</strong>。</p>
<p>关于拥塞控制的论文请参看《<a href="http://ee.lbl.gov/papers/congavoid.pdf" target="_blank" rel="external">Congestion Avoidance and Control</a> 》(PDF)</p>
<p>拥塞控制主要是四个算法：<strong>1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复</strong>。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:</p>
<ul>
<li>1988年，TCP-Tahoe 提出了1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li>
<li>1990年，TCP Reno 在Tahoe的基础上增加了4）快速恢复</li>
</ul>
<h2 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h2><p>首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</p>
<p>慢启动的算法如下(cwnd全称Congestion Window)：</p>
<ol>
<li>连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</li>
<li>每当收到一个ACK，cwnd++; 呈线性上升</li>
<li>每当过了一个RTT，cwnd = cwnd*2; 呈指数让升</li>
<li>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</li>
</ol>
<p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。<br><a href="http://idiotsky.me/images1/tcp-something-14.jpg"><img src="http://idiotsky.me/images1/tcp-something-14.jpg" alt=""></a></p>
<p>这里，我需要提一下的是一篇Google的论文《<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf" target="_blank" rel="external">An Argument for Increasing TCP’s Initial Congestion Window</a>》Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。 而Linux 3.0以前，比如2.6，Linux采用了<a href="http://www.rfc-editor.org/rfc/rfc3390.txt" target="_blank" rel="external">RFC3390</a>，cwnd是跟MSS的值来变的，如果MSS&lt; 1095，则cwnd = 4；如果MSS&gt;2190，则cwnd=2；其它情况下，则是3。</p>
<h2 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h2><p>前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p>
<ol>
<li>收到一个ACK时，cwnd = cwnd + 1/cwnd</li>
<li>当每过一个RTT时，cwnd = cwnd + 1</li>
</ol>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<h2 id="拥塞状态时的算法"><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h2><p>前面我们说过，当丢包的时候，会有两种情况：</p>
<ol>
<li>等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。<ul>
<li>sshthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>进入慢启动过程</li>
</ul>
</li>
<li>Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时<ul>
<li>TCP Tahoe的实现和RTO超时一样。</li>
<li>TCP Reno的实现是：<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法——Fast Recovery</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>
<h2 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h2><h3 id="TCP-Reno"><a href="#TCP-Reno" class="headerlink" title="TCP Reno"></a>TCP Reno</h3><p>这个算法定义在<a href="http://tools.ietf.org/html/rfc5681" target="_blank" rel="external">RFC5681</a>。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：</p>
<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
</ul>
<p>然后，真正的Fast Recovery算法如下：</p>
<ul>
<li>cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）</li>
<li>重传Duplicated ACKs指定的数据包</li>
<li>如果再收到 duplicated Acks，那么cwnd = cwnd +1</li>
<li>如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
<p>如果你仔细思考一下上面的这个算法，你就会知道，<strong>上面这个算法也有问题，那就是——它依赖于3个重复的Acks</strong>。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。</p>
<p>通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK（后面会讲）</p>
<h3 id="TCP-New-Reno"><a href="#TCP-New-Reno" class="headerlink" title="TCP New Reno"></a>TCP New Reno</h3><p>于是，1995年，TCP New Reno（参见 <a href="http://tools.ietf.org/html/rfc6582" target="_blank" rel="external">RFC 6582</a> ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的——</p>
<ul>
<li>当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。</li>
<li>一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程</li>
</ul>
<p>我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。</p>
<h2 id="算法示意图"><a href="#算法示意图" class="headerlink" title="算法示意图"></a>算法示意图</h2><p>下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：<br><a href="http://idiotsky.me/images1/tcp-something-15.jpg"><img src="http://idiotsky.me/images1/tcp-something-15.jpg" alt=""></a></p>
<h2 id="FACK算法"><a href="#FACK算法" class="headerlink" title="FACK算法"></a>FACK算法</h2><p>FACK全称Forward Acknowledgment 算法，论文地址在这里（PDF）<a href="http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf" target="_blank" rel="external">Forward Acknowledgement: Refining TCP Congestion Control</a> 这个算法是其于SACK的，前面我们说过SACK是使用了TCP扩展字段Ack了有哪些数据收到，哪些数据没有收到，他比Fast Retransmit的3 个duplicated acks好处在于，前者只知道有包丢了，不知道是一个还是多个，而SACK可以准确的知道有哪些包丢了。 所以，SACK可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK用来做重传过程中的拥塞流控。</p>
<ul>
<li>这个算法会把SACK中最大的Sequence Number 保存在snd.fack这个变量中，snd.fack的更新由ack带秋，如果网络一切安好则和snd.una一样（snd.una就是还没有收到ack的地方，也就是前面sliding window里的category #2的第一个地方）</li>
<li>然后定义一个awnd = snd.nxt – snd.fack（snd.nxt指向发送端sliding window中正在要被发送的地方——前面sliding windows图示的category#3第一个位置），这样awnd的意思就是在网络上的数据。（所谓awnd意为：actual quantity of data outstanding in the network）</li>
<li>如果需要重传数据，那么，awnd = snd.nxt – snd.fack + retran_data，也就是说，awnd是传出去的数据 + 重传的数据。</li>
<li>然后触发Fast Recovery 的条件是： ( ( snd.fack – snd.una ) &gt; (3*MSS) ) || (dupacks == 3) ) 。这样一来，就不需要等到3个duplicated acks才重传，而是只要sack中的最大的一个数据和ack的数据比较长了（3个MSS），那就触发重传。在整个重传过程中cwnd不变。直到当第一次丢包的snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd线性上涨。</li>
</ul>
<p>我们可以看到如果没有FACK在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的window的大小，而需要几个RTT的时间才会完成恢复，而FACK会比较激进地来干这事。 但是，FACK如果在一个网络包会被 reordering的网络里会有很大的问题。</p>
<h1 id="其它拥塞控制算法简介"><a href="#其它拥塞控制算法简介" class="headerlink" title="其它拥塞控制算法简介"></a>其它拥塞控制算法简介</h1><h2 id="TCP-Vegas-拥塞控制算法"><a href="#TCP-Vegas-拥塞控制算法" class="headerlink" title="TCP Vegas 拥塞控制算法"></a>TCP Vegas 拥塞控制算法</h2><p>这个算法1994年被提出，它主要对TCP Reno 做了些修改。这个算法通过对RTT的非常重的监控来计算一个基准RTT。然后通过这个基准RTT来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加cwnd的大小。如果这个计算出来的RTT大于了Timeout后，那么，不等ack超时就直接重传。（Vegas 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《TCP Vegas: End to End Congestion Avoidance on a Global Internet》这篇论文给了Vegas和 New Reno的对比：<br><a href="http://idiotsky.me/images1/tcp-something-16.jpg"><img src="http://idiotsky.me/images1/tcp-something-16.jpg" alt=""></a></p>
<p>关于这个算法实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h" target="_blank" rel="external">/net/ipv4/tcp_vegas.h</a>， <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c" target="_blank" rel="external">/net/ipv4/tcp_vegas.c</a></p>
<h2 id="HSTCP-High-Speed-TCP-算法"><a href="#HSTCP-High-Speed-TCP-算法" class="headerlink" title="HSTCP(High Speed TCP) 算法"></a>HSTCP(High Speed TCP) 算法</h2><p>这个算法来自<a href="http://tools.ietf.org/html/rfc3649" target="_blank" rel="external">RFC 3649</a>（<a href="http://en.wikipedia.org/wiki/HSTCP" target="_blank" rel="external">Wikipedia词条</a>）。其对最基础的算法进行了更改，他使得Congestion Window涨得快，减得慢。其中：</p>
<ul>
<li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li>
<li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li>
</ul>
<p>注：α(cwnd)和β(cwnd)都是函数，如果你要让他们和标准的TCP一样，那么让α(cwnd)=1，β(cwnd)=0.5就可以了。 对于α(cwnd)和β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c" target="_blank" rel="external">/net/ipv4/tcp_highspeed.c</a></p>
<h2 id="TCP-BIC-算法"><a href="#TCP-BIC-算法" class="headerlink" title="TCP BIC 算法"></a>TCP BIC 算法</h2><p>2004年，产内出BIC算法。现在你还可以查得到相关的新闻《Google：<a href="https://www.google.com/search?lr=lang_zh-CN%7Clang_zh-TW&amp;newwindow=1&amp;biw=1366&amp;bih=597&amp;tbs=lr%3Alang_1zh-CN%7Clang_1zh-TW&amp;q=美科学家研发BIC-TCP协议+速度是DSL六千倍&amp;oq=美科学家研发BIC-TCP协议+速度是DSL六千倍" target="_blank" rel="external">美科学家研发BIC-TCP协议 速度是DSL六千倍</a>》 BIC全称<a href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic" target="_blank" rel="external">Binary Increase Congestion control</a>，在Linux 2.6.8中是默认拥塞控制算法。BIC的发明者发这么多的拥塞控制算法都在努力找一个合适的cwnd – Congestion Window，而且BIC-TCP的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以BIC这个算法主要用的是Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看Linux源码：<a href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic" target="_blank" rel="external">/net/ipv4/tcp_bic.c</a></p>
<h2 id="TCP-WestWood算法"><a href="#TCP-WestWood算法" class="headerlink" title="TCP WestWood算法"></a>TCP WestWood算法</h2><p>westwood采用和Reno相同的慢启动算法、拥塞避免算法。westwood的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个RTT时间，会测量一次带宽，测量带宽的公式很简单，就是这段RTT内成功被ack了多少字节。因为，这个带宽和用RTT计算RTO一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送X个字节，而RTT是一个数据发出去后确认需要的时候，所以，X <em> RTT应该是我们缓冲区大小。所以，在这个算法中，ssthresh的值就是est_BD </em> min-RTT(最小的RTT值)，如果丢包是Duplicated ACKs引起的，那么如果cwnd &gt; ssthresh，则 cwin = ssthresh。如果是RTO引起的，cwnd = 1，进入慢启动。   关于这个算法实现，你可以参看Linux源码： <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c" target="_blank" rel="external">/net/ipv4/tcp_westwood.c</a></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>更多的算法，你可以从Wikipedia的 <a href="http://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm" target="_blank" rel="external">TCP Congestion Avoidance Algorithm</a>词条中找到相关的线索</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>好了，到这里我想可以结束了，TCP发展到今天，里面的东西可以写上好几本书。本文主要目的，还是把你带入这些古典的基础技术和知识中，希望本文能让你了解TCP，更希望本文能让你开始有学习这些基础或底层知识的兴趣和信心。</p>
<p>当然，TCP东西太多了，不同的人可能有不同的理解，而且本文可能也会有一些荒谬之言甚至错误，还希望得到您的反馈和批评。</p>
<p>（全文完）</p>
<blockquote>
<p>好长的文章</p>
</blockquote>
<p>from <a href="https://coolshell.cn" target="_blank" rel="external">酷壳</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;tcp看了很多的文章，这篇总结的很好。此文有点长👿&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;tcp在网络OSI的七层模型中的第四层——Transport(传输)层，IP在第三层——Network(网络)层，ARP在第二层——Data Link(数据链路)层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。&lt;/p&gt;
&lt;p&gt;首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。&lt;/p&gt;
&lt;h1 id=&quot;TCP头格式&quot;&gt;&lt;a href=&quot;#TCP头格式&quot; class=&quot;headerlink&quot; title=&quot;TCP头格式&quot;&gt;&lt;/a&gt;TCP头格式&lt;/h1&gt;&lt;p&gt;接下来，我们来看一下TCP头的格式&lt;br&gt;&lt;a href=&quot;http://idiotsky.me/images1/tcp-something-1.jpg&quot;&gt;&lt;img src=&quot;http://idiotsky.me/images1/tcp-something-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;br&gt;你需要注意这么几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。&lt;/li&gt;
&lt;li&gt;一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。&lt;/li&gt;
&lt;li&gt;注意上图中的四个非常重要的东西：&lt;ul&gt;
&lt;li&gt;Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。&lt;/li&gt;
&lt;li&gt;Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。&lt;/li&gt;
&lt;li&gt;Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。&lt;/li&gt;
&lt;li&gt;TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="tcp" scheme="http://idiotsky.me/categories/tcp/"/>
    
    
      <category term="tcp" scheme="http://idiotsky.me/tags/tcp/"/>
    
  </entry>
  
</feed>
