<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="IdiotSky" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="code freak">
<meta property="og:type" content="website">
<meta property="og:title" content="IdiotSky">
<meta property="og:url" content="http://idiotsky.me/page/14/index.html">
<meta property="og:site_name" content="IdiotSky">
<meta property="og:description" content="code freak">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IdiotSky">
<meta name="twitter:description" content="code freak">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '4C652JRMON',
      apiKey: 'ef468e206fb85903f33c4fc8b4bb2cd6',
      indexName: 'myblog',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://idiotsky.me/page/14/"/>





  <title>IdiotSky</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c2da852ee703ae71196b173fd6edef51";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">IdiotSky</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-books">
          <a href="/books/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            Books
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://idiotsky.me/2014/01/11/jquery-on/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ejunjsh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars7.githubusercontent.com/u/22493186?v=4&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IdiotSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/01/11/jquery-on/" itemprop="url">关于jQuery新的事件绑定机制on()的使用技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-01-11T22:30:29+08:00">
                11 Jan 14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jQuery/" itemprop="url" rel="index">
                    <span itemprop="name">jQuery</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>本篇文章介绍了，关于jQuery新的事件绑定机制on()的使用技巧。需要的朋友参考下<br>今天浏览jQuery的deprecated列表，发现live()和die()在里面了，赶紧看了一下，发现从jQuery1.7开始，jQuery引入了全新的事件绑定机制，on()和off()两个函数统一处理事件绑定。因为在此之前有bind(), live(), delegate()等方法来处理事件绑定，jQuery从性能优化以及方式统一方面考虑决定推出新的函数来统一事件绑定方法并且替换掉以前的方法。</p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2014/01/11/jquery-on/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://idiotsky.me/2014/01/06/linux-awk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ejunjsh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars7.githubusercontent.com/u/22493186?v=4&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IdiotSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/01/06/linux-awk/" itemprop="url">linux awk命令详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-01-06T21:53:22+08:00">
                06 Jan 14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux命令/" itemprop="url" rel="index">
                    <span itemprop="name">linux命令</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>
<p>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</p>
<p>awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2014/01/06/linux-awk/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://idiotsky.me/2014/01/05/linux-sed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ejunjsh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars7.githubusercontent.com/u/22493186?v=4&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IdiotSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/01/05/linux-sed/" itemprop="url">linux sed命令详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-01-05T23:53:22+08:00">
                05 Jan 14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux命令/" itemprop="url" rel="index">
                    <span itemprop="name">linux命令</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>功能说明：<br>利用script来处理文本文件。<br>语　　法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed [-hnV][-e script][-f script文件][文本文件]</div></pre></td></tr></table></figure></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2014/01/05/linux-sed/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://idiotsky.me/2014/01/04/linux-grep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ejunjsh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars7.githubusercontent.com/u/22493186?v=4&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IdiotSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/01/04/linux-grep/" itemprop="url">linux grep命令详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-01-04T21:53:22+08:00">
                04 Jan 14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux命令/" itemprop="url" rel="index">
                    <span itemprop="name">linux命令</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<p>Unix的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2014/01/04/linux-grep/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://idiotsky.me/2014/01/04/jquery-bind-delegate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ejunjsh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars7.githubusercontent.com/u/22493186?v=4&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IdiotSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/01/04/jquery-bind-delegate/" itemprop="url">jQuery的.bind()、.live()和.delegate()之间区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-01-04T01:56:51+08:00">
                04 Jan 14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jQuery/" itemprop="url" rel="index">
                    <span itemprop="name">jQuery</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><code>摘要: jQuery的.bind()、.live()和.delegate()之间的区别并非总是那么明显的，然而，如果我们对所有的不同之处都有清晰的理解的话，那么这将会有助于我们编写出更加简洁的代码，以及防止在交互应用中弹出错误。</code></p>
<p><a href="http://idiotsky.me/images/jquery-1.jpg"><img src="http://idiotsky.me/images/jquery-1.jpg" alt=""></a><br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2014/01/04/jquery-bind-delegate/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://idiotsky.me/2014/01/04/threadlocal-understanding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ejunjsh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars7.githubusercontent.com/u/22493186?v=4&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IdiotSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/01/04/threadlocal-understanding/" itemprop="url">正确理解ThreadLocal</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-01-04T01:19:51+08:00">
                04 Jan 14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>首先，ThreadLocal 不是用来解决共享对象的多线程访问问题的，一般情况下，通过ThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的。 各个线程中访问的是不同的对象。  </p>
<p>另外，说ThreadLocal使得各线程能够保持各自独立的一个对象，并不是通过ThreadLocal.set()来实现的，而是通过每个线程中的new 对象 的操作来创建的对象，每个线程创建一个，不是什么对象的拷贝或副本。 通过ThreadLocal.set()将这个新创建的对象的引用保存到各线程的自己的一个map中，每个线程都有这样一个map，执行ThreadLocal.get()时，各线程从自己的map中取出放进去的对象，因此取出来的是各自自己线程中的对象，ThreadLocal实例是作为map的key来使用的。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2014/01/04/threadlocal-understanding/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://idiotsky.me/2014/01/03/linux-vi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ejunjsh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars7.githubusercontent.com/u/22493186?v=4&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IdiotSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/01/03/linux-vi/" itemprop="url">vi/vim 编辑器命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-01-03T22:43:22+08:00">
                03 Jan 14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux命令/" itemprop="url" rel="index">
                    <span itemprop="name">linux命令</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>vi/vim 用法笔记。</p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2014/01/03/linux-vi/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://idiotsky.me/2014/01/01/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ejunjsh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars7.githubusercontent.com/u/22493186?v=4&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IdiotSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/01/01/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-01-01T22:50:58+08:00">
                01 Jan 14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/life/" itemprop="url" rel="index">
                    <span itemprop="name">life</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          The blog is beginning of writing.
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2014/01/01/hello-world/">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://idiotsky.me/2014/01/01/http-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ejunjsh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars7.githubusercontent.com/u/22493186?v=4&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IdiotSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/01/01/http-summary/" itemprop="url">HTTP 总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-01-01T22:50:58+08:00">
                01 Jan 14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/protocol/" itemprop="url" rel="index">
                    <span itemprop="name">protocol</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTTP-基础概述"><a href="#HTTP-基础概述" class="headerlink" title="HTTP 基础概述"></a>HTTP 基础概述</h1><p>Web 使用一种名为 HTTP (HyperText Transfer Protocol，超文本传输协议) 的协议作为规范的。</p>
<blockquote>
<p>HTTP 更加严谨的译名应该是 超文本转移协议。</p>
</blockquote>
<p>HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准，因为被称为 HTTP/0.9<br>HTTP 正式作为标准被公布是 1996 年 5 月，版本命名为 HTTP/1.0，记载于 RFC1945<br>HTTP 在 1997 年 1 月公布了当前最主流的版本，版本命名为 HTTP/1.1，记载于 RFC2616<br>HTTP/2 于 2015 年 5 月 14 日发布，引入了服务器推送等多种功能，是目前最新的版本。记载于 RFC7540<br>(它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3)</p>
<h1 id="HTTP-支持的方法"><a href="#HTTP-支持的方法" class="headerlink" title="HTTP 支持的方法"></a>HTTP 支持的方法</h1><p>HTTP 是一种不保存状态，即 无状态（ stateless ）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这也是为了更快的处理大量事务，确保协议的可伸缩性。</p>
<p>HTTP/1.1 虽然是无状态协议，但是为了实现期望的保持状态的功能，特意引入了 Cookie 技术。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">支持的 HTTP 协议版本</th>
<th style="text-align:center">详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">获取资源</td>
<td style="text-align:center">1.0、1.1</td>
<td style="text-align:center">GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。（我想访问你的某个资源）</td>
</tr>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">传输实体主体</td>
<td style="text-align:center">1.0、1.1</td>
<td style="text-align:center">POST 方法用来传输实体的主体。虽然 GET 也可以传输实体的主体，但一般不用 GET 而用 POST，POST 的主要目的并不是获取响应的主体内容。（我想把这条信息告诉你）</td>
</tr>
<tr>
<td style="text-align:center">PUT</td>
<td style="text-align:center">传输文件</td>
<td style="text-align:center">1.0、1.1</td>
<td style="text-align:center">要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定位置。（我想要把这份文件传给你）</td>
</tr>
<tr>
<td style="text-align:center">HEAD</td>
<td style="text-align:center">获取报文首部</td>
<td style="text-align:center">1.0、1.1</td>
<td style="text-align:center">HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等等（我想要那个相关信息）</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">删除文件</td>
<td style="text-align:center">1.0、1.1</td>
<td style="text-align:center">与 PUT 相反的方法，DELETE 方法按请求 URI 删除指定资源（把这份文件删掉吧）</td>
</tr>
<tr>
<td style="text-align:center">OPTIONS</td>
<td style="text-align:center">询问支持的方法</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">OPTIONS 用来查询针对请求 URI 指定的资源支持的方法（你支持哪些方法？）</td>
</tr>
<tr>
<td style="text-align:center">TRACE</td>
<td style="text-align:center">追踪路径</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">TRACE 方法是让 Web 服务器将之前的请求通信返回给客户端的方法，TRACE 方法不常用，并且容易引发 XST ( Cross-Site-Tracing ，跨站追踪)攻击，所以通常更不会用到了</td>
</tr>
<tr>
<td style="text-align:center">CONNECT</td>
<td style="text-align:center">要求用隧道协议连接代理</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信，主要使用 SSL （ Secure Sockets Layers ，安全套接层）和 TLS （ Transport Layer Security ，传输层安全）协议把通信内容加密后经网络隧道传输</td>
</tr>
<tr>
<td style="text-align:center">PATCH</td>
<td style="text-align:center">更新部分文件内容</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center"><strong>当资源存在的时候</strong>，PATCH 用于资源的部分内容的更新，例如更新某一个字段。具体比如说只更新用户信息的电话号码字段，而 PUT 用于更新某个资源较完整的内容，比如说用户要重填完整表单更新所有信息，后台处理更新时可能只是保留内部记录 ID 不变。<br><strong>当资源不存在的时候</strong>，PATCH 是修改原来的内容，也可能会产生一个新的版本。比如当资源不存在的时候，PATCH 可能会去创建一个新的资源，这个意义上像是 saveOrUpdate 操作。而 PUT 只对已有资源进行更新操作，所以是 update 操作</td>
</tr>
<tr>
<td style="text-align:center">LINK</td>
<td style="text-align:center">建立和资源之间的联系</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">✖︎最新版中已经废弃✖︎</td>
</tr>
<tr>
<td style="text-align:center">UNLINK</td>
<td style="text-align:center">断开连接关系</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">✖︎最新版中已经废弃✖︎</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">PROPFIND</td>
<td style="text-align:center">获取属性</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">WebDAV 获取属性</td>
</tr>
<tr>
<td style="text-align:center">PROPPATCH</td>
<td style="text-align:center">修改属性</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">WebDAV 修改属性</td>
</tr>
<tr>
<td style="text-align:center">MKCOL</td>
<td style="text-align:center">创建属性</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">WebDAV 创建属性</td>
</tr>
<tr>
<td style="text-align:center">COPY</td>
<td style="text-align:center">复制资源及属性</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">WebDAV 复制资源及属性</td>
</tr>
<tr>
<td style="text-align:center">MOVE</td>
<td style="text-align:center">移动资源</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">WebDAV 移动资源</td>
</tr>
<tr>
<td style="text-align:center">LOCK</td>
<td style="text-align:center">资源加锁</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">WebDAV 资源加锁</td>
</tr>
<tr>
<td style="text-align:center">UNLOCK</td>
<td style="text-align:center">资源解锁</td>
<td style="text-align:center">1.1</td>
<td style="text-align:center">WebDAV 资源解锁</td>
</tr>
</tbody>
</table>
<p>在HTTP/1.1规范中幂等性的定义是：</p>
<blockquote>
<p>Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</p>
</blockquote>
<p>从定义上看，HTTP 方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP 规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而 HTTP 的分布式本质也决定了它在 HTTP 中具有重要地位。</p>
<p>HTTP 方法的安全性指的是不会改变服务器状态，也就是说它只是可读的。所以只有 OPTIONS、GET、HEAD 是安全的，其他都是不安全的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">HTTP 方法</th>
<th style="text-align:center">幂等性</th>
<th style="text-align:center">安全性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OPTIONS</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">HEAD</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td style="text-align:center">PUT</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
</tr>
<tr>
<td style="text-align:center">PATCH</td>
<td style="text-align:center">no</td>
<td style="text-align:center">no</td>
</tr>
</tbody>
</table>
<p><strong>POST 和 PATCH 这两个不是幂等性的</strong>。<br>两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI。<br>对同一URI进行多次PUT的副作用和一次PUT是相同的。  </p>
<h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><p>服务器返回的  <strong>响应报文</strong>  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">类别</th>
<th style="text-align:center">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">Informational（信息性状态码）</td>
<td style="text-align:center">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<h2 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h2><ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul>
<li><p><strong>200 OK</strong> </p>
</li>
<li><p><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p>
</li>
<li><p><strong>206 Partial Content</strong> ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。</p>
</li>
</ul>
<h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul>
<li><p><strong>301 Moved Permanently</strong> ：永久性重定向</p>
</li>
<li><p><strong>302 Found</strong> ：临时性重定向</p>
</li>
<li><p><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p>
</li>
<li><p>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p>
</li>
<li><p><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p>
</li>
<li><p><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p>
</li>
</ul>
<h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul>
<li><p><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</p>
</li>
<li><p><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p>
</li>
<li><p><strong>403 Forbidden</strong> ：请求被拒绝，服务器端没有必要给出拒绝的详细理由。</p>
</li>
<li><p><strong>404 Not Found</strong> </p>
</li>
</ul>
<h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul>
<li><p><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</p>
</li>
<li><p><strong>503 Service Unavilable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
</li>
</ul>
<hr>
<h2 id="RFC-2616-状态码"><a href="#RFC-2616-状态码" class="headerlink" title="RFC 2616 状态码"></a>RFC 2616 状态码</h2><table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">类别</th>
<th style="text-align:center">原因短语</th>
<th style="text-align:center">含义</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">Informational（信息性状态码）</td>
<td style="text-align:center">Continue（继续）</td>
<td style="text-align:center">收到了请求的起始部分，客户端应该继续请求。</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center">101</td>
<td style="text-align:center">Informational（信息性状态码）</td>
<td style="text-align:center">Switching Protocols（切换协议）</td>
<td style="text-align:center">服务器正根据客户端的指示将协议切换成 Update 首部列出的协议。</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">200</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">OK</td>
<td style="text-align:center">服务器已成功处理请求</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center">201</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">Created（已创建）</td>
<td style="text-align:center">对那些要服务器创建对象的请求来说，资源已创建完毕</td>
</tr>
<tr>
<td style="text-align:center">202</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">Accepted（已接受）</td>
<td style="text-align:center">请求已接受，但服务器尚未处理</td>
</tr>
<tr>
<td style="text-align:center">203</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">Non-Authoritative Information（非权威信息）</td>
<td style="text-align:center">服务器已将事务成功处理，只是实体首部包含的信息不是来自原始服务器，而是来自资源的副本</td>
</tr>
<tr>
<td style="text-align:center">204</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">No Content（没有内容）</td>
<td style="text-align:center">响应报文包含一些首部和一个状态行，<strong>但不包含实体的主体内容</strong>，<strong>一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用</strong></td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center">205</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">Reset Content（重置内容）</td>
<td style="text-align:center">另一个主要用于浏览器的代码。意思是浏览器应该重置当前页面上所有的 HTML 表单</td>
</tr>
<tr>
<td style="text-align:center">206</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">Partial Content（部分内容）</td>
<td style="text-align:center">成功执行了一个部分或者 Range (范围)请求，客户端可以通过一些特殊的首部来获取部分或某个范围内的文档<br><strong>响应报文中包含由 Content-Range、Date、以及 ETag 或者 Content-Location 指定范围的实体内容</strong></td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">300</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">Multiple Choices（多项选择）</td>
<td style="text-align:center">客户端请求了实际指向多个资源的 URL。这个代码是和一个选项列表一起返回的，然后用户就可以选择他希望使用的选项了。服务器可以在 Location 首部包含首选 URL</td>
</tr>
<tr>
<td style="text-align:center">301</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">Moved Permanently（永久移除）</td>
<td style="text-align:center"><strong>永久性重定向</strong>，请求的 URL 已移走。响应中应该包含一个 Location URL，说明资源现在所处的位置</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center">302</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">Found（已找到）</td>
<td style="text-align:center"><strong>临时性重定向</strong>，与状态码 301 类似， 但这里的移除是临时的。客户端应该用 Location 首部给出的 URL 对资源进行临时定位</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center">303</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">See Other（参见其他）</td>
<td style="text-align:center">告诉客户端应该用另一个 URL 获取资源。这个新的 URL 位于响应报文的 Location 首部。303 状态码 和 302 状态码有相同的功能，<strong>但是 303 明确表示客户端应采用 GET 方法获取资源</strong>。</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。<br>301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">304</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">Not Modified（未修改）</td>
<td style="text-align:center">该状态码表示客户端发送附带条件的请求时，服务器允许请求访问资源，但因发生请求未满足条件的情况后，直接返回 304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）304 状态码返回时，不包含任何响应的主体部分。<strong>304 虽然被划分在 3XX 类别中，但是和重定向一点关系也没有</strong></td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">（附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since,If-None-Match，If-Range，If-Unmodified-Since 中任一首部）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">305</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">Use Proxy（使用代理）</td>
<td style="text-align:center">必须通过代理访问 资源，代理的位置是在 Location 首部中给出的</td>
</tr>
<tr>
<td style="text-align:center">306</td>
<td style="text-align:center">（未使用）</td>
<td style="text-align:center"></td>
<td style="text-align:center">这个状态码当前并未使用</td>
</tr>
<tr>
<td style="text-align:center">307</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">Temporary Redirect（临时重定向）</td>
<td style="text-align:center">和状态码 302 类似。但客户端应该用 Location 首部给出的 URL 对资源进行临时定位。<br>307 会遵守浏览器标准，不会从 POST 变成 GET</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">400</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Bad request（坏请求）</td>
<td style="text-align:center">告诉客户端它发送了一条异常请求</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center">401</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Unauthorized（未授权）</td>
<td style="text-align:center">与适当的首部一起返回，在客户端获得资源访问权之前，请它进行身份认证</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center">402</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Payment Required（要求付款）</td>
<td style="text-align:center">当前此状态码并未使用，是为未来使用预留的</td>
</tr>
<tr>
<td style="text-align:center">403</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Forbidden（禁止）</td>
<td style="text-align:center">服务器拒绝了请求</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center">404</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Not Found（未找到）</td>
<td style="text-align:center">服务器无法找到 所请求的 URL</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center">405</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Method Not Allowed（不允许使用的方法）</td>
<td style="text-align:center">请求中有一个所请求的 URI 不支持的方法。响应中应该包含一个 Allow 首部，以告知客户端所请求的资源支持使用哪些方法</td>
</tr>
<tr>
<td style="text-align:center">406</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Not Acceptable（无法接受）</td>
<td style="text-align:center">客户端可以指定一些参数来说明希望接受哪些类型的实体。服务器没有资源与客户端可接受的 URL 相匹配时可使用此代码</td>
</tr>
<tr>
<td style="text-align:center">407</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Proxy Authentication Required（要求进行代理认证）</td>
<td style="text-align:center">和状态码 401 类似，但用于需要进行资源认证的代理服务器</td>
</tr>
<tr>
<td style="text-align:center">408</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Request Timeout（请求超时）</td>
<td style="text-align:center">如果客户端完成其请求时花费的时间太长，服务器可以回送这个状态码并关闭连接</td>
</tr>
<tr>
<td style="text-align:center">409</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Conflict（ 冲突）</td>
<td style="text-align:center">发出的请求在资源上造成了一些冲突</td>
</tr>
<tr>
<td style="text-align:center">410</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Gone（消失了）</td>
<td style="text-align:center">除了服务器曾持有这些资源之外，与状态码 404 类似</td>
</tr>
<tr>
<td style="text-align:center">411</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Length Required（要求长度指示）</td>
<td style="text-align:center">服务器要求在请求报文中包含 Content- Length 首部时会使用这个代码。发起的请求中若没有 Content-Length 首部，服务器 是不会接受此资源请求的</td>
</tr>
<tr>
<td style="text-align:center">412</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Precondition Failed（先决条件失败）</td>
<td style="text-align:center">如果客户端发起了一个条件请求， 如果服务器无法满足其中的某个条件，就返回这个响应码</td>
</tr>
<tr>
<td style="text-align:center">413</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Request Entity Too Large（请求实体太大）</td>
<td style="text-align:center">客户端发送的实体主体部分比 服务器能够或者希望处理的要大</td>
</tr>
<tr>
<td style="text-align:center">414</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Request URI Too Long（请求 URI 太长）</td>
<td style="text-align:center">客户端发送的请求所携带的请求 URL 超过了服务器能够或者希望处理的长度</td>
</tr>
<tr>
<td style="text-align:center">415</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Unsupported Media Type（不支持的媒体类型）</td>
<td style="text-align:center">服务器无法理解或不支持客户端所发送的实体的内容类型</td>
</tr>
<tr>
<td style="text-align:center">416</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Requested Range Not Satisfiable（所请求的范围未得到满足）</td>
<td style="text-align:center">请求报文请求的是某范围内的指定资源，但那个范围无效，或者未得到满足</td>
</tr>
<tr>
<td style="text-align:center">417</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Expectation Failed（无法满足期望）</td>
<td style="text-align:center">请求的 Expect 首部包含了一个预期内容，但服务器无法满足</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">500</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">Internal Server Error（内部服务器错误）</td>
<td style="text-align:center">服务器遇到了一个错误，使其无法为请求提供服务</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center">501</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">Not Implemented（未实现）</td>
<td style="text-align:center">服务器无法满足客户端请求的某个功能</td>
</tr>
<tr>
<td style="text-align:center">502</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">Bad Gateway（网关故障）</td>
<td style="text-align:center">作为代理或网关使用的服务器遇到了来自响应链中上游的无效响应</td>
</tr>
<tr>
<td style="text-align:center">503</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">Service Unavailable（未提供此服务）</td>
<td style="text-align:center">服务器目前无法为请求提供服务，但过一段时间就可以恢复服务</td>
<td style="text-align:center">❤</td>
</tr>
<tr>
<td style="text-align:center">504</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">Gateway Timeout（网关超时）</td>
<td style="text-align:center">与状态码 408 类似，但是响应来自网关或代理，此网关或代理在等待另一台服务器的响应时出现了超时</td>
</tr>
<tr>
<td style="text-align:center">505</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">HTTP Version Not Supported（不支持的 HTTP 版本）</td>
<td style="text-align:center">服务器收到的请求是以它不支持或不愿支持的协议版本表示的</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在 RFC2616 中定义了 40 种 HTTP 状态码，webDAV ( Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制)在 RFC4918 和 RFC5842 中，定义了一些特殊的状态码，在 RFC2518、RFC2817、RFC2295、RFC2774、RFC6585 中还额外定义了一些附加的 HTTP 状态码。总共有 60+ 种。具体链接可以见 <a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="external">HTTP状态码 (wikipedia)</a></p>
</blockquote>
<p>webDAV 新增状态码</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">类别</th>
<th style="text-align:center">原因短语</th>
<th style="text-align:center">含义</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">102</td>
<td style="text-align:center">Informational（信息性状态码）</td>
<td style="text-align:center">Processing（处理中）</td>
<td style="text-align:center">可正常处理请求，但目前是处理中状态。WebDAV请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示​​服务器已经收到并正在处理请求，但无响应可用。这样可以防止客户端超时，并假设请求丢失。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">207</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">Multi-Status（多种状态）</td>
<td style="text-align:center">存在多种状态。代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">208</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">Already Reported（已经响应）</td>
<td style="text-align:center">DAV绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">422</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Unprocessable Entity（不可处理的实体）</td>
<td style="text-align:center">格式正确，内容有误，无法处理响应</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">423</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Locked（被锁定）</td>
<td style="text-align:center">资源已被加锁</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">424</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">Failed Dependency（失败的依赖）</td>
<td style="text-align:center">处理与某请求关联的请求失败，因为不再维持依赖关系。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">507</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">Insufficient Storage（存储空间不足）</td>
<td style="text-align:center">服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">508</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">Loop Detected（检测到环）</td>
<td style="text-align:center">服务器在处理请求时陷入死循环。</td>
</tr>
</tbody>
</table>
<h1 id="MIME-媒体内容"><a href="#MIME-媒体内容" class="headerlink" title="MIME 媒体内容"></a>MIME 媒体内容</h1><p>HTTP 仔细地给每种要通过 Web 传输的对象都打上了名为 MIME 类型（MIME type）的数据格式标签。最初设计 MIME（Multipurpose Internet Mail Extension，多用途因特网邮件扩展）是为了解决在不同的电子邮件系统之间搬移报文时存在的问题。MIME 在电子邮件系统中工作得非常好，因此 HTTP 也采纳了它，用它来描述并标记多媒体内容。</p>
<p>RFC2045，“ MIME: Format of Internet Message Bodies”（“ MIME：因特网报文主体的格式”）</p>
<p>常见的主 MIME 类型</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">application</td>
<td style="text-align:center">应用程序特有的内容格式（离散类型）</td>
</tr>
<tr>
<td style="text-align:center">audio</td>
<td style="text-align:center">音频格式（离散类型）</td>
</tr>
<tr>
<td style="text-align:center">chemical</td>
<td style="text-align:center">化学数据集（离散 IETF 扩展类型）</td>
</tr>
<tr>
<td style="text-align:center">image</td>
<td style="text-align:center">图片格式（离散类型）</td>
</tr>
<tr>
<td style="text-align:center">message</td>
<td style="text-align:center">报文格式（复合类型）</td>
</tr>
<tr>
<td style="text-align:center">model</td>
<td style="text-align:center">三维模型格式（离散 IETF 扩展类型）</td>
</tr>
<tr>
<td style="text-align:center">multipart</td>
<td style="text-align:center">多部分对象集合（复合类型）</td>
</tr>
<tr>
<td style="text-align:center">text</td>
<td style="text-align:center">文本格式（离散类型）</td>
</tr>
<tr>
<td style="text-align:center">video</td>
<td style="text-align:center">视频电影格式（离散类型）</td>
</tr>
</tbody>
</table>
<h1 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h1><p><a href="http://idiotsky.me/images3/http-summary-1.png"><img src="http://idiotsky.me/images3/http-summary-1.png" alt=""></a></p>
<p><a href="http://idiotsky.me/images3/http-summary-2.png"><img src="http://idiotsky.me/images3/http-summary-2.png" alt=""></a></p>
<p><a href="http://idiotsky.me/images3/http-summary-3.png"><img src="http://idiotsky.me/images3/http-summary-3.png" alt=""></a></p>
<p><a href="http://idiotsky.me/images3/http-summary-4.png"><img src="http://idiotsky.me/images3/http-summary-4.png" alt=""></a></p>
<p>Response Headers:</p>
<p><a href="http://idiotsky.me/images3/http-summary-5.png"><img src="http://idiotsky.me/images3/http-summary-5.png" alt=""></a></p>
<p>Request Headers:</p>
<p><a href="http://idiotsky.me/images3/http-summary-6.png"><img src="http://idiotsky.me/images3/http-summary-6.png" alt=""></a></p>
<p>请求报文是由请求方法，请求 URI，协议版本，可选请求首部字段和内容实体构成的。</p>
<p>响应报文基本上由协议版本，状态码（表示请求成功与失败的数字代码），用以解释状态码的原因短语，可选的响应首部字段以及实体主体构成。</p>
<h2 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h2><table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center">控制缓存的行为，用于随报文传送缓存的指示</td>
</tr>
<tr>
<td style="text-align:center">Connection</td>
<td style="text-align:center">允许客户端和服务器指定与请求/响应连接有关的选项</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">提供日期和时间标志，说明报文是什么时间创建的</td>
</tr>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">报文指令，另一种随报文传送指示的方式，但并不专用于缓存。Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。如果想要所有的服务器保持相同的行为，可以考虑发送 Pragma 指令。例如：Pragma: no-cache Cache-Control: no-cache</td>
</tr>
<tr>
<td style="text-align:center">MIME-Version</td>
<td style="text-align:center">给出了发送端使用的 MIME 版本</td>
</tr>
<tr>
<td style="text-align:center">Trailer</td>
<td style="text-align:center">如果报文采用了分块传输编码（chunked transfer encoding）方式，就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合</td>
</tr>
<tr>
<td style="text-align:center">Transfer- Encoding</td>
<td style="text-align:center">告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式</td>
</tr>
<tr>
<td style="text-align:center">Update</td>
<td style="text-align:center">给出了发送端可能想要 “升级” 使用的新版本或协议</td>
</tr>
<tr>
<td style="text-align:center">Via</td>
<td style="text-align:center">显示了报文经过的中间节点（代理、网关）</td>
</tr>
<tr>
<td style="text-align:center">Warning</td>
<td style="text-align:center">错误通知</td>
</tr>
</tbody>
</table>
<p>Cache-Control 首部功能很强大。服务器和客户端都可以用它来说明新鲜度，并且除了使用期或过期时间之外，还有很多指令可用。 </p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">报文类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">no-cache</td>
<td style="text-align:center"></td>
<td style="text-align:center">请求</td>
<td style="text-align:center">在重新向服务器验证之前，不要返回文档的缓存副本</td>
</tr>
<tr>
<td style="text-align:center">no-store</td>
<td style="text-align:center"></td>
<td style="text-align:center">请求</td>
<td style="text-align:center">不要返回文档的缓存副本。不要保存服务器的响应</td>
</tr>
<tr>
<td style="text-align:center">max-age = [秒]</td>
<td style="text-align:center">必须</td>
<td style="text-align:center">请求</td>
<td style="text-align:center">缓存中的文档不能超过指定的使用期</td>
</tr>
<tr>
<td style="text-align:center">max-stale ( = [秒])</td>
<td style="text-align:center">可省略</td>
<td style="text-align:center">请求</td>
<td style="text-align:center">文档允许过期（根据服务器提供的过期信息计算），但不能超过指令中指定的过期值</td>
</tr>
<tr>
<td style="text-align:center">min-fresh = [秒]</td>
<td style="text-align:center">必须</td>
<td style="text-align:center">请求</td>
<td style="text-align:center">文档的使用期不能小于这个指定的时间与它的当前存活时间之和。换句话说，响应必须至少在指定的这段时间之内保持新鲜</td>
</tr>
<tr>
<td style="text-align:center">no-transform</td>
<td style="text-align:center"></td>
<td style="text-align:center">请求</td>
<td style="text-align:center">文档在发送之前不允许被转换</td>
</tr>
<tr>
<td style="text-align:center">only-if-cached</td>
<td style="text-align:center"></td>
<td style="text-align:center">请求</td>
<td style="text-align:center">只有当文档在缓存中才发送，不要联系原始服务器</td>
</tr>
<tr>
<td style="text-align:center">cache-extension</td>
<td style="text-align:center"></td>
<td style="text-align:center">请求</td>
<td style="text-align:center">新指令标记（token）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center"></td>
<td style="text-align:center">响应</td>
<td style="text-align:center">响应可以被任何服务器缓存</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">可省略</td>
<td style="text-align:center">响应</td>
<td style="text-align:center">响应可以被缓存，但只能被单个客户端访问</td>
</tr>
<tr>
<td style="text-align:center">no-cache</td>
<td style="text-align:center">可省略</td>
<td style="text-align:center">响应</td>
<td style="text-align:center">如果该指令伴随一个首部列表的话，那么内容可以被缓存并提供给客户端，但必须先删除所列出的首部。如果没有指定首部，缓存中的副本在没有重新向服务器验证之前不能提供给客户端</td>
</tr>
<tr>
<td style="text-align:center">no-store</td>
<td style="text-align:center"></td>
<td style="text-align:center">响应</td>
<td style="text-align:center">响应不允许被缓存</td>
</tr>
<tr>
<td style="text-align:center">no-transform</td>
<td style="text-align:center"></td>
<td style="text-align:center">响应</td>
<td style="text-align:center">响应在提供给客户端之前不能做任何形式的修改</td>
</tr>
<tr>
<td style="text-align:center">must-revalidate</td>
<td style="text-align:center"></td>
<td style="text-align:center">响应</td>
<td style="text-align:center">响应在提供给客户端之前必须重新向服务器验证</td>
</tr>
<tr>
<td style="text-align:center">proxy-revalidate</td>
<td style="text-align:center"></td>
<td style="text-align:center">响应</td>
<td style="text-align:center">共享的缓存在提供给客户端之前必须重新向原始服务器验证。私有的缓存可以忽略这条指令</td>
</tr>
<tr>
<td style="text-align:center">max-age = [秒]</td>
<td style="text-align:center">必须</td>
<td style="text-align:center">响应</td>
<td style="text-align:center">指定文档可以被缓存的时间以及新鲜度的最长时间</td>
</tr>
<tr>
<td style="text-align:center">s-max-age = [秒]</td>
<td style="text-align:center">必须</td>
<td style="text-align:center">响应</td>
<td style="text-align:center">指定文档作为共享缓存时的最长使用时间（如果有 max-age 指令的话，以本指令为准）。私有的缓存可以忽略本指令</td>
</tr>
<tr>
<td style="text-align:center">cache-extension</td>
<td style="text-align:center"></td>
<td style="text-align:center">响应</td>
<td style="text-align:center">新指令标记（token）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>no-cache 和 no-store 的区别：no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后再处理资源。no-store 才是真正的不缓存。</p>
</blockquote>
<p>no-cache 并不代表完全的禁用缓存，而是代表会每次去核对服务端的 Etag，如果相同，那么就不会去服务端下载完整的资源，返回一个 304 Not Modified。（最长缓存 3 年）</p>
<p>no-store 才是真正的禁用缓存，它表示每次服务端都会去下载最新的资源。（当然，通常似乎都用不上）。</p>
<p>public 和 private 的差别主要在于如果是有用户认证环节的页面，设置为private 就只有终端浏览器会缓存，中间 CDN 并不会缓存，而设置为 public，则会在每一个环节缓存。默认不需要设置 public，因为 max-age 已经表明可以由各个环节缓存了（单位为秒）。此刻如果命中缓存，则不会再去请求服务器核对 Etag，而是直接返回 200(from disk)。</p>
<p>当然，由于 public 会在每一个环节缓存，如果对修改更新预览又强需求的网页，那么最好不要使用这一缓存策略，否则还需要刷新 CDN 源，很麻烦。</p>
<p>如果挑选缓存策略，可以见下图：</p>
<p><a href="http://idiotsky.me/images3/http-summary-7.png"><img src="http://idiotsky.me/images3/http-summary-7.png" alt=""></a></p>
<h1 id="HTTP-缓存控制"><a href="#HTTP-缓存控制" class="headerlink" title="HTTP 缓存控制"></a>HTTP 缓存控制</h1><p><a href="http://idiotsky.me/images3/http-summary-8.png"><img src="http://idiotsky.me/images3/http-summary-8.png" alt=""></a></p>
<p>针对“Expires 时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1 新增了 Cache-Control 来定义缓存过期时间。注意：若报文中同时出现了 Expires 和 Cache-Control，则以 Cache-Control 为准。</p>
<p>也就是说优先级从高到低分别是 <strong>Pragma -&gt; Cache-Control -&gt; Expires</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">头部</th>
<th style="text-align:center">优势和特点</th>
<th style="text-align:center">劣势和问题</th>
<th style="text-align:center">额外说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Expires</td>
<td style="text-align:center">1、HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。<br>2、以时刻标识失效时间。</td>
<td style="text-align:center">1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。<br>2、存在版本问题，到期之前的修改客户端是不可知的。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center">1、HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。<br>2、比Expires多了很多选项设置。</td>
<td style="text-align:center">1、HTTP 1.1 才有的内容，不适用于HTTP 1.0 。<br>2、存在版本问题，到期之前的修改客户端是不可知的。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Last-Modified</td>
<td style="text-align:center">1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。</td>
<td style="text-align:center">1、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。<br>2、以时刻作为标识，无法识别一秒内进行多次修改的情况。<br>3、某些服务器不能精确的得到文件的最后修改时间。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">ETag</td>
<td style="text-align:center">1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。<br>2、不存在版本问题，每次请求都回去服务器进行校验。</td>
<td style="text-align:center">1、计算ETag值需要性能损耗。<br>2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现ETag不匹配的情况。</td>
</tr>
</tbody>
</table>
<p>1、Expires / Cache-Control<br>Expires用时刻来标识失效时间，不免收到时间同步的影响，而Cache-Control使用时间间隔很好的解决了这个问题。 但是 Cache-Control 是 HTTP1.1 才有的，不适用于 HTTP1.0，而 Expires 既适用于 HTTP1.0，也适用于 HTTP1.1，所以说在大多数情况下同时发送这两个头会是一个更好的选择，当客户端两种头都能解析的时候，<strong>会优先使用 Cache-Control</strong>。</p>
<p>2、Last-Modified / ETag<br>二者都是通过某个标识值来请求资源， 如果服务器端的资源没有变化，则自动返回 HTTP 304 （Not Changed）状态码，内容为空，这样就节省了传输数据量。而当资源发生比那话后，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。<br>其中 Last-Modified 使用文件最后修改作为文件标识值，它无法处理文件一秒内多次修改的情况，而且只要文件修改了哪怕文件实质内容没有修改，也会重新返回资源内容；ETag 作为“被请求变量的实体值”，其完全可以解决 Last-Modified 头部的问题，但是其计算过程需要耗费服务器资源。</p>
<p>3、from-cache / 304<br>Expires 和 Cache-Control 都有一个问题就是服务端作为的修改，如果还在缓存时效里，那么客户端是不会去请求服务端资源的（非刷新），这就存在一个资源版本不符的问题，而强制刷新一定会发起 HTTP 请求并返回资源内容，无论该内容在这段时间内是否修改过；<strong>而 Last-Modified 和 Etag 每次请求资源都会发起请求，哪怕是很久都不会有修改的资源，都至少有一次请求响应的消耗</strong>。</p>
<p>对于所有可缓存资源，指定一个 Expires 或 Cache-Control max-age 以及一个 Last-Modified 或 ETag 至关重要。同时使用前者和后者可以很好的相互适应。<br><strong>前者不需要每次都发起一次请求来校验资源时效性，后者保证当资源未出现修改的时候不需要重新发送该资源</strong>。而在用户的不同刷新页面行为中，二者的结合也能很好的利用 HTTP 缓存控制特性，无论是在地址栏输入 URI 然后输入回车进行访问，还是点击刷新按钮，浏览器都能充分利用缓存内容，避免进行不必要的请求与数据传输。</p>
<p>4、避免 304</p>
<p>做法实际上很简单，<strong>它把服务侧 ETag 的那一套理论搬到了前端来使用</strong>。 页面的静态资源以版本形式发布，常用的方法是在文件名或参数带上一串md5或时间标记符：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">https://hm.baidu.com/hm.js?e23800c454aa573c0ccb16b52665ac26</div><div class="line">http://tb1.bdstatic.com/tb/_/tbean_safe_ajax_94e7ca2.js</div><div class="line">http://img1.gtimg.com/ninja/2/2016/04/ninja145972803357449.jpg</div></pre></td></tr></table></figure>
<p>可以看到上面的例子中有不同的做法，有的在URI后面加上了md5参数，有的将md5值作为文件名的一部分，有的将资源放在特性版本的目录中。</p>
<p>那么在文件没有变动的时候，浏览器不用发起请求直接可以使用缓存文件；而在文件有变化的时候，由于文件版本号的变更，导致文件名变化，请求的 url 变了，自然文件就更新了。这样能确保客户端能及时从服务器收取到新修改的文件。通过这样的处理，增长了静态资源，特别是图片资源的缓存时间，避免该资源很快过期，客户端频繁向服务端发起资源请求，服务器再返回 304 响应的情况（有 Last-Modified/Etag）。</p>
<p><a href="http://idiotsky.me/images3/http-summary-9.png"><img src="http://idiotsky.me/images3/http-summary-9.png" alt=""></a></p>
<table>
<thead>
<tr>
<th style="text-align:center">用户操作</th>
<th style="text-align:center">HTTP 状态码</th>
<th style="text-align:center">原因</th>
<th style="text-align:center">额外说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">在URI输入栏中输入然后回车</td>
<td style="text-align:center">200(from cache)</td>
<td style="text-align:center">由 Expires / Cache-Control 控制，Expires 是绝对时间，Cache-Control 是相对时间，两者都存在的时候，Cache-Control 覆盖 Expires ，只要没有失效，浏览器都只访问自己的缓存</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">F5/点击工具栏中的刷新按钮/右键菜单重新加载</td>
<td style="text-align:center">304</td>
<td style="text-align:center">由 Last-Modified/Etag 控制，当用户本地缓存失效，刷新的时候，浏览器会发送请求给服务器，如果服务端没有变化，则返回 304 给浏览器</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Ctl+F5</td>
<td style="text-align:center">200</td>
<td style="text-align:center">当本地浏览器没有缓存或者 304 返回的资源也失效的时候，或者用户强制 Ctl+F5 刷新的时候，浏览器最终才会去下载最新的数据</td>
</tr>
</tbody>
</table>
<p>总结：</p>
<ul>
<li>需要兼容 HTTP1.0 的时候需要使用 Expires，不然可以考虑直接使用 Cache-Control。</li>
<li>需要处理一秒内多次修改的情况，或者其他 Last-Modified 处理不了的情况，才使用 ETag，否则使用 Last-Modified。</li>
<li>对于所有可缓存资源，需要指定一个 Expires 或 Cache-Control，同时指定 Last-Modified 或者 Etag。</li>
<li>可以通过标识文件版本名、加长缓存时间的方式来减少 304 响应。</li>
</ul>
<hr>
<p>Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。</p>
<p>Warning 首部的格式如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Warning</span>: [警告码][警告的主机：端口号]"[警告内容]"([日期内容])</div></pre></td></tr></table></figure>
<p>HTTP/1.1 中定义了 7 种警告，警告码具备扩展性，今后可以能追加新的警告码。</p>
<table>
<thead>
<tr>
<th style="text-align:center">警告码</th>
<th style="text-align:center">警告内容</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">110</td>
<td style="text-align:center">Response is stale（响应已过期）</td>
<td style="text-align:center">代理返回已过期的资源</td>
</tr>
<tr>
<td style="text-align:center">111</td>
<td style="text-align:center">Revalidation failed（再验证失败）</td>
<td style="text-align:center">代理再验证资源有效性时失败（服务器无法到达等原因）</td>
</tr>
<tr>
<td style="text-align:center">112</td>
<td style="text-align:center">Disconnection operation（断开连接操作）</td>
<td style="text-align:center">代理与互联网连接被故意切断</td>
</tr>
<tr>
<td style="text-align:center">113</td>
<td style="text-align:center">Heuristic expiration（试探性过期）</td>
<td style="text-align:center">响应的使用期超过 24 小时（有效缓存的设定时间大于 24 小时的情况下）</td>
</tr>
<tr>
<td style="text-align:center">199</td>
<td style="text-align:center">Miscellaneous warning（杂项警告）</td>
<td style="text-align:center">任意的警告内容</td>
</tr>
<tr>
<td style="text-align:center">214</td>
<td style="text-align:center">Transformation applied（使用了转换）</td>
<td style="text-align:center">代理对内容编码或媒体类型等执行了某些处理时</td>
</tr>
<tr>
<td style="text-align:center">299</td>
<td style="text-align:center">Miscellaneous persistent warning（持久杂项警告）</td>
<td style="text-align:center">任意的警告内容</td>
</tr>
</tbody>
</table>
<h1 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h1><h2 id="请求信息性首部"><a href="#请求信息性首部" class="headerlink" title="请求信息性首部"></a>请求信息性首部</h2><table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Client-IP4</td>
<td style="text-align:center">提供了运行客户端的机器的 IP 地址</td>
</tr>
<tr>
<td style="text-align:center">From</td>
<td style="text-align:center">提供了客户端用户的 E-mail 地址</td>
</tr>
<tr>
<td style="text-align:center">Host</td>
<td style="text-align:center">给出了接收请求的服务器的主机名和端口号</td>
</tr>
<tr>
<td style="text-align:center">Referer</td>
<td style="text-align:center">提供了包含当前请求 URI 的文档的 URL（正确的拼写其实应该是Referrer ，大家一致沿用错误至今）</td>
</tr>
<tr>
<td style="text-align:center">UA-Color</td>
<td style="text-align:center">提供了与客户端显示器的显示颜色有关的信息</td>
</tr>
<tr>
<td style="text-align:center">UA-CPU</td>
<td style="text-align:center">给出了客户端 CPU 的类型或制造商</td>
</tr>
<tr>
<td style="text-align:center">UA-Disp</td>
<td style="text-align:center">提供了与客户端显示器（屏幕）能力有关的信息</td>
</tr>
<tr>
<td style="text-align:center">UA-OS</td>
<td style="text-align:center">给出了运行在客户端机器上的操作系统名称及版本</td>
</tr>
<tr>
<td style="text-align:center">UA-Pixels</td>
<td style="text-align:center">提供了客户端显示器的像素信息</td>
</tr>
<tr>
<td style="text-align:center">User-Agent</td>
<td style="text-align:center">将发起请求的应用程序名称告知服务器</td>
</tr>
</tbody>
</table>
<h2 id="Accept-首部"><a href="#Accept-首部" class="headerlink" title="Accept 首部"></a>Accept 首部</h2><table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept</td>
<td style="text-align:center">告诉服务器能够发送哪些媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Accept- Charset</td>
<td style="text-align:center">告诉服务器能够发送哪些字符集</td>
</tr>
<tr>
<td style="text-align:center">Accept- Encoding</td>
<td style="text-align:center">告诉服务器能够发送哪些编码方式</td>
</tr>
<tr>
<td style="text-align:center">Accept- Language</td>
<td style="text-align:center">告诉服务器能够发送哪些语言</td>
</tr>
<tr>
<td style="text-align:center">TE</td>
<td style="text-align:center">告诉服务器可以使用哪些扩展传输的编码</td>
</tr>
</tbody>
</table>
<p>常见内容编码</p>
<p>常用的内容编码有以下几种：</p>
<ul>
<li>gzip（GNU zip）<br>由文件压缩程序 gzip（GNU zip）生成的编码格式（RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余校验（Cyclic Redundancy Check，统称 CRC）</li>
<li>compress（UNIX 系统的标准压缩）<br>由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel-Ziv-Welch 算法 （LZW）</li>
<li>deflate（zlib）<br>组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式</li>
<li>identity（不进行编码）<br>不执行压缩或不会变化的默认编码格式</li>
</ul>
<h2 id="条件请求首部"><a href="#条件请求首部" class="headerlink" title="条件请求首部"></a>条件请求首部</h2><table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Expect</td>
<td style="text-align:center">允许客户端列出某请求所要求的服务器行为</td>
</tr>
<tr>
<td style="text-align:center">If-Match</td>
<td style="text-align:center">如果实体标记与文档当前的实体标记相匹配，就获取这份文档</td>
</tr>
<tr>
<td style="text-align:center">If-Modified-Since</td>
<td style="text-align:center">除非在某个指定的日期之后资源被修改过，否则就限制这个请求</td>
</tr>
<tr>
<td style="text-align:center">If-None-Match</td>
<td style="text-align:center">如果提供的实体标记与当前文档的实体标记不相符，就获取文档</td>
</tr>
<tr>
<td style="text-align:center">If-Range</td>
<td style="text-align:center">允许对文档的某个范围进行条件请求</td>
</tr>
<tr>
<td style="text-align:center">If-Unmodified-Since</td>
<td style="text-align:center">除非在某个指定日期之后资源没有被修改过，否则就限制这个请求</td>
</tr>
<tr>
<td style="text-align:center">Range</td>
<td style="text-align:center">如果服务器支持范围请求，就请求资源的指定范围</td>
</tr>
</tbody>
</table>
<h2 id="安全请求首部"><a href="#安全请求首部" class="headerlink" title="安全请求首部"></a>安全请求首部</h2><table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Authorization</td>
<td style="text-align:center">包含了客户端提供给服务器，以便对其自身进行认证的数据</td>
</tr>
<tr>
<td style="text-align:center">Cookie</td>
<td style="text-align:center">客户端用它向服务器传送一个令牌 —— 它并不是真正的安全首部，但确实隐含了安全功能</td>
</tr>
<tr>
<td style="text-align:center">Cookie</td>
<td style="text-align:center">用来说明请求端支持的 cookie 版本</td>
</tr>
</tbody>
</table>
<h2 id="代理请求首部"><a href="#代理请求首部" class="headerlink" title="代理请求首部"></a>代理请求首部</h2><table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Max-Forward</td>
<td style="text-align:center">在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数 —— 与 TRACE 方法一同使用</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authorization</td>
<td style="text-align:center">与 Authorization 首部相同， 但这个首部是在与代理进行认证时使用的</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Connection</td>
<td style="text-align:center">与 Connection 首部相同， 但这个首部是在与代理建立连接时使用的</td>
</tr>
</tbody>
</table>
<h1 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h1><h2 id="响应信息性首部"><a href="#响应信息性首部" class="headerlink" title="响应信息性首部"></a>响应信息性首部</h2><table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Age</td>
<td style="text-align:center">（从最初创建开始）响应持续时间</td>
</tr>
<tr>
<td style="text-align:center">Public</td>
<td style="text-align:center">服务器为其资源支持的请求方法列表</td>
</tr>
<tr>
<td style="text-align:center">Retry-After</td>
<td style="text-align:center">如果资源不可用的话，在此日期或时间重试 Server 服务器应用程序软件的名称和版本</td>
</tr>
<tr>
<td style="text-align:center">Title</td>
<td style="text-align:center">对 HTML 文档来说，就是 HTML 文档 的源端给出的标题</td>
</tr>
<tr>
<td style="text-align:center">Warning</td>
<td style="text-align:center">比原因短语中更详细一些的警告报文</td>
</tr>
</tbody>
</table>
<h2 id="协商首部"><a href="#协商首部" class="headerlink" title="协商首部"></a>协商首部</h2><table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept-Ranges</td>
<td style="text-align:center">对此资源来说，服务器可接受的范围类型</td>
</tr>
<tr>
<td style="text-align:center">Vary</td>
<td style="text-align:center">服务器查看的其他首部的列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端。首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。</td>
</tr>
</tbody>
</table>
<h2 id="安全响应首部"><a href="#安全响应首部" class="headerlink" title="安全响应首部"></a>安全响应首部</h2><table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Proxy-Authenticate</td>
<td style="text-align:center">来自代理的对客户端的质询列表</td>
</tr>
<tr>
<td style="text-align:center">Set-Cookie</td>
<td style="text-align:center">不是真正的安全首部，但隐含有安全功能；可以在客户端设置一个令牌，以便服务器对客户端进行标识</td>
</tr>
<tr>
<td style="text-align:center">Set-Cookie2</td>
<td style="text-align:center">与 Set-Cookie 类似，RFC 2965 Cookie 定义；</td>
</tr>
<tr>
<td style="text-align:center">WWW-Authenticate</td>
<td style="text-align:center">来自服务器的对客户端的质询列表。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）</td>
</tr>
</tbody>
</table>
<p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为了防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Set-Cookie</span>: name-value;HttpOnly</div></pre></td></tr></table></figure>
<p>顺带一提，该扩展并非是为了防止 XSS 而开发的。</p>
<h1 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h1><h2 id="实体信息性首部"><a href="#实体信息性首部" class="headerlink" title="实体信息性首部"></a>实体信息性首部</h2><table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Allow</td>
<td style="text-align:center">列出了可以对此实体执行的请求方法</td>
</tr>
<tr>
<td style="text-align:center">Location</td>
<td style="text-align:center">告知客户端实体实际上位于何处；用于将接收端定向到资源的（可能是新的）位置（URL）上去</td>
</tr>
</tbody>
</table>
<h2 id="内容首部"><a href="#内容首部" class="headerlink" title="内容首部"></a>内容首部</h2><table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Content-Base16</td>
<td style="text-align:center">解析主体中的相对 URL 时使用的基础 URL</td>
</tr>
<tr>
<td style="text-align:center">Content-Encoding</td>
<td style="text-align:center">对主体执行的任意编码方式</td>
</tr>
<tr>
<td style="text-align:center">Content-Language</td>
<td style="text-align:center">理解主体时最适宜使用的自然语言</td>
</tr>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">主体的长度或尺寸</td>
</tr>
<tr>
<td style="text-align:center">Content-Location</td>
<td style="text-align:center">资源实际所处的位置</td>
</tr>
<tr>
<td style="text-align:center">Content-MD5</td>
<td style="text-align:center">主体的 MD5 校验和</td>
</tr>
<tr>
<td style="text-align:center">Content-Range</td>
<td style="text-align:center">在整个资源中此实体表示的字节范围</td>
</tr>
<tr>
<td style="text-align:center">Content-Type</td>
<td style="text-align:center">这个主体的对象类型</td>
</tr>
</tbody>
</table>
<p>由于 HTTP 首部无法记录二进制值，所以要通过 Base-64 编码处理。采用 Content-MD5 这种方法，对内容上的偶发性改变是无从查证的，也无法检测出恶意篡改。原因在于，内容如果被篡改了，那么同时意味着 Content-MD5 也可以被重新计算后更新，被篡改。所以处在接收阶段的客户端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过的。</p>
<h2 id="实体缓存首部"><a href="#实体缓存首部" class="headerlink" title="实体缓存首部"></a>实体缓存首部</h2><table>
<thead>
<tr>
<th style="text-align:center">首部</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ETag</td>
<td style="text-align:center">与此实体相关的实体标记</td>
</tr>
<tr>
<td style="text-align:center">Expires</td>
<td style="text-align:center">实体不再有效，要从原始的源端再次获取此实体的日期和时间</td>
</tr>
<tr>
<td style="text-align:center">Last-Modified</td>
<td style="text-align:center">这个实体最后一次被修改的日期和时间</td>
</tr>
</tbody>
</table>
<p>Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p>
<p>Expires 的缺点是：响应报文中 Expires 所定义的缓存时间是相对服务器上的时间而言的，其定义的是资源“失效时刻”，如果客户端上的时间跟服务器上的时间不一致，缓存将失效。  </p>
<p>另外，Expires 主要使用在 HTTP1.0 版本。</p>
<p>如果两者的 URI 是相同，所以仅凭 URI 指定缓存的资源是很困难的。若下载过程中出现连续中断、再连接的情况，都会依据 ETag 值指定资源。</p>
<p>ETag 也分为强 ETag 值和弱 ETag 值：</p>
<p>强 ETag 值：</p>
<p>强 ETag 值，不论实体发生多少细微的变化都会改变其值。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ETag</span>: "usagi-1234"</div></pre></td></tr></table></figure>
<p>弱 ETag 值：</p>
<p>弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ETag</span>: W/"usagi-1234"</div></pre></td></tr></table></figure>
<h1 id="扩展首部"><a href="#扩展首部" class="headerlink" title="扩展首部"></a>扩展首部</h1><h2 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h2><p>首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。</p>
<h2 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h2><p>首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。0：将 XSS 过滤设置成无效状态，1：将 XSS 过滤设置成有效状态。</p>
<h2 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h2><p>首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。0：同意被追踪，1：拒绝被追踪。</p>
<h2 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h2><p>首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。</p>
<blockquote>
<p>在 HTTP 等多种协议中，通过给非标准参数加上前缀 X- ，来区别于标准参数，并使那些非标准的参数作为扩展变成可能。但是这种简单粗暴的做法有百害而无一益，因此在 “RFC6648 - Deprecating the “X-“ Prefix and Similar Constructs in Application Protocols ”中提议停止该做法。然而，对已经在使用中的 X- 前缀来说，不应该要求其变更。</p>
</blockquote>
<p>HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分为 端到端首部（End-to-end Header）、逐跳首部（Hop-by-hop Header）</p>
<ul>
<li>端到端首部：分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的相应中，另外规定它必须被转发。</li>
<li>逐跳首部：分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。（Connection、Keep-Alive、Proxy-Authenticate、Proxy-Authorization、Trailer、TE、Transfer-Encoding、Upgrade 这 8 个首部字段属于逐跳首部，除此以外的字段都属于端到端首部）</li>
</ul>
<h1 id="提高-HTTP-性能"><a href="#提高-HTTP-性能" class="headerlink" title="提高 HTTP 性能"></a>提高 HTTP 性能</h1><h2 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h2><p>通过多条 TCP 连接发起并发的 HTTP 请求。</p>
<h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p>重用 TCP 连接，以消除连接及关闭的时延。 持久连接（HTTP Persistent Connections），也称为 HTTP keep-alive 或者 HTTP connection reuse 。</p>
<p>在 HTTP/1.1 中，所有的连接默认都是持久连接。但是服务器端不一定都能够支持持久连接，所以除了服务端，客户端也需要支持持久连接。</p>
<h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2><p>通过共享的 TCP 连接发起并发的 HTTP 请求。</p>
<p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。以前发送请求后需要等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应，直接发送下一个请求。</p>
<p>比如当请求一个包含 10 张图片的 HTML Web 页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。</p>
<h2 id="复用的连接"><a href="#复用的连接" class="headerlink" title="复用的连接"></a>复用的连接</h2><p>交替传送请求和响应报文（实验阶段）。</p>
<h1 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在内容实体中(依旧是明文传输，只是和 GET 存放的位置不同罢了)。</p>
<p>GET 的传参方式相比于 POST 安全性较差，因为 GET 传的参数在 URL 中是可见的，可能会泄露私密信息。并且 GET 只支持 ASCII 字符，如果参数为中文则可能会出现乱码，而 POST 支持标准字符集。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/test/demo_form.asp?name1=value1&amp;name2=value2</span> HTTP/1.1</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POST /test/demo_form.asp HTTP/1.1</div><div class="line">Host: w3schools.com</div><div class="line">name1=value1&amp;name2=value2</div></pre></td></tr></table></figure>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>
<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。所有的安全方法也都是幂等的。</p>
<p>GET /pageX HTTP/1.1 是幂等的。连续调用多次，客户端接收到的结果都是一样的：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</div><div class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</div><div class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</div><div class="line"><span class="keyword">GET</span> <span class="string">/pageX</span> HTTP/1.1</div></pre></td></tr></table></figure>
<p>POST /add_row HTTP/1.1 不是幂等的。如果调用多次，就会增加多行记录：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POST /add_row HTTP/1.1</div><div class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</div><div class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</div></pre></td></tr></table></figure>
<p>DELETE /idX/delete HTTP/1.1 是幂等的，即便是不同请求之间接收到的状态码不一样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</div><div class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</div><div class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</div></pre></td></tr></table></figure>
<h2 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h2><p>如果要对响应进行缓存，需要满足以下条件：</p>
<ol>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li>
</ol>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p>
<blockquote>
<p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>
</blockquote>
<p>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</p>
<h1 id="HTTP-各版本比较"><a href="#HTTP-各版本比较" class="headerlink" title="HTTP 各版本比较"></a>HTTP 各版本比较</h1><h2 id="HTTP-1-0-与-HTTP-1-1-的区别"><a href="#HTTP-1-0-与-HTTP-1-1-的区别" class="headerlink" title="HTTP/1.0 与 HTTP/1.1 的区别"></a>HTTP/1.0 与 HTTP/1.1 的区别</h2><ol>
<li>HTTP/1.1 默认是持久连接</li>
<li>HTTP/1.1 支持管线化处理</li>
<li>HTTP/1.1 支持虚拟主机</li>
<li>HTTP/1.1 新增状态码 100</li>
<li>HTTP/1.1 支持分块传输编码</li>
<li>HTTP/1.1 新增缓存处理指令 max-age</li>
</ol>
<p>具体内容见上文</p>
<h2 id="HTTP-1-1-与-HTTP-2-0-的区别"><a href="#HTTP-1-1-与-HTTP-2-0-的区别" class="headerlink" title="HTTP/1.1 与 HTTP/2.0 的区别"></a>HTTP/1.1 与 HTTP/2.0 的区别</h2><blockquote>
<p><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="external">HTTP/2 简介</a></p>
</blockquote>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP/2.0 使用多路复用技术，同一个 TCP 连接可以处理多个请求。</p>
<h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。</p>
<h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 index.html 页面，服务端就把 index.js 一起发给客户端。</p>
<h3 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h3><p>HTTP/1.1 的解析是基于文本的，而 HTTP/2.0 采用二进制格式。</p>
<h1 id="浏览器同源政策及其规避方法"><a href="#浏览器同源政策及其规避方法" class="headerlink" title="浏览器同源政策及其规避方法"></a>浏览器同源政策及其规避方法</h1><p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>
<p>最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”。</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p>举例来说，<a href="http://www.example.com/dir/page.html" target="_blank" rel="external">http://www.example.com/dir/page.html</a>  这个网址，协议是<a href="http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。" target="_blank" rel="external">http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。</a></p>
<ul>
<li><a href="http://www.example.com/dir2/other.html" target="_blank" rel="external">http://www.example.com/dir2/other.html</a>  同源</li>
<li><a href="http://example.com/dir/other.html" target="_blank" rel="external">http://example.com/dir/other.html</a> 不同源（域名不同）</li>
<li><a href="http://v2.www.example.com/dir/other.html" target="_blank" rel="external">http://v2.www.example.com/dir/other.html</a> 不同源（域名不同）</li>
<li><a href="http://www.example.com:81/dir/other.html" target="_blank" rel="external">http://www.example.com:81/dir/other.html</a> 不同源（端口不同）</li>
</ul>
<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。<br>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？<br>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。<br>由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
<p>随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<ol>
<li>Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li>DOM 无法获得。</li>
<li>AJAX 请求不能发送。</li>
</ol>
<p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面，我将详细介绍，如何规避上面三种限制。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。<br>举例来说，A网页是<a href="http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。" target="_blank" rel="external">http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.domain = &apos;example.com&apos;;</div></pre></td></tr></table></figure>
<p>现在，A网页通过脚本设置一个 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.cookie = &quot;test1=hello&quot;;</div></pre></td></tr></table></figure>
<p>B网页就可以读到这个 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var allCookie = document.cookie;</div></pre></td></tr></table></figure>
<p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。<br>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie: key=value; domain=.example.com; path=/</div></pre></td></tr></table></figure>
<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p>
<h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h2><p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。<br>比如，父窗口运行下面的命令，如果iframe窗口不是同源，就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">document.getElementById(&quot;myIFrame&quot;).contentWindow.document</div><div class="line">// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.</div></pre></td></tr></table></figure>
<p>上面命令中，父窗口想获取子窗口的DOM，因为跨源导致报错。</p>
<p>反之亦然，子窗口获取主窗口的DOM也会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">window.parent.document.body</div><div class="line">// 报错</div></pre></td></tr></table></figure>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。<br>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</p>
<ul>
<li>片段识别符（fragment identifier）</li>
<li>window.name</li>
<li>跨文档通信API（Cross-document messaging）</li>
</ul>
<h3 id="片段识别符"><a href="#片段识别符" class="headerlink" title="片段识别符"></a>片段识别符</h3><p>片段标识符（fragment identifier）指的是，URL的#号后面的部分，比如<a href="http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。" target="_blank" rel="external">http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。</a></p>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var src = originURL + &apos;#&apos; + data;</div><div class="line">document.getElementById(&apos;myIFrame&apos;).src = src;</div></pre></td></tr></table></figure>
<p>子窗口通过监听hashchange事件得到通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">window.onhashchange = checkMessage;</div><div class="line"></div><div class="line">function checkMessage() &#123;</div><div class="line">  var message = window.location.hash;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parent.location.href= target + &quot;#&quot; + hash;</div></pre></td></tr></table></figure>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p>
<p>父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.name = data;</div></pre></td></tr></table></figure>
<p>接着，子窗口跳回一个与主窗口同域的网址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">location = &apos;http://parent.url.com/xxx.html&apos;;</div></pre></td></tr></table></figure>
<p>然后，主窗口就可以读取子窗口的window.name了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var data = document.getElementById(&apos;myFrame&apos;).contentWindow.name;</div></pre></td></tr></table></figure>
<p>这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。</p>
<h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h3><p>上面两种方法都属于破解，HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。<br>这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。<br>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用postMessage方法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);</div><div class="line">popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;);</div></pre></td></tr></table></figure>
<p>postMessage方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即”协议 + 域名 + 端口”。也可以设为*，表示不限制域名，向所有窗口发送。</p>
<p>子窗口向父窗口发送消息的写法类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;);</div></pre></td></tr></table></figure>
<p>父窗口和子窗口都可以通过message事件，监听对方的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&apos;message&apos;, function(e) &#123;</div><div class="line">  console.log(e.data);</div><div class="line">&#125;,false);</div></pre></td></tr></table></figure>
<p>message事件的事件对象event，提供以下三个属性。</p>
<ul>
<li>event.source：发送消息的窗口</li>
<li>event.origin: 消息发向的网址</li>
<li>event.data: 消息内容</li>
</ul>
<p>下面的例子是，子窗口通过event.source属性引用父窗口，然后发送消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&apos;message&apos;, receiveMessage);</div><div class="line">function receiveMessage(event) &#123;</div><div class="line">  event.source.postMessage(&apos;Nice to see you!&apos;, &apos;*&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>event.origin属性可以过滤不是发给本窗口的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">window.addEventListener(&apos;message&apos;, receiveMessage);</div><div class="line">function receiveMessage(event) &#123;</div><div class="line">  if (event.origin !== &apos;http://aaa.com&apos;) return;</div><div class="line">  if (event.data === &apos;Hello World&apos;) &#123;</div><div class="line">      event.source.postMessage(&apos;Hello&apos;, event.origin);</div><div class="line">  &#125; else &#123;</div><div class="line">    console.log(event.data);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><p>通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。</p>
<p>下面是一个例子，主窗口写入iframe子窗口的localStorage。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">window.onmessage = function(e) &#123;</div><div class="line">  if (e.origin !== &apos;http://bbb.com&apos;) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  var payload = JSON.parse(e.data);</div><div class="line">  localStorage.setItem(payload.key, JSON.stringify(payload.data));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。</p>
<p>父窗口发送消息的代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;</div><div class="line">var obj = &#123; name: &apos;Jack&apos; &#125;;</div><div class="line">win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, data: obj&#125;), &apos;http://bbb.com&apos;);</div></pre></td></tr></table></figure>
<p>加强版的子窗口接收消息的代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">window.onmessage = function(e) &#123;</div><div class="line">  if (e.origin !== &apos;http://bbb.com&apos;) return;</div><div class="line">  var payload = JSON.parse(e.data);</div><div class="line">  switch (payload.method) &#123;</div><div class="line">    case &apos;set&apos;:</div><div class="line">      localStorage.setItem(payload.key, JSON.stringify(payload.data));</div><div class="line">      break;</div><div class="line">    case &apos;get&apos;:</div><div class="line">      var parent = window.parent;</div><div class="line">      var data = localStorage.getItem(payload.key);</div><div class="line">      parent.postMessage(data, &apos;http://aaa.com&apos;);</div><div class="line">      break;</div><div class="line">    case &apos;remove&apos;:</div><div class="line">      localStorage.removeItem(payload.key);</div><div class="line">      break;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>加强版的父窗口发送消息代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;</div><div class="line">var obj = &#123; name: &apos;Jack&apos; &#125;;</div><div class="line">// 存入对象</div><div class="line">win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &apos;set&apos;, data: obj&#125;), &apos;http://bbb.com&apos;);</div><div class="line">// 读取对象</div><div class="line">win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &quot;get&quot;&#125;), &quot;*&quot;);</div><div class="line">window.onmessage = function(e) &#123;</div><div class="line">  if (e.origin != &apos;http://aaa.com&apos;) return;</div><div class="line">  // &quot;Jack&quot;</div><div class="line">  console.log(JSON.parse(e.data).name);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>
<p>它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>
<p>首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨源网址发出请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function addScriptTag(src) &#123;</div><div class="line">  var script = document.createElement(&apos;script&apos;);</div><div class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</div><div class="line">  script.src = src;</div><div class="line">  document.body.appendChild(script);</div><div class="line">&#125;</div><div class="line"></div><div class="line">window.onload = function () &#123;</div><div class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function foo(data) &#123;</div><div class="line">  console.log(&apos;Your public IP address is: &apos; + data.ip);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。</p>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo(&#123;</div><div class="line">  &quot;ip&quot;: &quot;8.8.8.8&quot;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。<br>下面是一个例子，浏览器发出的WebSocket请求的头信息.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /chat HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</div><div class="line">Sec-WebSocket-Protocol: chat, superchat</div><div class="line">Sec-WebSocket-Version: 13</div><div class="line">Origin: http://example.com</div></pre></td></tr></table></figure>
<p>上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 Switching Protocols</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</div><div class="line">Sec-WebSocket-Protocol: chat</div></pre></td></tr></table></figure>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>
<p>本文详细介绍CORS的内部机制。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h3 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h3><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<ol>
<li><p>请求方法是以下三种方法之一：<br>HEAD<br>GET<br>POST</p>
</li>
<li><p>HTTP的头信息不超出以下几种字段：<br>Accept<br>Accept-Language<br>Content-Language<br>Last-Event-ID<br>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</p>
</li>
</ol>
<p>凡是不同时满足上面两个条件，就属于非简单请求。<br>浏览器对这两种请求的处理，是不一样的。</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p>
<p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET /cors HTTP/1.1</div><div class="line">Origin: http://api.bob.com</div><div class="line">Host: api.alice.com</div><div class="line">Accept-Language: en-US</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0...</div></pre></td></tr></table></figure>
<p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Expose-Headers: FooBar</div><div class="line">Content-Type: text/html; charset=utf-8</div></pre></td></tr></table></figure>
<p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<ol>
<li>Access-Control-Allow-Origin<br>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</li>
<li>Access-Control-Allow-Credentials<br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</li>
<li>Access-Control-Expose-Headers<br>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</li>
</ol>
<h4 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h4><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Credentials: true</div></pre></td></tr></table></figure>
<p>另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.withCredentials = true;</div></pre></td></tr></table></figure>
<p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。<br>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.withCredentials = false;</div></pre></td></tr></table></figure>
<p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<p>下面是一段浏览器的JavaScript脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var url = &apos;http://api.alice.com/cors&apos;;</div><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">xhr.open(&apos;PUT&apos;, url, true);</div><div class="line">xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);</div><div class="line">xhr.send();</div></pre></td></tr></table></figure>
<p>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OPTIONS /cors HTTP/1.1</div><div class="line">Origin: http://api.bob.com</div><div class="line">Access-Control-Request-Method: PUT</div><div class="line">Access-Control-Request-Headers: X-Custom-Header</div><div class="line">Host: api.alice.com</div><div class="line">Accept-Language: en-US</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0...</div></pre></td></tr></table></figure>
<p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p>
<p>除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p>
<ol>
<li>Access-Control-Request-Method<br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li>
<li>Access-Control-Request-Headers<br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</li>
</ol>
<h4 id="预检请求的回应"><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h4><p>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</div><div class="line">Server: Apache/2.0.61 (Unix)</div><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Access-Control-Allow-Methods: GET, POST, PUT</div><div class="line">Access-Control-Allow-Headers: X-Custom-Header</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">Content-Encoding: gzip</div><div class="line">Content-Length: 0</div><div class="line">Keep-Alive: timeout=2, max=100</div><div class="line">Connection: Keep-Alive</div><div class="line">Content-Type: text/plain</div></pre></td></tr></table></figure>
<p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示<a href="http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。" target="_blank" rel="external">http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: *</div></pre></td></tr></table></figure>
<p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest cannot load http://api.alice.com.</div><div class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</div></pre></td></tr></table></figure>
<p>服务器回应的其他CORS相关字段如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Methods: GET, POST, PUT</div><div class="line">Access-Control-Allow-Headers: X-Custom-Header</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Max-Age: 1728000</div></pre></td></tr></table></figure>
<ol>
<li>Access-Control-Allow-Methods<br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</li>
<li>Access-Control-Allow-Headers<br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</li>
<li>Access-Control-Allow-Credentials<br>该字段与简单请求时的含义相同。</li>
<li>Access-Control-Max-Age<br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</li>
</ol>
<h4 id="浏览器的正常请求和回应"><a href="#浏览器的正常请求和回应" class="headerlink" title="浏览器的正常请求和回应"></a>浏览器的正常请求和回应</h4><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<p>下面是”预检”请求之后，浏览器的正常CORS请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PUT /cors HTTP/1.1</div><div class="line">Origin: http://api.bob.com</div><div class="line">Host: api.alice.com</div><div class="line">X-Custom-Header: value</div><div class="line">Accept-Language: en-US</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0...</div></pre></td></tr></table></figure>
<p>上面头信息的Origin字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://api.bob.com</div><div class="line">Content-Type: text/html; charset=utf-8</div></pre></td></tr></table></figure>
<p>上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。</p>
<h3 id="与JSONP的比较"><a href="#与JSONP的比较" class="headerlink" title="与JSONP的比较"></a>与JSONP的比较</h3><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<p>ref<br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a></p>
<p><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/HTTP.md" target="_blank" rel="external">https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/HTTP.md</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars7.githubusercontent.com/u/22493186?v=4&s=460"
               alt="ejunjsh" />
          <p class="site-author-name" itemprop="name">ejunjsh</p>
           
              <p class="site-description motion-element" itemprop="description">code freak</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">139</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">129</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ejunjsh" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/339238080" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:sjj050121014@163.com" target="_blank" title="Email">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      Email
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.facebook.com/junjie.shao.9" target="_blank" title="FB Page">
                  
                    <i class="fa fa-fw fa-facebook"></i>
                  
                    
                      FB Page
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 &mdash; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <a href="/mylove" style="border-bottom:none">
    <i class="fa fa-heart"></i>
    </a>
  </span>
  <span class="author" itemprop="copyrightHolder">ejunjsh</span>

  
</div>


  <div class="powered-by">
    Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
  </div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">
    Theme &mdash;
    <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
      NexT.Gemini
    </a>
  </div>


        







        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.2"></script>



  

  

  

  

  

  

</body>
</html>
